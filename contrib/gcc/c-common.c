begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines shared by all languages that are variants of C.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* For USING_SJLJ_EXCEPTIONS.  */
end_comment

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_decl_stmt
name|cpp_reader
modifier|*
name|parse_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declared in c-pragma.h.  */
end_comment

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR_TYPE gets overridden by -fshort-wchar.  */
end_comment

begin_define
define|#
directive|define
name|MODIFIED_WCHAR_TYPE
define|\
value|(flag_short_wchar ? "short unsigned int" : WCHAR_TYPE)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WINT_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WINT_TYPE
value|"unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INTMAX_TYPE
end_ifndef

begin_define
define|#
directive|define
name|INTMAX_TYPE
value|((INT_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 		     ? "int"					\ 		     : ((LONG_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 			? "long int"				\ 			: "long long int"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UINTMAX_TYPE
end_ifndef

begin_define
define|#
directive|define
name|UINTMAX_TYPE
value|((INT_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 		     ? "unsigned int"				\ 		     : ((LONG_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 			? "long unsigned int"			\ 			: "long long unsigned int"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The variant of the C language being processed.  */
end_comment

begin_decl_stmt
name|enum
name|c_language_kind
name|c_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following symbols are subsumed in the c_global_trees array, and    listed here individually for documentation purposes.     INTEGER_TYPE and REAL_TYPE nodes for the standard data types.  	tree short_integer_type_node; 	tree long_integer_type_node; 	tree long_long_integer_type_node;  	tree short_unsigned_type_node; 	tree long_unsigned_type_node; 	tree long_long_unsigned_type_node;  	tree boolean_type_node; 	tree boolean_false_node; 	tree boolean_true_node;  	tree ptrdiff_type_node;  	tree unsigned_char_type_node; 	tree signed_char_type_node; 	tree wchar_type_node; 	tree signed_wchar_type_node; 	tree unsigned_wchar_type_node;  	tree float_type_node; 	tree double_type_node; 	tree long_double_type_node;  	tree complex_integer_type_node; 	tree complex_float_type_node; 	tree complex_double_type_node; 	tree complex_long_double_type_node;  	tree intQI_type_node; 	tree intHI_type_node; 	tree intSI_type_node; 	tree intDI_type_node; 	tree intTI_type_node;  	tree unsigned_intQI_type_node; 	tree unsigned_intHI_type_node; 	tree unsigned_intSI_type_node; 	tree unsigned_intDI_type_node; 	tree unsigned_intTI_type_node;  	tree widest_integer_literal_type_node; 	tree widest_unsigned_literal_type_node;     Nodes for types `void *' and `const void *'.  	tree ptr_type_node, const_ptr_type_node;     Nodes for types `char *' and `const char *'.  	tree string_type_node, const_string_type_node;     Type `char[SOMENUMBER]'.    Used when an array of char is needed and the size is irrelevant.  	tree char_array_type_node;     Type `int[SOMENUMBER]' or something like it.    Used when an array of int needed and the size is irrelevant.  	tree int_array_type_node;     Type `wchar_t[SOMENUMBER]' or something like it.    Used when a wide string literal is created.  	tree wchar_array_type_node;     Type `int ()' -- used for implicit declaration of functions.  	tree default_function_type;     A VOID_TYPE node, packaged in a TREE_LIST.  	tree void_list_node;    The lazily created VAR_DECLs for __FUNCTION__, __PRETTY_FUNCTION__,   and __func__. (C doesn't generate __FUNCTION__ and__PRETTY_FUNCTION__   VAR_DECLS, but C++ does.)  	tree function_name_decl_node; 	tree pretty_function_name_decl_node; 	tree c99_function_name_decl_node;    Stack of nested function name VAR_DECLs.    	tree saved_function_name_decls;  */
end_comment

begin_decl_stmt
name|tree
name|c_global_trees
index|[
name|CTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switches common to the C front ends.  */
end_comment

begin_comment
comment|/* Nonzero if prepreprocessing only.  */
end_comment

begin_decl_stmt
name|int
name|flag_preprocess_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if an ISO standard was selected.  It rejects macros in the    user's namespace.  */
end_comment

begin_decl_stmt
name|int
name|flag_iso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero whenever Objective-C functionality is being used.  */
end_comment

begin_decl_stmt
name|int
name|flag_objc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if -undef was given.  It suppresses target built-in macros    and assertions.  */
end_comment

begin_decl_stmt
name|int
name|flag_undef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.    -ansi sets this.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_nonansi_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `wchar_t' the same size as `short'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_wchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow Microsoft extensions without warnings or errors.  */
end_comment

begin_decl_stmt
name|int
name|flag_ms_extensions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the keyword `asm'.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give string constants the type `const char *', as mandated    by the standard.  */
end_comment

begin_decl_stmt
name|int
name|flag_const_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means `$' can be in an identifier.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dollars_in_ident
init|=
name|DOLLARS_IN_IDENTIFIERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_bitfields
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|explicit_flag_signed_bitfields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that can drop a type qualifier    from the pointer target type.  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_qual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about functions which might be candidates for format attributes.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_format_attribute
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about sizeof(function) or addition/subtraction    of function pointers.  */
end_comment

begin_decl_stmt
name|int
name|warn_pointer_arith
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do not warn that K&R style main() is not a function prototype. */
end_comment

begin_decl_stmt
name|int
name|flag_bsd_no_warn_kr_main
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for any global function def    without separate previous prototype decl.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if adding () is suggested.  */
end_comment

begin_decl_stmt
name|int
name|warn_parentheses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if initializer is not completely bracketed.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_braces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about comparison of signed and unsigned values.    If -1, neither -Wsign-compare nor -Wno-sign-compare has been specified.  */
end_comment

begin_decl_stmt
name|int
name|warn_sign_compare
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about usage of long long when `-pedantic'.  */
end_comment

begin_decl_stmt
name|int
name|warn_long_long
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about deprecated conversion from string constant to    `char *'.  */
end_comment

begin_decl_stmt
name|int
name|warn_write_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about multiple (redundant) decls for the same single    variable or function.  */
end_comment

begin_decl_stmt
name|int
name|warn_redundant_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about testing equality of floating point numbers.  */
end_comment

begin_decl_stmt
name|int
name|warn_float_equal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about a subscript that has type char.  */
end_comment

begin_decl_stmt
name|int
name|warn_char_subscripts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a type conversion is done that might have confusing results.  */
end_comment

begin_decl_stmt
name|int
name|warn_conversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about #pragma directives that are not recognized.  */
end_comment

begin_decl_stmt
name|int
name|warn_unknown_pragmas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tri state variable.  */
end_comment

begin_comment
comment|/* Warn about format/argument anomalies in calls to formatted I/O functions    (*printf, *scanf, strftime, strfmon, etc.).  */
end_comment

begin_decl_stmt
name|int
name|warn_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about Y2K problems with strftime formats.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_y2k
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about excess arguments to formats.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_extra_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about zero-length formats.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_zero_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about non-literal format arguments.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_nonliteral
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about possible security problems with calls to format functions.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_security
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C/ObjC language option variables.  */
end_comment

begin_comment
comment|/* Nonzero means message about use of implicit function declarations;  1 means warning; 2 means error.  */
end_comment

begin_decl_stmt
name|int
name|mesg_implicit_function_declaration
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow type mismatches in conditional expressions;    just make their values `void'.  */
end_comment

begin_decl_stmt
name|int
name|flag_cond_mismatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means enable C89 Amendment 1 features.  */
end_comment

begin_decl_stmt
name|int
name|flag_isoc94
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use the ISO C99 dialect of C.  */
end_comment

begin_decl_stmt
name|int
name|flag_isoc99
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow the BSD kernel printf enhancements.  */
end_comment

begin_decl_stmt
name|int
name|flag_bsd_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we have builtin functions, and main is an int */
end_comment

begin_decl_stmt
name|int
name|flag_hosted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means add default format_arg attributes for functions not    in ISO C.  */
end_comment

begin_decl_stmt
name|int
name|flag_noniso_default_format_attributes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when casting a function call to a type that does    not match the return type (e.g. (float)sqrt() or (anything*)malloc()    when there is no previous declaration of sqrt or malloc.  */
end_comment

begin_decl_stmt
name|int
name|warn_bad_function_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about traditional constructs whose meanings changed in ANSI C.  */
end_comment

begin_decl_stmt
name|int
name|warn_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for non-prototype function decls    or non-prototyped defs without previous prototype.  */
end_comment

begin_decl_stmt
name|int
name|warn_strict_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for any global function def    without separate previous decl.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_declarations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about declarations of objects not at    file-scope level and about *all* declarations of functions (whether    or static) not at file-scope level.  Note that we exclude    implicit function declarations.  To get warnings about those, use    -Wimplicit.  */
end_comment

begin_decl_stmt
name|int
name|warn_nested_externs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if main is suspicious.  */
end_comment

begin_decl_stmt
name|int
name|warn_main
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about possible violations of sequence point rules.  */
end_comment

begin_decl_stmt
name|int
name|warn_sequence_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to warn about compile-time division by zero.  */
end_comment

begin_decl_stmt
name|int
name|warn_div_by_zero
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about use of implicit int.  */
end_comment

begin_decl_stmt
name|int
name|warn_implicit_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about NULL being passed to argument slots marked as requiring    non-NULL.  */
end_comment

begin_decl_stmt
name|int
name|warn_nonnull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ObjC language option variables.  */
end_comment

begin_comment
comment|/* Open and close the file for outputting class declarations, if    requested (ObjC).  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_declaration
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate code for GNU or NeXT runtime environment.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEXT_OBJC_RUNTIME
end_ifdef

begin_decl_stmt
name|int
name|flag_next_runtime
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_next_runtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tells the compiler that this is a special run.  Do not perform any    compiling, instead we are to test some platform dependent features    and output a C header file with appropriate definitions.  */
end_comment

begin_decl_stmt
name|int
name|print_struct_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ???.  Undocumented.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|constant_string_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if multiple methods are seen for the same selector, but with    different argument types.  Performs the check on the whole selector    table at the end of compilation.  */
end_comment

begin_decl_stmt
name|int
name|warn_selector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a @selector() is found, and no method with that selector    has been previously declared.  The check is done on each    @selector() as soon as it is found - so it warns about forward    declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_undeclared_selector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if methods required by a protocol are not implemented in the     class adopting it.  When turned off, methods inherited to that    class are also considered implemented.  */
end_comment

begin_decl_stmt
name|int
name|warn_protocol
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ language option variables.  */
end_comment

begin_comment
comment|/* Nonzero means don't recognize any extension keywords.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_gnu_keywords
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do emit exported implementations of functions even if    they can be inlined.  */
end_comment

begin_decl_stmt
name|int
name|flag_implement_inlines
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do emit exported implementations of templates, instead of    multiple static copies in each file that needs a definition.  */
end_comment

begin_decl_stmt
name|int
name|flag_external_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that the decision to emit or not emit the implementation of a    template depends on where the template is instantiated, rather than where    it is defined.  */
end_comment

begin_decl_stmt
name|int
name|flag_alt_external_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that implicit instantiations will be emitted if needed.  */
end_comment

begin_decl_stmt
name|int
name|flag_implicit_templates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that implicit instantiations of inline templates will be    emitted if needed, even if instantiations of non-inline templates    aren't.  */
end_comment

begin_decl_stmt
name|int
name|flag_implicit_inline_templates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate separate instantiation control files and    juggle them at link time.  */
end_comment

begin_decl_stmt
name|int
name|flag_use_repository
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to issue diagnostics that the standard says are not    required.  */
end_comment

begin_decl_stmt
name|int
name|flag_optional_diags
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should attempt to elide constructors when possible.  */
end_comment

begin_decl_stmt
name|int
name|flag_elide_constructors
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that member functions defined in class scope are    inline by default.  */
end_comment

begin_decl_stmt
name|int
name|flag_default_inline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether compiler generates 'type descriptor' that give    run-time type information.  */
end_comment

begin_decl_stmt
name|int
name|flag_rtti
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to conserve space in the .o files.  We do this    by putting uninitialized data and runtime initialized data into    .common instead of .data at the expense of not flagging multiple    definitions.  */
end_comment

begin_decl_stmt
name|int
name|flag_conserve_space
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to obey access control semantics.  */
end_comment

begin_decl_stmt
name|int
name|flag_access_control
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to check the return value of new and avoid calling    constructors if it is a null pointer.  */
end_comment

begin_decl_stmt
name|int
name|flag_check_new
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want the new ISO rules for pushing a new scope for `for'    initialization variables.    0: Old rules, set by -fno-for-scope.    2: New ISO rules, set by -ffor-scope.    1: Try to implement new ISO rules, but with backup compatibility    (and warnings).  This is the default, for now.  */
end_comment

begin_decl_stmt
name|int
name|flag_new_for_scope
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to emit defined symbols with common-like linkage as    weak symbols where possible, in order to conform to C++ semantics.    Otherwise, emit them as local symbols.  */
end_comment

begin_decl_stmt
name|int
name|flag_weak
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to use __cxa_atexit, rather than atexit, to register    destructors for local statics and global objects.  */
end_comment

begin_decl_stmt
name|int
name|flag_use_cxa_atexit
init|=
name|DEFAULT_USE_CXA_ATEXIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means output .vtable_{entry,inherit} for use in doing vtable gc.  */
end_comment

begin_decl_stmt
name|int
name|flag_vtable_gc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the default pedwarns warnings instead of errors.    The value of this flag is ignored if -pedantic is specified.  */
end_comment

begin_decl_stmt
name|int
name|flag_permissive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to implement standard semantics for exception    specifications, calling unexpected if an exception is thrown that    doesn't match the specification.  Zero means to treat them as    assertions and optimize accordingly, but not check them.  */
end_comment

begin_decl_stmt
name|int
name|flag_enforce_eh_specs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  The version of the C++ ABI in use.  The following values are     allowed:      0: The version of the ABI believed most conformant with the         C++ ABI specification.  This ABI may change as bugs are        discovered and fixed.  Therefore, 0 will not necessarily        indicate the same ABI in different versions of G++.      1: The version of the ABI first used in G++ 3.2.      Additional positive integers will be assigned as new versions of     the ABI become the default version of the ABI.  */
end_comment

begin_decl_stmt
name|int
name|flag_abi_version
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about things that will change when compiling    with an ABI-compliant compiler.  */
end_comment

begin_decl_stmt
name|int
name|warn_abi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about implicit declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_implicit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when all ctors or dtors are private, and the class    has no friends.  */
end_comment

begin_decl_stmt
name|int
name|warn_ctor_dtor_privacy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn in function declared in derived class has the    same name as a virtual in the base class, but fails to match the    type signature of any virtual function in the base class.  */
end_comment

begin_decl_stmt
name|int
name|warn_overloaded_virtual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when declaring a class that has a non virtual    destructor, when it really ought to have a virtual one.  */
end_comment

begin_decl_stmt
name|int
name|warn_nonvdtor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when the compiler will reorder code.  */
end_comment

begin_decl_stmt
name|int
name|warn_reorder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when synthesis behavior differs from Cfront's.  */
end_comment

begin_decl_stmt
name|int
name|warn_synth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when we convert a pointer to member function    into a pointer to (void or function).  */
end_comment

begin_decl_stmt
name|int
name|warn_pmf2ptr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about violation of some Effective C++ style rules.  */
end_comment

begin_decl_stmt
name|int
name|warn_ecpp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn where overload resolution chooses a promotion from    unsigned to signed over a conversion to an unsigned of the same size.  */
end_comment

begin_decl_stmt
name|int
name|warn_sign_promo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when an old-style cast is used.  */
end_comment

begin_decl_stmt
name|int
name|warn_old_style_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when non-templatized friend functions are    declared within a template */
end_comment

begin_decl_stmt
name|int
name|warn_nontemplate_friend
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means complain about deprecated features.  */
end_comment

begin_decl_stmt
name|int
name|warn_deprecated
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum template instantiation depth.  This limit is rather    arbitrary, but it exists to limit the time it takes to notice    infinite template instantiations.  */
end_comment

begin_decl_stmt
name|int
name|max_tinst_depth
init|=
literal|500
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes for the reserved    type names and storage classes.  It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|ridpointers
decl_stmt|;
end_decl_stmt

begin_macro
name|tree
argument_list|(
argument|*make_fname_decl
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If non-NULL, the address of a language-specific function that    returns 1 for language-specific statement codes.  */
end_comment

begin_macro
name|int
argument_list|(
argument|*lang_statement_code_p
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If non-NULL, the address of a language-specific function that takes    any action required right before expand_function_end is called.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*lang_expand_function_end
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Nonzero means the expression being parsed will never be evaluated.    This is a count, since unevaluated expressions can nest.  */
end_comment

begin_decl_stmt
name|int
name|skip_evaluation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information about how a function name is generated.  */
end_comment

begin_struct
struct|struct
name|fname_var_t
block|{
name|tree
modifier|*
specifier|const
name|decl
decl_stmt|;
comment|/* pointer to the VAR_DECL.  */
specifier|const
name|unsigned
name|rid
decl_stmt|;
comment|/* RID number for the identifier.  */
specifier|const
name|int
name|pretty
decl_stmt|;
comment|/* How pretty is it? */
block|}
struct|;
end_struct

begin_comment
comment|/* The three ways of getting then name of the current function.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|fname_var_t
name|fname_vars
index|[]
init|=
block|{
comment|/* C99 compliant __func__, must be first.  */
block|{
operator|&
name|c99_function_name_decl_node
block|,
name|RID_C99_FUNCTION_NAME
block|,
literal|0
block|}
block|,
comment|/* GCC __FUNCTION__ compliant.  */
block|{
operator|&
name|function_name_decl_node
block|,
name|RID_FUNCTION_NAME
block|,
literal|0
block|}
block|,
comment|/* GCC __PRETTY_FUNCTION__ compliant.  */
block|{
operator|&
name|pretty_function_name_decl_node
block|,
name|RID_PRETTY_FUNCTION_NAME
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constant_fits_type_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep a stack of if statements.  We record the number of compound    statements seen up to the if keyword, as well as the line number    and file of the if.  If a potentially ambiguous else is seen, that    fact is recorded; the warning is issued when we can be sure that    the enclosing if statement does not have an else branch.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|compstmt_count
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|needs_warning
decl_stmt|;
name|tree
name|if_stmt
decl_stmt|;
block|}
name|if_elt
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|if_elt
modifier|*
name|if_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of space in the if statement stack.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|if_stack_space
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|if_stack_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_packed_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_nocommon_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_common_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_noreturn_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_noinline_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_always_inline_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_used_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_unused_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_const_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_transparent_union_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_constructor_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_destructor_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_mode_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_section_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_aligned_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_weak_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_alias_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_visibility_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_tls_model_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_no_instrument_function_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_malloc_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_no_limit_stack_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_pure_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_deprecated_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_vector_size_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_nonnull_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_nothrow_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_cleanup_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vector_size_helper
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_function_nonnull
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_nonnull_arg
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|nonnull_check_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|get_nonnull_operand
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|builtin_define_std
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|builtin_define_with_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|builtin_define_with_int_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|builtin_define_with_hex_fp_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|builtin_define_type_max
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|builtin_define_type_precision
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|builtin_define_float_constants
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of machine-independent attributes common to all C-like languages.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|c_common_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"packed"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_packed_attribute
block|}
block|,
block|{
literal|"nocommon"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_nocommon_attribute
block|}
block|,
block|{
literal|"common"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_common_attribute
block|}
block|,
comment|/* FIXME: logically, noreturn attributes should be listed as      "false, true, true" and apply to function types.  But implementing this      would require all the places in the compiler that use TREE_THIS_VOLATILE      on a decl to identify non-returning functions to be located and fixed      to check the function type instead.  */
block|{
literal|"noreturn"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noreturn_attribute
block|}
block|,
block|{
literal|"volatile"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noreturn_attribute
block|}
block|,
block|{
literal|"noinline"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noinline_attribute
block|}
block|,
block|{
literal|"always_inline"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_always_inline_attribute
block|}
block|,
block|{
literal|"used"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_used_attribute
block|}
block|,
block|{
literal|"unused"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_unused_attribute
block|}
block|,
comment|/* The same comments as for noreturn attributes apply to const ones.  */
block|{
literal|"const"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_const_attribute
block|}
block|,
block|{
literal|"transparent_union"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_transparent_union_attribute
block|}
block|,
block|{
literal|"constructor"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_constructor_attribute
block|}
block|,
block|{
literal|"destructor"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_destructor_attribute
block|}
block|,
block|{
literal|"mode"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|handle_mode_attribute
block|}
block|,
block|{
literal|"section"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_section_attribute
block|}
block|,
block|{
literal|"aligned"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_aligned_attribute
block|}
block|,
block|{
literal|"weak"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_weak_attribute
block|}
block|,
block|{
literal|"alias"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_alias_attribute
block|}
block|,
block|{
literal|"no_instrument_function"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_no_instrument_function_attribute
block|}
block|,
block|{
literal|"malloc"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_malloc_attribute
block|}
block|,
block|{
literal|"no_stack_limit"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_no_limit_stack_attribute
block|}
block|,
block|{
literal|"pure"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_pure_attribute
block|}
block|,
block|{
literal|"deprecated"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_deprecated_attribute
block|}
block|,
block|{
literal|"vector_size"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|handle_vector_size_attribute
block|}
block|,
block|{
literal|"visibility"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_visibility_attribute
block|}
block|,
block|{
literal|"tls_model"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_tls_model_attribute
block|}
block|,
block|{
literal|"nonnull"
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_nonnull_attribute
block|}
block|,
block|{
literal|"nothrow"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_nothrow_attribute
block|}
block|,
block|{
literal|"may_alias"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"cleanup"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_cleanup_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Give the specifications for the format attributes, used by C and all    descendents.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|c_common_format_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"format"
block|,
literal|3
block|,
literal|3
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_format_attribute
block|}
block|,
block|{
literal|"format_arg"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_format_arg_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the start of an if-then, and record the start of it    for ambiguous else detection.     COND is the condition for the if-then statement.     IF_STMT is the statement node that has already been created for    this if-then statement.  It is created before parsing the    condition to keep line number information accurate.  */
end_comment

begin_function
name|void
name|c_expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|compstmt_count
parameter_list|,
name|if_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|compstmt_count
decl_stmt|;
name|tree
name|if_stmt
decl_stmt|;
block|{
comment|/* Make sure there is enough space on the stack.  */
if|if
condition|(
name|if_stack_space
operator|==
literal|0
condition|)
block|{
name|if_stack_space
operator|=
literal|10
expr_stmt|;
name|if_stack
operator|=
operator|(
name|if_elt
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|if_elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_stack_space
operator|==
name|if_stack_pointer
condition|)
block|{
name|if_stack_space
operator|+=
literal|10
expr_stmt|;
name|if_stack
operator|=
operator|(
name|if_elt
operator|*
operator|)
name|xrealloc
argument_list|(
name|if_stack
argument_list|,
name|if_stack_space
operator|*
sizeof|sizeof
argument_list|(
name|if_elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
name|add_stmt
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
comment|/* Record this if statement.  */
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|compstmt_count
operator|=
name|compstmt_count
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|file
operator|=
name|input_filename
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|line
operator|=
name|lineno
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|needs_warning
operator|=
literal|0
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|if_stmt
operator|=
name|if_stmt
expr_stmt|;
name|if_stack_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after the then-clause for an if-statement is processed.  */
end_comment

begin_function
name|void
name|c_finish_then
parameter_list|()
block|{
name|tree
name|if_stmt
init|=
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|if_stmt
decl_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the end of an if-then.  Optionally warn if a nested    if statement had an ambiguous else clause.  */
end_comment

begin_function
name|void
name|c_expand_end_cond
parameter_list|()
block|{
name|if_stack_pointer
operator|--
expr_stmt|;
if|if
condition|(
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|needs_warning
condition|)
name|warning_with_file_and_line
argument_list|(
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|file
argument_list|,
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|line
argument_list|,
literal|"suggest explicit braces to avoid ambiguous `else'"
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called between the then-clause and the else-clause    of an if-then-else.  */
end_comment

begin_function
name|void
name|c_expand_start_else
parameter_list|()
block|{
comment|/* An ambiguous else warning must be generated for the enclosing if      statement, unless we see an else branch for that one, too.  */
if|if
condition|(
name|warn_parentheses
operator|&&
name|if_stack_pointer
operator|>
literal|1
operator|&&
operator|(
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|compstmt_count
operator|==
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|2
index|]
operator|.
name|compstmt_count
operator|)
condition|)
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|2
index|]
operator|.
name|needs_warning
operator|=
literal|1
expr_stmt|;
comment|/* Even if a nested if statement had an else branch, it can't be      ambiguous if this one also has an else.  So don't warn in that      case.  Also don't warn for any if statements nested in this else.  */
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|needs_warning
operator|=
literal|0
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|compstmt_count
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after the else-clause for an if-statement is processed.  */
end_comment

begin_function
name|void
name|c_finish_else
parameter_list|()
block|{
name|tree
name|if_stmt
init|=
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|if_stmt
decl_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin an if-statement.  Returns a newly created IF_STMT if    appropriate.     Unlike the C++ front-end, we do not call add_stmt here; it is    probably safe to do so, but I am not very familiar with this    code so I am being extra careful not to change its behavior    beyond what is strictly necessary for correctness.  */
end_comment

begin_function
name|tree
name|c_begin_if_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|IF_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin a while statement.  Returns a newly created WHILE_STMT if    appropriate.     Unlike the C++ front-end, we do not call add_stmt here; it is    probably safe to do so, but I am not very familiar with this    code so I am being extra careful not to change its behavior    beyond what is strictly necessary for correctness.  */
end_comment

begin_function
name|tree
name|c_begin_while_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|WHILE_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|c_finish_while_stmt_cond
parameter_list|(
name|cond
parameter_list|,
name|while_stmt
parameter_list|)
name|tree
name|while_stmt
decl_stmt|;
name|tree
name|cond
decl_stmt|;
block|{
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push current bindings for the function name VAR_DECLS.  */
end_comment

begin_function
name|void
name|start_fname_decls
parameter_list|()
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|saved
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|decl
init|=
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|saved
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|build_int_2
argument_list|(
name|ix
argument_list|,
literal|0
argument_list|)
argument_list|,
name|saved
argument_list|)
expr_stmt|;
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|saved
operator|||
name|saved_function_name_decls
condition|)
comment|/* Normally they'll have been NULL, so only push if we've got a        stack, or they are non-NULL.  */
name|saved_function_name_decls
operator|=
name|tree_cons
argument_list|(
name|saved
argument_list|,
name|NULL_TREE
argument_list|,
name|saved_function_name_decls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up the current bindings, adding them into the    current function's statement tree. This is done by wrapping the    function's body in a COMPOUND_STMT containing these decls too. This    must be done _before_ finish_stmt_tree is called. If there is no    current function, we must be at file scope and no statements are    involved. Pop the previous bindings.  */
end_comment

begin_function
name|void
name|finish_fname_decls
parameter_list|()
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|body
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|stack
init|=
name|saved_function_name_decls
decl_stmt|;
for|for
control|(
init|;
name|stack
operator|&&
name|TREE_VALUE
argument_list|(
name|stack
argument_list|)
condition|;
name|stack
operator|=
name|TREE_CHAIN
argument_list|(
name|stack
argument_list|)
control|)
name|body
operator|=
name|chainon
argument_list|(
name|TREE_VALUE
argument_list|(
name|stack
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
condition|)
block|{
comment|/* They were called into existence, so add to statement tree.  */
name|body
operator|=
name|chainon
argument_list|(
name|body
argument_list|,
name|TREE_CHAIN
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_stmt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|body
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|=
name|body
expr_stmt|;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|stack
condition|)
block|{
comment|/* We had saved values, restore them.  */
name|tree
name|saved
decl_stmt|;
for|for
control|(
name|saved
operator|=
name|TREE_PURPOSE
argument_list|(
name|stack
argument_list|)
init|;
name|saved
condition|;
name|saved
operator|=
name|TREE_CHAIN
argument_list|(
name|saved
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_PURPOSE
argument_list|(
name|saved
argument_list|)
decl_stmt|;
name|unsigned
name|ix
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|saved
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
block|}
name|stack
operator|=
name|TREE_CHAIN
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
name|saved_function_name_decls
operator|=
name|stack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the text name of the current function, suitable prettified    by PRETTY_P.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fname_as_string
parameter_list|(
name|pretty_p
parameter_list|)
name|int
name|pretty_p
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pretty_p
condition|)
name|name
operator|=
operator|(
name|current_function_decl
condition|?
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
else|:
literal|"top level"
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|""
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return the text name of the current function, formatted as    required by the supplied RID value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fname_string
parameter_list|(
name|rid
parameter_list|)
name|unsigned
name|rid
decl_stmt|;
block|{
name|unsigned
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|fname_vars
index|[
name|ix
index|]
operator|.
name|rid
operator|==
name|rid
condition|)
break|break;
return|return
name|fname_as_string
argument_list|(
name|fname_vars
index|[
name|ix
index|]
operator|.
name|pretty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the VAR_DECL for a const char array naming the current    function. If the VAR_DECL has not yet been created, create it    now. RID indicates how it should be formatted and IDENTIFIER_NODE    ID is its name (unfortunately C and C++ hold the RID values of    keywords in different places, so we can't derive RID from ID in    this language independent code.  */
end_comment

begin_function
name|tree
name|fname_decl
parameter_list|(
name|rid
parameter_list|,
name|id
parameter_list|)
name|unsigned
name|rid
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|fname_vars
index|[
name|ix
index|]
operator|.
name|rid
operator|==
name|rid
condition|)
break|break;
name|decl
operator|=
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
name|tree
name|saved_last_tree
init|=
name|last_tree
decl_stmt|;
comment|/* If a tree is built here, it would normally have the lineno of 	 the current statement.  Later this tree will be moved to the 	 beginning of the function and this line number will be wrong. 	 To avoid this problem set the lineno to 0 here; that prevents 	 it from appearing in the RTL.  */
name|int
name|saved_lineno
init|=
name|lineno
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|decl
operator|=
call|(
modifier|*
name|make_fname_decl
call|)
argument_list|(
name|id
argument_list|,
name|fname_vars
index|[
name|ix
index|]
operator|.
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_tree
operator|!=
name|saved_last_tree
condition|)
block|{
comment|/* We created some statement tree for the decl. This belongs 	     at the start of the function, so remove it now and reinsert 	     it after the function is complete.  */
name|tree
name|stmts
init|=
name|TREE_CHAIN
argument_list|(
name|saved_last_tree
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|saved_last_tree
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|last_tree
operator|=
name|saved_last_tree
expr_stmt|;
name|saved_function_name_decls
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|stmts
argument_list|,
name|saved_function_name_decls
argument_list|)
expr_stmt|;
block|}
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ix
operator|&&
operator|!
name|current_function_decl
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' is not defined outside of function scope"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given a STRING_CST, give it a suitable array-of-chars data type.  */
end_comment

begin_function
name|tree
name|fix_string_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
specifier|const
name|int
name|wchar_bytes
init|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
specifier|const
name|int
name|wide_flag
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|wchar_array_type_node
decl_stmt|;
specifier|const
name|int
name|nchars_max
init|=
name|flag_isoc99
condition|?
literal|4095
else|:
literal|509
decl_stmt|;
name|int
name|length
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|int
name|nchars
decl_stmt|;
comment|/* Compute the number of elements, for the array type.  */
name|nchars
operator|=
name|wide_flag
condition|?
name|length
operator|/
name|wchar_bytes
else|:
name|length
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|nchars
operator|-
literal|1
operator|>
name|nchars_max
operator|&&
name|c_language
operator|==
name|clk_c
condition|)
name|pedwarn
argument_list|(
literal|"string length `%d' is greater than the length `%d' ISO C%d compilers are required to support"
argument_list|,
name|nchars
operator|-
literal|1
argument_list|,
name|nchars_max
argument_list|,
name|flag_isoc99
condition|?
literal|99
else|:
literal|89
argument_list|)
expr_stmt|;
comment|/* Create the array type for the string constant.      -Wwrite-strings says make the string constant an array of const char      so that copying it to a non-const pointer will get a warning.      For C++, this is the standard behavior.  */
if|if
condition|(
name|flag_const_strings
operator|&&
operator|!
name|flag_writable_strings
condition|)
block|{
name|tree
name|elements
init|=
name|build_type_variant
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|elements
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|value
argument_list|)
operator|=
operator|!
name|flag_writable_strings
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Given a VARRAY of STRING_CST nodes, concatenate them into one    STRING_CST.  */
end_comment

begin_function
name|tree
name|combine_strings
parameter_list|(
name|strings
parameter_list|)
name|varray_type
name|strings
decl_stmt|;
block|{
specifier|const
name|int
name|wchar_bytes
init|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
specifier|const
name|int
name|nstrings
init|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|strings
argument_list|)
decl_stmt|;
name|tree
name|value
decl_stmt|,
name|t
decl_stmt|;
name|int
name|length
init|=
literal|1
decl_stmt|;
name|int
name|wide_length
init|=
literal|0
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Don't include the \0 at the end of each substring.  Count wide      strings and ordinary strings separately.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstrings
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|=
name|VARRAY_TREE
argument_list|(
name|strings
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
block|{
name|wide_length
operator|+=
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
name|wchar_bytes
expr_stmt|;
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|C_ARTIFICIAL_STRING_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
literal|"concatenation of string literals with __FUNCTION__ is deprecated"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If anything is wide, the non-wides will be converted,      which makes them take more space.  */
if|if
condition|(
name|wide_flag
condition|)
name|length
operator|=
name|length
operator|*
name|wchar_bytes
operator|+
name|wide_length
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* Copy the individual strings into the new combined string.      If the combined string is wide, convert the chars to ints      for any individual strings that are not wide.  */
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstrings
condition|;
operator|++
name|i
control|)
block|{
name|int
name|len
decl_stmt|,
name|this_wide
decl_stmt|;
name|t
operator|=
name|VARRAY_TREE
argument_list|(
name|strings
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|this_wide
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
operator|(
name|this_wide
condition|?
name|wchar_bytes
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|this_wide
operator|==
name|wide_flag
condition|)
block|{
name|memcpy
argument_list|(
name|q
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|nzeros
init|=
operator|(
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nzeros
condition|;
name|j
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
operator|*
name|q
operator|++
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nzeros
condition|;
name|j
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Nul terminate the string.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wchar_bytes
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|build_string
argument_list|(
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|wchar_array_type_node
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|is_valid_printf_arglist
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|c_expand_builtin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|c_expand_builtin_printf
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|c_expand_builtin_fprintf
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print a warning if a constant expression had overflow in folding.    Invoke this function on every expression that the language    requires to be a constant expression.    Note the ANSI C standard says it is erroneous for a    constant expression to overflow.  */
end_comment

begin_function
name|void
name|constant_expression_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VECTOR_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"overflow in constant expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning if an expression had overflow in folding.    Invoke this function on every expression that    (1) appears in the source code, and    (2) might be a constant expression that overflowed, and    (3) is not already checked by convert_and_check;    however, do not invoke this function on operands of explicit casts.  */
end_comment

begin_function
name|void
name|overflow_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"integer overflow in expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"floating point overflow in expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"vector overflow in expression"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a warning if a large constant is truncated to unsigned,    or if -Wconversion is used and a constant< 0 is converted to unsigned.    Invoke this function on every expression that might be implicitly    converted to an unsigned type.  */
end_comment

begin_function
name|void
name|unsigned_conversion_warning
parameter_list|(
name|result
parameter_list|,
name|operand
parameter_list|)
name|tree
name|result
decl_stmt|,
name|operand
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|skip_evaluation
operator|==
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|c_common_signed_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* This detects cases like converting -129 or 256 to unsigned char.  */
name|warning
argument_list|(
literal|"large integer implicitly truncated to unsigned type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_conversion
condition|)
name|warning
argument_list|(
literal|"negative integer implicitly converted to unsigned type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if constant C has a value that is permissible    for type TYPE (an INTEGER_TYPE).  */
end_comment

begin_function
specifier|static
name|int
name|constant_fits_type_p
parameter_list|(
name|c
parameter_list|,
name|type
parameter_list|)
name|tree
name|c
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|int_fits_type_p
argument_list|(
name|c
argument_list|,
name|type
argument_list|)
return|;
name|c
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|!
name|TREE_OVERFLOW
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE, warning about conversion problems with constants.    Invoke this function on every expression that is converted implicitly,    i.e. because of language rules and not because of an explicit cast.  */
end_comment

begin_function
name|tree
name|convert_and_check
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do not diagnose overflow in a constant expression merely 	     because a conversion overflowed.  */
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* No warning for converting 0x80000000 to int.  */
if|if
condition|(
operator|!
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* If EXPR fits in the unsigned version of TYPE, 	       don't warn unless pedantic.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|constant_fits_type_p
argument_list|(
name|expr
argument_list|,
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"overflow in implicit constant conversion"
argument_list|)
expr_stmt|;
block|}
else|else
name|unsigned_conversion_warning
argument_list|(
name|t
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A node in a list that describes references to variables (EXPR), which are    either read accesses if WRITER is zero, or write accesses, in which case    WRITER is the parent of EXPR.  */
end_comment

begin_struct
struct|struct
name|tlist
block|{
name|struct
name|tlist
modifier|*
name|next
decl_stmt|;
name|tree
name|expr
decl_stmt|,
name|writer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to implement a cache the results of a call to verify_tree.  We only    use this for SAVE_EXPRs.  */
end_comment

begin_struct
struct|struct
name|tlist_cache
block|{
name|struct
name|tlist_cache
modifier|*
name|next
decl_stmt|;
name|struct
name|tlist
modifier|*
name|cache_before_sp
decl_stmt|;
name|struct
name|tlist
modifier|*
name|cache_after_sp
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Obstack to use when allocating tlist structures, and corresponding    firstobj.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|tlist_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tlist_firstobj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of the identifiers we've warned about, so we can avoid duplicate    warnings.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tlist
modifier|*
name|warned_ids
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SAVE_EXPRs need special treatment.  We process them only once and then    cache the results.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tlist_cache
modifier|*
name|save_expr_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_tlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|*
operator|,
expr|struct
name|tlist
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_tlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|*
operator|,
expr|struct
name|tlist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verify_tree
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|tlist
operator|*
operator|*
operator|,
expr|struct
name|tlist
operator|*
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warning_candidate_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_for_collisions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_for_collisions_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|struct
name|tlist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tlist
modifier|*
name|new_tlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verify_sequence_points
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new struct tlist and fill in its fields.  */
end_comment

begin_function
specifier|static
name|struct
name|tlist
modifier|*
name|new_tlist
parameter_list|(
name|next
parameter_list|,
name|t
parameter_list|,
name|writer
parameter_list|)
name|struct
name|tlist
modifier|*
name|next
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|writer
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
expr|struct
name|tlist
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|l
operator|->
name|expr
operator|=
name|t
expr_stmt|;
name|l
operator|->
name|writer
operator|=
name|writer
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Add duplicates of the nodes found in ADD to the list *TO.  If EXCLUDE_WRITER    is nonnull, we ignore any node we find which has a writer equal to it.  */
end_comment

begin_function
specifier|static
name|void
name|add_tlist
parameter_list|(
name|to
parameter_list|,
name|add
parameter_list|,
name|exclude_writer
parameter_list|,
name|copy
parameter_list|)
name|struct
name|tlist
modifier|*
modifier|*
name|to
decl_stmt|;
name|struct
name|tlist
modifier|*
name|add
decl_stmt|;
name|tree
name|exclude_writer
decl_stmt|;
name|int
name|copy
decl_stmt|;
block|{
while|while
condition|(
name|add
condition|)
block|{
name|struct
name|tlist
modifier|*
name|next
init|=
name|add
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|copy
condition|)
name|add
operator|->
name|next
operator|=
operator|*
name|to
expr_stmt|;
if|if
condition|(
operator|!
name|exclude_writer
operator|||
name|add
operator|->
name|writer
operator|!=
name|exclude_writer
condition|)
operator|*
name|to
operator|=
name|copy
condition|?
name|new_tlist
argument_list|(
operator|*
name|to
argument_list|,
name|add
operator|->
name|expr
argument_list|,
name|add
operator|->
name|writer
argument_list|)
else|:
name|add
expr_stmt|;
name|add
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge the nodes of ADD into TO.  This merging process is done so that for    each variable that already exists in TO, no new node is added; however if    there is a write access recorded in ADD, and an occurrence on TO is only    a read access, then the occurrence in TO will be modified to record the    write.  */
end_comment

begin_function
specifier|static
name|void
name|merge_tlist
parameter_list|(
name|to
parameter_list|,
name|add
parameter_list|,
name|copy
parameter_list|)
name|struct
name|tlist
modifier|*
modifier|*
name|to
decl_stmt|;
name|struct
name|tlist
modifier|*
name|add
decl_stmt|;
name|int
name|copy
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
modifier|*
name|end
init|=
name|to
decl_stmt|;
while|while
condition|(
operator|*
name|end
condition|)
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|add
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|tlist
modifier|*
name|tmp2
decl_stmt|;
name|struct
name|tlist
modifier|*
name|next
init|=
name|add
operator|->
name|next
decl_stmt|;
for|for
control|(
name|tmp2
operator|=
operator|*
name|to
init|;
name|tmp2
condition|;
name|tmp2
operator|=
name|tmp2
operator|->
name|next
control|)
if|if
condition|(
name|tmp2
operator|->
name|expr
operator|==
name|add
operator|->
name|expr
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tmp2
operator|->
name|writer
condition|)
name|tmp2
operator|->
name|writer
operator|=
name|add
operator|->
name|writer
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|*
name|end
operator|=
name|copy
condition|?
name|add
else|:
name|new_tlist
argument_list|(
name|NULL
argument_list|,
name|add
operator|->
name|expr
argument_list|,
name|add
operator|->
name|writer
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
block|}
name|add
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* WRITTEN is a variable, WRITER is its parent.  Warn if any of the variable    references in list LIST conflict with it, excluding reads if ONLY writers    is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_collisions_1
parameter_list|(
name|written
parameter_list|,
name|writer
parameter_list|,
name|list
parameter_list|,
name|only_writes
parameter_list|)
name|tree
name|written
decl_stmt|,
name|writer
decl_stmt|;
name|struct
name|tlist
modifier|*
name|list
decl_stmt|;
name|int
name|only_writes
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|tmp
decl_stmt|;
comment|/* Avoid duplicate warnings.  */
for|for
control|(
name|tmp
operator|=
name|warned_ids
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|tmp
operator|->
name|expr
operator|==
name|written
condition|)
return|return;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|expr
operator|==
name|written
operator|&&
name|list
operator|->
name|writer
operator|!=
name|writer
operator|&&
operator|(
operator|!
name|only_writes
operator|||
name|list
operator|->
name|writer
operator|)
condition|)
block|{
name|warned_ids
operator|=
name|new_tlist
argument_list|(
name|warned_ids
argument_list|,
name|written
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"operation on `%s' may be undefined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|list
operator|->
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a list LIST of references to variables, find whether any of these    can cause conflicts due to missing sequence points.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_collisions
parameter_list|(
name|list
parameter_list|)
name|struct
name|tlist
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|list
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tmp
operator|->
name|writer
condition|)
name|warn_for_collisions_1
argument_list|(
name|tmp
operator|->
name|expr
argument_list|,
name|tmp
operator|->
name|writer
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if X is a tree that can be verified by the sequence point    warnings.  */
end_comment

begin_function
specifier|static
name|int
name|warning_candidate_p
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
return|return
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
return|;
block|}
end_function

begin_comment
comment|/* Walk the tree X, and record accesses to variables.  If X is written by the    parent tree, WRITER is the parent.    We store accesses in one of the two lists: PBEFORE_SP, and PNO_SP.  If this    expression or its only operand forces a sequence point, then everything up    to the sequence point is stored in PBEFORE_SP.  Everything else gets stored    in PNO_SP.    Once we return, we will have emitted warnings if any subexpression before    such a sequence point could be undefined.  On a higher level, however, the    sequence point may not be relevant, and we'll merge the two lists.     Example: (b++, a) + b;    The call that processes the COMPOUND_EXPR will store the increment of B    in PBEFORE_SP, and the use of A in PNO_SP.  The higher-level call that    processes the PLUS_EXPR will need to merge the two lists so that    eventually, all accesses end up on the same list (and we'll warn about the    unordered subexpressions b++ and b.     A note on merging.  If we modify the former example so that our expression    becomes      (b++, b) + a    care must be taken not simply to add all three expressions into the final    PNO_SP list.  The function merge_tlist takes care of that by merging the    before-SP list of the COMPOUND_EXPR into its after-SP list in a special    way, so that no more than one access to B is recorded.  */
end_comment

begin_function
specifier|static
name|void
name|verify_tree
parameter_list|(
name|x
parameter_list|,
name|pbefore_sp
parameter_list|,
name|pno_sp
parameter_list|,
name|writer
parameter_list|)
name|tree
name|x
decl_stmt|;
name|struct
name|tlist
modifier|*
modifier|*
name|pbefore_sp
decl_stmt|,
decl|*
modifier|*
name|pno_sp
decl_stmt|;
end_function

begin_decl_stmt
name|tree
name|writer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tlist
modifier|*
name|tmp_before
decl_stmt|,
modifier|*
name|tmp_nosp
decl_stmt|,
modifier|*
name|tmp_list2
decl_stmt|,
modifier|*
name|tmp_list3
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|char
name|class
decl_stmt|;
comment|/* X may be NULL if it is the operand of an empty statement expression      ({ }).  */
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return;
name|restart
label|:
name|code
operator|=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_candidate_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|pno_sp
operator|=
name|new_tlist
argument_list|(
operator|*
name|pno_sp
argument_list|,
name|x
argument_list|,
name|writer
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
return|return;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_nosp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|pno_sp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXPR
case|:
name|tmp_before
operator|=
name|tmp_list2
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_list2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_list2
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
name|tmp_list2
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_list2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_list2
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rather than add both tmp_nosp and tmp_list2, we have to merge the 	 two first, to avoid warning for (a ? b++ : b++).  */
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_list2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pno_sp
argument_list|,
name|pno_sp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Expressions inside the LHS are not ordered wrt. the sequence points 	 in the RHS.  Example: 	   *a = (a++, 2) 	 Despite the fact that the modification of "a" is in the before_sp 	 list (tmp_before), it conflicts with the use of "a" in the LHS. 	 We can handle this by adding the contents of tmp_list3 	 to those of tmp_before, and redoing the collision warnings for that 	 list.  */
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_list3
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_before
argument_list|)
expr_stmt|;
comment|/* Exclude the LHS itself here; we first have to merge it into the 	 tmp_nosp list.  This is done to avoid warning for "a = a"; if we 	 didn't exclude the LHS, we'd get it twice, once as a read and once 	 as a write.  */
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_list3
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|tmp_nosp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_candidate_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|new_tlist
argument_list|(
name|NULL
argument_list|,
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
comment|/* We need to warn about conflicts among arguments and conflicts between 	 args and the function address.  Side effects of the function address, 	 however, are not ordered by the sequence point of the call.  */
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list2
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list2
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_list3
argument_list|,
name|tmp_list2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_list3
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_before
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|TREE_LIST
case|:
comment|/* Scan all the list, e.g. indices of multi dimensional array.  */
while|while
condition|(
name|x
condition|)
block|{
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|SAVE_EXPR
case|:
block|{
name|struct
name|tlist_cache
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|save_expr_cache
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|expr
operator|==
name|x
condition|)
break|break;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|t
operator|=
operator|(
expr|struct
name|tlist_cache
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|save_expr_cache
expr_stmt|;
name|t
operator|->
name|expr
operator|=
name|x
expr_stmt|;
name|save_expr_cache
operator|=
name|t
expr_stmt|;
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp_nosp
condition|)
block|{
name|struct
name|tlist
modifier|*
name|t
init|=
name|tmp_nosp
decl_stmt|;
name|tmp_nosp
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_list3
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|cache_before_sp
operator|=
name|tmp_before
expr_stmt|;
name|t
operator|->
name|cache_after_sp
operator|=
name|tmp_list3
expr_stmt|;
block|}
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|t
operator|->
name|cache_before_sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|t
operator|->
name|cache_after_sp
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|class
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|first_rtl_op
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writer
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'<'
case|:
case|case
literal|'2'
case|:
case|case
literal|'b'
case|:
case|case
literal|'e'
case|:
case|case
literal|'s'
case|:
case|case
literal|'x'
case|:
block|{
name|int
name|lp
decl_stmt|;
name|int
name|max
init|=
name|first_rtl_op
argument_list|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|lp
operator|=
literal|0
init|;
name|lp
operator|<
name|max
condition|;
name|lp
operator|++
control|)
block|{
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
name|lp
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Try to warn for undefined behavior in EXPR due to missing sequence    points.  */
end_comment

begin_function
specifier|static
name|void
name|verify_sequence_points
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|before_sp
init|=
literal|0
decl_stmt|,
modifier|*
name|after_sp
init|=
literal|0
decl_stmt|;
name|warned_ids
operator|=
literal|0
expr_stmt|;
name|save_expr_cache
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tlist_firstobj
operator|==
literal|0
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|tlist_obstack
argument_list|)
expr_stmt|;
name|tlist_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|verify_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|before_sp
argument_list|,
operator|&
name|after_sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|after_sp
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
name|tlist_firstobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|c_expand_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
comment|/* Do default conversion if safe and possibly important,      in case within ({...}).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|flag_isoc99
operator|||
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_sequence_point
condition|)
name|verify_sequence_points
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"expression statement has incomplete type"
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate the expression after `case' and apply default promotions.  */
end_comment

begin_function
name|tree
name|check_case_value
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
return|return
name|value
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* In C++, the following is allowed:         const int i = 3;        switch (...) { case i: ... }       So, we try to reduce the VALUE to a constant that way.  */
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
block|{
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|fold
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"case label does not reduce to an integer constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
comment|/* Promote char or short to int.  */
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|c_common_type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|unsigned
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a data type that has machine mode MODE.    If the mode is an integer,    then UNSIGNEDP selects between signed and unsigned types.  */
end_comment

begin_function
name|tree
name|c_common_type_for_mode
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|QImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|HImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V16QImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V16QI_type_node
else|:
name|V16QI_type_node
return|;
case|case
name|V8HImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V8HI_type_node
else|:
name|V8HI_type_node
return|;
case|case
name|V4SImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V4SI_type_node
else|:
name|V4SI_type_node
return|;
case|case
name|V2DImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V2DI_type_node
else|:
name|V2DI_type_node
return|;
case|case
name|V2SImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V2SI_type_node
else|:
name|V2SI_type_node
return|;
case|case
name|V2HImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V2HI_type_node
else|:
name|V2HI_type_node
return|;
case|case
name|V4HImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V4HI_type_node
else|:
name|V4HI_type_node
return|;
case|case
name|V8QImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V8QI_type_node
else|:
name|V8QI_type_node
return|;
case|case
name|V1DImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V1DI_type_node
else|:
name|V1DI_type_node
return|;
case|case
name|V16SFmode
case|:
return|return
name|V16SF_type_node
return|;
case|case
name|V4SFmode
case|:
return|return
name|V4SF_type_node
return|;
case|case
name|V2SFmode
case|:
return|return
name|V2SF_type_node
return|;
case|case
name|V2DFmode
case|:
return|return
name|V2DF_type_node
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|c_common_unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|widest_integer_literal_type_node
condition|)
return|return
name|widest_unsigned_literal_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|intTI_type_node
condition|)
return|return
name|unsigned_intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|intDI_type_node
condition|)
return|return
name|unsigned_intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intSI_type_node
condition|)
return|return
name|unsigned_intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intHI_type_node
condition|)
return|return
name|unsigned_intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intQI_type_node
condition|)
return|return
name|unsigned_intQI_type_node
return|;
return|return
name|c_common_signed_or_unsigned_type
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|c_common_signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|widest_unsigned_literal_type_node
condition|)
return|return
name|widest_integer_literal_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|unsigned_intTI_type_node
condition|)
return|return
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|unsigned_intDI_type_node
condition|)
return|return
name|intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intSI_type_node
condition|)
return|return
name|intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intHI_type_node
condition|)
return|return
name|intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intQI_type_node
condition|)
return|return
name|intQI_type_node
return|;
return|return
name|c_common_signed_or_unsigned_type
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|c_common_signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|unsignedp
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the minimum number of bits needed to represent VALUE in a    signed or unsigned type, UNSIGNEDP says which.  */
end_comment

begin_function
name|unsigned
name|int
name|min_precision
parameter_list|(
name|value
parameter_list|,
name|unsignedp
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|log
decl_stmt|;
comment|/* If the value is negative, compute its negative minus 1.  The latter      adjustment is because the absolute value of the largest negative value      is one larger than the largest positive value.  This is equivalent to      a bit-wise negation, so use that operation instead.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|)
name|value
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the number of bits needed, taking into account the fact      that we need one more bit for a signed than unsigned type.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|value
argument_list|)
condition|)
name|log
operator|=
literal|0
expr_stmt|;
else|else
name|log
operator|=
name|tree_floor_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|log
operator|+
literal|1
operator|+
operator|!
name|unsignedp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation    CODE.  NOP_EXPR is used as a special case (see    c_common_truthvalue_conversion).  */
end_comment

begin_function
name|void
name|binary_op_error
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|error
argument_list|(
literal|"invalid truth-value expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|opname
operator|=
literal|"rotate"
expr_stmt|;
break|break;
default|default:
name|opname
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.    This function is also responsible for converting the two operands    to the proper common type for comparison.     The arguments of this function are all pointers to local variables    of build_binary_op: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
name|tree
name|shorten_compare
parameter_list|(
name|op0_ptr
parameter_list|,
name|op1_ptr
parameter_list|,
name|restype_ptr
parameter_list|,
name|rescode_ptr
parameter_list|)
name|tree
modifier|*
name|op0_ptr
decl_stmt|,
decl|*
name|op1_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|tree
modifier|*
name|restype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tree_code
modifier|*
name|rescode_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  Don't do this if      the second arg is 0.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|primop0
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
operator|!
name|real_zerop
argument_list|(
name|primop1
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If TYPE is an enumeration, then we need to get its min/max 	 values from it's underlying integral type, not the enumerated 	 type itself.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|type
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|unsignedp0
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|c_common_signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|primop1
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
comment|/* This used to be a switch, but Genix compiler can't handle that.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
block|{
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|type
operator|=
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|boolean_false_node
condition|)
name|warning
argument_list|(
literal|"comparison is always false due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|boolean_true_node
condition|)
name|warning
argument_list|(
literal|"comparison is always true due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
comment|/* All unsigned values are>= 0, so we warn if extra warnings 		 are requested.  However, if OP0 is a constant that is>= 0, the signedness of the comparison isn't an issue, 		 so suppress the warning.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|c_common_signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of unsigned expression>= 0 is always true"
argument_list|)
expr_stmt|;
name|value
operator|=
name|boolean_true_node
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|c_common_signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of unsigned expression< 0 is always false"
argument_list|)
expr_stmt|;
name|value
operator|=
name|boolean_false_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|value
argument_list|)
return|;
return|return
name|value
return|;
block|}
block|}
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|boolean_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
name|tree
name|pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|size_exp
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|tree
name|folded
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type `void *' used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer to member function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a member used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|size_exp
argument_list|)
comment|/* If the constant comes from pointer subtraction, 	 skip this optimization--it would cause an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
comment|/* If the constant is unsigned, and smaller than the pointer size, 	 then we must skip this optimization.  This is because it could cause 	 an overflow error if the constant is negative but INTOP is not.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|int_type
init|=
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
comment|/* Convert both subexpression types to the type of intop, 	 because weird cases involving pointer arithmetic 	 can result in a sum or difference with different type args.  */
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intop
operator|=
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as sizetype      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
condition|)
name|intop
operator|=
name|convert
argument_list|(
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument with a suitable product by the object size.      Do this multiplication as signed, then convert to the appropriate      pointer type (actually unsigned integral).  */
name|intop
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|,
name|size_exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|ptrop
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, boolean_false_node, 1),    but we optimize comparisons,&&, ||, and !.     The resulting type should always be `boolean_type_node'.  */
end_comment

begin_function
name|tree
name|c_common_truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|#
directive|if
literal|0
comment|/* This appears to be wrong for C++.  */
comment|/* These really should return error_mark_node after 2.4 is stable.      But not all callers handle ERROR_MARK properly.  */
block|switch (TREE_CODE (TREE_TYPE (expr)))     {     case RECORD_TYPE:       error ("struct type value used where scalar is required");       return boolean_false_node;      case UNION_TYPE:       error ("union type value used where scalar is required");       return boolean_false_node;      case ARRAY_TYPE:       error ("array type value used where scalar is required");       return boolean_false_node;      default:       break;     }
endif|#
directive|endif
comment|/* 0 */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
return|return
name|expr
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
return|;
case|case
name|REAL_CST
case|:
return|return
name|real_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* If we are taking the address of an external decl, it might be zero 	 if it is weak, so we cannot optimize.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|boolean_true_node
argument_list|)
return|;
else|else
return|return
name|boolean_true_node
return|;
case|case
name|COMPLEX_EXPR
case|:
return|return
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FFS_EXPR
case|:
comment|/* These don't change whether an object is nonzero or zero.  */
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These don't change whether an object is zero or nonzero, but 	 we can't ignore them if their second arg has side-effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
comment|/* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE, 	 since that affects how `default_conversion' will behave.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* fall through...  */
case|case
name|NOP_EXPR
case|:
comment|/* If this is widening the argument, we can ignore it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Perhaps reduce (x - y) != 0 to (x != y).  The expressions 	 aren't guaranteed to the be same for modes that can represent 	 infinity, since if x and y are both +infinity, or both 	 -infinity, then x - y is not a number.  	 Note that this transformation is safe when x or y is NaN. 	 (x - y) is then NaN, and both (x - y) != 0 and x != y will 	 be false.  */
if|if
condition|(
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* fall through...  */
case|case
name|BIT_XOR_EXPR
case|:
comment|/* This and MINUS_EXPR can be changed into a comparison of the 	 two objects.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|boolean_type_node
condition|)
comment|/* Using convert here would cause infinite recursion.  */
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|)
return|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|warn_parentheses
operator|&&
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|t
init|=
name|save_expr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
operator|(
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|tree
name|builtin_function_2
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
expr|enum
name|built_in_class
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a variant type in the proper way for C/C++, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|c_build_qualified_type
parameter_list|(
name|type
parameter_list|,
name|type_quals
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
block|{
comment|/* A restrict-qualified pointer type must be a pointer to object or      incomplete type.  Note that the use of POINTER_TYPE_P also allows      REFERENCE_TYPEs, which is appropriate for C++.  Unfortunately,      the C++ front-end also use POINTER_TYPE for pointer-to-member      values, so even though it should be illegal to use `restrict'      with such an entity we don't flag that here.  Thus, special case      code for that case is required in the C++ front-end.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator|&&
operator|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|C_TYPE_OBJECT_OR_INCOMPLETE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of `restrict'"
argument_list|)
expr_stmt|;
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_RESTRICT
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|build_array_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Apply the TYPE_QUALS to the new DECL.  */
end_comment

begin_function
name|void
name|c_apply_type_quals_to_decl
parameter_list|(
name|type_quals
parameter_list|,
name|decl
parameter_list|)
name|int
name|type_quals
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
operator|!
name|C_TYPE_OBJECT_OR_INCOMPLETE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of `restrict'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_strict_aliasing
condition|)
comment|/* Indicate we need to make a unique alias set for this pointer. 	   We can't do it here because it might be pointing to an 	   incomplete type.  */
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|decl
argument_list|)
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the typed-based alias set for T, which may be an expression    or a type.  Return -1 if we don't do anything special.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|c_common_get_alias_set
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|u
decl_stmt|;
comment|/* Permit type-punning when accessing a union, provided the access      is directly through the union.  For example, this code does not      permit taking the address of a union member and then storing      through it.  Even the type-punning allowed here is a GCC      extension, albeit a common and useful one; the C standard says      that such accesses have implementation-defined behavior.  */
for|for
control|(
name|u
operator|=
name|t
init|;
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|ARRAY_REF
condition|;
name|u
operator|=
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|0
return|;
comment|/* That's all the expressions we handle specially.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The C standard guarantess that any object may be accessed via an      lvalue that has character type.  */
if|if
condition|(
name|t
operator|==
name|char_type_node
operator|||
name|t
operator|==
name|signed_char_type_node
operator|||
name|t
operator|==
name|unsigned_char_type_node
condition|)
return|return
literal|0
return|;
comment|/* If it has the may_alias attribute, it can alias anything.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"may_alias"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The C standard specifically allows aliasing between signed and      unsigned variants of the same type.  We treat the signed      variant as canonical.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|t1
init|=
name|c_common_signed_type
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* t1 == t can happen for boolean nodes which are always unsigned.  */
if|if
condition|(
name|t1
operator|!=
name|t
condition|)
return|return
name|get_alias_set
argument_list|(
name|t1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|;
comment|/* Unfortunately, there is no canonical form of a pointer type. 	 In particular, if we have `typedef int I', then `int *', and 	 `I *' are different types.  So, we have to pick a canonical 	 representative.  We do this below.  	 Technically, this approach is actually more conservative that 	 it needs to be.  In particular, `const int *' and `int *' 	 should be in different alias sets, according to the C and C++ 	 standard, since their types are not the same, and so, 	 technically, an `int **' and `const int **' cannot point at 	 the same thing.           But, the standard is wrong.  In particular, this code is 	 legal C++:              int *ip;             int **ipp =&ip;             const int* const* cipp =&ipp;           And, it doesn't make sense for that to be legal unless you 	 can dereference IPP and CIPP.  So, we ignore cv-qualifiers on 	 the pointed-to types.  This issue has been reported to the 	 C++ committee.  */
name|t1
operator|=
name|build_type_no_quals
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t
condition|)
return|return
name|get_alias_set
argument_list|(
name|t1
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the value of 'sizeof (TYPE)' or '__alignof__ (TYPE)', where the    second parameter indicates which OPERATOR is being applied.  The COMPLAIN    flag controls whether we should diagnose possibly ill-formed    constructs or not.  */
end_comment

begin_function
name|tree
name|c_sizeof_or_alignof_type
parameter_list|(
name|type
parameter_list|,
name|op
parameter_list|,
name|complain
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|tree_code
name|op
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|op_name
decl_stmt|;
name|tree
name|value
init|=
name|NULL
decl_stmt|;
name|enum
name|tree_code
name|type_code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|op
operator|==
name|SIZEOF_EXPR
operator|||
name|op
operator|==
name|ALIGNOF_EXPR
argument_list|,
literal|20020720
argument_list|)
expr_stmt|;
name|op_name
operator|=
name|op
operator|==
name|SIZEOF_EXPR
condition|?
literal|"sizeof"
else|:
literal|"__alignof__"
expr_stmt|;
if|if
condition|(
name|type_code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SIZEOF_EXPR
condition|)
block|{
if|if
condition|(
name|complain
operator|&&
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid application of `sizeof' to a function type"
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_one_node
expr_stmt|;
block|}
else|else
name|value
operator|=
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_code
operator|==
name|VOID_TYPE
operator|||
name|type_code
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|type_code
operator|==
name|VOID_TYPE
operator|&&
name|complain
operator|&&
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid application of `%s' to a void type"
argument_list|,
name|op_name
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid application of `%s' to an incomplete type"
argument_list|,
name|op_name
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_zero_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|==
name|SIZEOF_EXPR
condition|)
comment|/* Convert in case a char is more than one unit.  */
name|value
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* VALUE will have an integer type with TYPE_IS_SIZETYPE set.      TYPE_IS_SIZETYPE means that certain things (like overflow) will      never happen.  However, this node should really have type      `size_t', which is just a typedef for an ordinary integer type.  */
name|value
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|size_type_node
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
literal|20001021
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of EXPR, measured in bytes.  For VAR_DECL's and    FIELD_DECL's return DECL_ALIGN (which can be set from an    "aligned" __attribute__ specification).  */
end_comment

begin_function
name|tree
name|c_alignof_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|expr
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`__alignof' applied to a bit-field"
argument_list|)
expr_stmt|;
name|t
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|best
init|=
name|t
decl_stmt|;
name|int
name|bestalign
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|int
name|thisalign
decl_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisalign
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisalign
operator|>
name|bestalign
condition|)
name|best
operator|=
name|t
operator|,
name|bestalign
operator|=
name|thisalign
expr_stmt|;
block|}
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|best
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|size_type_node
argument_list|,
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle C and C++ default attributes.  */
end_comment

begin_enum
enum|enum
name|built_in_attribute
block|{
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_FN_ATTR
parameter_list|(
name|NAME
parameter_list|,
name|ATTRS
parameter_list|,
name|PREDICATE
parameter_list|)
comment|/* No entry needed in enum.  */
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
undef|#
directive|undef
name|DEF_FN_ATTR
name|ATTR_LAST
block|}
enum|;
end_enum

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|built_in_attributes
index|[
operator|(
name|int
operator|)
name|ATTR_LAST
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|bool
name|c_attrs_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|c_init_attributes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build tree nodes and builtin functions common to both C and C++ language    frontends.  */
end_comment

begin_function
name|void
name|c_common_nodes_and_builtins
parameter_list|()
block|{
enum|enum
name|builtin_type
block|{
define|#
directive|define
name|DEF_PRIMITIVE_TYPE
parameter_list|(
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_0
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_1
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_2
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_3
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_4
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_0
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_1
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_2
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_3
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_POINTER_TYPE
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|)
value|NAME,
include|#
directive|include
file|"builtin-types.def"
undef|#
directive|undef
name|DEF_PRIMITIVE_TYPE
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_3
undef|#
directive|undef
name|DEF_POINTER_TYPE
name|BT_LAST
block|}
enum|;
typedef|typedef
name|enum
name|builtin_type
name|builtin_type
typedef|;
name|tree
name|builtin_types
index|[
operator|(
name|int
operator|)
name|BT_LAST
index|]
decl_stmt|;
name|int
name|wchar_type_size
decl_stmt|;
name|tree
name|array_domain_type
decl_stmt|;
name|tree
name|va_list_ref_type_node
decl_stmt|;
name|tree
name|va_list_arg_type_node
decl_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|record_builtin_type
argument_list|(
name|RID_INT
argument_list|,
name|NULL
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_CHAR
argument_list|,
literal|"char"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* `signed' is the same as `int'.  FIXME: the declarations of "signed",      "unsigned long", "long long unsigned" and "unsigned short" were in C++      but not C.  Are the conditionals here needed?  */
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_SIGNED
argument_list|,
name|NULL
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_LONG
argument_list|,
literal|"long int"
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long unsigned int"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned long"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long int"
argument_list|,
name|long_long_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned int"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_SHORT
argument_list|,
literal|"short int"
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"short unsigned int"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned short"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"signed char"
argument_list|,
name|signed_char_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned char"
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* These are types that c_common_type_for_size and      c_common_type_for_mode use.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__int128_t"
argument_list|)
argument_list|,
name|intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__uint128_t"
argument_list|)
argument_list|,
name|unsigned_intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create the widest literal types.  */
name|widest_integer_literal_type_node
operator|=
name|make_signed_type
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|widest_integer_literal_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|widest_unsigned_literal_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|widest_unsigned_literal_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `unsigned long' is the standard type for sizeof.      Note that stddef.h uses `unsigned long',      and this must agree, even if long and int are the same size.  */
name|size_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|signed_size_type_node
operator|=
name|c_common_signed_type
argument_list|(
name|size_type_node
argument_list|)
expr_stmt|;
name|set_sizetype
argument_list|(
name|size_type_node
argument_list|)
expr_stmt|;
name|build_common_tree_nodes_2
argument_list|(
name|flag_short_double
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_FLOAT
argument_list|,
name|NULL
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DOUBLE
argument_list|,
name|NULL
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long double"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex int"
argument_list|)
argument_list|,
name|complex_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex float"
argument_list|)
argument_list|,
name|complex_float_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex double"
argument_list|)
argument_list|,
name|complex_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex long double"
argument_list|)
argument_list|,
name|complex_long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Types which are common to the fortran compiler and libf2c.  When      changing these, you also need to be concerned with f/com.h.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
block|{
name|g77_integer_type_node
operator|=
name|long_integer_type_node
expr_stmt|;
name|g77_uinteger_type_node
operator|=
name|long_unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|g77_integer_type_node
operator|=
name|integer_type_node
expr_stmt|;
name|g77_uinteger_type_node
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
else|else
name|g77_integer_type_node
operator|=
name|g77_uinteger_type_node
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|g77_integer_type_node
operator|!=
name|NULL_TREE
condition|)
block|{
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__g77_integer"
argument_list|)
argument_list|,
name|g77_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__g77_uinteger"
argument_list|)
argument_list|,
name|g77_uinteger_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|*
literal|2
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
block|{
name|g77_longint_type_node
operator|=
name|long_integer_type_node
expr_stmt|;
name|g77_ulongint_type_node
operator|=
name|long_unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|*
literal|2
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
block|{
name|g77_longint_type_node
operator|=
name|long_long_integer_type_node
expr_stmt|;
name|g77_ulongint_type_node
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
block|}
else|else
name|g77_longint_type_node
operator|=
name|g77_ulongint_type_node
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|g77_longint_type_node
operator|!=
name|NULL_TREE
condition|)
block|{
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__g77_longint"
argument_list|)
argument_list|,
name|g77_longint_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__g77_ulongint"
argument_list|)
argument_list|,
name|g77_ulongint_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_VOID
argument_list|,
name|NULL
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|void_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|void_zero_node
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|void_list_node
operator|=
name|build_void_list_node
argument_list|()
expr_stmt|;
comment|/* Make a type to be the domain of a few array types      whose domains don't really matter.      200 is small enough that it always fits in size_t      and large enough that it can hold most function names for the      initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|array_domain_type
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a type for arrays of characters.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|const_string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is special for C++ so functions can be overloaded.  */
name|wchar_type_node
operator|=
name|get_identifier
argument_list|(
name|MODIFIED_WCHAR_TYPE
argument_list|)
expr_stmt|;
name|wchar_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|wchar_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_type_size
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|)
name|wchar_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
else|else
name|wchar_type_node
operator|=
name|make_signed_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_WCHAR
argument_list|,
literal|"wchar_t"
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signed_wchar_type_node
operator|=
name|c_common_signed_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|unsigned_wchar_type_node
operator|=
name|c_common_unsigned_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
block|}
comment|/* This is for wide string constants.  */
name|wchar_array_type_node
operator|=
name|build_array_type
argument_list|(
name|wchar_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
name|wint_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|WINT_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intmax_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|INTMAX_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|uintmax_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|UINTMAX_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ptrdiff_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|PTRDIFF_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_ptrdiff_type_node
operator|=
name|c_common_unsigned_type
argument_list|(
name|ptrdiff_type_node
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__builtin_va_list"
argument_list|)
argument_list|,
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__builtin_ptrdiff_t"
argument_list|)
argument_list|,
name|ptrdiff_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__builtin_size_t"
argument_list|)
argument_list|,
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|va_list_arg_type_node
operator|=
name|va_list_ref_type_node
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va_list_arg_type_node
operator|=
name|va_list_type_node
expr_stmt|;
name|va_list_ref_type_node
operator|=
name|build_reference_type
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|DEF_PRIMITIVE_TYPE
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|builtin_types[(int) ENUM] = VALUE;
define|#
directive|define
name|DEF_FUNCTION_TYPE_0
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|)
define|\
value|builtin_types[(int) ENUM]				\     = build_function_type (builtin_types[(int) RETURN],	\ 			   void_list_node);
define|#
directive|define
name|DEF_FUNCTION_TYPE_1
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						\     = build_function_type (builtin_types[(int) RETURN],			\ 			   tree_cons (NULL_TREE,			\ 				      builtin_types[(int) ARG1],	\ 				      void_list_node));
define|#
directive|define
name|DEF_FUNCTION_TYPE_2
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
define|\
value|builtin_types[(int) ENUM]				\     = build_function_type 				\       (builtin_types[(int) RETURN],			\        tree_cons (NULL_TREE,				\ 		  builtin_types[(int) ARG1],		\ 		  tree_cons (NULL_TREE,			\ 			     builtin_types[(int) ARG2],	\ 			     void_list_node)));
define|#
directive|define
name|DEF_FUNCTION_TYPE_3
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						 \     = build_function_type						 \       (builtin_types[(int) RETURN],					 \        tree_cons (NULL_TREE,						 \ 		  builtin_types[(int) ARG1],				 \ 		  tree_cons (NULL_TREE,					 \ 			     builtin_types[(int) ARG2],			 \ 			     tree_cons (NULL_TREE,			 \ 					builtin_types[(int) ARG3],	 \ 					void_list_node))));
define|#
directive|define
name|DEF_FUNCTION_TYPE_4
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						\     = build_function_type						\       (builtin_types[(int) RETURN],					\        tree_cons (NULL_TREE,						\ 		  builtin_types[(int) ARG1],				\ 		  tree_cons (NULL_TREE,					\ 			     builtin_types[(int) ARG2],			\ 			     tree_cons 					\ 			     (NULL_TREE,				\ 			      builtin_types[(int) ARG3],	 	\ 			      tree_cons (NULL_TREE,			\ 					 builtin_types[(int) ARG4],	\ 					 void_list_node)))));
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_0
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						\     = build_function_type (builtin_types[(int) RETURN], NULL_TREE);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_1
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						 \     = build_function_type (builtin_types[(int) RETURN], 		 \ 			   tree_cons (NULL_TREE,			 \ 				      builtin_types[(int) ARG1],	 \ 				      NULL_TREE));
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_2
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
define|\
value|builtin_types[(int) ENUM]					\     = build_function_type 					\       (builtin_types[(int) RETURN],				\        tree_cons (NULL_TREE,					\ 		  builtin_types[(int) ARG1],			\ 		  tree_cons (NULL_TREE,				\ 			     builtin_types[(int) ARG2],		\ 			     NULL_TREE)));
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_3
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						\     = build_function_type 						\       (builtin_types[(int) RETURN],					\        tree_cons (NULL_TREE,						\ 		  builtin_types[(int) ARG1],				\ 		  tree_cons (NULL_TREE,					\ 			     builtin_types[(int) ARG2],			\ 			     tree_cons (NULL_TREE,			\ 					builtin_types[(int) ARG3],	\ 					NULL_TREE))));
define|#
directive|define
name|DEF_POINTER_TYPE
parameter_list|(
name|ENUM
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|builtin_types[(int) ENUM]				\     = build_pointer_type (builtin_types[(int) TYPE]);
include|#
directive|include
file|"builtin-types.def"
undef|#
directive|undef
name|DEF_PRIMITIVE_TYPE
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_3
undef|#
directive|undef
name|DEF_POINTER_TYPE
if|if
condition|(
operator|!
name|c_attrs_initialized
condition|)
name|c_init_attributes
argument_list|()
expr_stmt|;
define|#
directive|define
name|DEF_BUILTIN
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|TYPE
parameter_list|,
name|LIBTYPE
parameter_list|,			\
name|BOTH_P
parameter_list|,
name|FALLBACK_P
parameter_list|,
name|NONANSI_P
parameter_list|,
name|ATTRS
parameter_list|)
define|\
value|if (NAME)								\     {									\       tree decl;							\ 									\       if (strncmp (NAME, "__builtin_", strlen ("__builtin_")) != 0)	\ 	abort ();							\ 									\       if (!BOTH_P)							\ 	decl = builtin_function (NAME, builtin_types[TYPE], ENUM,	\ 				 CLASS,					\ 				 (FALLBACK_P				\ 				  ? (NAME + strlen ("__builtin_"))	\ 				  : NULL),				\ 				 built_in_attributes[(int) ATTRS]);	\       else								\ 	decl = builtin_function_2 (NAME,				\ 				   NAME + strlen ("__builtin_"),	\ 				   builtin_types[TYPE],			\ 				   builtin_types[LIBTYPE],		\ 				   ENUM,				\ 				   CLASS,				\ 				   FALLBACK_P,				\ 				   NONANSI_P,				\ 				   built_in_attributes[(int) ATTRS]);	\ 									\       built_in_decls[(int) ENUM] = decl;				\     }
include|#
directive|include
file|"builtins.def"
undef|#
directive|undef
name|DEF_BUILTIN
call|(
modifier|*
name|targetm
operator|.
name|init_builtins
call|)
argument_list|()
expr_stmt|;
name|main_identifier_node
operator|=
name|get_identifier
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|build_va_arg
parameter_list|(
name|expr
parameter_list|,
name|type
parameter_list|)
name|tree
name|expr
decl_stmt|,
name|type
decl_stmt|;
block|{
return|return
name|build1
argument_list|(
name|VA_ARG_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Linked list of disabled built-in functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|disabled_builtin
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|disabled_builtin
modifier|*
name|next
decl_stmt|;
block|}
name|disabled_builtin
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|disabled_builtin
modifier|*
name|disabled_builtins
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|builtin_function_disabled_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disable a built-in function specified by -fno-builtin-NAME.  If NAME    begins with "__builtin_", give an error.  */
end_comment

begin_function
name|void
name|disable_builtin_function
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|,
name|strlen
argument_list|(
literal|"__builtin_"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cannot disable built-in function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|disabled_builtin
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|disabled_builtin
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|disabled_builtins
expr_stmt|;
name|disabled_builtins
operator|=
name|new
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the built-in function NAME has been disabled, false    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|builtin_function_disabled_p
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|disabled_builtin
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|disabled_builtins
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Possibly define a builtin function with one or two names.  BUILTIN_NAME    is an __builtin_-prefixed name; NAME is the ordinary name; one or both    of these may be NULL (though both being NULL is useless).    BUILTIN_TYPE is the type of the __builtin_-prefixed function;    TYPE is the type of the function with the ordinary name.  These    may differ if the ordinary name is declared with a looser type to avoid    conflicts with headers.  FUNCTION_CODE and CLASS are as for    builtin_function.  If LIBRARY_NAME_P is nonzero, NAME is passed as    the LIBRARY_NAME parameter to builtin_function when declaring BUILTIN_NAME.    If NONANSI_P is nonzero, the name NAME is treated as a non-ANSI name;    ATTRS is the tree list representing the builtin's function attributes.    Returns the declaration of BUILTIN_NAME, if any, otherwise    the declaration of NAME.  Does not declare NAME if flag_no_builtin,    or if NONANSI_P and flag_no_nonansi_builtin.  */
end_comment

begin_function
specifier|static
name|tree
name|builtin_function_2
parameter_list|(
name|builtin_name
parameter_list|,
name|name
parameter_list|,
name|builtin_type
parameter_list|,
name|type
parameter_list|,
name|function_code
parameter_list|,
name|class
parameter_list|,
name|library_name_p
parameter_list|,
name|nonansi_p
parameter_list|,
name|attrs
parameter_list|)
specifier|const
name|char
modifier|*
name|builtin_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|builtin_type
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|function_code
decl_stmt|;
name|enum
name|built_in_class
name|class
decl_stmt|;
name|int
name|library_name_p
decl_stmt|;
name|int
name|nonansi_p
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
block|{
name|tree
name|bdecl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|builtin_name
operator|!=
literal|0
condition|)
block|{
name|bdecl
operator|=
name|builtin_function
argument_list|(
name|builtin_name
argument_list|,
name|builtin_type
argument_list|,
name|function_code
argument_list|,
name|class
argument_list|,
name|library_name_p
condition|?
name|name
else|:
name|NULL
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
literal|0
operator|&&
operator|!
name|flag_no_builtin
operator|&&
operator|!
name|builtin_function_disabled_p
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
operator|(
name|nonansi_p
operator|&&
name|flag_no_nonansi_builtin
operator|)
condition|)
block|{
name|decl
operator|=
name|builtin_function
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|function_code
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonansi_p
condition|)
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|bdecl
operator|!=
literal|0
condition|?
name|bdecl
else|:
name|decl
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the type T promotes to int.  This is (nearly) the    integral promotions defined in ISO C99 6.3.1.1/2.  */
end_comment

begin_function
name|bool
name|c_promoting_integer_type_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
return|return
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|signed_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|unsigned_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|short_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|short_unsigned_type_node
operator|||
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
comment|/* ??? Technically all enumerations not larger than an int 	 promote to an int.  But this is used along code paths 	 that only want to notice a size change.  */
return|return
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
return|;
case|case
name|BOOLEAN_TYPE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|self_promoting_args_p
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Recursively examines the array elements of TYPE, until a non-array    element type is found.  */
end_comment

begin_function
name|tree
name|strip_array_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|expand_unordered_cmp
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|enum
name|tree_code
operator|,
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand a call to an unordered comparison function such as    __builtin_isgreater().  FUNCTION is the function's declaration and    PARAMS a list of the values passed.  For __builtin_isunordered(),    UNORDERED_CODE is UNORDERED_EXPR and ORDERED_CODE is NOP_EXPR.  In    other cases, UNORDERED_CODE and ORDERED_CODE are comparison codes    that give the opposite of the desired result.  UNORDERED_CODE is    used for modes that can hold NaNs and ORDERED_CODE is used for the    rest.  */
end_comment

begin_function
specifier|static
name|tree
name|expand_unordered_cmp
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|unordered_code
parameter_list|,
name|ordered_code
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
name|enum
name|tree_code
name|unordered_code
decl_stmt|,
name|ordered_code
decl_stmt|;
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|type
decl_stmt|;
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
comment|/* Check that we have exactly two arguments.  */
if|if
condition|(
name|params
operator|==
literal|0
operator|||
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that the arguments have a common type of REAL.  */
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"non-floating-point argument to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|unordered_code
operator|==
name|UNORDERED_EXPR
condition|)
block|{
if|if
condition|(
name|MODE_HAS_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|unordered_code
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|integer_zero_node
return|;
block|}
return|return
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|build_binary_op
argument_list|(
name|MODE_HAS_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|?
name|unordered_code
else|:
name|ordered_code
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recognize certain built-in functions so we can make tree-codes    other than CALL_EXPR.  We do this when it enables fold-const.c    to do something useful.  */
end_comment

begin_comment
comment|/* ??? By rights this should go in builtins.c, but only C and C++    implement build_{binary,unary}_op.  Not exactly sure what bits    of functionality are actually needed from those functions, or    where the similar functionality exists in the other front ends.  */
end_comment

begin_function
name|tree
name|expand_tree_builtin
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|coerced_params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|,
name|coerced_params
decl_stmt|;
block|{
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|function
argument_list|)
operator|!=
name|BUILT_IN_NORMAL
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|function
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_LLABS
case|:
case|case
name|BUILT_IN_IMAXABS
case|:
case|case
name|BUILT_IN_FABS
case|:
case|case
name|BUILT_IN_FABSL
case|:
case|case
name|BUILT_IN_FABSF
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_CONJ
case|:
case|case
name|BUILT_IN_CONJF
case|:
case|case
name|BUILT_IN_CONJL
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|CONJ_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_CREAL
case|:
case|case
name|BUILT_IN_CREALF
case|:
case|case
name|BUILT_IN_CREALL
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_CIMAG
case|:
case|case
name|BUILT_IN_CIMAGF
case|:
case|case
name|BUILT_IN_CIMAGL
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_ISGREATER
case|:
return|return
name|expand_unordered_cmp
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|UNLE_EXPR
argument_list|,
name|LE_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISGREATEREQUAL
case|:
return|return
name|expand_unordered_cmp
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|UNLT_EXPR
argument_list|,
name|LT_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISLESS
case|:
return|return
name|expand_unordered_cmp
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|UNGE_EXPR
argument_list|,
name|GE_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISLESSEQUAL
case|:
return|return
name|expand_unordered_cmp
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|UNGT_EXPR
argument_list|,
name|GT_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISLESSGREATER
case|:
return|return
name|expand_unordered_cmp
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|UNEQ_EXPR
argument_list|,
name|EQ_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISUNORDERED
case|:
return|return
name|expand_unordered_cmp
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|UNORDERED_EXPR
argument_list|,
name|NOP_EXPR
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if CODE is the code for a statement.  */
end_comment

begin_function
name|int
name|statement_code_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLEANUP_STMT
case|:
case|case
name|EXPR_STMT
case|:
case|case
name|COMPOUND_STMT
case|:
case|case
name|DECL_STMT
case|:
case|case
name|IF_STMT
case|:
case|case
name|FOR_STMT
case|:
case|case
name|WHILE_STMT
case|:
case|case
name|DO_STMT
case|:
case|case
name|RETURN_STMT
case|:
case|case
name|BREAK_STMT
case|:
case|case
name|CONTINUE_STMT
case|:
case|case
name|SCOPE_STMT
case|:
case|case
name|SWITCH_STMT
case|:
case|case
name|GOTO_STMT
case|:
case|case
name|LABEL_STMT
case|:
case|case
name|ASM_STMT
case|:
case|case
name|FILE_STMT
case|:
case|case
name|CASE_LABEL
case|:
return|return
literal|1
return|;
default|default:
if|if
condition|(
name|lang_statement_code_p
condition|)
return|return
call|(
modifier|*
name|lang_statement_code_p
call|)
argument_list|(
name|code
argument_list|)
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Walk the statement tree, rooted at *tp.  Apply FUNC to all the    sub-trees of *TP in a pre-order traversal.  FUNC is called with the    DATA and the address of each sub-tree.  If FUNC returns a non-NULL    value, the traversal is aborted, and the value returned by FUNC is    returned.  If FUNC sets WALK_SUBTREES to zero, then the subtrees of    the node being visited are not walked.     We don't need a without_duplicates variant of this one because the    statement tree is a tree, not a graph.  */
end_comment

begin_function
name|tree
name|walk_stmt_tree
parameter_list|(
name|tp
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|walk_tree_fn
name|func
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|walk_subtrees
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
define|#
directive|define
name|WALK_SUBTREE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\       result = walk_stmt_tree (&(NODE), func, data);	\       if (result)					\ 	return result;					\     }							\   while (0)
comment|/* Skip empty subtrees.  */
if|if
condition|(
operator|!
operator|*
name|tp
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Skip subtrees below non-statement nodes.  */
if|if
condition|(
operator|!
name|statement_code_p
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Call the function.  */
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If we found something, return it.  */
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* FUNC may have modified the tree, recheck that we're looking at a      statement node.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|statement_code_p
argument_list|(
name|code
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Visit the subtrees unless FUNC decided that there was nothing      interesting below this point in the tree.  */
if|if
condition|(
name|walk_subtrees
condition|)
block|{
comment|/* Walk over all the sub-trees of this operand.  Statement nodes 	 never contain RTL, and we needn't worry about TARGET_EXPRs.  */
name|len
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Go through the subtrees.  We need to do this in forward order so 	 that the scope of a FOR_EXPR is handled properly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|WALK_SUBTREE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finally visit the chain.  This can be tail-recursion optimized if      we write it this way.  */
return|return
name|walk_stmt_tree
argument_list|(
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
return|;
undef|#
directive|undef
name|WALK_SUBTREE
block|}
end_function

begin_comment
comment|/* Used to compare case labels.  K1 and K2 are actually tree nodes    representing case labels, or NULL_TREE for a `default' label.    Returns -1 if K1 is ordered before K2, -1 if K1 is ordered after    K2, and 0 if K1 and K2 are equal.  */
end_comment

begin_function
name|int
name|case_compare
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|)
name|splay_tree_key
name|k1
decl_stmt|;
name|splay_tree_key
name|k2
decl_stmt|;
block|{
comment|/* Consider a NULL key (such as arises with a `default' label) to be      smaller than anything else.  */
if|if
condition|(
operator|!
name|k1
condition|)
return|return
name|k2
condition|?
operator|-
literal|1
else|:
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|k2
condition|)
return|return
name|k1
condition|?
literal|1
else|:
literal|0
return|;
return|return
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|k1
argument_list|,
operator|(
name|tree
operator|)
name|k2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process a case label for the range LOW_VALUE ... HIGH_VALUE.  If    LOW_VALUE and HIGH_VALUE are both NULL_TREE then this case label is    actually a `default' label.  If only HIGH_VALUE is NULL_TREE, then    case label was declared using the usual C/C++ syntax, rather than    the GNU case range extension.  CASES is a tree containing all the    case ranges processed so far; COND is the condition for the    switch-statement itself.  Returns the CASE_LABEL created, or    ERROR_MARK_NODE if no CASE_LABEL is created.  */
end_comment

begin_function
name|tree
name|c_add_case_label
parameter_list|(
name|cases
parameter_list|,
name|cond
parameter_list|,
name|low_value
parameter_list|,
name|high_value
parameter_list|)
name|splay_tree
name|cases
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|tree
name|low_value
decl_stmt|;
name|tree
name|high_value
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|tree
name|case_label
decl_stmt|;
name|splay_tree_node
name|node
decl_stmt|;
comment|/* Create the LABEL_DECL itself.  */
name|label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* If there was an error processing the switch condition, bail now      before we get more confused.  */
if|if
condition|(
operator|!
name|cond
operator|||
name|cond
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Add a label anyhow so that the back-end doesn't think that 	 the beginning of the switch is unreachable.  */
if|if
condition|(
operator|!
name|cases
operator|->
name|root
condition|)
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|low_value
operator|&&
name|TREE_TYPE
argument_list|(
name|low_value
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|low_value
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|high_value
operator|&&
name|TREE_TYPE
argument_list|(
name|high_value
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|high_value
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"pointers are not permitted as case values"
argument_list|)
expr_stmt|;
comment|/* Case ranges are a GNU extension.  */
if|if
condition|(
name|high_value
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids range expressions in switch statements"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C forbids range expressions in switch statements"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|low_value
condition|)
block|{
name|low_value
operator|=
name|check_case_value
argument_list|(
name|low_value
argument_list|)
expr_stmt|;
name|low_value
operator|=
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|low_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|high_value
condition|)
block|{
name|high_value
operator|=
name|check_case_value
argument_list|(
name|high_value
argument_list|)
expr_stmt|;
name|high_value
operator|=
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
block|}
comment|/* If an error has occurred, bail out now.  */
if|if
condition|(
name|low_value
operator|==
name|error_mark_node
operator|||
name|high_value
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|cases
operator|->
name|root
condition|)
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't      really a case range, even though it was written that way.  Remove      the HIGH_VALUE to simplify later processing.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|)
condition|)
name|high_value
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|low_value
operator|&&
name|high_value
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"empty range specified"
argument_list|)
expr_stmt|;
comment|/* Look up the LOW_VALUE in the table of case labels we already      have.  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
comment|/* If there was not an exact match, check for overlapping ranges.      There's no need to do this if there's no LOW_VALUE or HIGH_VALUE;      that's a `default' label and the only overlap is an exact match.  */
if|if
condition|(
operator|!
name|node
operator|&&
operator|(
name|low_value
operator|||
name|high_value
operator|)
condition|)
block|{
name|splay_tree_node
name|low_bound
decl_stmt|;
name|splay_tree_node
name|high_bound
decl_stmt|;
comment|/* Even though there wasn't an exact match, there might be an 	 overlap between this case range and another case range. 	 Since we've (inductively) not allowed any overlapping case 	 ranges, we simply need to find the greatest low case label 	 that is smaller that LOW_VALUE, and the smallest low case 	 label that is greater than LOW_VALUE.  If there is an overlap 	 it will occur in one of these two ranges.  */
name|low_bound
operator|=
name|splay_tree_predecessor
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
name|high_bound
operator|=
name|splay_tree_successor
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
comment|/* Check to see if the LOW_BOUND overlaps.  It is smaller than 	 the LOW_VALUE, so there is no need to check unless the 	 LOW_BOUND is in fact itself a case range.  */
if|if
condition|(
name|low_bound
operator|&&
name|CASE_HIGH
argument_list|(
operator|(
name|tree
operator|)
name|low_bound
operator|->
name|value
argument_list|)
operator|&&
name|tree_int_cst_compare
argument_list|(
name|CASE_HIGH
argument_list|(
operator|(
name|tree
operator|)
name|low_bound
operator|->
name|value
argument_list|)
argument_list|,
name|low_value
argument_list|)
operator|>=
literal|0
condition|)
name|node
operator|=
name|low_bound
expr_stmt|;
comment|/* Check to see if the HIGH_BOUND overlaps.  The low end of that 	 range is bigger than the low end of the current range, so we 	 are only interested if the current range is a real range, and 	 not an ordinary case label.  */
elseif|else
if|if
condition|(
name|high_bound
operator|&&
name|high_value
operator|&&
operator|(
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|high_bound
operator|->
name|key
argument_list|,
name|high_value
argument_list|)
operator|<=
literal|0
operator|)
condition|)
name|node
operator|=
name|high_bound
expr_stmt|;
block|}
comment|/* If there was an overlap, issue an error.  */
if|if
condition|(
name|node
condition|)
block|{
name|tree
name|duplicate
init|=
name|CASE_LABEL_DECL
argument_list|(
operator|(
name|tree
operator|)
name|node
operator|->
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|high_value
condition|)
block|{
name|error
argument_list|(
literal|"duplicate (or overlapping) case value"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|duplicate
argument_list|,
literal|"this is the first entry overlapping that value"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low_value
condition|)
block|{
name|error
argument_list|(
literal|"duplicate case value"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|duplicate
argument_list|,
literal|"previously used here"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"multiple default labels in one switch"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|duplicate
argument_list|,
literal|"this is the first default label"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cases
operator|->
name|root
condition|)
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add a CASE_LABEL to the statement-tree.  */
name|case_label
operator|=
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register this case label in the splay tree.  */
name|splay_tree_insert
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|case_label
argument_list|)
expr_stmt|;
return|return
name|case_label
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression taking the address of LABEL.  Returns an    expression for the address.  */
end_comment

begin_function
name|tree
name|finish_label_address_expr
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of a label"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C forbids taking the address of a label"
argument_list|)
expr_stmt|;
block|}
name|label
operator|=
name|lookup_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL_TREE
condition|)
name|result
operator|=
name|null_pointer_node
expr_stmt|;
else|else
block|{
name|TREE_USED
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The current function in not necessarily uninlinable. 	 Computed gotos are incompatible with inlining, but the value 	 here could be used only in a diagnostic, for example.  */
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Hook used by expand_expr to expand language-specific tree codes.  */
end_comment

begin_function
name|rtx
name|c_expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|int
name|modifier
decl_stmt|;
comment|/* Actually enum_modifier.  */
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|STMT_EXPR
case|:
block|{
name|tree
name|rtl_expr
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|bool
name|preserve_result
init|=
name|false
decl_stmt|;
name|bool
name|return_target
init|=
name|false
decl_stmt|;
comment|/* Since expand_expr_stmt calls free_temp_slots after every 	   expression statement, we must call push_temp_slots here. 	   Otherwise, any temporaries in use now would be considered 	   out-of-scope after the first EXPR_STMT from within the 	   STMT_EXPR.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|rtl_expr
operator|=
name|expand_start_stmt_expr
argument_list|(
operator|!
name|STMT_EXPR_NO_SCOPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we want the result of this expression, find the last            EXPR_STMT in the COMPOUND_STMT and mark it as addressable.  */
if|if
condition|(
name|target
operator|!=
name|const0_rtx
operator|&&
name|TREE_CODE
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|COMPOUND_STMT
operator|&&
name|TREE_CODE
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SCOPE_STMT
condition|)
block|{
name|tree
name|expr
init|=
name|COMPOUND_BODY
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|last
init|=
name|TREE_CHAIN
argument_list|(
name|expr
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|expr
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|SCOPE_STMT
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|EXPR_STMT
condition|)
block|{
if|if
condition|(
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL_IF_SET
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|target
condition|)
comment|/* If the last expression is a variable whose RTL is the 		     same as our target, just return the target; if it 		     isn't valid expanding the decl would produce different 		     RTL, and store_expr would try to do a copy.  */
name|return_target
operator|=
name|true
expr_stmt|;
else|else
block|{
comment|/* Otherwise, note that we want the value from the last 		       expression.  */
name|TREE_ADDRESSABLE
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|preserve_result
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
name|expand_stmt
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_stmt_expr
argument_list|(
name|rtl_expr
argument_list|)
expr_stmt|;
name|result
operator|=
name|expand_expr
argument_list|(
name|rtl_expr
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_target
condition|)
name|result
operator|=
name|target
expr_stmt|;
elseif|else
if|if
condition|(
name|preserve_result
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|!=
name|BLKmode
condition|)
name|result
operator|=
name|copy_to_reg
argument_list|(
name|result
argument_list|)
expr_stmt|;
else|else
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* If the statment-expression does not have a scope, then the 	   new temporaries we created within it must live beyond the 	   statement-expression.  */
if|if
condition|(
name|STMT_EXPR_NO_SCOPE
argument_list|(
name|exp
argument_list|)
condition|)
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BUILT_IN_FRONTEND
operator|)
condition|)
return|return
name|c_expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
block|{
comment|/* Initialize the anonymous variable declared in the compound 	   literal, then return the variable.  */
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|emit_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|decl
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Hook used by safe_from_p to handle language-specific tree codes.  */
end_comment

begin_function
name|int
name|c_safe_from_p
parameter_list|(
name|target
parameter_list|,
name|exp
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
comment|/* We can see statements here when processing the body of a      statement-expression.  For a declaration statement declaring a      variable, look at the variable's initializer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|DECL_STMT
condition|)
block|{
name|tree
name|decl
init|=
name|DECL_STMT_DECL
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*top_p=*/
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* For any statement, we must follow the statement-chain.  */
if|if
condition|(
name|statement_code_p
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|,
comment|/*top_p=*/
literal|0
argument_list|)
return|;
comment|/* Assume everything else is safe.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hook used by unsafe_for_reeval to handle language-specific tree codes.  */
end_comment

begin_function
name|int
name|c_common_unsafe_for_reeval
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* Statement expressions may not be reevaluated, likewise compound      literals.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STMT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
condition|)
return|return
literal|2
return|;
comment|/* Walk all other expressions.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hook used by staticp to handle language-specific tree codes.  */
end_comment

begin_function
name|int
name|c_staticp
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
operator|&&
name|TREE_STATIC
argument_list|(
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CALLED_AS_BUILT_IN
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
end_define

begin_function
specifier|static
name|rtx
name|c_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|const
name|int
name|ignore
init|=
operator|(
name|target
operator|==
name|const0_rtx
operator|||
operator|(
operator|(
name|code
operator|==
name|NON_LVALUE_EXPR
operator|||
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|REFERENCE_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_PRINTF
case|:
name|target
operator|=
name|c_expand_builtin_printf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_PRINTF_UNLOCKED
case|:
name|target
operator|=
name|c_expand_builtin_printf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF
case|:
name|target
operator|=
name|c_expand_builtin_fprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF_UNLOCKED
case|:
name|target
operator|=
name|c_expand_builtin_fprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
default|default:
comment|/* just do library call, if unknown builtin */
name|error
argument_list|(
literal|"built-in function `%s' not currently supported"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The switch statement above can drop through to cause the function      to be called normally.  */
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check an arglist to *printf for problems.  The arglist should start    at the format specifier, with the remaining arguments immediately    following it.  */
end_comment

begin_function
specifier|static
name|int
name|is_valid_printf_arglist
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
comment|/* Save this value so we can restore it later.  */
specifier|const
name|int
name|SAVE_pedantic
init|=
name|pedantic
decl_stmt|;
name|int
name|diagnostic_occurred
init|=
literal|0
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
comment|/* Set this to a known value so the user setting won't affect code      generation.  */
name|pedantic
operator|=
literal|1
expr_stmt|;
comment|/* Check to make sure there are no format specifier errors.  */
name|attrs
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"format"
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"printf"
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|check_function_format
argument_list|(
operator|&
name|diagnostic_occurred
argument_list|,
name|attrs
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Restore the value of `pedantic'.  */
name|pedantic
operator|=
name|SAVE_pedantic
expr_stmt|;
comment|/* If calling `check_function_format_ptr' produces a warning, we      return false, otherwise we return true.  */
return|return
operator|!
name|diagnostic_occurred
return|;
block|}
end_function

begin_comment
comment|/* If the arguments passed to printf are suitable for optimizations,    we attempt to transform the call.  */
end_comment

begin_function
specifier|static
name|rtx
name|c_expand_builtin_printf
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|,
name|ignore
parameter_list|,
name|unlocked
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|int
name|unlocked
decl_stmt|;
block|{
name|tree
name|fn_putchar
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_PUTCHAR_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_PUTCHAR
index|]
decl_stmt|;
name|tree
name|fn_puts
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_PUTS_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_PUTS
index|]
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|format_arg
decl_stmt|,
name|stripped_string
decl_stmt|;
comment|/* If the return value is used, or the replacement _DECL isn't      initialized, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
operator|||
operator|!
name|fn_putchar
operator|||
operator|!
name|fn_puts
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check the specifier vs. the parameters.  */
if|if
condition|(
operator|!
name|is_valid_printf_arglist
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|format_arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|stripped_string
operator|=
name|format_arg
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|stripped_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripped_string
operator|&&
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|stripped_string
operator|=
name|TREE_OPERAND
argument_list|(
name|stripped_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the format specifier isn't a STRING_CST, punt.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
comment|/* OK!  We can attempt optimization.  */
comment|/* If the format specifier was "%s\n", call __builtin_puts(arg2).  */
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%s\n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_putchar (arg2).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%c"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|'%'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the resulting constant string has a length of 1, call          putchar.  Note, TREE_STRING_LENGTH includes the terminating          NULL in its count.  */
if|if
condition|(
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Given printf("c"), (where c is any one character,)              convert "c"[0] to an int and pass that to the replacement              function.  */
name|arglist
operator|=
name|build_int_2
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
comment|/* If the resulting constant was "string\n", call          __builtin_puts("string").  Ensure "string" has at least one          character besides the trailing \n.  Note, TREE_STRING_LENGTH          includes the terminating NULL in its count.  */
elseif|else
if|if
condition|(
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|>
literal|2
operator|&&
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
index|[
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* Create a NULL-terminated string that's one char shorter 	     than the original, stripping off the trailing '\n'.  */
specifier|const
name|int
name|newlen
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|newstr
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|newlen
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
name|newlen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newstr
index|[
name|newlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|arglist
operator|=
name|fix_string_type
argument_list|(
name|build_string
argument_list|(
name|newlen
argument_list|,
name|newstr
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
else|else
comment|/* We'd like to arrange to call fputs(string) here, but we            need stdout and don't have a way to get it ... yet.  */
return|return
literal|0
return|;
block|}
return|return
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|target
operator|)
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the arguments passed to fprintf are suitable for optimizations,    we attempt to transform the call.  */
end_comment

begin_function
specifier|static
name|rtx
name|c_expand_builtin_fprintf
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|,
name|ignore
parameter_list|,
name|unlocked
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|int
name|unlocked
decl_stmt|;
block|{
name|tree
name|fn_fputc
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
decl_stmt|;
name|tree
name|fn_fputs
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTS_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_FPUTS
index|]
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|format_arg
decl_stmt|,
name|stripped_string
decl_stmt|;
comment|/* If the return value is used, or the replacement _DECL isn't      initialized, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
operator|||
operator|!
name|fn_fputc
operator|||
operator|!
name|fn_fputs
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check the specifier vs. the parameters.  */
if|if
condition|(
operator|!
name|is_valid_printf_arglist
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|format_arg
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|stripped_string
operator|=
name|format_arg
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|stripped_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripped_string
operator|&&
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|stripped_string
operator|=
name|TREE_OPERAND
argument_list|(
name|stripped_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the format specifier isn't a STRING_CST, punt.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
comment|/* OK!  We can attempt optimization.  */
comment|/* If the format specifier was "%s", call __builtin_fputs(arg3, arg1).  */
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|newarglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_fputc (arg3, arg1).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%c"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|newarglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|'%'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* When "string" doesn't contain %, replace all cases of          fprintf(stream,string) with fputs(string,stream).  The fputs          builtin will take take of special cases like length==1.  */
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|target
operator|)
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a boolean expression ARG, return a tree representing an increment    or decrement (as indicated by CODE) of ARG.  The front end must check for    invalid cases (e.g., decrement in C++).  */
end_comment

begin_function
name|tree
name|boolean_increment
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|true_res
init|=
operator|(
name|c_language
operator|==
name|clk_cplusplus
condition|?
name|boolean_true_node
else|:
name|c_bool_true_node
operator|)
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|true_res
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|true_res
argument_list|)
expr_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define NAME with value TYPE precision.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_type_precision
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the float.h constants for TYPE using NAME_PREFIX and FP_SUFFIX.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_float_constants
parameter_list|(
name|name_prefix
parameter_list|,
name|fp_suffix
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|name_prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|fp_suffix
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
comment|/* Used to convert radix-based values to base 10 values in several cases.       In the max_exp -> max_10_exp conversion for 128-bit IEEE, we need at      least 6 significant digits for correct results.  Using the fraction      formed by (log(2)*1e6)/(log(10)*1e6) overflows a 32-bit integer as an      intermediate; perhaps someone can find a better approximation, in the      mean time, I suspect using doubles won't harm the bootstrap here.  */
specifier|const
name|double
name|log10_2
init|=
literal|.30102999566398119521
decl_stmt|;
name|double
name|log10_b
decl_stmt|;
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|,
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|dig
decl_stmt|,
name|min_10_exp
decl_stmt|,
name|max_10_exp
decl_stmt|;
name|int
name|decimal_dig
decl_stmt|;
name|fmt
operator|=
name|real_format_for_mode
index|[
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|-
name|QFmode
index|]
expr_stmt|;
comment|/* The radix of the exponent representation.  */
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|builtin_define_with_int_value
argument_list|(
literal|"__FLT_RADIX__"
argument_list|,
name|fmt
operator|->
name|b
argument_list|)
expr_stmt|;
name|log10_b
operator|=
name|log10_2
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
comment|/* The number of radix digits, p, in the floating-point significand.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MANT_DIG__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|fmt
operator|->
name|p
argument_list|)
expr_stmt|;
comment|/* The number of decimal digits, q, such that any floating-point number      with q decimal digits can be rounded into a floating-point number with      p radix b digits and back again without change to the q decimal digits,  	p log10 b			if b is a power of 10  	floor((p - 1) log10 b)		otherwise   */
name|dig
operator|=
operator|(
name|fmt
operator|->
name|p
operator|-
literal|1
operator|)
operator|*
name|log10_b
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_DIG__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|dig
argument_list|)
expr_stmt|;
comment|/* The minimum negative int x such that b**(x-1) is a normalized float.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|fmt
operator|->
name|emin
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The minimum negative int x such that 10**x is a normalized float,  	  ceil (log10 (b ** (emin - 1))) 	= ceil (log10 (b) * (emin - 1))       Recall that emin is negative, so the integer truncation calculates      the ceiling, not the floor, in this case.  */
name|min_10_exp
operator|=
operator|(
name|fmt
operator|->
name|emin
operator|-
literal|1
operator|)
operator|*
name|log10_b
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN_10_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|min_10_exp
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The maximum int x such that b**(x-1) is a representable float.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|fmt
operator|->
name|emax
argument_list|)
expr_stmt|;
comment|/* The maximum int x such that 10**x is in the range of representable      finite floating-point numbers,  	  floor (log10((1 - b**-p) * b**emax)) 	= floor (log10(1 - b**-p) + log10(b**emax)) 	= floor (log10(1 - b**-p) + log10(b)*emax)       The safest thing to do here is to just compute this number.  But since      we don't link cc1 with libm, we cannot.  We could implement log10 here      a series expansion, but that seems too much effort because:       Note that the first term, for all extant p, is a number exceedingly close      to zero, but slightly negative.  Note that the second term is an integer      scaling an irrational number, and that because of the floor we are only      interested in its integral portion.       In order for the first term to have any effect on the integral portion      of the second term, the second term has to be exceedingly close to an      integer itself (e.g. 123.000000000001 or something).  Getting a result      that close to an integer requires that the irrational multiplicand have      a long series of zeros in its expansion, which doesn't occur in the      first 20 digits or so of log10(b).       Hand-waving aside, crunching all of the sets of constants above by hand      does not yield a case for which the first term is significant, which      in the end is all that matters.  */
name|max_10_exp
operator|=
name|fmt
operator|->
name|emax
operator|*
name|log10_b
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX_10_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|max_10_exp
argument_list|)
expr_stmt|;
comment|/* The number of decimal digits, n, such that any floating-point number      can be rounded to n decimal digits and back again without change to      the value.   	p * log10(b)			if b is a power of 10 	ceil(1 + p * log10(b))		otherwise       The only macro we care about is this number for the widest supported      floating type, but we want this value for rendering constants below.  */
block|{
name|double
name|d_decimal_dig
init|=
literal|1
operator|+
name|fmt
operator|->
name|p
operator|*
name|log10_b
decl_stmt|;
name|decimal_dig
operator|=
name|d_decimal_dig
expr_stmt|;
if|if
condition|(
name|decimal_dig
operator|<
name|d_decimal_dig
condition|)
name|decimal_dig
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|builtin_define_with_int_value
argument_list|(
literal|"__DECIMAL_DIG__"
argument_list|,
name|decimal_dig
argument_list|)
expr_stmt|;
comment|/* Since, for the supported formats, B is always a power of 2, we      construct the following numbers directly as a hexadecimal      constants.  */
comment|/* The maximum representable finite floating-point number,      (1 - b**-p) * b**emax  */
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0x0."
argument_list|)
expr_stmt|;
name|n
operator|=
name|fmt
operator|->
name|p
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buf
operator|+
literal|4
init|;
name|i
operator|+
literal|3
operator|<
name|n
condition|;
name|i
operator|+=
literal|4
control|)
operator|*
name|p
operator|++
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
condition|)
operator|*
name|p
operator|++
operator|=
literal|"08ce"
index|[
name|n
operator|-
name|i
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"p%d"
argument_list|,
name|fmt
operator|->
name|emax
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
comment|/* The minimum normalized positive floating-point number,      b**(emin-1).  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x1p%d"
argument_list|,
operator|(
name|fmt
operator|->
name|emin
operator|-
literal|1
operator|)
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
comment|/* The difference between 1 and the least value greater than 1 that is      representable in the given floating point type, b**(1-p).  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_EPSILON__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x1p%d"
argument_list|,
operator|(
literal|1
operator|-
name|fmt
operator|->
name|p
operator|)
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
comment|/* For C++ std::numeric_limits<T>::denorm_min.  The minimum denormalized      positive floating-point number, b**(emin-p).  Zero for formats that      don't support denormals.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_DENORM_MIN__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|has_denorm
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x1p%d"
argument_list|,
operator|(
name|fmt
operator|->
name|emin
operator|-
name|fmt
operator|->
name|p
operator|)
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0.0%s"
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hook that registers front end and target-specific built-ins.  */
end_comment

begin_function
name|void
name|cb_register_builtins
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* -undef turns off target-specific built-ins.  */
if|if
condition|(
name|flag_undef
condition|)
return|return;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
block|{
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__GXX_WEAK__=1"
argument_list|)
expr_stmt|;
else|else
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__GXX_WEAK__=0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_deprecated
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__DEPRECATED"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_exceptions
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__EXCEPTIONS"
argument_list|)
expr_stmt|;
comment|/* represents the C++ ABI version, always defined so it can be used while      preprocessing C and assembler.  */
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__GXX_ABI_VERSION=102"
argument_list|)
expr_stmt|;
comment|/* libgcc needs to know this.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__USING_SJLJ_EXCEPTIONS__"
argument_list|)
expr_stmt|;
comment|/* stddef.h needs to know these.  */
name|builtin_define_with_value
argument_list|(
literal|"__SIZE_TYPE__"
argument_list|,
name|SIZE_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__PTRDIFF_TYPE__"
argument_list|,
name|PTRDIFF_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__WCHAR_TYPE__"
argument_list|,
name|MODIFIED_WCHAR_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__WINT_TYPE__"
argument_list|,
name|WINT_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* limits.h needs to know these.  */
name|builtin_define_type_max
argument_list|(
literal|"__SCHAR_MAX__"
argument_list|,
name|signed_char_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__SHRT_MAX__"
argument_list|,
name|short_integer_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__INT_MAX__"
argument_list|,
name|integer_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__LONG_MAX__"
argument_list|,
name|long_integer_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__LONG_LONG_MAX__"
argument_list|,
name|long_long_integer_type_node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__WCHAR_MAX__"
argument_list|,
name|wchar_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_precision
argument_list|(
literal|"__CHAR_BIT__"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* float.h needs to know these.  */
name|builtin_define_with_int_value
argument_list|(
literal|"__FLT_EVAL_METHOD__"
argument_list|,
name|TARGET_FLT_EVAL_METHOD
argument_list|)
expr_stmt|;
name|builtin_define_float_constants
argument_list|(
literal|"FLT"
argument_list|,
literal|"F"
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
name|builtin_define_float_constants
argument_list|(
literal|"DBL"
argument_list|,
literal|""
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|builtin_define_float_constants
argument_list|(
literal|"LDBL"
argument_list|,
literal|"L"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
comment|/* For use in assembly language.  */
name|builtin_define_with_value
argument_list|(
literal|"__REGISTER_PREFIX__"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__USER_LABEL_PREFIX__"
argument_list|,
name|user_label_prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Misc.  */
name|builtin_define_with_value
argument_list|(
literal|"__VERSION__"
argument_list|,
name|version_string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Other target-independent built-ins determined by command-line      options.  */
if|if
condition|(
name|optimize_size
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__OPTIMIZE_SIZE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__OPTIMIZE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_hosted
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_HOSTED__=1"
argument_list|)
expr_stmt|;
else|else
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_HOSTED__=0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast_math_flags_set_p
argument_list|()
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__FAST_MATH__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_really_no_inline
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__NO_INLINE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_signaling_nans
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__SUPPORT_SNAN__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_finite_math_only
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__FINITE_MATH_ONLY__=1"
argument_list|)
expr_stmt|;
else|else
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__FINITE_MATH_ONLY__=0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_iso
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__STRICT_ANSI__"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_signed_char
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__CHAR_UNSIGNED__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__WCHAR_UNSIGNED__"
argument_list|)
expr_stmt|;
comment|/* Make the choice of ObjC runtime visible to source code.  */
if|if
condition|(
name|flag_objc
operator|&&
name|flag_next_runtime
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__NEXT_RUNTIME__"
argument_list|)
expr_stmt|;
comment|/* A straightforward target hook doesn't work, because of problems      linking that hook's body when part of non-C front ends.  */
define|#
directive|define
name|preprocessing_asm_p
parameter_list|()
value|(cpp_get_options (pfile)->lang == CLK_ASM)
define|#
directive|define
name|preprocessing_trad_p
parameter_list|()
value|(cpp_get_options (pfile)->traditional)
define|#
directive|define
name|builtin_define
parameter_list|(
name|TXT
parameter_list|)
value|cpp_define (pfile, TXT)
define|#
directive|define
name|builtin_assert
parameter_list|(
name|TXT
parameter_list|)
value|cpp_assert (pfile, TXT)
name|TARGET_CPU_CPP_BUILTINS
argument_list|()
expr_stmt|;
name|TARGET_OS_CPP_BUILTINS
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass an object-like macro.  If it doesn't lie in the user's    namespace, defines it unconditionally.  Otherwise define a version    with two leading underscores, and another version with two leading    and trailing underscores, and define the original only if an ISO    standard was not nominated.     e.g. passing "unix" defines "__unix", "__unix__" and possibly    "unix".  Passing "_mips" defines "__mips", "__mips__" and possibly    "_mips".  */
end_comment

begin_function
name|void
name|builtin_define_std
parameter_list|(
name|macro
parameter_list|)
specifier|const
name|char
modifier|*
name|macro
decl_stmt|;
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buff
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|5
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buff
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|p
operator|+
name|len
decl_stmt|;
comment|/* prepend __ (or maybe just _) if in user's namespace.  */
name|memcpy
argument_list|(
name|p
argument_list|,
name|macro
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|||
name|ISUPPER
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'_'
condition|)
operator|*
operator|--
name|p
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
operator|*
operator|--
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If it was in user's namespace...  */
if|if
condition|(
name|p
operator|!=
name|buff
operator|+
literal|2
condition|)
block|{
comment|/* Define the macro with leading and following __.  */
if|if
condition|(
name|q
index|[
operator|-
literal|1
index|]
operator|!=
literal|'_'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|q
index|[
operator|-
literal|2
index|]
operator|!=
literal|'_'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Finally, define the original macro if permitted.  */
if|if
condition|(
operator|!
name|flag_iso
condition|)
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|macro
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pass an object-like macro and a value to define it to.  The third    parameter says whether or not to turn the value into a string    constant.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_with_value
parameter_list|(
name|macro
parameter_list|,
name|expansion
parameter_list|,
name|is_str
parameter_list|)
specifier|const
name|char
modifier|*
name|macro
decl_stmt|;
specifier|const
name|char
modifier|*
name|expansion
decl_stmt|;
name|int
name|is_str
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|mlen
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
name|size_t
name|elen
init|=
name|strlen
argument_list|(
name|expansion
argument_list|)
decl_stmt|;
name|size_t
name|extra
init|=
literal|2
decl_stmt|;
comment|/* space for an = and a NUL */
if|if
condition|(
name|is_str
condition|)
name|extra
operator|+=
literal|2
expr_stmt|;
comment|/* space for two quote marks */
name|buf
operator|=
name|alloca
argument_list|(
name|mlen
operator|+
name|elen
operator|+
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_str
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=\"%s\""
argument_list|,
name|macro
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|macro
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass an object-like macro and an integer value to define it to.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_with_int_value
parameter_list|(
name|macro
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|macro
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|mlen
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
name|size_t
name|vlen
init|=
literal|18
decl_stmt|;
name|size_t
name|extra
init|=
literal|2
decl_stmt|;
comment|/* space for = and NUL.  */
name|buf
operator|=
name|alloca
argument_list|(
name|mlen
operator|+
name|vlen
operator|+
name|extra
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|macro
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|buf
index|[
name|mlen
index|]
operator|=
literal|'='
expr_stmt|;
name|sprintf
argument_list|(
name|buf
operator|+
name|mlen
operator|+
literal|1
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass an object-like macro a hexadecimal floating-point value.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_with_hex_fp_value
parameter_list|(
name|macro
parameter_list|,
name|type
parameter_list|,
name|digits
parameter_list|,
name|hex_str
parameter_list|,
name|fp_suffix
parameter_list|)
specifier|const
name|char
modifier|*
name|macro
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|digits
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|fp_suffix
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
name|char
name|dec_str
index|[
literal|64
index|]
decl_stmt|,
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* Hex values are really cool and convenient, except that they're      not supported in strict ISO C90 mode.  First, the "p-" sequence      is not valid as part of a preprocessor number.  Second, we get a      pedwarn from the preprocessor, which has no context, so we can't      suppress the warning with __extension__.       So instead what we do is construct the number in hex (because       it's easy to get the exact correct value), parse it as a real,      then print it back out as decimal.  */
name|real_from_string
argument_list|(
operator|&
name|real
argument_list|,
name|hex_str
argument_list|)
expr_stmt|;
name|real_to_decimal
argument_list|(
name|dec_str
argument_list|,
operator|&
name|real
argument_list|,
sizeof|sizeof
argument_list|(
name|dec_str
argument_list|)
argument_list|,
name|digits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s%s"
argument_list|,
name|macro
argument_list|,
name|dec_str
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define MAX for TYPE based on the precision of the type.  IS_LONG is    1 for type "long" and 2 for "long long".  We have to handle    unsigned types, since wchar_t might be unsigned.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_type_max
parameter_list|(
name|macro
parameter_list|,
name|type
parameter_list|,
name|is_long
parameter_list|)
specifier|const
name|char
modifier|*
name|macro
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|is_long
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|values
index|[]
init|=
block|{
literal|"127"
block|,
literal|"255"
block|,
literal|"32767"
block|,
literal|"65535"
block|,
literal|"2147483647"
block|,
literal|"4294967295"
block|,
literal|"9223372036854775807"
block|,
literal|"18446744073709551615"
block|,
literal|"170141183460469231731687303715884105727"
block|,
literal|"340282366920938463463374607431768211455"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|suffixes
index|[]
init|=
block|{
literal|""
block|,
literal|"U"
block|,
literal|"L"
block|,
literal|"UL"
block|,
literal|"LL"
block|,
literal|"ULL"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
comment|/* Pre-rendering the values mean we don't have to futz with printing a      multi-word decimal value.  There are also a very limited number of      precisions that we support, so it's really a waste of time.  */
switch|switch
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|idx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|idx
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|idx
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|idx
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|idx
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|value
operator|=
name|values
index|[
name|idx
operator|+
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
name|suffix
operator|=
name|suffixes
index|[
name|is_long
operator|*
literal|2
operator|+
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|macro
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s%s"
argument_list|,
name|macro
argument_list|,
name|value
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|c_init_attributes
parameter_list|()
block|{
comment|/* Fill in the built_in_attributes array.  */
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = NULL_TREE;
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = build_int_2 (VALUE, VALUE< 0 ? -1 : 0);
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = get_identifier (STRING);
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM]			\     = tree_cons (built_in_attributes[(int) PURPOSE],	\ 		 built_in_attributes[(int) VALUE],	\ 		 built_in_attributes[(int) CHAIN]);
define|#
directive|define
name|DEF_FN_ATTR
parameter_list|(
name|NAME
parameter_list|,
name|ATTRS
parameter_list|,
name|PREDICATE
parameter_list|)
comment|/* No initialization needed.  */
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
undef|#
directive|undef
name|DEF_FN_ATTR
name|c_attrs_initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Depending on the name of DECL, apply default attributes to it.  */
end_comment

begin_function
name|void
name|c_common_insert_default_attributes
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c_attrs_initialized
condition|)
name|c_init_attributes
argument_list|()
expr_stmt|;
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
comment|/* Nothing needed after initialization.  */
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
define|#
directive|define
name|DEF_FN_ATTR
parameter_list|(
name|NAME
parameter_list|,
name|ATTRS
parameter_list|,
name|PREDICATE
parameter_list|)
define|\
value|if ((PREDICATE)&& name == built_in_attributes[(int) NAME])	\     decl_attributes (&decl, built_in_attributes[(int) ATTRS],	\ 		     ATTR_FLAG_BUILT_IN);
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
undef|#
directive|undef
name|DEF_FN_ATTR
block|}
end_function

begin_comment
comment|/* Output a -Wshadow warning MSGID about NAME, an IDENTIFIER_NODE, and    additionally give the location of the previous declaration DECL.  */
end_comment

begin_function
name|void
name|shadow_warning
parameter_list|(
name|msgid
parameter_list|,
name|name
parameter_list|,
name|decl
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"declaration of `%s' shadows %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"shadowed declaration is here"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attribute handlers common to C front ends.  */
end_comment

begin_comment
comment|/* Handle a "packed" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_packed_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_PACKED
argument_list|(
operator|*
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|DECL_PACKED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can't set DECL_PACKED for a VAR_DECL, because the bit is      used for DECL_REGISTER.  It wouldn't mean anything anyway.  */
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "nocommon" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_nocommon_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "common" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_common_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "noreturn" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_noreturn_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
comment|/* See FIXME comment in c_common_attribute_table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "noinline" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_noinline_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_UNINLINABLE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "always_inline" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_always_inline_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Do nothing else, just set the attribute.  We'll get at 	 it later with lookup_attribute.  */
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "used" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_used_attribute
parameter_list|(
name|pnode
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|pnode
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|node
init|=
operator|*
name|pnode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "unused" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_unused_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "const" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_const_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
comment|/* See FIXME comment on noreturn in c_common_attribute_table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_READONLY
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "transparent_union" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_transparent_union_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|int
name|is_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|decl
operator|=
operator|*
name|node
expr_stmt|;
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
name|type
operator|=
name|node
operator|,
name|is_type
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_type
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|decl
operator|==
literal|0
operator|||
operator|(
name|TYPE_FIELDS
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_TRANSPARENT_UNION
argument_list|(
operator|*
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
condition|)
name|DECL_TRANSPARENT_UNION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "constructor" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_constructor_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "destructor" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_destructor_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "mode" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_mode_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|typefm
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|newp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|-
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newp
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|newp
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|newp
expr_stmt|;
block|}
comment|/* Change this type to have a type with the specified mode. 	 First check for the special modes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"byte"
argument_list|)
condition|)
name|mode
operator|=
name|byte_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"word"
argument_list|)
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pointer"
argument_list|)
condition|)
name|mode
operator|=
name|ptr_mode
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
name|j
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|error
argument_list|(
literal|"unknown machine mode `%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
operator|(
name|typefm
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"no data type for mode `%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If this is a vector, make sure we either have hardware 	     support, or we can emulate it.  */
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
operator|!
name|vector_mode_valid_p
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"unable to emulate '%s'"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
operator|*
name|node
operator|=
name|typefm
expr_stmt|;
comment|/* No need to layout the type here.  The caller should do this.  */
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "section" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_section_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section attribute cannot be specified for local variables"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* The decl may have already been given a section attribute 	     from a previous declaration.  Ensure they match.  */
elseif|else
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|"section of `%s' conflicts with previous declaration"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_with_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|"section attribute not allowed for `%s'"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|error_with_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|"section attributes are not supported for this target"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "aligned" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_aligned_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|int
name|is_type
init|=
literal|0
decl_stmt|;
name|tree
name|align_expr
init|=
operator|(
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
name|size_int
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|decl
operator|=
operator|*
name|node
expr_stmt|;
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
name|type
operator|=
name|node
operator|,
name|is_type
operator|=
literal|1
expr_stmt|;
comment|/* Strip any NOPs of any kind.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|align_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|align_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is not a constant"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|tree_log2
argument_list|(
name|align_expr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is not a power of 2"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|HOST_BITS_PER_INT
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is too large"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_type
condition|)
block|{
comment|/* If we have a TYPE_DECL, then copy the type, so that we 	 don't accidentally modify a builtin type.  See pushdecl.  */
if|if
condition|(
name|decl
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|tt
expr_stmt|;
name|TYPE_NAME
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_USED
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
operator|*
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
operator|*
name|type
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
operator|*
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment may not be specified for `%s'"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "weak" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_weak_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|declare_weak
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "alias" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_alias_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' defined both normally and as an alias"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"alias arg not a string"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|id
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This counts as a use of the object pointed to.  */
name|TREE_USED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "visibility" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_visibility_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"visibility arg not a string"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"hidden"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"protected"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"internal"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"visibility arg must be one of \"default\", \"hidden\", \"protected\" or \"internal\""
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "tls_model" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_tls_model_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"tls_model arg not a string"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"local-exec"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"initial-exec"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"local-dynamic"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"global-dynamic"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"tls_model arg must be one of \"local-exec\", \"initial-exec\", \"local-dynamic\" or \"global-dynamic\""
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "no_instrument_function" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_no_instrument_function_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' attribute applies only to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"can't set `%s' attribute after definition"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "malloc" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_malloc_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_IS_MALLOC
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? TODO: Support types.  */
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "no_limit_stack" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_no_limit_stack_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' attribute applies only to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"can't set `%s' attribute after definition"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_NO_LIMIT_STACK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "pure" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_pure_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_IS_PURE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? TODO: Support types.  */
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "cleanup" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_cleanup_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|cleanup_id
decl_stmt|,
name|cleanup_decl
decl_stmt|;
comment|/* ??? Could perhaps support cleanups on TREE_STATIC, much like we do      for global destructors in C++.  This requires infrastructure that      we don't have generically at the moment.  It's also not a feature      we'd be missing too much, since we do have attribute constructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Verify that the argument is a function in scope.  */
comment|/* ??? We could support pointers to functions here as well, if      that was considered desirable.  */
name|cleanup_id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cleanup_id
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|error
argument_list|(
literal|"cleanup arg not an identifier"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|cleanup_decl
operator|=
name|lookup_name
argument_list|(
name|cleanup_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cleanup_decl
operator|||
name|TREE_CODE
argument_list|(
name|cleanup_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"cleanup arg not a function"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* That the function has proper type is checked with the       eventual call to build_function_call.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "deprecated" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_deprecated_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|warn
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|warn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_DEPRECATED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
operator|*
name|node
expr_stmt|;
block|}
else|else
name|warn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
literal|"`%s' attribute ignored for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Keep a list of vector type nodes we created in handle_vector_size_attribute,    to prevent us from duplicating type nodes unnecessarily.    The normal mechanism to prevent duplicates is to use type_hash_canon, but    since we want to distinguish types that are essentially identical (except    for their debug representation), we use a local list here.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|vector_type_node_list
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Handle a "vector_size" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_vector_size_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|vecsize
decl_stmt|,
name|nunits
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|orig_mode
decl_stmt|,
name|new_mode
decl_stmt|;
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|,
name|new_type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type_list_node
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Get the vector size (in bytes).  */
name|vecsize
operator|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We need to provide for vector pointers, vector arrays, and      functions returning vectors.  For example:         __attribute__((vector_size(16))) short *foo;       In this case, the mode is SI, but the type being modified is      HI, so we need to look further.  */
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Get the mode of the type being modified.  */
name|orig_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|orig_mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|orig_mode
argument_list|)
operator|!=
name|MODE_INT
operator|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid vector type for attribute `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Calculate how many units fit in the vector.  */
name|nunits
operator|=
name|vecsize
operator|/
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Find a suitably sized vector.  */
name|new_mode
operator|=
name|VOIDmode
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|orig_mode
argument_list|)
operator|==
name|MODE_INT
condition|?
name|MODE_VECTOR_INT
else|:
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|vecsize
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|nunits
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|new_mode
operator|=
name|mode
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new_mode
operator|==
name|VOIDmode
condition|)
block|{
name|error
argument_list|(
literal|"no vector mode with the size and type specified could be found"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
for|for
control|(
name|type_list_node
operator|=
name|vector_type_node_list
init|;
name|type_list_node
condition|;
name|type_list_node
operator|=
name|TREE_CHAIN
argument_list|(
name|type_list_node
argument_list|)
control|)
block|{
name|tree
name|other_type
init|=
name|TREE_VALUE
argument_list|(
name|type_list_node
argument_list|)
decl_stmt|;
name|tree
name|record
init|=
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|other_type
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
decl_stmt|;
name|tree
name|field_type
init|=
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|tree
name|array_type
init|=
name|TREE_TYPE
argument_list|(
name|field_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|other_type
argument_list|)
operator|==
name|mode
operator|&&
name|type
operator|==
name|array_type
condition|)
block|{
name|new_type
operator|=
name|other_type
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_type
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|index
decl_stmt|,
name|array
decl_stmt|,
name|rt
decl_stmt|,
name|list_node
decl_stmt|;
name|new_type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|new_mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_type
condition|)
block|{
name|error
argument_list|(
literal|"no vector mode with the size and type specified could be found"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|new_type
operator|=
name|build_type_copy
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
comment|/* If this is a vector, make sure we either have hardware          support, or we can emulate it.  */
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
operator|!
name|vector_mode_valid_p
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"unable to emulate '%s'"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Set the debug information here, because this is the only 	 place where we know the underlying type for a vector made 	 with vector_size.  For debugging purposes we pretend a vector 	 is an array within a structure.  */
name|index
operator|=
name|build_int_2
argument_list|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|new_type
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|array
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_index_type
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|rt
argument_list|)
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"f"
argument_list|)
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|=
name|rt
expr_stmt|;
name|layout_type
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|new_type
argument_list|)
operator|=
name|rt
expr_stmt|;
name|list_node
operator|=
name|build_tree_list
argument_list|(
name|NULL
argument_list|,
name|new_type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|list_node
argument_list|)
operator|=
name|vector_type_node_list
expr_stmt|;
name|vector_type_node_list
operator|=
name|list_node
expr_stmt|;
block|}
comment|/* Build back pointers if needed.  */
operator|*
name|node
operator|=
name|vector_size_helper
argument_list|(
operator|*
name|node
argument_list|,
name|new_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* HACK.  GROSS.  This is absolutely disgusting.  I wish there was a    better way.     If we requested a pointer to a vector, build up the pointers that    we stripped off while looking for the inner type.  Similarly for    return values from functions.     The argument "type" is the top of the chain, and "bottom" is the    new type which we will point to.  */
end_comment

begin_function
specifier|static
name|tree
name|vector_size_helper
parameter_list|(
name|type
parameter_list|,
name|bottom
parameter_list|)
name|tree
name|type
decl_stmt|,
name|bottom
decl_stmt|;
block|{
name|tree
name|inner
decl_stmt|,
name|outer
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|inner
operator|=
name|vector_size_helper
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_pointer_type
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|inner
operator|=
name|vector_size_helper
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_array_type
argument_list|(
name|inner
argument_list|,
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|inner
operator|=
name|vector_size_helper
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_function_type
argument_list|(
name|inner
argument_list|,
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|bottom
return|;
name|TREE_READONLY
argument_list|(
name|outer
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|outer
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|outer
return|;
block|}
end_function

begin_comment
comment|/* Handle the "nonnull" attribute.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_nonnull_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|attr_arg_num
decl_stmt|;
comment|/* If no arguments are specified, all pointer arguments should be      non-null.  Veryify a full prototype is given so that the arguments      will have the correct types when we actually check them later.  */
if|if
condition|(
operator|!
name|args
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"nonnull attribute without arguments on a non-prototype"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Argument list specified.  Verify that each argument number references      a pointer argument.  */
for|for
control|(
name|attr_arg_num
operator|=
literal|1
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|argument
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|,
name|ck_num
decl_stmt|;
if|if
condition|(
operator|!
name|get_nonnull_operand
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
operator|&
name|arg_num
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"nonnull argument has invalid operand number (arg %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|attr_arg_num
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
for|for
control|(
name|ck_num
operator|=
literal|1
init|;
condition|;
name|ck_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|argument
operator|||
name|ck_num
operator|==
name|arg_num
condition|)
break|break;
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"nonnull argument with out-of-range operand number (arg %lu, operand %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|attr_arg_num
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|arg_num
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"nonnull argument references non-pointer operand (arg %lu, operand %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|attr_arg_num
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|arg_num
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check the argument list of a function call for null in argument slots    that are marked as requiring a non-null pointer argument.  */
end_comment

begin_function
specifier|static
name|void
name|check_function_nonnull
parameter_list|(
name|attrs
parameter_list|,
name|params
parameter_list|)
name|tree
name|attrs
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|tree
name|a
decl_stmt|,
name|args
decl_stmt|,
name|param
decl_stmt|;
name|int
name|param_num
decl_stmt|;
for|for
control|(
name|a
operator|=
name|attrs
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"nonnull"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
name|args
operator|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Walk the argument list.  If we encounter an argument number we              should check for non-null, do it.  If the attribute has no args,              then every pointer argument is checked (in which case the check 	     for pointer type is done in check_nonnull_arg).  */
for|for
control|(
name|param
operator|=
name|params
operator|,
name|param_num
operator|=
literal|1
init|;
condition|;
name|param_num
operator|++
operator|,
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|param
condition|)
break|break;
if|if
condition|(
operator|!
name|args
operator|||
name|nonnull_check_p
argument_list|(
name|args
argument_list|,
name|param_num
argument_list|)
condition|)
name|check_function_arguments_recurse
argument_list|(
name|check_nonnull_arg
argument_list|,
name|NULL
argument_list|,
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper for check_function_nonnull; given a list of operands which    must be non-null in ARGS, determine if operand PARAM_NUM should be    checked.  */
end_comment

begin_function
specifier|static
name|bool
name|nonnull_check_p
parameter_list|(
name|args
parameter_list|,
name|param_num
parameter_list|)
name|tree
name|args
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|param_num
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|get_nonnull_operand
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
operator|&
name|arg_num
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg_num
operator|==
name|param_num
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check that the function argument PARAM (which is operand number    PARAM_NUM) is non-null.  This is called by check_function_nonnull    via check_function_arguments_recurse.  */
end_comment

begin_function
specifier|static
name|void
name|check_nonnull_arg
parameter_list|(
name|ctx
parameter_list|,
name|param
parameter_list|,
name|param_num
parameter_list|)
name|void
modifier|*
name|ctx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|param
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|param_num
decl_stmt|;
block|{
comment|/* Just skip checking the argument if it's not a pointer.  This can      happen if the "nonnull" attribute was given without an operand      list (which means to check every pointer argument).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|param
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return;
if|if
condition|(
name|integer_zerop
argument_list|(
name|param
argument_list|)
condition|)
name|warning
argument_list|(
literal|"null argument where non-null required (arg %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|param_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for nonnull attribute handling; fetch the operand number    from the attribute argument list.  */
end_comment

begin_function
specifier|static
name|bool
name|get_nonnull_operand
parameter_list|(
name|arg_num_expr
parameter_list|,
name|valp
parameter_list|)
name|tree
name|arg_num_expr
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|valp
decl_stmt|;
block|{
comment|/* Strip any conversions from the arg number and verify they      are constants.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|arg_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|arg_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|arg_num_expr
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
operator|*
name|valp
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg_num_expr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a "nothrow" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_nothrow_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_NOTHROW
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? TODO: Support types.  */
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check for valid arguments being passed to a function.  */
end_comment

begin_function
name|void
name|check_function_arguments
parameter_list|(
name|attrs
parameter_list|,
name|params
parameter_list|)
name|tree
name|attrs
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
comment|/* Check for null being passed in a pointer argument that must be      non-null.  We also need to do this if format checking is enabled.  */
if|if
condition|(
name|warn_nonnull
condition|)
name|check_function_nonnull
argument_list|(
name|attrs
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Check for errors in format strings.  */
if|if
condition|(
name|warn_format
condition|)
name|check_function_format
argument_list|(
name|NULL
argument_list|,
name|attrs
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generic argument checking recursion routine.  PARAM is the argument to    be checked.  PARAM_NUM is the number of the argument.  CALLBACK is invoked    once the argument is resolved.  CTX is context for the callback.  */
end_comment

begin_function_decl
name|void
name|check_function_arguments_recurse
parameter_list|(
name|callback
parameter_list|,
name|ctx
parameter_list|,
name|param
parameter_list|,
name|param_num
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*callback
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|HOST_WIDE_INT
name|param_num
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|param
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* Strip coercion.  */
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|0
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|param
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|bool
name|found_format_arg
init|=
name|false
decl_stmt|;
comment|/* See if this is a call to a known internationalization function 	 that modifies a format arg.  Such a function may have multiple 	 format_arg attributes (for example, ngettext).  */
for|for
control|(
name|attrs
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
init|;
name|attrs
condition|;
name|attrs
operator|=
name|TREE_CHAIN
argument_list|(
name|attrs
argument_list|)
control|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format_arg"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|attrs
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner_args
decl_stmt|;
name|tree
name|format_num_expr
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Extract the argument number, which was previously checked 	       to be valid.  */
name|format_num_expr
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|format_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|format_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
for|for
control|(
name|inner_args
operator|=
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|=
literal|1
init|;
name|inner_args
operator|!=
literal|0
condition|;
name|inner_args
operator|=
name|TREE_CHAIN
argument_list|(
name|inner_args
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|format_num
condition|)
block|{
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_VALUE
argument_list|(
name|inner_args
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
name|found_format_arg
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we found a format_arg attribute and did a recursive check, 	 we are done with checking this argument.  Otherwise, we continue 	 and this will be considered a non-literal.  */
if|if
condition|(
name|found_format_arg
condition|)
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|param
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* Check both halves of the conditional expression.  */
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|2
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|callback
call|)
argument_list|(
name|ctx
argument_list|,
name|param
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|"gt-c-common.h"
end_include

end_unit

