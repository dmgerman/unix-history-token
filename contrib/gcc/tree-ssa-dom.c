begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SSA Dominator optimizations for trees    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* This file implements optimizations on the dominator tree.  */
end_comment

begin_comment
comment|/* Structure for recording edge equivalences as well as any pending    edge redirections during the dominator optimizer.     Computing and storing the edge equivalences instead of creating    them on-demand can save significant amounts of time, particularly    for pathological cases involving switch statements.       These structures live for a single iteration of the dominator    optimizer in the edge's AUX field.  At the end of an iteration we    free each of these structures and update the AUX field to point    to any requested redirection target (the code for updating the    CFG and SSA graph for edge redirection expects redirection edge    targets to be in the AUX field for each edge.  */
end_comment

begin_struct
struct|struct
name|edge_info
block|{
comment|/* If this edge creates a simple equivalence, the LHS and RHS of      the equivalence will be stored here.  */
name|tree
name|lhs
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
comment|/* Traversing an edge may also indicate one or more particular conditions      are true or false.  The number of recorded conditions can vary, but      can be determined by the condition's code.  So we have an array      and its maximum index rather than use a varray.  */
name|tree
modifier|*
name|cond_equivalences
decl_stmt|;
name|unsigned
name|int
name|max_cond_equivalences
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash table with expressions made available during the renaming process.    When an assignment of the form X_i = EXPR is found, the statement is    stored in this table.  If the same expression EXPR is later found on the    RHS of another statement, it is replaced with X_i (thus performing    global redundancy elimination).  Similarly as we pass through conditionals    we record the conditional itself as having either a true or false value    in this table.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|avail_exprs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of available expressions in AVAIL_EXPRs.  Each block pushes any    expressions it enters into the hash table along with a marker entry    (null).  When we finish processing the block, we pop off entries and    remove the expressions from the global hash table until we hit the    marker.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|avail_exprs_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Stack of statements we need to rescan during finalization for newly    exposed variables.     Statement rescanning must occur after the current block's available    expressions are removed from AVAIL_EXPRS.  Else we may change the    hash code for an expression and be unable to find/remove it from    AVAIL_EXPRS.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|stmts_to_rescan
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Structure for entries in the expression hash table.     This requires more memory for the hash table entries, but allows us    to avoid creating silly tree nodes and annotations for conditionals,    eliminates 2 global hash tables and two block local varrays.        It also allows us to reduce the number of hash table lookups we    have to perform in lookup_avail_expr and finally it allows us to    significantly reduce the number of calls into the hashing routine    itself.  */
end_comment

begin_struct
struct|struct
name|expr_hash_elt
block|{
comment|/* The value (lhs) of this expression.  */
name|tree
name|lhs
decl_stmt|;
comment|/* The expression (rhs) we want to record.  */
name|tree
name|rhs
decl_stmt|;
comment|/* The stmt pointer if this element corresponds to a statement.  */
name|tree
name|stmt
decl_stmt|;
comment|/* The hash value for RHS/ann.  */
name|hashval_t
name|hash
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Stack of dest,src pairs that need to be restored during finalization.     A NULL entry is used to mark the end of pairs which need to be    restored during finalization of this block.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|const_and_copies_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Track whether or not we have changed the control flow graph.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|cfg_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap of blocks that have had EH statements cleaned.  We should    remove their dead edges eventually.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|need_eh_cleanup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics for dominator optimizations.  */
end_comment

begin_struct
struct|struct
name|opt_stats_d
block|{
name|long
name|num_stmts
decl_stmt|;
name|long
name|num_exprs_considered
decl_stmt|;
name|long
name|num_re
decl_stmt|;
name|long
name|num_const_prop
decl_stmt|;
name|long
name|num_copy_prop
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|opt_stats_d
name|opt_stats
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|eq_expr_value
block|{
name|tree
name|src
decl_stmt|;
name|tree
name|dst
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|optimize_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|block_stmt_iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_avail_expr
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|avail_expr_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|real_avail_expr_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|avail_expr_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htab_statistics
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_cond
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_const_or_copy
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_equality
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_equivalences_from_phis
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_equivalences_from_incoming_edge
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|eliminate_redundant_computations
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_equivalences_from_stmt
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|stmt_ann_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dom_thread_across_edge
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dom_opt_finalize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dom_opt_initialize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_to_outgoing_edges
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_local_expressions_from_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restore_vars_to_original_value
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|single_incoming_edge_ignoring_loop_edges
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate an EDGE_INFO for edge E and attach it to E.    Return the new EDGE_INFO structure.  */
end_comment

begin_function
specifier|static
name|struct
name|edge_info
modifier|*
name|allocate_edge_info
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
name|edge_info
operator|=
name|XCNEW
argument_list|(
expr|struct
name|edge_info
argument_list|)
expr_stmt|;
name|e
operator|->
name|aux
operator|=
name|edge_info
expr_stmt|;
return|return
name|edge_info
return|;
block|}
end_function

begin_comment
comment|/* Free all EDGE_INFO structures associated with edges in the CFG.    If a particular edge can be threaded, copy the redirection    target from the EDGE_INFO structure into the edge's AUX field    as required by code to update the CFG and SSA graph for    jump threading.  */
end_comment

begin_function
specifier|static
name|void
name|free_all_edge_infos
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|struct
name|edge_info
modifier|*
name|edge_info
init|=
operator|(
expr|struct
name|edge_info
operator|*
operator|)
name|e
operator|->
name|aux
decl_stmt|;
if|if
condition|(
name|edge_info
condition|)
block|{
if|if
condition|(
name|edge_info
operator|->
name|cond_equivalences
condition|)
name|free
argument_list|(
name|edge_info
operator|->
name|cond_equivalences
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edge_info
argument_list|)
expr_stmt|;
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Jump threading, redundancy elimination and const/copy propagation.      This pass may expose new symbols that need to be renamed into SSA.  For    every new symbol exposed, its corresponding bit will be set in    VARS_TO_RENAME.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_dominator_optimize
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dom_walk_data
name|walk_data
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|loops
name|loops_info
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opt_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create our hash tables.  */
name|avail_exprs
operator|=
name|htab_create
argument_list|(
literal|1024
argument_list|,
name|real_avail_expr_hash
argument_list|,
name|avail_expr_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|avail_exprs_stack
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|const_and_copies_stack
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|stmts_to_rescan
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|need_eh_cleanup
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Setup callbacks for the generic dominator tree walker.  */
name|walk_data
operator|.
name|walk_stmts_backward
operator|=
name|false
expr_stmt|;
name|walk_data
operator|.
name|dom_direction
operator|=
name|CDI_DOMINATORS
expr_stmt|;
name|walk_data
operator|.
name|initialize_block_local_data
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|dom_opt_initialize_block
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_walk_stmts
operator|=
name|optimize_stmt
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_after_stmts
operator|=
name|propagate_to_outgoing_edges
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_before_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_walk_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_after_stmts
operator|=
name|dom_opt_finalize_block
expr_stmt|;
comment|/* Right now we only attach a dummy COND_EXPR to the global data pointer.      When we attach more stuff we'll need to fill this out with a real      structure.  */
name|walk_data
operator|.
name|global_data
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|block_local_data_size
operator|=
literal|0
expr_stmt|;
name|walk_data
operator|.
name|interesting_blocks
operator|=
name|NULL
expr_stmt|;
comment|/* Now initialize the dominator walker.  */
name|init_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* We need to know which edges exit loops so that we can      aggressively thread through loop headers to an exit      edge.  */
name|flow_loops_find
argument_list|(
operator|&
name|loops_info
argument_list|)
expr_stmt|;
name|mark_loop_exit_edges
argument_list|(
operator|&
name|loops_info
argument_list|)
expr_stmt|;
name|flow_loops_free
argument_list|(
operator|&
name|loops_info
argument_list|)
expr_stmt|;
comment|/* Clean up the CFG so that any forwarder blocks created by loop      canonicalization are removed.  */
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* We need accurate information regarding back edges in the CFG      for jump threading.  */
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
comment|/* Recursively walk the dominator tree optimizing statements.  */
name|walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|update_stmt_if_modified
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we exposed any new variables, go ahead and put them into      SSA form now, before we handle jump threading.  This simplifies      interactions between rewriting of _DECL nodes into SSA form      and rewriting SSA_NAME nodes into SSA form after block      duplication and CFG manipulation.  */
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
name|free_all_edge_infos
argument_list|()
expr_stmt|;
comment|/* Thread jumps, creating duplicate blocks as needed.  */
name|cfg_altered
operator||=
name|thread_through_all_blocks
argument_list|()
expr_stmt|;
comment|/* Removal of statements may make some EH edges dead.  Purge      such edges from the CFG as needed.  */
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|need_eh_cleanup
argument_list|)
condition|)
block|{
name|cfg_altered
operator||=
name|tree_purge_all_dead_eh_edges
argument_list|(
name|need_eh_cleanup
argument_list|)
expr_stmt|;
name|bitmap_zero
argument_list|(
name|need_eh_cleanup
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg_altered
condition|)
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Finally, remove everything except invariants in SSA_NAME_VALUE.       Long term we will be able to let everything in SSA_NAME_VALUE      persist.  However, for now, we know this is the safe thing to do.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
continue|continue;
name|value
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|value
argument_list|)
condition|)
name|SSA_NAME_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Debugging dumps.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|dump_dominator_optimization_stats
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
comment|/* Delete our main hashtable.  */
name|htab_delete
argument_list|(
name|avail_exprs
argument_list|)
expr_stmt|;
comment|/* And finalize the dominator walker.  */
name|fini_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* Free asserted bitmaps and stacks.  */
name|BITMAP_FREE
argument_list|(
name|need_eh_cleanup
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|avail_exprs_stack
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|const_and_copies_stack
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|stmts_to_rescan
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_dominator
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_dom
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_dominator
init|=
block|{
literal|"dom"
block|,
comment|/* name */
name|gate_dominator
block|,
comment|/* gate */
name|tree_ssa_dominator_optimize
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_SSA_DOMINATOR_OPTS
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_cleanup_cfg
operator||
name|TODO_verify_ssa
operator||
name|TODO_update_smt_usage
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a stmt CONDSTMT containing a COND_EXPR, canonicalize the    COND_EXPR into a canonical form.  */
end_comment

begin_function
specifier|static
name|void
name|canonicalize_comparison
parameter_list|(
name|tree
name|condstmt
parameter_list|)
block|{
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|condstmt
argument_list|)
decl_stmt|;
name|tree
name|op0
decl_stmt|;
name|tree
name|op1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
return|return;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If it would be profitable to swap the operands, then do so to      canonicalize the statement, enabling better optimization.       By placing canonicalization of such expressions here we      transparently keep statements in canonical form, even      when the statement is modified.  */
if|if
condition|(
name|tree_swap_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|false
argument_list|)
condition|)
block|{
comment|/* For relationals we need to swap the operands 	 and change the code.  */
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
operator|||
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|TREE_SET_CODE
argument_list|(
name|cond
argument_list|,
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|swap_tree_operands
argument_list|(
name|condstmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one operand was in the operand cache, but the other is 	     not, because it is a constant, this is a case that the 	     internal updating code of swap_tree_operands can't handle 	     properly.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|!=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
name|update_stmt
argument_list|(
name|condstmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize local stacks for this optimizer and record equivalences    upon entry to BB.  Equivalences can come from the edge traversed to    reach BB or they may come from PHI nodes at the start of BB.  */
end_comment

begin_function
specifier|static
name|void
name|dom_opt_initialize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\nOptimizing block #%d\n\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Push a marker on the stacks of local information so that we know how      far to unwind when we finalize this block.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|avail_exprs_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|const_and_copies_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|record_equivalences_from_incoming_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* PHI nodes can create equivalences too.  */
name|record_equivalences_from_phis
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an expression EXPR (a relational expression or a statement),     initialize the hash table element pointed to by ELEMENT.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_hash_element
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|struct
name|expr_hash_elt
modifier|*
name|element
parameter_list|)
block|{
comment|/* Hash table elements may be based on conditional expressions or statements.       For the former case, we have no annotation and we want to hash the      conditional expression.  In the latter case we have an annotation and      we want to record the expression the statement evaluates.  */
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
name|element
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
name|element
operator|->
name|rhs
operator|=
name|expr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|element
operator|->
name|stmt
operator|=
name|expr
expr_stmt|;
name|element
operator|->
name|rhs
operator|=
name|COND_EXPR_COND
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
name|element
operator|->
name|stmt
operator|=
name|expr
expr_stmt|;
name|element
operator|->
name|rhs
operator|=
name|SWITCH_COND
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|element
operator|->
name|stmt
operator|=
name|expr
expr_stmt|;
name|element
operator|->
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|GOTO_EXPR
condition|)
block|{
name|element
operator|->
name|stmt
operator|=
name|expr
expr_stmt|;
name|element
operator|->
name|rhs
operator|=
name|GOTO_DESTINATION
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|element
operator|->
name|stmt
operator|=
name|expr
expr_stmt|;
name|element
operator|->
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|element
operator|->
name|lhs
operator|=
name|lhs
expr_stmt|;
name|element
operator|->
name|hash
operator|=
name|avail_expr_hash
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all the expressions in LOCALS from TABLE, stopping when there are    LIMIT entries left in LOCALs.  */
end_comment

begin_function
specifier|static
name|void
name|remove_local_expressions_from_table
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Remove all the expressions made available in this block.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|avail_exprs_stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|expr_hash_elt
name|element
decl_stmt|;
name|tree
name|expr
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|avail_exprs_stack
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
break|break;
name|initialize_hash_element
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|,
operator|&
name|element
argument_list|)
expr_stmt|;
name|htab_remove_elt_with_hash
argument_list|(
name|avail_exprs
argument_list|,
operator|&
name|element
argument_list|,
name|element
operator|.
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Use the source/dest pairs in CONST_AND_COPIES_STACK to restore    CONST_AND_COPIES to its original state, stopping when we hit a    NULL marker.  */
end_comment

begin_function
specifier|static
name|void
name|restore_vars_to_original_value
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|const_and_copies_stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|prev_value
decl_stmt|,
name|dest
decl_stmt|;
name|dest
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|const_and_copies_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
break|break;
name|prev_value
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|const_and_copies_stack
argument_list|)
expr_stmt|;
name|SSA_NAME_VALUE
argument_list|(
name|dest
argument_list|)
operator|=
name|prev_value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A trivial wrapper so that we can present the generic jump    threading code with a simple API for simplifying statements.  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_stmt_for_jump_threading
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|within_stmt
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|lookup_avail_expr
argument_list|(
name|stmt
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper for common code to attempt to thread an edge.  For example,    it handles lazily building the dummy condition and the bookkeeping    when jump threading is successful.  */
end_comment

begin_function
specifier|static
name|void
name|dom_thread_across_edge
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
comment|/* If we don't already have a dummy condition, build it now.  */
if|if
condition|(
operator|!
name|walk_data
operator|->
name|global_data
condition|)
block|{
name|tree
name|dummy_cond
init|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
name|dummy_cond
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dummy_cond
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_data
operator|->
name|global_data
operator|=
name|dummy_cond
expr_stmt|;
block|}
name|thread_across_edge
argument_list|(
name|walk_data
operator|->
name|global_data
argument_list|,
name|e
argument_list|,
name|false
argument_list|,
operator|&
name|const_and_copies_stack
argument_list|,
name|simplify_stmt_for_jump_threading
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We have finished processing the dominator children of BB, perform    any finalization actions in preparation for leaving this node in    the dominator tree.  */
end_comment

begin_function
specifier|static
name|void
name|dom_opt_finalize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|last
decl_stmt|;
comment|/* If we have an outgoing edge to a block with multiple incoming and      outgoing edges, then we may be able to thread the edge.  ie, we      may be able to statically determine which of the outgoing edges      will be traversed when the incoming edge from BB is traversed.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|&&
operator|(
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
operator|&&
name|potentially_threadable_block
argument_list|(
name|single_succ
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
name|dom_thread_across_edge
argument_list|(
name|walk_data
argument_list|,
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|last
operator|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|COMPARISON_CLASS_P
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|last
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|==
literal|2
operator|&&
operator|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
condition|)
block|{
name|edge
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
name|extract_true_false_edges_from_block
argument_list|(
name|bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* Only try to thread the edge if it reaches a target block with 	 more than one predecessor and more than one successor.  */
if|if
condition|(
name|potentially_threadable_block
argument_list|(
name|true_edge
operator|->
name|dest
argument_list|)
condition|)
block|{
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Push a marker onto the available expression stack so that we 	     unwind any expressions related to the TRUE arm before processing 	     the false arm below.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|avail_exprs_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|const_and_copies_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|edge_info
operator|=
operator|(
expr|struct
name|edge_info
operator|*
operator|)
name|true_edge
operator|->
name|aux
expr_stmt|;
comment|/* If we have info associated with this edge, record it into 	     our equivalency tables.  */
if|if
condition|(
name|edge_info
condition|)
block|{
name|tree
modifier|*
name|cond_equivalences
init|=
name|edge_info
operator|->
name|cond_equivalences
decl_stmt|;
name|tree
name|lhs
init|=
name|edge_info
operator|->
name|lhs
decl_stmt|;
name|tree
name|rhs
init|=
name|edge_info
operator|->
name|rhs
decl_stmt|;
comment|/* If we have a simple NAME = VALUE equivalency record it.  */
if|if
condition|(
name|lhs
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|record_const_or_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* If we have 0 = COND or 1 = COND equivalences, record them 		 into our expression hash tables.  */
if|if
condition|(
name|cond_equivalences
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edge_info
operator|->
name|max_cond_equivalences
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|tree
name|expr
init|=
name|cond_equivalences
index|[
name|i
index|]
decl_stmt|;
name|tree
name|value
init|=
name|cond_equivalences
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|record_cond
argument_list|(
name|expr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|dom_thread_across_edge
argument_list|(
name|walk_data
argument_list|,
name|true_edge
argument_list|)
expr_stmt|;
comment|/* And restore the various tables to their state before 	     we threaded this edge.  */
name|remove_local_expressions_from_table
argument_list|()
expr_stmt|;
block|}
comment|/* Similarly for the ELSE arm.  */
if|if
condition|(
name|potentially_threadable_block
argument_list|(
name|false_edge
operator|->
name|dest
argument_list|)
condition|)
block|{
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|const_and_copies_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|edge_info
operator|=
operator|(
expr|struct
name|edge_info
operator|*
operator|)
name|false_edge
operator|->
name|aux
expr_stmt|;
comment|/* If we have info associated with this edge, record it into 	     our equivalency tables.  */
if|if
condition|(
name|edge_info
condition|)
block|{
name|tree
modifier|*
name|cond_equivalences
init|=
name|edge_info
operator|->
name|cond_equivalences
decl_stmt|;
name|tree
name|lhs
init|=
name|edge_info
operator|->
name|lhs
decl_stmt|;
name|tree
name|rhs
init|=
name|edge_info
operator|->
name|rhs
decl_stmt|;
comment|/* If we have a simple NAME = VALUE equivalency record it.  */
if|if
condition|(
name|lhs
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|record_const_or_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* If we have 0 = COND or 1 = COND equivalences, record them 		 into our expression hash tables.  */
if|if
condition|(
name|cond_equivalences
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edge_info
operator|->
name|max_cond_equivalences
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|tree
name|expr
init|=
name|cond_equivalences
index|[
name|i
index|]
decl_stmt|;
name|tree
name|value
init|=
name|cond_equivalences
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|record_cond
argument_list|(
name|expr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now thread the edge.  */
name|dom_thread_across_edge
argument_list|(
name|walk_data
argument_list|,
name|false_edge
argument_list|)
expr_stmt|;
comment|/* No need to remove local expressions from our tables 	     or restore vars to their original value as that will 	     be done immediately below.  */
block|}
block|}
name|remove_local_expressions_from_table
argument_list|()
expr_stmt|;
name|restore_vars_to_original_value
argument_list|()
expr_stmt|;
comment|/* If we queued any statements to rescan in this block, then      go ahead and rescan them now.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|stmts_to_rescan
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|stmt
init|=
name|VEC_last
argument_list|(
name|tree
argument_list|,
name|stmts_to_rescan
argument_list|)
decl_stmt|;
name|basic_block
name|stmt_bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt_bb
operator|!=
name|bb
condition|)
break|break;
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|stmts_to_rescan
argument_list|)
expr_stmt|;
name|mark_new_vars_to_rename
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PHI nodes can create equivalences too.     Ignoring any alternatives which are the same as the result, if    all the alternatives are equal, then the PHI node creates an    equivalence.  */
end_comment

begin_function
specifier|static
name|void
name|record_equivalences_from_phis
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|lhs
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|t
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Ignore alternatives which are the same as our LHS.  Since 	     LHS is a PHI_RESULT, it is known to be a SSA_NAME, so we 	     can simply compare pointers.  */
if|if
condition|(
name|lhs
operator|==
name|t
condition|)
continue|continue;
comment|/* If we have not processed an alternative yet, then set 	     RHS to this alternative.  */
if|if
condition|(
name|rhs
operator|==
name|NULL
condition|)
name|rhs
operator|=
name|t
expr_stmt|;
comment|/* If we have processed an alternative (stored in RHS), then 	     see if it is equal to this one.  If it isn't, then stop 	     the search.  */
elseif|else
if|if
condition|(
operator|!
name|operand_equal_for_phi_arg_p
argument_list|(
name|rhs
argument_list|,
name|t
argument_list|)
condition|)
break|break;
block|}
comment|/* If we had no interesting alternatives, then all the RHS alternatives 	 must have been the same as LHS.  */
if|if
condition|(
operator|!
name|rhs
condition|)
name|rhs
operator|=
name|lhs
expr_stmt|;
comment|/* If we managed to iterate through each PHI alternative without 	 breaking out of the loop, then we have a PHI which may create 	 a useful equivalence.  We do not need to record unwind data for 	 this, since this is a true assignment and not an equivalence 	 inferred from a comparison.  All uses of this ssa name are dominated 	 by this assignment, so unwinding just costs time and space.  */
if|if
condition|(
name|i
operator|==
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|&&
name|may_propagate_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
name|SSA_NAME_VALUE
argument_list|(
name|lhs
argument_list|)
operator|=
name|rhs
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ignoring loop backedges, if BB has precisely one incoming edge then    return that edge.  Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|edge
name|single_incoming_edge_ignoring_loop_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|retval
init|=
name|NULL
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
comment|/* A loop back edge can be identified by the destination of 	 the edge dominating the source of the edge.  */
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
comment|/* If we have already seen a non-loop edge, then we must have 	 multiple incoming non-loop edges and thus we return NULL.  */
if|if
condition|(
name|retval
condition|)
return|return
name|NULL
return|;
comment|/* This is the first non-loop incoming edge we have found.  Record 	 it.  */
name|retval
operator|=
name|e
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Record any equivalences created by the incoming edge to BB.  If BB    has more than one incoming edge, then no equivalence is created.  */
end_comment

begin_function
specifier|static
name|void
name|record_equivalences_from_incoming_edge
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|parent
decl_stmt|;
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
comment|/* If our parent block ended with a control statement, then we may be      able to record some equivalences based on which outgoing edge from      the parent was followed.  */
name|parent
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|e
operator|=
name|single_incoming_edge_ignoring_loop_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* If we had a single incoming edge from our parent block, then enter      any data associated with the edge into our tables.  */
if|if
condition|(
name|e
operator|&&
name|e
operator|->
name|src
operator|==
name|parent
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|edge_info
operator|=
operator|(
expr|struct
name|edge_info
operator|*
operator|)
name|e
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|edge_info
condition|)
block|{
name|tree
name|lhs
init|=
name|edge_info
operator|->
name|lhs
decl_stmt|;
name|tree
name|rhs
init|=
name|edge_info
operator|->
name|rhs
decl_stmt|;
name|tree
modifier|*
name|cond_equivalences
init|=
name|edge_info
operator|->
name|cond_equivalences
decl_stmt|;
if|if
condition|(
name|lhs
condition|)
name|record_equality
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_equivalences
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edge_info
operator|->
name|max_cond_equivalences
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|tree
name|expr
init|=
name|cond_equivalences
index|[
name|i
index|]
decl_stmt|;
name|tree
name|value
init|=
name|cond_equivalences
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|record_cond
argument_list|(
name|expr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Dump SSA statistics on FILE.  */
end_comment

begin_function
name|void
name|dump_dominator_optimization_stats
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|long
name|n_exprs
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total number of statements:                   %6ld\n\n"
argument_list|,
name|opt_stats
operator|.
name|num_stmts
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Exprs considered for dominator optimizations: %6ld\n"
argument_list|,
name|opt_stats
operator|.
name|num_exprs_considered
argument_list|)
expr_stmt|;
name|n_exprs
operator|=
name|opt_stats
operator|.
name|num_exprs_considered
expr_stmt|;
if|if
condition|(
name|n_exprs
operator|==
literal|0
condition|)
name|n_exprs
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"    Redundant expressions eliminated:         %6ld (%.0f%%)\n"
argument_list|,
name|opt_stats
operator|.
name|num_re
argument_list|,
name|PERCENT
argument_list|(
name|opt_stats
operator|.
name|num_re
argument_list|,
name|n_exprs
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"    Constants propagated:                     %6ld\n"
argument_list|,
name|opt_stats
operator|.
name|num_const_prop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"    Copies propagated:                        %6ld\n"
argument_list|,
name|opt_stats
operator|.
name|num_copy_prop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nHash table statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"    avail_exprs: "
argument_list|)
expr_stmt|;
name|htab_statistics
argument_list|(
name|file
argument_list|,
name|avail_exprs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump SSA statistics on stderr.  */
end_comment

begin_function
name|void
name|debug_dominator_optimization_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_dominator_optimization_stats
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump statistics for the hash table HTAB.  */
end_comment

begin_function
specifier|static
name|void
name|htab_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|htab_t
name|htab
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"size %ld, %ld elements, %f collision/search ratio\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|htab
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|htab
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|htab
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a statement into the true/false expression hash table indicating    that the condition COND has the value VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|record_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|struct
name|expr_hash_elt
modifier|*
name|element
init|=
name|XCNEW
argument_list|(
expr|struct
name|expr_hash_elt
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|initialize_hash_element
argument_list|(
name|cond
argument_list|,
name|value
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|avail_exprs
argument_list|,
operator|(
name|void
operator|*
operator|)
name|element
argument_list|,
name|element
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|element
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|avail_exprs_stack
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a new conditional using NEW_CODE, OP0 and OP1 and store    the new conditional into *p, then store a boolean_true_node    into *(p + 1).  */
end_comment

begin_function
specifier|static
name|void
name|build_and_record_new_cond
parameter_list|(
name|enum
name|tree_code
name|new_code
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
name|build2
argument_list|(
name|new_code
argument_list|,
name|boolean_type_node
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|boolean_true_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that COND is true and INVERTED is false into the edge information    structure.  Also record that any conditions dominated by COND are true    as well.     For example, if a< b is true, then a<= b must also be true.  */
end_comment

begin_function
specifier|static
name|void
name|record_conditions
parameter_list|(
name|struct
name|edge_info
modifier|*
name|edge_info
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|inverted
parameter_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
return|return;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|12
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|ORDERED_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|LTGT_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|8
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|build_and_record_new_cond
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|LT_EXPR
condition|?
name|LE_EXPR
else|:
name|GE_EXPR
operator|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|NE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|6
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|ORDERED_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|4
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|10
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|ORDERED_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|8
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|build_and_record_new_cond
argument_list|(
name|LE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|GE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|16
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|NE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|UNLE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|UNGE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|UNEQ_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|UNLT_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|UNGT_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLT_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|8
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|UNLT_EXPR
condition|?
name|UNLE_EXPR
else|:
name|UNGE_EXPR
operator|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|NE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEQ_EXPR
case|:
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|8
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|UNLE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|UNGE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTGT_EXPR
case|:
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|8
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|NE_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|build_and_record_new_cond
argument_list|(
name|ORDERED_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
operator|&
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|edge_info
operator|->
name|max_cond_equivalences
operator|=
literal|4
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now store the original true and false conditions into the first      two slots.  */
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|0
index|]
operator|=
name|cond
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|1
index|]
operator|=
name|boolean_true_node
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|2
index|]
operator|=
name|inverted
expr_stmt|;
name|edge_info
operator|->
name|cond_equivalences
index|[
literal|3
index|]
operator|=
name|boolean_false_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A helper function for record_const_or_copy and record_equality.    Do the work of recording the value and undo info.  */
end_comment

begin_function
specifier|static
name|void
name|record_const_or_copy_1
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|y
parameter_list|,
name|tree
name|prev_x
parameter_list|)
block|{
name|SSA_NAME_VALUE
argument_list|(
name|x
argument_list|)
operator|=
name|y
expr_stmt|;
name|VEC_reserve
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|const_and_copies_stack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|const_and_copies_stack
argument_list|,
name|prev_x
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|const_and_copies_stack
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the loop depth of the basic block of the defining statement of X.    This number should not be treated as absolutely correct because the loop    information may not be completely up-to-date when dom runs.  However, it    will be relatively correct, and as more passes are taught to keep loop info    up to date, the result will become more and more accurate.  */
end_comment

begin_function
name|int
name|loop_depth_of_name
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|defstmt
decl_stmt|;
name|basic_block
name|defbb
decl_stmt|;
comment|/* If it's not an SSA_NAME, we have no clue where the definition is.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
literal|0
return|;
comment|/* Otherwise return the loop depth of the defining statement's bb.      Note that there may not actually be a bb for this statement, if the      ssa_name is live on entry.  */
name|defstmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|defbb
operator|=
name|bb_for_stmt
argument_list|(
name|defstmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defbb
condition|)
return|return
literal|0
return|;
return|return
name|defbb
operator|->
name|loop_depth
return|;
block|}
end_function

begin_comment
comment|/* Record that X is equal to Y in const_and_copies.  Record undo    information in the block-local vector.  */
end_comment

begin_function
specifier|static
name|void
name|record_const_or_copy
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|y
parameter_list|)
block|{
name|tree
name|prev_x
init|=
name|SSA_NAME_VALUE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|tmp
init|=
name|SSA_NAME_VALUE
argument_list|(
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
name|y
operator|=
name|tmp
expr_stmt|;
block|}
name|record_const_or_copy_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|prev_x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, but assume that X and Y are the two operands of an EQ_EXPR.    This constrains the cases in which we may treat this as assignment.  */
end_comment

begin_function
specifier|static
name|void
name|record_equality
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|y
parameter_list|)
block|{
name|tree
name|prev_x
init|=
name|NULL
decl_stmt|,
name|prev_y
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|prev_x
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|prev_y
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* If one of the previous values is invariant, or invariant in more loops      (by depth), then use that.      Otherwise it doesn't matter which value we choose, just so      long as we canonicalize on one value.  */
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|y
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|loop_depth_of_name
argument_list|(
name|x
argument_list|)
operator|<=
name|loop_depth_of_name
argument_list|(
name|y
argument_list|)
operator|)
condition|)
name|prev_x
operator|=
name|x
operator|,
name|x
operator|=
name|y
operator|,
name|y
operator|=
name|prev_x
operator|,
name|prev_x
operator|=
name|prev_y
expr_stmt|;
elseif|else
if|if
condition|(
name|prev_x
operator|&&
name|TREE_INVARIANT
argument_list|(
name|prev_x
argument_list|)
condition|)
name|x
operator|=
name|y
operator|,
name|y
operator|=
name|prev_x
operator|,
name|prev_x
operator|=
name|prev_y
expr_stmt|;
elseif|else
if|if
condition|(
name|prev_y
operator|&&
name|TREE_CODE
argument_list|(
name|prev_y
argument_list|)
operator|!=
name|VALUE_HANDLE
condition|)
name|y
operator|=
name|prev_y
expr_stmt|;
comment|/* After the swapping, we must have one SSA_NAME.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return;
comment|/* For IEEE, -0.0 == 0.0, so we don't necessarily know the sign of a      variable compared against zero.  If we're honoring signed zeros,      then we cannot record this value unless we know that the value is      nonzero.  */
if|if
condition|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|REAL_CST
operator|||
name|REAL_VALUES_EQUAL
argument_list|(
name|dconst0
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|record_const_or_copy_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|prev_x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true when STMT is a simple iv increment.  It detects the    following situation:        i_1 = phi (..., i_2)    i_2 = i_1 +/- ...  */
end_comment

begin_function
specifier|static
name|bool
name|simple_iv_increment_p
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|preinc
decl_stmt|,
name|phi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|MINUS_EXPR
condition|)
return|return
name|false
return|;
name|preinc
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|preinc
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|phi
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|preinc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|!=
name|PHI_NODE
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|==
name|lhs
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* CONST_AND_COPIES is a table which maps an SSA_NAME to the current    known value for that SSA_NAME (or NULL if no value is known).       Propagate values from CONST_AND_COPIES into the PHI nodes of the    successors of BB.  */
end_comment

begin_function
specifier|static
name|void
name|cprop_into_successor_phis
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|int
name|indx
decl_stmt|;
comment|/* If this is an abnormal edge, then we do not want to copy propagate 	 into the PHI alternative associated with this edge.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
continue|continue;
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phi
condition|)
continue|continue;
name|indx
operator|=
name|e
operator|->
name|dest_idx
expr_stmt|;
for|for
control|(
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|new
decl_stmt|;
name|use_operand_p
name|orig_p
decl_stmt|;
name|tree
name|orig
decl_stmt|;
comment|/* The alternative may be associated with a constant, so verify 	     it is an SSA_NAME before doing anything with it.  */
name|orig_p
operator|=
name|PHI_ARG_DEF_PTR
argument_list|(
name|phi
argument_list|,
name|indx
argument_list|)
expr_stmt|;
name|orig
operator|=
name|USE_FROM_PTR
argument_list|(
name|orig_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
comment|/* If we have *ORIG_P in our constant/copy table, then replace 	     ORIG_P with its value in our constant/copy table.  */
name|new
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&&
name|new
operator|!=
name|orig
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|new
argument_list|)
operator|)
operator|&&
name|may_propagate_copy
argument_list|(
name|orig
argument_list|,
name|new
argument_list|)
condition|)
name|propagate_value
argument_list|(
name|orig_p
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We have finished optimizing BB, record any information implied by    taking a specific outgoing edge from BB.  */
end_comment

begin_function
specifier|static
name|void
name|record_edge_info
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
name|tree
name|cond
init|=
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|labels
init|=
name|SWITCH_LABELS
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_labels
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|info
init|=
name|XCNEWVEC
argument_list|(
name|tree
argument_list|,
name|last_basic_block
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_labels
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|label
init|=
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|basic_block
name|target_bb
init|=
name|label_to_block
argument_list|(
name|CASE_LABEL
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CASE_HIGH
argument_list|(
name|label
argument_list|)
operator|||
operator|!
name|CASE_LOW
argument_list|(
name|label
argument_list|)
operator|||
name|info
index|[
name|target_bb
operator|->
name|index
index|]
condition|)
name|info
index|[
name|target_bb
operator|->
name|index
index|]
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|info
index|[
name|target_bb
operator|->
name|index
index|]
operator|=
name|label
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|basic_block
name|target_bb
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|tree
name|node
init|=
name|info
index|[
name|target_bb
operator|->
name|index
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
operator|&&
name|node
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|x
init|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|CASE_LOW
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|edge_info
operator|->
name|lhs
operator|=
name|cond
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
name|x
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A COND_EXPR may create equivalences too.  */
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|edge
name|true_edge
decl_stmt|;
name|edge
name|false_edge
decl_stmt|;
name|extract_true_false_edges_from_block
argument_list|(
name|bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* If the conditional is a single variable 'X', record 'X = 1' 	     for the true edge and 'X = 0' on the false edge.  */
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|true_edge
argument_list|)
expr_stmt|;
name|edge_info
operator|->
name|lhs
operator|=
name|cond
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|false_edge
argument_list|)
expr_stmt|;
name|edge_info
operator|->
name|lhs
operator|=
name|cond
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Equality tests may create one or two equivalences.  */
elseif|else
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Special case comparing booleans against a constant as we 		 know the value of OP0 on both arms of the branch.  i.e., we 		 can record an equivalence for OP0 rather than COND.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|)
block|{
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|true_edge
argument_list|)
expr_stmt|;
name|edge_info
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
operator|)
expr_stmt|;
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|false_edge
argument_list|)
expr_stmt|;
name|edge_info
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
operator|)
expr_stmt|;
block|}
else|else
block|{
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|true_edge
argument_list|)
expr_stmt|;
name|edge_info
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
operator|)
expr_stmt|;
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|false_edge
argument_list|)
expr_stmt|;
name|edge_info
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
name|tree
name|inverted
init|=
name|invert_truthvalue
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|true_edge
argument_list|)
expr_stmt|;
name|record_conditions
argument_list|(
name|edge_info
argument_list|,
name|cond
argument_list|,
name|inverted
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|)
block|{
name|edge_info
operator|->
name|lhs
operator|=
name|op1
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
name|op0
expr_stmt|;
block|}
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|false_edge
argument_list|)
expr_stmt|;
name|record_conditions
argument_list|(
name|edge_info
argument_list|,
name|inverted
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
condition|)
block|{
name|edge_info
operator|->
name|lhs
operator|=
name|op1
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
name|op0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
operator|)
condition|)
block|{
name|tree
name|inverted
init|=
name|invert_truthvalue
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|struct
name|edge_info
modifier|*
name|edge_info
decl_stmt|;
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|true_edge
argument_list|)
expr_stmt|;
name|record_conditions
argument_list|(
name|edge_info
argument_list|,
name|cond
argument_list|,
name|inverted
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|)
block|{
name|edge_info
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
name|op1
expr_stmt|;
block|}
name|edge_info
operator|=
name|allocate_edge_info
argument_list|(
name|false_edge
argument_list|)
expr_stmt|;
name|record_conditions
argument_list|(
name|edge_info
argument_list|,
name|inverted
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
condition|)
block|{
name|edge_info
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|edge_info
operator|->
name|rhs
operator|=
name|op1
expr_stmt|;
block|}
block|}
block|}
comment|/* ??? TRUTH_NOT_EXPR can create an equivalence too.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Propagate information from BB to its outgoing edges.     This can include equivalency information implied by control statements    at the end of BB and const/copy propagation into PHIs in BB's    successor blocks.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_to_outgoing_edges
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|record_edge_info
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|cprop_into_successor_phis
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search for redundant computations in STMT.  If any are found, then    replace them with the variable holding the result of the computation.     If safe, record this expression into the available expression hash    table.  */
end_comment

begin_function
specifier|static
name|bool
name|eliminate_redundant_computations
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
modifier|*
name|expr_p
decl_stmt|,
name|def
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|insert
init|=
name|true
decl_stmt|;
name|tree
name|cached_lhs
decl_stmt|;
name|bool
name|retval
init|=
name|false
decl_stmt|;
name|bool
name|modify_expr_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|def
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Certain expressions on the RHS can be optimized away, but can not      themselves be entered into the hash tables.  */
if|if
condition|(
operator|!
name|def
operator|||
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|!=
name|SSA_NAME
operator|||
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|def
argument_list|)
operator|||
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMAYDEF
argument_list|)
comment|/* Do not record equivalences for increments of ivs.  This would create 	 overlapping live ranges for a very questionable gain.  */
operator|||
name|simple_iv_increment_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|insert
operator|=
name|false
expr_stmt|;
comment|/* Check if the expression has been computed before.  */
name|cached_lhs
operator|=
name|lookup_avail_expr
argument_list|(
name|stmt
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|opt_stats
operator|.
name|num_exprs_considered
operator|++
expr_stmt|;
comment|/* Get a pointer to the expression we are trying to optimize.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|expr_p
operator|=
operator|&
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
name|expr_p
operator|=
operator|&
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|expr_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|modify_expr_p
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|expr_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|modify_expr_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* It is safe to ignore types here since we have already done      type checking in the hashing and equality routines.  In fact      type checking here merely gets in the way of constant      propagation.  Also, make sure that it is safe to propagate      CACHED_LHS into *EXPR_P.  */
if|if
condition|(
name|cached_lhs
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|(
name|modify_expr_p
operator|||
name|tree_ssa_useless_type_conversion_1
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|cached_lhs
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
name|may_propagate_copy
argument_list|(
operator|*
name|expr_p
argument_list|,
name|cached_lhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Replaced redundant expr '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
operator|*
name|expr_p
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"' with '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|cached_lhs
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
name|opt_stats
operator|.
name|num_re
operator|++
expr_stmt|;
if|#
directive|if
name|defined
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|cached_lhs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|cached_lhs
argument_list|)
operator|)
condition|)
name|retval
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|modify_expr_p
operator|&&
operator|!
name|tree_ssa_useless_type_conversion_1
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|cached_lhs
argument_list|)
argument_list|)
condition|)
name|cached_lhs
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|cached_lhs
argument_list|)
expr_stmt|;
name|propagate_tree_value
argument_list|(
name|expr_p
argument_list|,
name|cached_lhs
argument_list|)
expr_stmt|;
name|mark_stmt_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* STMT, a MODIFY_EXPR, may create certain equivalences, in either    the available expressions table or the const_and_copies table.    Detect and record those equivalences.  */
end_comment

begin_function
specifier|static
name|void
name|record_equivalences_from_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|int
name|may_optimize_p
parameter_list|,
name|stmt_ann_t
name|ann
parameter_list|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|lhs_code
init|=
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|lhs_code
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Strip away any useless type conversions.  */
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* If the RHS of the assignment is a constant or another variable that 	 may be propagated, register it in the CONST_AND_COPIES table.  We 	 do not need to record unwind data for this, since this is a true 	 assignment and not an equivalence inferred from a comparison.  All 	 uses of this ssa name are dominated by this assignment, so unwinding 	 just costs time and space.  */
if|if
condition|(
name|may_optimize_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
name|SSA_NAME_VALUE
argument_list|(
name|lhs
argument_list|)
operator|=
name|rhs
expr_stmt|;
block|}
comment|/* A memory store, even an aliased store, creates a useful      equivalence.  By exchanging the LHS and RHS, creating suitable      vops and recording the result in the available expression table,      we may be able to expose more redundant loads.  */
if|if
condition|(
operator|!
name|ann
operator|->
name|has_volatile_ops
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|new
decl_stmt|;
comment|/* FIXME: If the LHS of the assignment is a bitfield and the RHS          is a constant, we need to adjust the constant to fit into the          type of the LHS.  If the LHS is a bitfield and the RHS is not 	 a constant, then we can not record any equivalences for this 	 statement since we would need to represent the widening or 	 narrowing of RHS.  This fixes gcc.c-torture/execute/921016-1.c 	 and should not be necessary if GCC represented bitfields 	 properly.  */
if|if
condition|(
name|lhs_code
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|widen_bitfield
argument_list|(
name|rhs
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|NULL
expr_stmt|;
comment|/* If the value overflowed, then we can not use this equivalence.  */
if|if
condition|(
name|rhs
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rhs
condition|)
block|{
comment|/* Build a new statement with the RHS and LHS exchanged.  */
name|new
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|rhs
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|create_ssa_artficial_load_stmt
argument_list|(
name|new
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|/* Finally enter the statement into the available expression 	     table.  */
name|lookup_avail_expr
argument_list|(
name|new
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace *OP_P in STMT with any known equivalent value for *OP_P from    CONST_AND_COPIES.  */
end_comment

begin_function
specifier|static
name|bool
name|cprop_operand
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|use_operand_p
name|op_p
parameter_list|)
block|{
name|bool
name|may_have_exposed_new_symbols
init|=
name|false
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|tree
name|op
init|=
name|USE_FROM_PTR
argument_list|(
name|op_p
argument_list|)
decl_stmt|;
comment|/* If the operand has a known constant value or it is known to be a      copy of some other variable, use the value or copy stored in      CONST_AND_COPIES.  */
name|val
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|val
operator|!=
name|op
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VALUE_HANDLE
condition|)
block|{
name|tree
name|op_type
decl_stmt|,
name|val_type
decl_stmt|;
comment|/* Do not change the base variable in the virtual operand 	 tables.  That would make it impossible to reconstruct 	 the renamed virtual operand if we later modify this 	 statement.  Also only allow the new value to be an SSA_NAME 	 for propagation into virtual operands.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|SSA_NAME
operator|||
name|is_gimple_reg
argument_list|(
name|val
argument_list|)
operator|||
name|get_virtual_var
argument_list|(
name|val
argument_list|)
operator|!=
name|get_virtual_var
argument_list|(
name|op
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Do not replace hard register operands in asm statements.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
operator|&&
operator|!
name|may_propagate_copy_into_asm
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Get the toplevel type of each operand.  */
name|op_type
operator|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|val_type
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* While both types are pointers, get the type of the object 	 pointed to.  */
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|op_type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|val_type
argument_list|)
condition|)
block|{
name|op_type
operator|=
name|TREE_TYPE
argument_list|(
name|op_type
argument_list|)
expr_stmt|;
name|val_type
operator|=
name|TREE_TYPE
argument_list|(
name|val_type
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure underlying types match before propagating a constant by 	 converting the constant to the proper type.  Note that convert may 	 return a non-gimple expression, in which case we ignore this 	 propagation opportunity.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|op_type
argument_list|,
name|val_type
argument_list|)
condition|)
block|{
name|val
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Certain operands are not allowed to be copy propagated due 	 to their interaction with exception handling and some GCC 	 extensions.  */
elseif|else
if|if
condition|(
operator|!
name|may_propagate_copy
argument_list|(
name|op
argument_list|,
name|val
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Do not propagate copies if the propagated value is at a deeper loop 	 depth than the propagatee.  Otherwise, this may move loop variant 	 variables outside of their loops and prevent coalescing 	 opportunities.  If the value was loop invariant, it will be hoisted 	 by LICM and exposed for copy propagation.  */
if|if
condition|(
name|loop_depth_of_name
argument_list|(
name|val
argument_list|)
operator|>
name|loop_depth_of_name
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Dump details.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Replaced '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|op
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"' with %s '"
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|SSA_NAME
condition|?
literal|"constant"
else|:
literal|"variable"
operator|)
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|val
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If VAL is an ADDR_EXPR or a constant of pointer type, note 	 that we may have exposed a new symbol for SSA renaming.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|may_have_exposed_new_symbols
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|opt_stats
operator|.
name|num_const_prop
operator|++
expr_stmt|;
else|else
name|opt_stats
operator|.
name|num_copy_prop
operator|++
expr_stmt|;
name|propagate_value
argument_list|(
name|op_p
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* And note that we modified this statement.  This is now 	 safe, even if we changed virtual operands since we will 	 rescan the statement and rewrite its operands again.  */
name|mark_stmt_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|may_have_exposed_new_symbols
return|;
block|}
end_function

begin_comment
comment|/* CONST_AND_COPIES is a table which maps an SSA_NAME to the current    known value for that SSA_NAME (or NULL if no value is known).       Propagate values from CONST_AND_COPIES into the uses, vuses and    v_may_def_ops of STMT.  */
end_comment

begin_function
specifier|static
name|bool
name|cprop_into_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|bool
name|may_have_exposed_new_symbols
init|=
name|false
decl_stmt|;
name|use_operand_p
name|op_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|op_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|USE_FROM_PTR
argument_list|(
name|op_p
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|may_have_exposed_new_symbols
operator||=
name|cprop_operand
argument_list|(
name|stmt
argument_list|,
name|op_p
argument_list|)
expr_stmt|;
block|}
return|return
name|may_have_exposed_new_symbols
return|;
block|}
end_function

begin_comment
comment|/* Optimize the statement pointed to by iterator SI.        We try to perform some simplistic global redundancy elimination and    constant propagation:     1- To detect global redundancy, we keep track of expressions that have       been computed in this block and its dominators.  If we find that the       same expression is computed more than once, we eliminate repeated       computations by using the target of the first one.     2- Constant values and copy assignments.  This is used to do very       simplistic constant and copy propagation.  When a constant or copy       assignment is found, we map the value on the RHS of the assignment to       the variable in the LHS in the CONST_AND_COPIES table.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|block_stmt_iterator
name|si
parameter_list|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|old_stmt
decl_stmt|;
name|bool
name|may_optimize_p
decl_stmt|;
name|bool
name|may_have_exposed_new_symbols
init|=
name|false
decl_stmt|;
name|old_stmt
operator|=
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|canonicalize_comparison
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|update_stmt_if_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|opt_stats
operator|.
name|num_stmts
operator|++
expr_stmt|;
name|may_have_exposed_new_symbols
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Optimizing statement "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Const/copy propagate into USES, VUSES and the RHS of V_MAY_DEFs.  */
name|may_have_exposed_new_symbols
operator|=
name|cprop_into_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If the statement has been modified with constant replacements,      fold its RHS before checking for redundant computations.  */
if|if
condition|(
name|ann
operator|->
name|modified
condition|)
block|{
name|tree
name|rhs
decl_stmt|;
comment|/* Try to fold the statement making sure that STMT is kept 	 up to date.  */
if|if
condition|(
name|fold_stmt
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|si
argument_list|)
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Folded to: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
block|}
name|rhs
operator|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Constant/copy propagation above may change the set of  	 virtual operands associated with this statement.  Folding 	 may remove the need for some virtual operands.  	 Indicate we will need to rescan and rewrite the statement.  */
name|may_have_exposed_new_symbols
operator|=
name|true
expr_stmt|;
block|}
comment|/* Check for redundant computations.  Do this optimization only      for assignments that have no volatile ops and conditionals.  */
name|may_optimize_p
operator|=
operator|(
operator|!
name|ann
operator|->
name|has_volatile_ops
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|!
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|may_optimize_p
condition|)
name|may_have_exposed_new_symbols
operator||=
name|eliminate_redundant_computations
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Record any additional equivalences created by this statement.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|record_equivalences_from_stmt
argument_list|(
name|stmt
argument_list|,
name|may_optimize_p
argument_list|,
name|ann
argument_list|)
expr_stmt|;
comment|/* If STMT is a COND_EXPR and it was modified, then we may know      where it goes.  If that is the case, then mark the CFG as altered.       This will cause us to later call remove_unreachable_blocks and      cleanup_tree_cfg when it is safe to do so.  It is not safe to       clean things up here since removal of edges and such can trigger      the removal of PHI nodes, which in turn can release SSA_NAMEs to      the manager.       That's all fine and good, except that once SSA_NAMEs are released      to the manager, we must not call create_ssa_name until all references      to released SSA_NAMEs have been eliminated.       All references to the deleted SSA_NAMEs can not be eliminated until      we remove unreachable blocks.       We can not remove unreachable blocks until after we have completed      any queued jump threading.       We can not complete any queued jump threads until we have taken      appropriate variables out of SSA form.  Taking variables out of      SSA form can call create_ssa_name and thus we lose.       Ultimately I suspect we're going to need to change the interface      into the SSA_NAME manager.  */
if|if
condition|(
name|ann
operator|->
name|modified
condition|)
block|{
name|tree
name|val
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|val
operator|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
name|val
operator|=
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|find_taken_edge
argument_list|(
name|bb
argument_list|,
name|val
argument_list|)
condition|)
name|cfg_altered
operator|=
name|true
expr_stmt|;
comment|/* If we simplified a statement in such a way as to be shown that it 	 cannot trap, update the eh information and the cfg to match.  */
if|if
condition|(
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|old_stmt
argument_list|,
name|stmt
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|need_eh_cleanup
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Flagged to clear EH edges.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|may_have_exposed_new_symbols
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|stmts_to_rescan
argument_list|,
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search for an existing instance of STMT in the AVAIL_EXPRS table.  If    found, return its LHS. Otherwise insert STMT in the table and return    NULL_TREE.     Also, when an expression is first inserted in the AVAIL_EXPRS table, it    is also added to the stack pointed to by BLOCK_AVAIL_EXPRS_P, so that they    can be removed when we finish processing this block and its children.     NOTE: This function assumes that STMT is a MODIFY_EXPR node that    contains no CALL_EXPR on its RHS and makes no volatile nor    aliased references.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_avail_expr
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
name|insert
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|tree
name|lhs
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|struct
name|expr_hash_elt
modifier|*
name|element
init|=
name|XNEW
argument_list|(
expr|struct
name|expr_hash_elt
argument_list|)
decl_stmt|;
name|lhs
operator|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|?
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
else|:
name|NULL
expr_stmt|;
name|initialize_hash_element
argument_list|(
name|stmt
argument_list|,
name|lhs
argument_list|,
name|element
argument_list|)
expr_stmt|;
comment|/* Don't bother remembering constant assignments and copy operations.      Constants and copy operations are handled by the constant/copy propagator      in optimize_stmt.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
operator|->
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|element
operator|->
name|rhs
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Finally try to find the expression in the main expression hash table.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|avail_exprs
argument_list|,
name|element
argument_list|,
name|element
operator|->
name|hash
argument_list|,
operator|(
name|insert
condition|?
name|INSERT
else|:
name|NO_INSERT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|element
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|avail_exprs_stack
argument_list|,
name|stmt
condition|?
name|stmt
else|:
name|element
operator|->
name|rhs
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Extract the LHS of the assignment so that it can be used as the current      definition of another variable.  */
name|lhs
operator|=
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
operator|*
name|slot
operator|)
operator|->
name|lhs
expr_stmt|;
comment|/* See if the LHS appears in the CONST_AND_COPIES table.  If it does, then      use the value from the const_and_copies table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|temp
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|TREE_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VALUE_HANDLE
condition|)
name|lhs
operator|=
name|temp
expr_stmt|;
block|}
name|free
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|lhs
return|;
block|}
end_function

begin_comment
comment|/* Hashing and equality functions for AVAIL_EXPRS.  The table stores    MODIFY_EXPR statements.  We compute a value number for expressions using    the code of the expression and the SSA numbers of its operands.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|avail_expr_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p
operator|)
operator|->
name|stmt
decl_stmt|;
name|tree
name|rhs
init|=
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p
operator|)
operator|->
name|rhs
decl_stmt|;
name|tree
name|vuse
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|hashval_t
name|val
init|=
literal|0
decl_stmt|;
comment|/* iterative_hash_expr knows how to deal with any expression and      deals with commutative operators as well, so just use it instead      of duplicating such complexities here.  */
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|rhs
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* If the hash table entry is not associated with a statement, then we      can just hash the expression and not worry about virtual operands      and such.  */
if|if
condition|(
operator|!
name|stmt
operator|||
operator|!
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|val
return|;
comment|/* Add the SSA version numbers of every vuse operand.  This is important      because compound variables like arrays are not renamed in the      operands.  Rather, the rename is done on the virtual variable      representing all the elements of the array.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vuse
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|vuse
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|real_avail_expr_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p
operator|)
operator|->
name|hash
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|avail_expr_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|tree
name|stmt1
init|=
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p1
operator|)
operator|->
name|stmt
decl_stmt|;
name|tree
name|rhs1
init|=
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p1
operator|)
operator|->
name|rhs
decl_stmt|;
name|tree
name|stmt2
init|=
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p2
operator|)
operator|->
name|stmt
decl_stmt|;
name|tree
name|rhs2
init|=
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p2
operator|)
operator|->
name|rhs
decl_stmt|;
comment|/* If they are the same physical expression, return true.  */
if|if
condition|(
name|rhs1
operator|==
name|rhs2
operator|&&
name|stmt1
operator|==
name|stmt2
condition|)
return|return
name|true
return|;
comment|/* If their codes are not equal, then quit now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|rhs2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* In case of a collision, both RHS have to be identical and have the      same VUSE operands.  */
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|rhs1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|rhs2
argument_list|)
operator|||
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs2
argument_list|)
argument_list|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|rhs1
argument_list|,
name|rhs2
argument_list|,
name|OEP_PURE_SAME
argument_list|)
condition|)
block|{
name|bool
name|ret
init|=
name|compare_ssa_operands_equal
argument_list|(
name|stmt1
argument_list|,
name|stmt2
argument_list|,
name|SSA_OP_VUSE
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ret
operator|||
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p1
operator|)
operator|->
name|hash
operator|==
operator|(
operator|(
expr|struct
name|expr_hash_elt
operator|*
operator|)
name|p2
operator|)
operator|->
name|hash
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* PHI-ONLY copy and constant propagation.  This pass is meant to clean    up degenerate PHIs created by or exposed by jump threading.  */
end_comment

begin_comment
comment|/* Given PHI, return its RHS if the PHI is a degenerate, otherwise return    NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|degenerate_phi_result
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|tree
name|lhs
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Ignoring arguments which are the same as LHS, if all the remaining      arguments are the same, then the PHI is a degenerate and has the      value of that common argument.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|lhs
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|val
condition|)
name|val
operator|=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|==
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|?
name|val
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a tree node T, which is either a PHI_NODE or MODIFY_EXPR,    remove it from the IL.  */
end_comment

begin_function
specifier|static
name|void
name|remove_stmt_or_phi
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
name|remove_phi_node
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a tree node T, which is either a PHI_NODE or MODIFY_EXPR,    return the "rhs" of the node, in the case of a non-degenerate    PHI, NULL is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|get_rhs_or_phi_arg
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return
name|degenerate_phi_result
argument_list|(
name|t
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tree node T, which is either a PHI_NODE or a MODIFY_EXPR,    return the "lhs" of the node.  */
end_comment

begin_function
specifier|static
name|tree
name|get_lhs_or_phi_result
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Propagate RHS into all uses of LHS (when possible).     RHS and LHS are derived from STMT, which is passed in solely so    that we can remove it if propagation is successful.     When propagating into a PHI node or into a statement which turns    into a trivial copy or constant initialization, set the    appropriate bit in INTERESTING_NAMEs so that we will visit those    nodes as well in an effort to pick up secondary optimization    opportunities.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_rhs_into_lhs
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|bitmap
name|interesting_names
parameter_list|)
block|{
comment|/* First verify that propagation is valid and isn't going to move a      loop variant variable outside its loop.  */
if|if
condition|(
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|lhs
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|rhs
argument_list|)
operator|)
operator|&&
name|may_propagate_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|&&
name|loop_depth_of_name
argument_list|(
name|lhs
argument_list|)
operator|>=
name|loop_depth_of_name
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|use_operand_p
name|use_p
decl_stmt|;
name|imm_use_iterator
name|iter
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|;
name|bool
name|all
init|=
name|true
decl_stmt|;
comment|/* Dump details.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Replacing '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|lhs
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"' with %s '"
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|SSA_NAME
condition|?
literal|"constant"
else|:
literal|"variable"
operator|)
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|rhs
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Walk over every use of LHS and try to replace the use with RHS.  	 At this point the only reason why such a propagation would not 	 be successful would be if the use occurs in an ASM_EXPR.  */
name|FOR_EACH_IMM_USE_STMT
argument_list|(
argument|use_stmt
argument_list|,
argument|iter
argument_list|,
argument|lhs
argument_list|)
block|{
comment|/* It's not always safe to propagate into an ASM_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|ASM_EXPR
operator|&&
operator|!
name|may_propagate_copy_into_asm
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|all
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
comment|/* Dump details.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"    Original statement:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|use_stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate the RHS into this use of the LHS.  */
name|FOR_EACH_IMM_USE_ON_STMT
argument_list|(
argument|use_p
argument_list|,
argument|iter
argument_list|)
name|propagate_value
argument_list|(
name|use_p
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* Special cases to avoid useless calls into the folding 	     routines, operand scanning, etc.  	     First, propagation into a PHI may cause the PHI to become 	     a degenerate, so mark the PHI as interesting.  No other 	     actions are necessary.  	     Second, if we're propagating a virtual operand and the 	     propagation does not change the underlying _DECL node for 	     the virtual operand, then no further actions are necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|PHI_NODE
operator|||
operator|(
operator|!
name|is_gimple_reg
argument_list|(
name|lhs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_VAR
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME_VAR
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
comment|/* Dump details.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"    Updated statement:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|use_stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Propagation into a PHI may expose new degenerate PHIs, 		 so mark the result of the PHI as interesting.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|tree
name|result
init|=
name|get_lhs_or_phi_result
argument_list|(
name|use_stmt
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|interesting_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* From this point onward we are propagating into a  	     real statement.  Folding may (or may not) be possible, 	     we may expose new operands, expose dead EH edges, 	     etc.  */
name|fold_stmt_inplace
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
comment|/* Sometimes propagation can expose new operands to the 	     renamer.  Note this will call update_stmt at the  	     appropriate time.  */
name|mark_new_vars_to_rename
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
comment|/* Dump details.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"    Updated statement:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|use_stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If we replaced a variable index with a constant, then 	     we would need to update the invariant flag for ADDR_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we cleaned up EH information from the statement, 	     mark its containing block as needing EH cleanups.  */
if|if
condition|(
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|use_stmt
argument_list|,
name|use_stmt
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|need_eh_cleanup
argument_list|,
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Flagged to clear EH edges.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Propagation may expose new trivial copy/constant propagation 	     opportunities.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|result
init|=
name|get_lhs_or_phi_result
argument_list|(
name|use_stmt
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|interesting_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Propagation into these nodes may make certain edges in 	     the CFG unexecutable.  We want to identify them as PHI nodes 	     at the destination of those unexecutable edges may become 	     degenerates.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|SWITCH_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|GOTO_EXPR
condition|)
block|{
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|val
operator|=
name|COND_EXPR_COND
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
name|val
operator|=
name|SWITCH_COND
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|GOTO_DESTINATION
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
decl_stmt|;
name|edge
name|te
init|=
name|find_taken_edge
argument_list|(
name|bb
argument_list|,
name|val
argument_list|)
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* Remove all outgoing edges except TE.  */
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|!=
name|te
condition|)
block|{
name|tree
name|phi
decl_stmt|;
comment|/* Mark all the PHI nodes at the destination of 			     the unexecutable edge as interesting.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|result
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|int
name|version
init|=
name|SSA_NAME_VERSION
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|interesting_names
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
name|te
operator|->
name|probability
operator|+=
name|e
operator|->
name|probability
expr_stmt|;
name|te
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|cfg_altered
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* And fixup the flags on the single remaining edge.  */
name|te
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
expr_stmt|;
name|te
operator|->
name|flags
operator|&=
operator|~
name|EDGE_ABNORMAL
expr_stmt|;
name|te
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|probability
operator|>
name|REG_BR_PROB_BASE
condition|)
name|te
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
block|}
block|}
comment|/* Ensure there is nothing else to do. */
name|gcc_assert
argument_list|(
operator|!
name|all
operator|||
name|has_zero_uses
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we were able to propagate away all uses of LHS, then 	 we can remove STMT.  */
if|if
condition|(
name|all
condition|)
name|remove_stmt_or_phi
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* T is either a PHI node (potentially a degenerate PHI node) or    a statement that is a trivial copy or constant initialization.     Attempt to eliminate T by propagating its RHS into all uses of    its LHS.  This may in turn set new bits in INTERESTING_NAMES    for nodes we want to revisit later.     All exit paths should clear INTERESTING_NAMES for the result    of T.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_const_or_copy
parameter_list|(
name|tree
name|t
parameter_list|,
name|bitmap
name|interesting_names
parameter_list|)
block|{
name|tree
name|lhs
init|=
name|get_lhs_or_phi_result
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|int
name|version
init|=
name|SSA_NAME_VERSION
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
comment|/* If the LHS of this statement or PHI has no uses, then we can      just eliminate it.  This can occur if, for example, the PHI      was created by block duplication due to threading and its only      use was in the conditional at the end of the block which was      deleted.  */
if|if
condition|(
name|has_zero_uses
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|interesting_names
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|remove_stmt_or_phi
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the RHS of the assignment or PHI node if the PHI is a      degenerate.  */
name|rhs
operator|=
name|get_rhs_or_phi_arg
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rhs
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|interesting_names
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return;
block|}
name|propagate_rhs_into_lhs
argument_list|(
name|t
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|interesting_names
argument_list|)
expr_stmt|;
comment|/* Note that T may well have been deleted by now, so do      not access it, instead use the saved version # to clear      T's entry in the worklist.  */
name|bitmap_clear_bit
argument_list|(
name|interesting_names
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The first phase in degenerate PHI elimination.     Eliminate the degenerate PHIs in BB, then recurse on the    dominator children of BB.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_degenerate_phis_1
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bitmap
name|interesting_names
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|next
decl_stmt|;
name|basic_block
name|son
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|next
control|)
block|{
name|next
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|eliminate_const_or_copy
argument_list|(
name|phi
argument_list|,
name|interesting_names
argument_list|)
expr_stmt|;
block|}
comment|/* Recurse into the dominator children of BB.  */
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|eliminate_degenerate_phis_1
argument_list|(
name|son
argument_list|,
name|interesting_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A very simple pass to eliminate degenerate PHI nodes from the    IL.  This is meant to be fast enough to be able to be run several    times in the optimization pipeline.     Certain optimizations, particularly those which duplicate blocks    or remove edges from the CFG can create or expose PHIs which are    trivial copies or constant initializations.     While we could pick up these optimizations in DOM or with the    combination of copy-prop and CCP, those solutions are far too    heavy-weight for our needs.     This implementation has two phases so that we can efficiently    eliminate the first order degenerate PHIs and second order    degenerate PHIs.     The first phase performs a dominator walk to identify and eliminate    the vast majority of the degenerate PHIs.  When a degenerate PHI    is identified and eliminated any affected statements or PHIs    are put on a worklist.     The second phase eliminates degenerate PHIs and trivial copies    or constant initializations using the worklist.  This is how we    pick up the secondary optimization opportunities with minimal    cost.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|eliminate_degenerate_phis
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap
name|interesting_names
decl_stmt|;
name|bitmap
name|interesting_names1
decl_stmt|;
comment|/* Bitmap of blocks which need EH information updated.  We can not      update it on-the-fly as doing so invalidates the dominator tree.  */
name|need_eh_cleanup
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* INTERESTING_NAMES is effectively our worklist, indexed by      SSA_NAME_VERSION.       A set bit indicates that the statement or PHI node which      defines the SSA_NAME should be (re)examined to determine if      it has become a degenerate PHI or trivial const/copy propagation      opportunity.        Experiments have show we generally get better compilation      time behavior with bitmaps rather than sbitmaps.  */
name|interesting_names
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|interesting_names1
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* First phase.  Eliminate degenerate PHIs via a dominator      walk of the CFG.       Experiments have indicated that we generally get better      compile-time behavior by visiting blocks in the first      phase in dominator order.  Presumably this is because walking      in dominator order leaves fewer PHIs for later examination      by the worklist phase.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|eliminate_degenerate_phis_1
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|interesting_names
argument_list|)
expr_stmt|;
comment|/* Second phase.  Eliminate second order degenerate PHIs as well      as trivial copies or constant initializations identified by      the first phase or this phase.  Basically we keep iterating      until our set of INTERESTING_NAMEs is empty.   */
while|while
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|interesting_names
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* EXECUTE_IF_SET_IN_BITMAP does not like its bitmap 	 changed during the loop.  Copy it to another bitmap and 	 use that.  */
name|bitmap_copy
argument_list|(
name|interesting_names1
argument_list|,
name|interesting_names
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|interesting_names1
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Ignore SSA_NAMEs that have been released because 	     their defining statement was deleted (unreachable).  */
if|if
condition|(
name|name
condition|)
name|eliminate_const_or_copy
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|interesting_names
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Propagation of const and copies may make some EH edges dead.  Purge      such edges from the CFG as needed.  */
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|need_eh_cleanup
argument_list|)
condition|)
block|{
name|cfg_altered
operator||=
name|tree_purge_all_dead_eh_edges
argument_list|(
name|need_eh_cleanup
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|need_eh_cleanup
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|interesting_names
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|interesting_names1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_altered
condition|)
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_phi_only_cprop
init|=
block|{
literal|"phicprop"
block|,
comment|/* name */
name|gate_dominator
block|,
comment|/* gate */
name|eliminate_degenerate_phis
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_PHI_CPROP
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_cleanup_cfg
operator||
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_verify_stmts
operator||
name|TODO_update_smt_usage
operator||
name|TODO_update_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

