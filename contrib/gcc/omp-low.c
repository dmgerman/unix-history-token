begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lowering pass for OpenMP directives.  Converts OpenMP directives    into explicit calls to the runtime library (libgomp) and data    marshalling to implement data sharing and copying clauses.    Contributed by Diego Novillo<dnovillo@redhat.com>     Copyright (C) 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* Lowering of OpenMP parallel and workshare constructs proceeds in two     phases.  The first phase scans the function looking for OMP statements    and then for variables that must be replaced to satisfy data sharing    clauses.  The second phase expands code for the constructs, as well as    re-gimplifying things when variables have been replaced with complex    expressions.     Final code generation is done by pass_expand_omp.  The flowgraph is    scanned for parallel regions which are then moved to a new    function, to be invoked by the thread library.  */
end_comment

begin_comment
comment|/* Context structure.  Used to store information about each parallel    directive in the code.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|omp_context
block|{
comment|/* This field must be at the beginning, as we do "inheritance": Some      callback functions for tree-inline.c (e.g., omp_copy_decl)      receive a copy_body_data pointer that is up-casted to an      omp_context pointer.  */
name|copy_body_data
name|cb
decl_stmt|;
comment|/* The tree of contexts corresponding to the encountered constructs.  */
name|struct
name|omp_context
modifier|*
name|outer
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
comment|/* Map variables to fields in a structure that allows communication       between sending and receiving threads.  */
name|splay_tree
name|field_map
decl_stmt|;
name|tree
name|record_type
decl_stmt|;
name|tree
name|sender_decl
decl_stmt|;
name|tree
name|receiver_decl
decl_stmt|;
comment|/* A chain of variables to add to the top-level block surrounding the      construct.  In the case of a parallel, this is in the child function.  */
name|tree
name|block_vars
decl_stmt|;
comment|/* What to do with variables with implicitly determined sharing      attributes.  */
name|enum
name|omp_clause_default_kind
name|default_kind
decl_stmt|;
comment|/* Nesting depth of this context.  Used to beautify error messages re      invalid gotos.  The outermost ctx is depth 1, with depth 0 being      reserved for the main body of the function.  */
name|int
name|depth
decl_stmt|;
comment|/* True if this parallel directive is nested within another.  */
name|bool
name|is_nested
decl_stmt|;
block|}
name|omp_context
typedef|;
end_typedef

begin_comment
comment|/* A structure describing the main elements of a parallel loop.  */
end_comment

begin_struct
struct|struct
name|omp_for_data
block|{
name|tree
name|v
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|step
decl_stmt|,
name|chunk_size
decl_stmt|,
name|for_stmt
decl_stmt|;
name|enum
name|tree_code
name|cond_code
decl_stmt|;
name|tree
name|pre
decl_stmt|;
name|bool
name|have_nowait
decl_stmt|,
name|have_ordered
decl_stmt|;
name|enum
name|omp_clause_schedule_kind
name|sched_kind
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|splay_tree
name|all_contexts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parallel_nesting_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|omp_region
modifier|*
name|root_omp_region
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|scan_omp
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|omp_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lower_omp
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|omp_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_decl_in_outer_ctx
parameter_list|(
name|tree
parameter_list|,
name|omp_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|maybe_lookup_decl_in_outer_ctx
parameter_list|(
name|tree
parameter_list|,
name|omp_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Find an OpenMP clause of type KIND within CLAUSES.  */
end_comment

begin_function
specifier|static
name|tree
name|find_omp_clause
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|enum
name|omp_clause_code
name|kind
parameter_list|)
block|{
for|for
control|(
init|;
name|clauses
condition|;
name|clauses
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clauses
argument_list|)
control|)
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|clauses
argument_list|)
operator|==
name|kind
condition|)
return|return
name|clauses
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return true if CTX is for an omp parallel.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_parallel_ctx
parameter_list|(
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|TREE_CODE
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
operator|==
name|OMP_PARALLEL
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGION is a combined parallel+workshare region.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_combined_parallel
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
return|return
name|region
operator|->
name|is_combined_parallel
return|;
block|}
end_function

begin_comment
comment|/* Extract the header elements of parallel loop FOR_STMT and store    them into *FD.  */
end_comment

begin_function
specifier|static
name|void
name|extract_omp_for_data
parameter_list|(
name|tree
name|for_stmt
parameter_list|,
name|struct
name|omp_for_data
modifier|*
name|fd
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|fd
operator|->
name|for_stmt
operator|=
name|for_stmt
expr_stmt|;
name|fd
operator|->
name|pre
operator|=
name|NULL
expr_stmt|;
name|t
operator|=
name|OMP_FOR_INIT
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|fd
operator|->
name|v
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|fd
operator|->
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|v
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
argument_list|)
expr_stmt|;
name|fd
operator|->
name|n1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|OMP_FOR_COND
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
name|fd
operator|->
name|cond_code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|fd
operator|->
name|v
argument_list|)
expr_stmt|;
name|fd
operator|->
name|n2
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fd
operator|->
name|cond_code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
break|break;
case|case
name|LE_EXPR
case|:
name|fd
operator|->
name|n2
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|n2
argument_list|)
argument_list|,
name|fd
operator|->
name|n2
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|n2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|->
name|cond_code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|fd
operator|->
name|n2
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|n2
argument_list|)
argument_list|,
name|fd
operator|->
name|n2
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|n2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|->
name|cond_code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|t
operator|=
name|OMP_FOR_INCR
argument_list|(
name|fd
operator|->
name|for_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|fd
operator|->
name|v
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|fd
operator|->
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|fd
operator|->
name|step
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|fd
operator|->
name|step
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fd
operator|->
name|step
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|step
argument_list|)
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fd
operator|->
name|have_nowait
operator|=
name|fd
operator|->
name|have_ordered
operator|=
name|false
expr_stmt|;
name|fd
operator|->
name|sched_kind
operator|=
name|OMP_CLAUSE_SCHEDULE_STATIC
expr_stmt|;
name|fd
operator|->
name|chunk_size
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|OMP_FOR_CLAUSES
argument_list|(
name|for_stmt
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_NOWAIT
case|:
name|fd
operator|->
name|have_nowait
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_ORDERED
case|:
name|fd
operator|->
name|have_ordered
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
name|fd
operator|->
name|sched_kind
operator|=
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|fd
operator|->
name|chunk_size
operator|=
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|fd
operator|->
name|sched_kind
operator|==
name|OMP_CLAUSE_SCHEDULE_RUNTIME
condition|)
name|gcc_assert
argument_list|(
name|fd
operator|->
name|chunk_size
operator|==
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|->
name|chunk_size
operator|==
name|NULL
condition|)
block|{
comment|/* We only need to compute a default chunk size for ordered 	 static loops and dynamic loops.  */
if|if
condition|(
name|fd
operator|->
name|sched_kind
operator|!=
name|OMP_CLAUSE_SCHEDULE_STATIC
operator|||
name|fd
operator|->
name|have_ordered
condition|)
name|fd
operator|->
name|chunk_size
operator|=
operator|(
name|fd
operator|->
name|sched_kind
operator|==
name|OMP_CLAUSE_SCHEDULE_STATIC
operator|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given two blocks PAR_ENTRY_BB and WS_ENTRY_BB such that WS_ENTRY_BB    is the immediate dominator of PAR_ENTRY_BB, return true if there    are no data dependencies that would prevent expanding the parallel    directive at PAR_ENTRY_BB as a combined parallel+workshare region.     When expanding a combined parallel+workshare region, the call to    the child function may need additional arguments in the case of    OMP_FOR regions.  In some cases, these arguments are computed out    of variables passed in from the parent to the child via 'struct    .omp_data_s'.  For instance:  	#pragma omp parallel for schedule (guided, i * 4) 	for (j ...)     Is lowered into:     	# BLOCK 2 (PAR_ENTRY_BB) 	.omp_data_o.i = i; 	#pragma omp parallel [child fn: bar.omp_fn.0 ( ..., D.1598) 	 	# BLOCK 3 (WS_ENTRY_BB) 	.omp_data_i =&.omp_data_o; 	D.1667 = .omp_data_i->i; 	D.1598 = D.1667 * 4; 	#pragma omp for schedule (guided, D.1598)     When we outline the parallel region, the call to the child function    'bar.omp_fn.0' will need the value D.1598 in its argument list, but    that value is computed *after* the call site.  So, in principle we    cannot do the transformation.     To see whether the code in WS_ENTRY_BB blocks the combined    parallel+workshare call, we collect all the variables used in the    OMP_FOR header check whether they appear on the LHS of any    statement in WS_ENTRY_BB.  If so, then we cannot emit the combined    call.     FIXME.  If we had the SSA form built at this point, we could merely    hoist the code in block 3 into block 2 and be done with it.  But at    this point we don't have dataflow information and though we could    hack something up here, it is really not worth the aggravation.  */
end_comment

begin_function
specifier|static
name|bool
name|workshare_safe_to_combine_p
parameter_list|(
name|basic_block
name|par_entry_bb
parameter_list|,
name|basic_block
name|ws_entry_bb
parameter_list|)
block|{
name|struct
name|omp_for_data
name|fd
decl_stmt|;
name|tree
name|par_stmt
decl_stmt|,
name|ws_stmt
decl_stmt|;
name|par_stmt
operator|=
name|last_stmt
argument_list|(
name|par_entry_bb
argument_list|)
expr_stmt|;
name|ws_stmt
operator|=
name|last_stmt
argument_list|(
name|ws_entry_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ws_stmt
argument_list|)
operator|==
name|OMP_SECTIONS
condition|)
return|return
name|true
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ws_stmt
argument_list|)
operator|==
name|OMP_FOR
argument_list|)
expr_stmt|;
name|extract_omp_for_data
argument_list|(
name|ws_stmt
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
comment|/* FIXME.  We give up too easily here.  If any of these arguments      are not constants, they will likely involve variables that have      been mapped into fields of .omp_data_s for sharing with the child      function.  With appropriate data flow, it would be possible to      see through this.  */
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|fd
operator|.
name|n1
argument_list|)
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|fd
operator|.
name|n2
argument_list|)
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|fd
operator|.
name|step
argument_list|)
operator|||
operator|(
name|fd
operator|.
name|chunk_size
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|fd
operator|.
name|chunk_size
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Collect additional arguments needed to emit a combined    parallel+workshare call.  WS_STMT is the workshare directive being    expanded.  */
end_comment

begin_function
specifier|static
name|tree
name|get_ws_args_for
parameter_list|(
name|tree
name|ws_stmt
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ws_stmt
argument_list|)
operator|==
name|OMP_FOR
condition|)
block|{
name|struct
name|omp_for_data
name|fd
decl_stmt|;
name|tree
name|ws_args
decl_stmt|;
name|extract_omp_for_data
argument_list|(
name|ws_stmt
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|ws_args
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fd
operator|.
name|chunk_size
condition|)
block|{
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|.
name|chunk_size
argument_list|)
expr_stmt|;
name|ws_args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|ws_args
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|.
name|step
argument_list|)
expr_stmt|;
name|ws_args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|ws_args
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|.
name|n2
argument_list|)
expr_stmt|;
name|ws_args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|ws_args
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|.
name|n1
argument_list|)
expr_stmt|;
name|ws_args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|ws_args
argument_list|)
expr_stmt|;
return|return
name|ws_args
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ws_stmt
argument_list|)
operator|==
name|OMP_SECTIONS
condition|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|ws_stmt
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discover whether REGION is a combined parallel+workshare region.  */
end_comment

begin_function
specifier|static
name|void
name|determine_parallel_type
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|basic_block
name|par_entry_bb
decl_stmt|,
name|par_exit_bb
decl_stmt|;
name|basic_block
name|ws_entry_bb
decl_stmt|,
name|ws_exit_bb
decl_stmt|;
if|if
condition|(
name|region
operator|==
name|NULL
operator|||
name|region
operator|->
name|inner
operator|==
name|NULL
operator|||
name|region
operator|->
name|exit
operator|==
name|NULL
operator|||
name|region
operator|->
name|inner
operator|->
name|exit
operator|==
name|NULL
condition|)
return|return;
comment|/* We only support parallel+for and parallel+sections.  */
if|if
condition|(
name|region
operator|->
name|type
operator|!=
name|OMP_PARALLEL
operator|||
operator|(
name|region
operator|->
name|inner
operator|->
name|type
operator|!=
name|OMP_FOR
operator|&&
name|region
operator|->
name|inner
operator|->
name|type
operator|!=
name|OMP_SECTIONS
operator|)
condition|)
return|return;
comment|/* Check for perfect nesting PAR_ENTRY_BB -> WS_ENTRY_BB and      WS_EXIT_BB -> PAR_EXIT_BB.  */
name|par_entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|par_exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
name|ws_entry_bb
operator|=
name|region
operator|->
name|inner
operator|->
name|entry
expr_stmt|;
name|ws_exit_bb
operator|=
name|region
operator|->
name|inner
operator|->
name|exit
expr_stmt|;
if|if
condition|(
name|single_succ
argument_list|(
name|par_entry_bb
argument_list|)
operator|==
name|ws_entry_bb
operator|&&
name|single_succ
argument_list|(
name|ws_exit_bb
argument_list|)
operator|==
name|par_exit_bb
operator|&&
name|workshare_safe_to_combine_p
argument_list|(
name|par_entry_bb
argument_list|,
name|ws_entry_bb
argument_list|)
operator|&&
operator|(
name|OMP_PARALLEL_COMBINED
argument_list|(
name|last_stmt
argument_list|(
name|par_entry_bb
argument_list|)
argument_list|)
operator|||
operator|(
name|last_and_only_stmt
argument_list|(
name|ws_entry_bb
argument_list|)
operator|&&
name|last_and_only_stmt
argument_list|(
name|par_exit_bb
argument_list|)
operator|)
operator|)
condition|)
block|{
name|tree
name|ws_stmt
init|=
name|last_stmt
argument_list|(
name|ws_entry_bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|inner
operator|->
name|type
operator|==
name|OMP_FOR
condition|)
block|{
comment|/* If this is a combined parallel loop, we need to determine 	     whether or not to use the combined library calls.  There 	     are two cases where we do not apply the transformation: 	     static loops and any kind of ordered loop.  In the first 	     case, we already open code the loop so there is no need 	     to do anything else.  In the latter case, the combined 	     parallel loop call would still need extra synchronization 	     to implement ordered semantics, so there would not be any 	     gain in using the combined call.  */
name|tree
name|clauses
init|=
name|OMP_FOR_CLAUSES
argument_list|(
name|ws_stmt
argument_list|)
decl_stmt|;
name|tree
name|c
init|=
name|find_omp_clause
argument_list|(
name|clauses
argument_list|,
name|OMP_CLAUSE_SCHEDULE
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_SCHEDULE_STATIC
operator|||
name|find_omp_clause
argument_list|(
name|clauses
argument_list|,
name|OMP_CLAUSE_ORDERED
argument_list|)
condition|)
block|{
name|region
operator|->
name|is_combined_parallel
operator|=
name|false
expr_stmt|;
name|region
operator|->
name|inner
operator|->
name|is_combined_parallel
operator|=
name|false
expr_stmt|;
return|return;
block|}
block|}
name|region
operator|->
name|is_combined_parallel
operator|=
name|true
expr_stmt|;
name|region
operator|->
name|inner
operator|->
name|is_combined_parallel
operator|=
name|true
expr_stmt|;
name|region
operator|->
name|ws_args
operator|=
name|get_ws_args_for
argument_list|(
name|ws_stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if EXPR is variable sized.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_variable_sized
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if DECL is a reference type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_reference
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_privatize_by_reference
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup variables in the decl or field splay trees.  The "maybe" form    allows for the variable form to not have been entered, otherwise we    assert that the variable must have been entered.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|lookup_decl
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|cb
operator|.
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|var
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree
operator|)
name|n
operator|->
name|value
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|tree
name|maybe_lookup_decl
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|cb
operator|.
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|var
argument_list|)
expr_stmt|;
return|return
name|n
condition|?
operator|(
name|tree
operator|)
name|n
operator|->
name|value
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|tree
name|lookup_field
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|field_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|var
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree
operator|)
name|n
operator|->
name|value
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|tree
name|maybe_lookup_field
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|field_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|var
argument_list|)
expr_stmt|;
return|return
name|n
condition|?
operator|(
name|tree
operator|)
name|n
operator|->
name|value
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return true if DECL should be copied by pointer.  SHARED_P is true    if DECL is to be shared.  */
end_comment

begin_function
specifier|static
name|bool
name|use_pointer_for_field
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|shared_p
parameter_list|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* We can only use copy-in/copy-out semantics for shared variables      when we know the value is not accessible from an outer scope.  */
if|if
condition|(
name|shared_p
condition|)
block|{
comment|/* ??? Trivially accessible from anywhere.  But why would we even 	 be passing an address in this case?  Should we simply assert 	 this to be false, or should we have a cleanup pass that removes 	 these from the list of mappings?  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* For variables with DECL_HAS_VALUE_EXPR_P set, we cannot tell 	 without analyzing the expression whether or not its location 	 is accessible to anyone else.  In the case of nested parallel 	 regions it certainly may be.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|RESULT_DECL
operator|&&
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Do not use copy-in/copy-out for variables that have their 	 address taken.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Construct a new automatic decl similar to VAR.  */
end_comment

begin_function
specifier|static
name|tree
name|omp_copy_decl_2
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|copy
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_ARTIFICIAL
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_IGNORED_P
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|copy
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|copy
argument_list|)
operator|=
name|ctx
operator|->
name|block_vars
expr_stmt|;
name|ctx
operator|->
name|block_vars
operator|=
name|copy
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|omp_copy_decl_1
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|omp_copy_decl_2
argument_list|(
name|var
argument_list|,
name|DECL_NAME
argument_list|(
name|var
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build tree nodes to access the field for VAR on the receiver side.  */
end_comment

begin_function
specifier|static
name|tree
name|build_receiver_ref
parameter_list|(
name|tree
name|var
parameter_list|,
name|bool
name|by_ref
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|x
decl_stmt|,
name|field
init|=
name|lookup_field
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
comment|/* If the receiver record type was remapped in the child function,      remap the field into the new record type.  */
name|x
operator|=
name|maybe_lookup_field
argument_list|(
name|field
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
name|field
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|build_fold_indirect_ref
argument_list|(
name|ctx
operator|->
name|receiver_decl
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|x
argument_list|,
name|field
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|by_ref
condition|)
name|x
operator|=
name|build_fold_indirect_ref
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Build tree nodes to access VAR in the scope outer to CTX.  In the case    of a parallel, this is a component reference; for workshare constructs    this is some variable.  */
end_comment

begin_function
specifier|static
name|tree
name|build_outer_var_ref
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|is_global_var
argument_list|(
name|maybe_lookup_decl_in_outer_ctx
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
argument_list|)
condition|)
name|x
operator|=
name|var
expr_stmt|;
elseif|else
if|if
condition|(
name|is_variable_sized
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|DECL_VALUE_EXPR
argument_list|(
name|var
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_outer_var_ref
argument_list|(
name|x
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_fold_indirect_ref
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_parallel_ctx
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|bool
name|by_ref
init|=
name|use_pointer_for_field
argument_list|(
name|var
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|x
operator|=
name|build_receiver_ref
argument_list|(
name|var
argument_list|,
name|by_ref
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|outer
condition|)
name|x
operator|=
name|lookup_decl
argument_list|(
name|var
argument_list|,
name|ctx
operator|->
name|outer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_reference
argument_list|(
name|var
argument_list|)
condition|)
comment|/* This can happen with orphaned constructs.  If var is reference, it is        possible it is shared and as such valid.  */
name|x
operator|=
name|var
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_reference
argument_list|(
name|var
argument_list|)
condition|)
name|x
operator|=
name|build_fold_indirect_ref
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Build tree nodes to access the field for VAR on the sender side.  */
end_comment

begin_function
specifier|static
name|tree
name|build_sender_ref
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
return|return
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|ctx
operator|->
name|sender_decl
argument_list|,
name|field
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a new field for VAR inside the structure CTX->SENDER_DECL.  */
end_comment

begin_function
specifier|static
name|void
name|install_var_field
parameter_list|(
name|tree
name|var
parameter_list|,
name|bool
name|by_ref
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|field
decl_stmt|,
name|type
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|field_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|by_ref
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|var
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Remember what variable this field was created for.  This does have a      side effect of making dwarf2out ignore this member, so for helpful      debugging we clear it later in delete_omp_context.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|field
argument_list|)
operator|=
name|var
expr_stmt|;
name|insert_field_into_struct
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|ctx
operator|->
name|field_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|var
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|field
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|install_var_local
parameter_list|(
name|tree
name|var
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|new_var
init|=
name|omp_copy_decl_1
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|insert_decl_map
argument_list|(
operator|&
name|ctx
operator|->
name|cb
argument_list|,
name|var
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
return|return
name|new_var
return|;
block|}
end_function

begin_comment
comment|/* Adjust the replacement for DECL in CTX for the new context.  This means    copying the DECL_VALUE_EXPR, and fixing up the type.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_remapped_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|,
name|bool
name|private_debug
parameter_list|)
block|{
name|tree
name|new_decl
decl_stmt|,
name|size
decl_stmt|;
name|new_decl
operator|=
name|lookup_decl
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|ctx
operator|->
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|new_decl
argument_list|)
argument_list|)
operator|||
name|private_debug
operator|)
operator|&&
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|ve
init|=
name|DECL_VALUE_EXPR
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|walk_tree
argument_list|(
operator|&
name|ve
argument_list|,
name|copy_body_r
argument_list|,
operator|&
name|ctx
operator|->
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|new_decl
argument_list|,
name|ve
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|new_decl
argument_list|)
argument_list|)
condition|)
block|{
name|size
operator|=
name|remap_decl
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|ctx
operator|->
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|size
expr_stmt|;
name|size
operator|=
name|remap_decl
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|ctx
operator|->
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The callback for remap_decl.  Search all containing contexts for a    mapping of the variable; this avoids having to duplicate the splay    tree ahead of time.  We know a mapping doesn't already exist in the    given context.  Create new mappings to implement default semantics.  */
end_comment

begin_function
specifier|static
name|tree
name|omp_copy_decl
parameter_list|(
name|tree
name|var
parameter_list|,
name|copy_body_data
modifier|*
name|cb
parameter_list|)
block|{
name|omp_context
modifier|*
name|ctx
init|=
operator|(
name|omp_context
operator|*
operator|)
name|cb
decl_stmt|;
name|tree
name|new_var
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
name|new_var
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|new_var
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|insert_decl_map
argument_list|(
operator|&
name|ctx
operator|->
name|cb
argument_list|,
name|var
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
return|return
name|new_var
return|;
block|}
while|while
condition|(
operator|!
name|is_parallel_ctx
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|ctx
operator|=
name|ctx
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
name|var
return|;
name|new_var
operator|=
name|maybe_lookup_decl
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_var
condition|)
return|return
name|new_var
return|;
block|}
if|if
condition|(
name|is_global_var
argument_list|(
name|var
argument_list|)
operator|||
name|decl_function_context
argument_list|(
name|var
argument_list|)
operator|!=
name|ctx
operator|->
name|cb
operator|.
name|src_fn
condition|)
return|return
name|var
return|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Return the parallel region associated with STMT.  */
end_comment

begin_comment
comment|/* Debugging dumps for parallel regions.  */
end_comment

begin_function_decl
name|void
name|dump_omp_region
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|omp_region
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_omp_region
parameter_list|(
name|struct
name|omp_region
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_all_omp_regions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dump the parallel region tree rooted at REGION.  */
end_comment

begin_function
name|void
name|dump_omp_region
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|omp_region
modifier|*
name|region
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%*sbb %d: %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|region
operator|->
name|entry
operator|->
name|index
argument_list|,
name|tree_code_name
index|[
name|region
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|inner
condition|)
name|dump_omp_region
argument_list|(
name|file
argument_list|,
name|region
operator|->
name|inner
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|cont
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%*sbb %d: OMP_CONTINUE\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|region
operator|->
name|cont
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|->
name|exit
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%*sbb %d: OMP_RETURN\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|region
operator|->
name|exit
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%*s[no exit marker]\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|next
condition|)
name|dump_omp_region
argument_list|(
name|file
argument_list|,
name|region
operator|->
name|next
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_omp_region
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|dump_omp_region
argument_list|(
name|stderr
argument_list|,
name|region
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_all_omp_regions
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_omp_region
argument_list|(
name|stderr
argument_list|,
name|root_omp_region
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new parallel region starting at STMT inside region PARENT.  */
end_comment

begin_function
name|struct
name|omp_region
modifier|*
name|new_omp_region
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|enum
name|tree_code
name|type
parameter_list|,
name|struct
name|omp_region
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|omp_region
modifier|*
name|region
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|region
argument_list|)
argument_list|)
decl_stmt|;
name|region
operator|->
name|outer
operator|=
name|parent
expr_stmt|;
name|region
operator|->
name|entry
operator|=
name|bb
expr_stmt|;
name|region
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
comment|/* This is a nested region.  Add it to the list of inner 	 regions in PARENT.  */
name|region
operator|->
name|next
operator|=
name|parent
operator|->
name|inner
expr_stmt|;
name|parent
operator|->
name|inner
operator|=
name|region
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a toplevel region.  Add it to the list of toplevel 	 regions in ROOT_OMP_REGION.  */
name|region
operator|->
name|next
operator|=
name|root_omp_region
expr_stmt|;
name|root_omp_region
operator|=
name|region
expr_stmt|;
block|}
return|return
name|region
return|;
block|}
end_function

begin_comment
comment|/* Release the memory associated with the region tree rooted at REGION.  */
end_comment

begin_function
specifier|static
name|void
name|free_omp_region_1
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|omp_region
modifier|*
name|i
decl_stmt|,
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
name|region
operator|->
name|inner
init|;
name|i
condition|;
name|i
operator|=
name|n
control|)
block|{
name|n
operator|=
name|i
operator|->
name|next
expr_stmt|;
name|free_omp_region_1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release the memory for the entire omp region tree.  */
end_comment

begin_function
name|void
name|free_omp_regions
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|omp_region
modifier|*
name|r
decl_stmt|,
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|r
operator|=
name|root_omp_region
init|;
name|r
condition|;
name|r
operator|=
name|n
control|)
block|{
name|n
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|free_omp_region_1
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|root_omp_region
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new context, with OUTER_CTX being the surrounding context.  */
end_comment

begin_function
specifier|static
name|omp_context
modifier|*
name|new_omp_context
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|omp_context
modifier|*
name|outer_ctx
parameter_list|)
block|{
name|omp_context
modifier|*
name|ctx
init|=
name|XCNEW
argument_list|(
name|omp_context
argument_list|)
decl_stmt|;
name|splay_tree_insert
argument_list|(
name|all_contexts
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|stmt
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
if|if
condition|(
name|outer_ctx
condition|)
block|{
name|ctx
operator|->
name|outer
operator|=
name|outer_ctx
expr_stmt|;
name|ctx
operator|->
name|cb
operator|=
name|outer_ctx
operator|->
name|cb
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|block
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|depth
operator|=
name|outer_ctx
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|cb
operator|.
name|src_fn
operator|=
name|current_function_decl
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|dst_fn
operator|=
name|current_function_decl
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|src_node
operator|=
name|cgraph_node
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|dst_node
operator|=
name|ctx
operator|->
name|cb
operator|.
name|src_node
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|src_cfun
operator|=
name|cfun
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|copy_decl
operator|=
name|omp_copy_decl
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|eh_region
operator|=
operator|-
literal|1
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|transform_call_graph_edges
operator|=
name|CB_CGE_MOVE
expr_stmt|;
name|ctx
operator|->
name|depth
operator|=
literal|1
expr_stmt|;
block|}
name|ctx
operator|->
name|cb
operator|.
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/* Destroy a omp_context data structures.  Called through the splay tree    value delete callback.  */
end_comment

begin_function
specifier|static
name|void
name|delete_omp_context
parameter_list|(
name|splay_tree_value
name|value
parameter_list|)
block|{
name|omp_context
modifier|*
name|ctx
init|=
operator|(
name|omp_context
operator|*
operator|)
name|value
decl_stmt|;
name|splay_tree_delete
argument_list|(
name|ctx
operator|->
name|cb
operator|.
name|decl_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|field_map
condition|)
name|splay_tree_delete
argument_list|(
name|ctx
operator|->
name|field_map
argument_list|)
expr_stmt|;
comment|/* We hijacked DECL_ABSTRACT_ORIGIN earlier.  We need to clear it before      it produces corrupt debug information.  */
if|if
condition|(
name|ctx
operator|->
name|record_type
condition|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|XDELETE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up RECEIVER_DECL with a type that has been remapped to the child    context.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_child_record_type
parameter_list|(
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|f
decl_stmt|,
name|type
init|=
name|ctx
operator|->
name|record_type
decl_stmt|;
comment|/* ??? It isn't sufficient to just call remap_type here, because      variably_modified_type_p doesn't work the way we expect for      record types.  Testing each field for whether it needs remapping      and creating a new record by hand works, however.  */
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|,
name|ctx
operator|->
name|cb
operator|.
name|src_fn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|f
condition|)
block|{
name|tree
name|name
decl_stmt|,
name|new_fields
init|=
name|NULL
decl_stmt|;
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
block|{
name|tree
name|new_f
init|=
name|copy_node
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|new_f
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_f
argument_list|)
operator|=
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|ctx
operator|->
name|cb
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new_f
argument_list|)
operator|=
name|new_fields
expr_stmt|;
name|new_fields
operator|=
name|new_f
expr_stmt|;
comment|/* Arrange to be able to look up the receiver field 	     given the sender field.  */
name|splay_tree_insert
argument_list|(
name|ctx
operator|->
name|field_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|f
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|new_f
argument_list|)
expr_stmt|;
block|}
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nreverse
argument_list|(
name|new_fields
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|ctx
operator|->
name|receiver_decl
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Instantiate decls as necessary in CTX to satisfy the data sharing    specified by CLAUSES.  */
end_comment

begin_function
specifier|static
name|void
name|scan_sharing_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|c
decl_stmt|,
name|decl
decl_stmt|;
name|bool
name|scan_array_reductions
init|=
name|false
decl_stmt|;
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
block|{
name|bool
name|by_ref
decl_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_variable_sized
argument_list|(
name|decl
argument_list|)
condition|)
name|install_var_local
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SHARED
case|:
name|gcc_assert
argument_list|(
name|is_parallel_ctx
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|is_variable_sized
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|by_ref
operator|=
name|use_pointer_for_field
argument_list|(
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Global variables don't need to be copied, 	     the receiver side will use them directly.  */
if|if
condition|(
name|is_global_var
argument_list|(
name|maybe_lookup_decl_in_outer_ctx
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|||
name|by_ref
operator|||
name|is_reference
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|install_var_field
argument_list|(
name|decl
argument_list|,
name|by_ref
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|install_var_local
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We don't need to copy const scalar vars back.  */
name|OMP_CLAUSE_SET_CODE
argument_list|(
name|c
argument_list|,
name|OMP_CLAUSE_FIRSTPRIVATE
argument_list|)
expr_stmt|;
goto|goto
name|do_private
goto|;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
comment|/* Let the corresponding firstprivate clause create 	     the variable.  */
if|if
condition|(
name|OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|do_private
label|:
if|if
condition|(
name|is_variable_sized
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|is_parallel_ctx
argument_list|(
name|ctx
argument_list|)
operator|&&
operator|!
name|is_global_var
argument_list|(
name|maybe_lookup_decl_in_outer_ctx
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
argument_list|)
condition|)
block|{
name|by_ref
operator|=
name|use_pointer_for_field
argument_list|(
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|install_var_field
argument_list|(
name|decl
argument_list|,
name|by_ref
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
name|install_var_local
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
if|if
condition|(
name|ctx
operator|->
name|outer
condition|)
name|scan_omp
argument_list|(
operator|&
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
argument_list|,
name|ctx
operator|->
name|outer
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_COPYIN
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|by_ref
operator|=
name|use_pointer_for_field
argument_list|(
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|install_var_field
argument_list|(
name|decl
argument_list|,
name|by_ref
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_DEFAULT
case|:
name|ctx
operator|->
name|default_kind
operator|=
name|OMP_CLAUSE_DEFAULT_KIND
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
if|if
condition|(
name|ctx
operator|->
name|outer
condition|)
name|scan_omp
argument_list|(
operator|&
name|OMP_CLAUSE_OPERAND
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ctx
operator|->
name|outer
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
block|{
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
comment|/* Let the corresponding firstprivate clause create 	     the variable.  */
if|if
condition|(
name|OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_variable_sized
argument_list|(
name|decl
argument_list|)
condition|)
name|install_var_local
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|fixup_remapped_decl
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|,
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_PRIVATE
operator|&&
name|OMP_CLAUSE_PRIVATE_DEBUG
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_REDUCTION
operator|&&
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
condition|)
name|scan_array_reductions
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SHARED
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_global_var
argument_list|(
name|maybe_lookup_decl_in_outer_ctx
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|)
argument_list|)
condition|)
name|fixup_remapped_decl
argument_list|(
name|decl
argument_list|,
name|ctx
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scan_array_reductions
condition|)
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_REDUCTION
operator|&&
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|scan_omp
argument_list|(
operator|&
name|OMP_CLAUSE_REDUCTION_INIT
argument_list|(
name|c
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_CLAUSE_REDUCTION_MERGE
argument_list|(
name|c
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new name for omp child function.  Returns an identifier.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|int
name|tmp_ompfn_id_num
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|create_omp_child_function_name
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|prefix
operator|=
name|alloca
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"_omp_fn"
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|prefix
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prefix
operator|+
name|len
argument_list|,
literal|"_omp_fn"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DOT_IN_LABEL
name|prefix
index|[
name|len
index|]
operator|=
literal|'.'
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
name|NO_DOLLAR_IN_LABEL
name|prefix
index|[
name|len
index|]
operator|=
literal|'$'
expr_stmt|;
endif|#
directive|endif
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|tmp_name
argument_list|,
name|prefix
argument_list|,
name|tmp_ompfn_id_num
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|tmp_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a decl for the omp child function.  It'll not contain a body    yet, just the bare decl.  */
end_comment

begin_function
specifier|static
name|void
name|create_omp_child_function
parameter_list|(
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|name
decl_stmt|,
name|t
decl_stmt|;
name|name
operator|=
name|create_omp_child_function_name
argument_list|()
expr_stmt|;
name|type
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cb
operator|.
name|dst_fn
operator|=
name|decl
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|".omp_data_i"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|ptr_type_node
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|t
expr_stmt|;
name|ctx
operator|->
name|receiver_decl
operator|=
name|t
expr_stmt|;
comment|/* Allocate memory for the function structure.  The call to       allocate_struct_function clobbers CFUN, so we need to restore      it afterward.  */
name|allocate_struct_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|EXPR_LOCATION
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|function_end_locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|cfun
operator|=
name|ctx
operator|->
name|cb
operator|.
name|src_cfun
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan an OpenMP parallel directive.  */
end_comment

begin_function
specifier|static
name|void
name|scan_omp_parallel
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|outer_ctx
parameter_list|)
block|{
name|omp_context
modifier|*
name|ctx
decl_stmt|;
name|tree
name|name
decl_stmt|;
comment|/* Ignore parallel directives with empty bodies, unless there      are copyin clauses.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|empty_body_p
argument_list|(
name|OMP_PARALLEL_BODY
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|)
operator|&&
name|find_omp_clause
argument_list|(
name|OMP_CLAUSES
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|,
name|OMP_CLAUSE_COPYIN
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
return|return;
block|}
name|ctx
operator|=
name|new_omp_context
argument_list|(
operator|*
name|stmt_p
argument_list|,
name|outer_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|parallel_nesting_level
operator|>
literal|1
condition|)
name|ctx
operator|->
name|is_nested
operator|=
name|true
expr_stmt|;
name|ctx
operator|->
name|field_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|default_kind
operator|=
name|OMP_CLAUSE_DEFAULT_SHARED
expr_stmt|;
name|ctx
operator|->
name|record_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|name
operator|=
name|create_tmp_var_name
argument_list|(
literal|".omp_data_s"
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|ctx
operator|->
name|record_type
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
operator|=
name|name
expr_stmt|;
name|create_omp_child_function
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_FN
argument_list|(
operator|*
name|stmt_p
argument_list|)
operator|=
name|ctx
operator|->
name|cb
operator|.
name|dst_fn
expr_stmt|;
name|scan_sharing_clauses
argument_list|(
name|OMP_PARALLEL_CLAUSES
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_PARALLEL_BODY
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|record_type
operator|=
name|ctx
operator|->
name|receiver_decl
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|layout_type
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
expr_stmt|;
name|fixup_child_record_type
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan an OpenMP loop directive.  */
end_comment

begin_function
specifier|static
name|void
name|scan_omp_for
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|outer_ctx
parameter_list|)
block|{
name|omp_context
modifier|*
name|ctx
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|stmt
operator|=
operator|*
name|stmt_p
expr_stmt|;
name|ctx
operator|=
name|new_omp_context
argument_list|(
name|stmt
argument_list|,
name|outer_ctx
argument_list|)
expr_stmt|;
name|scan_sharing_clauses
argument_list|(
name|OMP_FOR_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_FOR_PRE_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_FOR_INIT
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_FOR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_FOR_INCR
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_FOR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan an OpenMP sections directive.  */
end_comment

begin_function
specifier|static
name|void
name|scan_omp_sections
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|outer_ctx
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|omp_context
modifier|*
name|ctx
decl_stmt|;
name|stmt
operator|=
operator|*
name|stmt_p
expr_stmt|;
name|ctx
operator|=
name|new_omp_context
argument_list|(
name|stmt
argument_list|,
name|outer_ctx
argument_list|)
expr_stmt|;
name|scan_sharing_clauses
argument_list|(
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_SECTIONS_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan an OpenMP single directive.  */
end_comment

begin_function
specifier|static
name|void
name|scan_omp_single
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|outer_ctx
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
name|omp_context
modifier|*
name|ctx
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|ctx
operator|=
name|new_omp_context
argument_list|(
name|stmt
argument_list|,
name|outer_ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|field_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|record_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|name
operator|=
name|create_tmp_var_name
argument_list|(
literal|".omp_copy_s"
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|ctx
operator|->
name|record_type
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
operator|=
name|name
expr_stmt|;
name|scan_sharing_clauses
argument_list|(
name|OMP_SINGLE_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_SINGLE_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|record_type
operator|=
name|NULL
expr_stmt|;
else|else
name|layout_type
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check OpenMP nesting restrictions.  */
end_comment

begin_function
specifier|static
name|void
name|check_omp_nesting_restrictions
parameter_list|(
name|tree
name|t
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
for|for
control|(
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|outer
control|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
condition|)
block|{
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_MASTER
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"work-sharing region may not be closely nested inside "
literal|"of work-sharing, critical, ordered or master region"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OMP_PARALLEL
case|:
return|return;
default|default:
break|break;
block|}
break|break;
case|case
name|OMP_MASTER
case|:
for|for
control|(
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|outer
control|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
condition|)
block|{
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"master region may not be closely nested inside "
literal|"of work-sharing region"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OMP_PARALLEL
case|:
return|return;
default|default:
break|break;
block|}
break|break;
case|case
name|OMP_ORDERED
case|:
for|for
control|(
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|outer
control|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
condition|)
block|{
case|case
name|OMP_CRITICAL
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ordered region may not be closely nested inside "
literal|"of critical region"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OMP_FOR
case|:
if|if
condition|(
name|find_omp_clause
argument_list|(
name|OMP_CLAUSES
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
argument_list|,
name|OMP_CLAUSE_ORDERED
argument_list|)
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ordered region must be closely nested inside "
literal|"a loop region with an ordered clause"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OMP_PARALLEL
case|:
return|return;
default|default:
break|break;
block|}
break|break;
case|case
name|OMP_CRITICAL
case|:
for|for
control|(
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|outer
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
operator|==
name|OMP_CRITICAL
operator|&&
name|OMP_CRITICAL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|OMP_CRITICAL_NAME
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"critical region may not be nested inside a critical "
literal|"region with the same name"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Callback for walk_stmts used to scan for OpenMP directives at TP.  */
end_comment

begin_function
specifier|static
name|tree
name|scan_omp_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
name|data
decl_stmt|;
name|omp_context
modifier|*
name|ctx
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|t
argument_list|)
condition|)
name|input_location
operator|=
name|EXPR_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Check the OpenMP nesting restrictions.  */
if|if
condition|(
name|OMP_DIRECTIVE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|ctx
operator|!=
name|NULL
condition|)
name|check_omp_nesting_restrictions
argument_list|(
name|t
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|OMP_PARALLEL
case|:
name|parallel_nesting_level
operator|++
expr_stmt|;
name|scan_omp_parallel
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|parallel_nesting_level
operator|--
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|scan_omp_for
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTIONS
case|:
name|scan_omp_sections
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SINGLE
case|:
name|scan_omp_single
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
name|ctx
operator|=
name|new_omp_context
argument_list|(
operator|*
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|OMP_BODY
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
block|{
name|tree
name|var
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|var
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|t
argument_list|)
init|;
name|var
condition|;
name|var
operator|=
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
control|)
name|insert_decl_map
argument_list|(
operator|&
name|ctx
operator|->
name|cb
argument_list|,
name|var
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|ctx
condition|)
operator|*
name|tp
operator|=
name|remap_decl
argument_list|(
name|t
argument_list|,
operator|&
name|ctx
operator|->
name|cb
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ctx
operator|&&
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|tp
operator|=
name|remap_type
argument_list|(
name|t
argument_list|,
operator|&
name|ctx
operator|->
name|cb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Scan all the statements starting at STMT_P.  CTX contains context    information about the OpenMP directives and clauses found during    the scan.  */
end_comment

begin_function
specifier|static
name|void
name|scan_omp
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|location_t
name|saved_location
decl_stmt|;
name|struct
name|walk_stmt_info
name|wi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|wi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|.
name|callback
operator|=
name|scan_omp_1
expr_stmt|;
name|wi
operator|.
name|info
operator|=
name|ctx
expr_stmt|;
name|wi
operator|.
name|want_bind_expr
operator|=
operator|(
name|ctx
operator|!=
name|NULL
operator|)
expr_stmt|;
name|wi
operator|.
name|want_locations
operator|=
name|true
expr_stmt|;
name|saved_location
operator|=
name|input_location
expr_stmt|;
name|walk_stmts
argument_list|(
operator|&
name|wi
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|saved_location
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Re-gimplification and code generation routines.  */
end_comment

begin_comment
comment|/* Build a call to GOMP_barrier.  */
end_comment

begin_function
specifier|static
name|void
name|build_omp_barrier
parameter_list|(
name|tree
modifier|*
name|stmt_list
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_BARRIER
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If a context was created for STMT when it was scanned, return it.  */
end_comment

begin_function
specifier|static
name|omp_context
modifier|*
name|maybe_lookup_ctx
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|all_contexts
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|stmt
argument_list|)
expr_stmt|;
return|return
name|n
condition|?
operator|(
name|omp_context
operator|*
operator|)
name|n
operator|->
name|value
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find the mapping for DECL in CTX or the immediately enclosing    context that has a mapping for DECL.     If CTX is a nested parallel directive, we may have to use the decl    mappings created in CTX's parent context.  Suppose that we have the    following parallel nesting (variable UIDs showed for clarity):  	iD.1562 = 0;      	#omp parallel shared(iD.1562)		-> outer parallel 	  iD.1562 = iD.1562 + 1;  	  #omp parallel shared (iD.1562)	-> inner parallel 	     iD.1562 = iD.1562 - 1;     Each parallel structure will create a distinct .omp_data_s structure    for copying iD.1562 in/out of the directive:    	outer parallel		.omp_data_s.1.i -> iD.1562 	inner parallel		.omp_data_s.2.i -> iD.1562     A shared variable mapping will produce a copy-out operation before    the parallel directive and a copy-in operation after it.  So, in    this case we would have:    	iD.1562 = 0; 	.omp_data_o.1.i = iD.1562; 	#omp parallel shared(iD.1562)		-> outer parallel 	  .omp_data_i.1 =&.omp_data_o.1 	  .omp_data_i.1->i = .omp_data_i.1->i + 1;  	  .omp_data_o.2.i = iD.1562;		-> ** 	  #omp parallel shared(iD.1562)		-> inner parallel 	    .omp_data_i.2 =&.omp_data_o.2 	    .omp_data_i.2->i = .omp_data_i.2->i - 1;       ** This is a problem.  The symbol iD.1562 cannot be referenced        inside the body of the outer parallel region.  But since we are        emitting this copy operation while expanding the inner parallel        directive, we need to access the CTX structure of the outer        parallel directive to get the correct mapping:  	  .omp_data_o.2.i = .omp_data_i.1->i      Since there may be other workshare or parallel directives enclosing     the parallel directive, it may be necessary to walk up the context     parent chain.  This is not a problem in general because nested     parallelism happens only rarely.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_decl_in_outer_ctx
parameter_list|(
name|tree
name|decl
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|omp_context
modifier|*
name|up
decl_stmt|;
name|gcc_assert
argument_list|(
name|ctx
operator|->
name|is_nested
argument_list|)
expr_stmt|;
for|for
control|(
name|up
operator|=
name|ctx
operator|->
name|outer
operator|,
name|t
operator|=
name|NULL
init|;
name|up
operator|&&
name|t
operator|==
name|NULL
condition|;
name|up
operator|=
name|up
operator|->
name|outer
control|)
name|t
operator|=
name|maybe_lookup_decl
argument_list|(
name|decl
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|t
operator|||
name|is_global_var
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
condition|?
name|t
else|:
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Similar to lookup_decl_in_outer_ctx, but return DECL if not found    in outer contexts.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_lookup_decl_in_outer_ctx
parameter_list|(
name|tree
name|decl
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|t
init|=
name|NULL
decl_stmt|;
name|omp_context
modifier|*
name|up
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|is_nested
condition|)
for|for
control|(
name|up
operator|=
name|ctx
operator|->
name|outer
operator|,
name|t
operator|=
name|NULL
init|;
name|up
operator|&&
name|t
operator|==
name|NULL
condition|;
name|up
operator|=
name|up
operator|->
name|outer
control|)
name|t
operator|=
name|maybe_lookup_decl
argument_list|(
name|decl
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
name|t
condition|?
name|t
else|:
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Construct the initialization value for reduction CLAUSE.  */
end_comment

begin_function
name|tree
name|omp_reduction_init
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|OMP_CLAUSE_REDUCTION_CODE
argument_list|(
name|clause
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|NE_EXPR
case|:
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|EQ_EXPR
case|:
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_minus_one_node
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|max
decl_stmt|,
name|min
decl_stmt|;
if|if
condition|(
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|real_inf
argument_list|(
operator|&
name|max
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|min
argument_list|,
name|NEGATE_EXPR
argument_list|,
operator|&
name|max
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|real_maxval
argument_list|(
operator|&
name|min
argument_list|,
literal|1
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|min
argument_list|)
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
return|;
block|}
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|max
decl_stmt|;
if|if
condition|(
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|real_inf
argument_list|(
operator|&
name|max
argument_list|)
expr_stmt|;
else|else
name|real_maxval
argument_list|(
operator|&
name|max
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|max
argument_list|)
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to implement the input clauses, FIRSTPRIVATE and COPYIN,    from the receiver (aka child) side and initializers for REFERENCE_TYPE    private variables.  Initialization statements go in ILIST, while calls    to destructors go in DLIST.  */
end_comment

begin_function
specifier|static
name|void
name|lower_rec_input_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
modifier|*
name|ilist
parameter_list|,
name|tree
modifier|*
name|dlist
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree_stmt_iterator
name|diter
decl_stmt|;
name|tree
name|c
decl_stmt|,
name|dtor
decl_stmt|,
name|copyin_seq
decl_stmt|,
name|x
decl_stmt|,
name|args
decl_stmt|,
name|ptr
decl_stmt|;
name|bool
name|copyin_by_ref
init|=
name|false
decl_stmt|;
name|bool
name|lastprivate_firstprivate
init|=
name|false
decl_stmt|;
name|int
name|pass
decl_stmt|;
operator|*
name|dlist
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|diter
operator|=
name|tsi_start
argument_list|(
operator|*
name|dlist
argument_list|)
expr_stmt|;
name|copyin_seq
operator|=
name|NULL
expr_stmt|;
comment|/* Do all the fixed sized types in the first pass, and the variable sized      types in the second pass.  This makes sure that the scalar arguments to      the variable sized types are processed before we use them in the       variable sized operations.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
operator|++
name|pass
control|)
block|{
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
block|{
name|enum
name|omp_clause_code
name|c_kind
init|=
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|new_var
decl_stmt|;
name|bool
name|by_ref
decl_stmt|;
switch|switch
condition|(
name|c_kind
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
if|if
condition|(
name|OMP_CLAUSE_PRIVATE_DEBUG
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|OMP_CLAUSE_SHARED
case|:
if|if
condition|(
name|maybe_lookup_decl
argument_list|(
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
argument_list|,
name|ctx
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|gcc_assert
argument_list|(
name|is_global_var
argument_list|(
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
break|break;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
if|if
condition|(
name|OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|lastprivate_firstprivate
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
continue|continue;
block|}
break|break;
default|default:
continue|continue;
block|}
name|new_var
operator|=
name|var
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_kind
operator|!=
name|OMP_CLAUSE_COPYIN
condition|)
name|new_var
operator|=
name|lookup_decl
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_kind
operator|==
name|OMP_CLAUSE_SHARED
operator|||
name|c_kind
operator|==
name|OMP_CLAUSE_COPYIN
condition|)
block|{
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|is_variable_sized
argument_list|(
name|var
argument_list|)
condition|)
block|{
comment|/* For variable sized types, we need to allocate the 		 actual storage here.  Call alloca and store the 		 result in the pointer decl that we created elsewhere.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
continue|continue;
name|ptr
operator|=
name|DECL_VALUE_EXPR
argument_list|(
name|new_var
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|INDIRECT_REF
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|TREE_OPERAND
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_var
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_ALLOCA
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|x
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ptr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_reference
argument_list|(
name|var
argument_list|)
condition|)
block|{
comment|/* For references that are being privatized for Fortran, 		 allocate new backing storage for the new pointer 		 variable.  This allows us to avoid changing all the 		 code that expects a pointer to something that expects 		 a direct variable.  Note that this doesn't apply to 		 C++, since reference types are disallowed in data 		 sharing clauses there, except for NRV optimized 		 return values.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
continue|continue;
name|x
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_var
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|var
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|new_var
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|create_tmp_var_raw
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_var
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimple_add_tmp_var
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_fold_addr_expr_with_type
argument_list|(
name|x
argument_list|,
name|TREE_TYPE
argument_list|(
name|new_var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_ALLOCA
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|x
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_var
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|new_var
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
name|new_var
operator|=
name|build_fold_indirect_ref
argument_list|(
name|new_var
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_kind
operator|==
name|OMP_CLAUSE_REDUCTION
operator|&&
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_SHARED
case|:
comment|/* Shared global vars are just accessed directly.  */
if|if
condition|(
name|is_global_var
argument_list|(
name|new_var
argument_list|)
condition|)
break|break;
comment|/* Set up the DECL_VALUE_EXPR for shared variables now.  This 		 needs to be delayed until after fixup_child_record_type so 		 that we get the correct type during the dereference.  */
name|by_ref
operator|=
name|use_pointer_for_field
argument_list|(
name|var
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_receiver_ref
argument_list|(
name|var
argument_list|,
name|by_ref
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|new_var
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|new_var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? If VAR is not passed by reference, and the variable 		 hasn't been initialized yet, then we'll get a warning for 		 the store into the omp_data_s structure.  Ideally, we'd be 		 able to notice this and not store anything at all, but  		 we're generating code too early.  Suppress the warning.  */
if|if
condition|(
operator|!
name|by_ref
condition|)
name|TREE_NO_WARNING
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
if|if
condition|(
name|OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_PRIVATE
case|:
name|x
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_clause_default_ctor
argument_list|(
name|c
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
name|do_dtor
label|:
name|x
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_clause_dtor
argument_list|(
name|c
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|dtor
operator|=
name|x
expr_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|dtor
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
operator|&
name|diter
argument_list|,
name|dtor
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
name|x
operator|=
name|build_outer_var_ref
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_clause_copy_ctor
argument_list|(
name|c
argument_list|,
name|new_var
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
goto|goto
name|do_dtor
goto|;
break|break;
case|case
name|OMP_CLAUSE_COPYIN
case|:
name|by_ref
operator|=
name|use_pointer_for_field
argument_list|(
name|var
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_receiver_ref
argument_list|(
name|var
argument_list|,
name|by_ref
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_clause_assign_op
argument_list|(
name|c
argument_list|,
name|new_var
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|copyin_seq
argument_list|)
expr_stmt|;
name|copyin_by_ref
operator||=
name|by_ref
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
if|if
condition|(
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|gimplify_and_add
argument_list|(
name|OMP_CLAUSE_REDUCTION_INIT
argument_list|(
name|c
argument_list|)
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_REDUCTION_INIT
argument_list|(
name|c
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|omp_reduction_init
argument_list|(
name|c
argument_list|,
name|TREE_TYPE
argument_list|(
name|new_var
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_var
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|new_var
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* The copyin sequence is not to be executed by the main thread, since      that would result in self-copies.  Perhaps not visible to scalars,      but it certainly is to C++ operator=.  */
if|if
condition|(
name|copyin_seq
condition|)
block|{
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_OMP_GET_THREAD_NUM
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|x
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|,
name|copyin_seq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
block|}
comment|/* If any copyin variable is passed by reference, we must ensure the      master thread doesn't modify it before it is copied over in all      threads.  Similarly for variables in both firstprivate and      lastprivate clauses we need to ensure the lastprivate copying      happens after firstprivate copying in all threads.  */
if|if
condition|(
name|copyin_by_ref
operator|||
name|lastprivate_firstprivate
condition|)
name|build_omp_barrier
argument_list|(
name|ilist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to implement the LASTPRIVATE clauses.  This is used for    both parallel and workshare constructs.  PREDICATE may be NULL if it's    always true.   */
end_comment

begin_function
specifier|static
name|void
name|lower_lastprivate_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
name|predicate
parameter_list|,
name|tree
modifier|*
name|stmt_list
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|sub_list
decl_stmt|,
name|x
decl_stmt|,
name|c
decl_stmt|;
comment|/* Early exit if there are no lastprivate clauses.  */
name|clauses
operator|=
name|find_omp_clause
argument_list|(
name|clauses
argument_list|,
name|OMP_CLAUSE_LASTPRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|clauses
operator|==
name|NULL
condition|)
block|{
comment|/* If this was a workshare clause, see if it had been combined 	 with its parallel.  In that case, look for the clauses on the 	 parallel statement itself.  */
if|if
condition|(
name|is_parallel_ctx
argument_list|(
name|ctx
argument_list|)
condition|)
return|return;
name|ctx
operator|=
name|ctx
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
operator|||
operator|!
name|is_parallel_ctx
argument_list|(
name|ctx
argument_list|)
condition|)
return|return;
name|clauses
operator|=
name|find_omp_clause
argument_list|(
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|ctx
operator|->
name|stmt
argument_list|)
argument_list|,
name|OMP_CLAUSE_LASTPRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|clauses
operator|==
name|NULL
condition|)
return|return;
block|}
name|sub_list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
block|{
name|tree
name|var
decl_stmt|,
name|new_var
decl_stmt|;
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|OMP_CLAUSE_LASTPRIVATE
condition|)
continue|continue;
name|var
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|new_var
operator|=
name|lookup_decl
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_outer_var_ref
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reference
argument_list|(
name|var
argument_list|)
condition|)
name|new_var
operator|=
name|build_fold_indirect_ref
argument_list|(
name|new_var
argument_list|)
expr_stmt|;
name|x
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_clause_assign_op
argument_list|(
name|c
argument_list|,
name|x
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|sub_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|predicate
condition|)
name|x
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|predicate
argument_list|,
name|sub_list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|sub_list
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to implement the REDUCTION clauses.  */
end_comment

begin_function
specifier|static
name|void
name|lower_reduction_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
modifier|*
name|stmt_list
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|sub_list
init|=
name|NULL
decl_stmt|,
name|x
decl_stmt|,
name|c
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* First see if there is exactly one reduction clause.  Use OMP_ATOMIC      update in that case, otherwise use a lock.  */
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
operator|&&
name|count
operator|<
literal|2
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_REDUCTION
condition|)
block|{
if|if
condition|(
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Never use OMP_ATOMIC for array reductions.  */
name|count
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
block|{
name|tree
name|var
decl_stmt|,
name|ref
decl_stmt|,
name|new_var
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|OMP_CLAUSE_REDUCTION
condition|)
continue|continue;
name|var
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|new_var
operator|=
name|lookup_decl
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reference
argument_list|(
name|var
argument_list|)
condition|)
name|new_var
operator|=
name|build_fold_indirect_ref
argument_list|(
name|new_var
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_outer_var_ref
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|code
operator|=
name|OMP_CLAUSE_REDUCTION_CODE
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* reduction(-:var) sums up the partial results, so it acts 	 identically to reduction(+:var).  */
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|tree
name|addr
init|=
name|build_fold_addr_expr
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|ref
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|OMP_ATOMIC
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|tree
name|placeholder
init|=
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_reference
argument_list|(
name|var
argument_list|)
condition|)
name|ref
operator|=
name|build_fold_addr_expr
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|placeholder
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|placeholder
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|OMP_CLAUSE_REDUCTION_MERGE
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|sub_list
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_REDUCTION_MERGE
argument_list|(
name|c
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|ref
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_outer_var_ref
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ref
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|sub_list
argument_list|)
expr_stmt|;
block|}
block|}
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_ATOMIC_START
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|sub_list
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_ATOMIC_END
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to implement the COPYPRIVATE clauses.  */
end_comment

begin_function
specifier|static
name|void
name|lower_copyprivate_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
modifier|*
name|slist
parameter_list|,
name|tree
modifier|*
name|rlist
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
block|{
name|tree
name|var
decl_stmt|,
name|ref
decl_stmt|,
name|x
decl_stmt|;
name|bool
name|by_ref
decl_stmt|;
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|OMP_CLAUSE_COPYPRIVATE
condition|)
continue|continue;
name|var
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|by_ref
operator|=
name|use_pointer_for_field
argument_list|(
name|var
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_sender_ref
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|ctx
operator|->
name|is_nested
operator|)
condition|?
name|lookup_decl_in_outer_ctx
argument_list|(
name|var
argument_list|,
name|ctx
argument_list|)
else|:
name|var
expr_stmt|;
name|x
operator|=
name|by_ref
condition|?
name|build_fold_addr_expr
argument_list|(
name|x
argument_list|)
else|:
name|x
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ref
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|slist
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_receiver_ref
argument_list|(
name|var
argument_list|,
name|by_ref
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reference
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|ref
operator|=
name|build_fold_indirect_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|var
operator|=
name|build_fold_indirect_ref
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_clause_assign_op
argument_list|(
name|c
argument_list|,
name|var
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|rlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to implement the clauses, FIRSTPRIVATE, COPYIN, LASTPRIVATE,    and REDUCTION from the sender (aka parent) side.  */
end_comment

begin_function
specifier|static
name|void
name|lower_send_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
modifier|*
name|ilist
parameter_list|,
name|tree
modifier|*
name|olist
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
block|{
name|tree
name|val
decl_stmt|,
name|ref
decl_stmt|,
name|x
decl_stmt|,
name|var
decl_stmt|;
name|bool
name|by_ref
decl_stmt|,
name|do_in
init|=
name|false
decl_stmt|,
name|do_out
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
break|break;
default|default:
continue|continue;
block|}
name|var
operator|=
name|val
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|is_nested
condition|)
name|var
operator|=
name|lookup_decl_in_outer_ctx
argument_list|(
name|val
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|OMP_CLAUSE_COPYIN
operator|&&
name|is_global_var
argument_list|(
name|var
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|is_variable_sized
argument_list|(
name|val
argument_list|)
condition|)
continue|continue;
name|by_ref
operator|=
name|use_pointer_for_field
argument_list|(
name|val
argument_list|,
name|false
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
name|do_in
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
if|if
condition|(
name|by_ref
operator|||
name|is_reference
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
name|do_in
operator|=
name|true
expr_stmt|;
block|}
else|else
name|do_out
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|do_in
operator|=
name|true
expr_stmt|;
name|do_out
operator|=
operator|!
operator|(
name|by_ref
operator|||
name|is_reference
argument_list|(
name|val
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|do_in
condition|)
block|{
name|ref
operator|=
name|build_sender_ref
argument_list|(
name|val
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|by_ref
condition|?
name|build_fold_addr_expr
argument_list|(
name|var
argument_list|)
else|:
name|var
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ref
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_out
condition|)
block|{
name|ref
operator|=
name|build_sender_ref
argument_list|(
name|val
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|var
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|olist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate code to implement SHARED from the sender (aka parent) side.    This is trickier, since OMP_PARALLEL_CLAUSES doesn't list things that    got automatically shared.  */
end_comment

begin_function
specifier|static
name|void
name|lower_send_shared_vars
parameter_list|(
name|tree
modifier|*
name|ilist
parameter_list|,
name|tree
modifier|*
name|olist
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|var
decl_stmt|,
name|ovar
decl_stmt|,
name|nvar
decl_stmt|,
name|f
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|record_type
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
block|{
name|ovar
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|nvar
operator|=
name|maybe_lookup_decl
argument_list|(
name|ovar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nvar
operator|||
operator|!
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|nvar
argument_list|)
condition|)
continue|continue;
name|var
operator|=
name|ovar
expr_stmt|;
comment|/* If CTX is a nested parallel directive.  Find the immediately 	 enclosing parallel or workshare construct that contains a 	 mapping for OVAR.  */
if|if
condition|(
name|ctx
operator|->
name|is_nested
condition|)
name|var
operator|=
name|lookup_decl_in_outer_ctx
argument_list|(
name|ovar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_pointer_for_field
argument_list|(
name|ovar
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|x
operator|=
name|build_sender_ref
argument_list|(
name|ovar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|var
operator|=
name|build_fold_addr_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|build_sender_ref
argument_list|(
name|ovar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_sender_ref
argument_list|(
name|ovar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|var
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|olist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Build the function calls to GOMP_parallel_start etc to actually     generate the parallel operation.  REGION is the parallel region    being expanded.  BB is the block where to insert the code.  WS_ARGS    will be set if this is a call to a combined parallel+workshare    construct, it contains the list of additional arguments needed by    the workshare construct.  */
end_comment

begin_function
specifier|static
name|void
name|expand_parallel_call
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
name|entry_stmt
parameter_list|,
name|tree
name|ws_args
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|,
name|val
decl_stmt|,
name|cond
decl_stmt|,
name|c
decl_stmt|,
name|list
decl_stmt|,
name|clauses
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|int
name|start_ix
decl_stmt|;
name|clauses
operator|=
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|entry_stmt
argument_list|)
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
comment|/* Determine what flavor of GOMP_parallel_start we will be      emitting.  */
name|start_ix
operator|=
name|BUILT_IN_GOMP_PARALLEL_START
expr_stmt|;
if|if
condition|(
name|is_combined_parallel
argument_list|(
name|region
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|region
operator|->
name|inner
operator|->
name|type
condition|)
block|{
case|case
name|OMP_FOR
case|:
name|start_ix
operator|=
name|BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START
operator|+
name|region
operator|->
name|inner
operator|->
name|sched_kind
expr_stmt|;
break|break;
case|case
name|OMP_SECTIONS
case|:
name|start_ix
operator|=
name|BUILT_IN_GOMP_PARALLEL_SECTIONS_START
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* By default, the value of NUM_THREADS is zero (selected at run time)      and there is no conditional.  */
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
name|val
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|find_omp_clause
argument_list|(
name|clauses
argument_list|,
name|OMP_CLAUSE_IF
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|cond
operator|=
name|OMP_CLAUSE_IF_EXPR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|find_omp_clause
argument_list|(
name|clauses
argument_list|,
name|OMP_CLAUSE_NUM_THREADS
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|val
operator|=
name|OMP_CLAUSE_NUM_THREADS_EXPR
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Ensure 'val' is of the correct type.  */
name|val
operator|=
name|fold_convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* If we found the clause 'if (cond)', build either      (cond != 0) or (cond ? val : 1u).  */
if|if
condition|(
name|cond
condition|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
name|cond
operator|=
name|gimple_boolify
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|unsigned_type_node
argument_list|,
name|cond
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|basic_block
name|cond_bb
decl_stmt|,
name|then_bb
decl_stmt|,
name|else_bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|then_lab
decl_stmt|,
name|else_lab
decl_stmt|,
name|tmp
decl_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cond_bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|then_bb
operator|=
name|create_empty_bb
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|else_bb
operator|=
name|create_empty_bb
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
name|then_lab
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|else_lab
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|then_lab
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|else_lab
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|then_lab
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tmp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|else_lab
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tmp
argument_list|,
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cond_bb
argument_list|,
name|then_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cond_bb
argument_list|,
name|else_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|then_bb
argument_list|,
name|bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|else_bb
argument_list|,
name|bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|val
operator|=
name|tmp
expr_stmt|;
block|}
name|list
operator|=
name|NULL_TREE
expr_stmt|;
name|val
operator|=
name|get_formal_tmp_var
argument_list|(
name|val
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|NULL_TREE
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|OMP_PARALLEL_DATA_ARG
argument_list|(
name|entry_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|t
operator|=
name|null_pointer_node
expr_stmt|;
else|else
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|OMP_PARALLEL_FN
argument_list|(
name|entry_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws_args
condition|)
name|args
operator|=
name|chainon
argument_list|(
name|args
argument_list|,
name|ws_args
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|start_ix
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|OMP_PARALLEL_DATA_ARG
argument_list|(
name|entry_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|t
operator|=
name|null_pointer_node
expr_stmt|;
else|else
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|OMP_PARALLEL_FN
argument_list|(
name|entry_stmt
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_PARALLEL_END
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If exceptions are enabled, wrap *STMT_P in a MUST_NOT_THROW catch    handler.  This prevents programs from violating the structured    block semantics with throws.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_catch_exception
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|f
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
return|return;
if|if
condition|(
name|lang_protect_cleanup_actions
condition|)
name|t
operator|=
name|lang_protect_cleanup_actions
argument_list|()
expr_stmt|;
else|else
block|{
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_TRAP
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|build2
argument_list|(
name|EH_FILTER_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EH_FILTER_MUST_NOT_THROW
argument_list|(
name|f
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|EH_FILTER_FAILURE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|void_type_node
argument_list|,
operator|*
name|stmt_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|f
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|NULL
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Chain all the DECLs in LIST by their TREE_CHAIN fields.  */
end_comment

begin_function
specifier|static
name|tree
name|list2chain
parameter_list|(
name|tree
name|list
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|list
condition|?
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Remove barriers in REGION->EXIT's block.  Note that this is only    valid for OMP_PARALLEL regions.  Since the end of a parallel region    is an implicit barrier, any workshare inside the OMP_PARALLEL that    left a barrier at the end of the OMP_PARALLEL region can now be    removed.  */
end_comment

begin_function
specifier|static
name|void
name|remove_exit_barrier
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
name|basic_block
name|exit_bb
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
comment|/* If the parallel region doesn't return, we don't have REGION->EXIT      block at all.  */
if|if
condition|(
operator|!
name|exit_bb
condition|)
return|return;
comment|/* The last insn in the block will be the parallel's OMP_RETURN.  The      workshare's OMP_RETURN will be in a preceding block.  The kinds of      statements that can appear in between are extremely limited -- no      memory operations at all.  Here, we allow nothing at all, so the      only thing we allow to precede this OMP_RETURN is a label.  */
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|bsi_prev
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
return|return;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|exit_bb->preds
argument_list|)
block|{
name|si
operator|=
name|bsi_last
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|)
continue|continue;
name|t
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OMP_RETURN
condition|)
name|OMP_RETURN_NOWAIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_exit_barriers
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|OMP_PARALLEL
condition|)
name|remove_exit_barrier
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|inner
condition|)
block|{
name|region
operator|=
name|region
operator|->
name|inner
expr_stmt|;
name|remove_exit_barriers
argument_list|(
name|region
argument_list|)
expr_stmt|;
while|while
condition|(
name|region
operator|->
name|next
condition|)
block|{
name|region
operator|=
name|region
operator|->
name|next
expr_stmt|;
name|remove_exit_barriers
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Expand the OpenMP parallel directive starting at REGION.  */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_parallel
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|basic_block
name|entry_bb
decl_stmt|,
name|exit_bb
decl_stmt|,
name|new_bb
decl_stmt|;
name|struct
name|function
modifier|*
name|child_cfun
decl_stmt|,
modifier|*
name|saved_cfun
decl_stmt|;
name|tree
name|child_fn
decl_stmt|,
name|block
decl_stmt|,
name|t
decl_stmt|,
name|ws_args
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|entry_stmt
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|bool
name|do_cleanup_cfg
init|=
name|false
decl_stmt|;
name|entry_stmt
operator|=
name|last_stmt
argument_list|(
name|region
operator|->
name|entry
argument_list|)
expr_stmt|;
name|child_fn
operator|=
name|OMP_PARALLEL_FN
argument_list|(
name|entry_stmt
argument_list|)
expr_stmt|;
name|child_cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|child_fn
argument_list|)
expr_stmt|;
name|saved_cfun
operator|=
name|cfun
expr_stmt|;
name|entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
if|if
condition|(
name|is_combined_parallel
argument_list|(
name|region
argument_list|)
condition|)
name|ws_args
operator|=
name|region
operator|->
name|ws_args
expr_stmt|;
else|else
name|ws_args
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|child_cfun
operator|->
name|cfg
condition|)
block|{
comment|/* Due to inlining, it may happen that we have already outlined 	 the region, in which case all we need to do is make the 	 sub-graph unreachable and emit the parallel call.  */
name|edge
name|entry_succ_e
decl_stmt|,
name|exit_succ_e
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|entry_succ_e
operator|=
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_PARALLEL
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|entry_bb
expr_stmt|;
name|remove_edge
argument_list|(
name|entry_succ_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_bb
condition|)
block|{
name|exit_succ_e
operator|=
name|single_succ_edge
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|new_bb
argument_list|,
name|exit_succ_e
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
name|do_cleanup_cfg
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* If the parallel region needs data sent from the parent 	 function, then the very first statement (except possible 	 tree profile counter updates) of the parallel body 	 is a copy assignment .OMP_DATA_I =&.OMP_DATA_O.  Since&.OMP_DATA_O is passed as an argument to the child function, 	 we need to replace it with the argument as seen by the child 	 function.  	 In most cases, this will end up being the identity assignment 	 .OMP_DATA_I = .OMP_DATA_I.  However, if the parallel body had 	 a function call that has been inlined, the original PARM_DECL 	 .OMP_DATA_I may have been converted into a different local 	 variable.  In which case, we need to keep the assignment.  */
if|if
condition|(
name|OMP_PARALLEL_DATA_ARG
argument_list|(
name|entry_stmt
argument_list|)
condition|)
block|{
name|basic_block
name|entry_succ_bb
init|=
name|single_succ
argument_list|(
name|entry_bb
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|entry_succ_bb
argument_list|)
init|;
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
decl_stmt|,
name|arg
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
continue|continue;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|==
name|OMP_PARALLEL_DATA_ARG
argument_list|(
name|entry_stmt
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|==
name|DECL_ARGUMENTS
argument_list|(
name|child_fn
argument_list|)
condition|)
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|child_fn
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Declare local variables needed in CHILD_CFUN.  */
name|block
operator|=
name|DECL_INITIAL
argument_list|(
name|child_fn
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|list2chain
argument_list|(
name|child_cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|child_fn
argument_list|)
operator|=
name|single_succ
argument_list|(
name|entry_bb
argument_list|)
operator|->
name|stmt_list
expr_stmt|;
comment|/* Reset DECL_CONTEXT on locals and function arguments.  */
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|child_fn
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|child_fn
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|child_fn
expr_stmt|;
comment|/* Split ENTRY_BB at OMP_PARALLEL so that it can be moved to the 	 child function.  */
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|t
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OMP_PARALLEL
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|e
operator|=
name|split_block
argument_list|(
name|entry_bb
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|entry_bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
comment|/* Move the parallel region into CHILD_CFUN.  We need to reset 	 dominance information because the expansion of the inner 	 regions has invalidated it.  */
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|move_sese_region_to_fn
argument_list|(
name|child_cfun
argument_list|,
name|entry_bb
argument_list|,
name|exit_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_bb
condition|)
name|single_succ_edge
argument_list|(
name|new_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
name|cgraph_add_new_function
argument_list|(
name|child_fn
argument_list|)
expr_stmt|;
comment|/* Convert OMP_RETURN into a RETURN_EXPR.  */
if|if
condition|(
name|exit_bb
condition|)
block|{
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|RETURN_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit a library call to launch the children threads.  */
name|expand_parallel_call
argument_list|(
name|region
argument_list|,
name|new_bb
argument_list|,
name|entry_stmt
argument_list|,
name|ws_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_cleanup_cfg
condition|)
block|{
comment|/* Clean up the unreachable sub-graph we created above.  */
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of expand_omp_for.  Generate code for a parallel    loop with any schedule.  Given parameters:  	for (V = N1; V cond N2; V += STEP) BODY;     where COND is "<" or ">", we generate pseudocode  	more = GOMP_loop_foo_start (N1, N2, STEP, CHUNK,&istart0,&iend0); 	if (more) goto L0; else goto L3;     L0: 	V = istart0; 	iend = iend0;     L1: 	BODY; 	V += STEP; 	if (V cond iend) goto L1; else goto L2;     L2: 	if (GOMP_loop_foo_next (&istart0,&iend0)) goto L0; else goto L3;     L3:      If this is a combined omp parallel loop, instead of the call to     GOMP_loop_foo_start, we emit 'goto L3'.  */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_for_generic
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|,
name|struct
name|omp_for_data
modifier|*
name|fd
parameter_list|,
name|enum
name|built_in_function
name|start_fn
parameter_list|,
name|enum
name|built_in_function
name|next_fn
parameter_list|)
block|{
name|tree
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|l2
init|=
name|NULL
decl_stmt|,
name|l3
init|=
name|NULL
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|istart0
decl_stmt|,
name|iend0
decl_stmt|,
name|iend
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|,
name|list
decl_stmt|;
name|basic_block
name|entry_bb
decl_stmt|,
name|cont_bb
decl_stmt|,
name|exit_bb
decl_stmt|,
name|l0_bb
decl_stmt|,
name|l1_bb
decl_stmt|;
name|basic_block
name|l2_bb
init|=
name|NULL
decl_stmt|,
name|l3_bb
init|=
name|NULL
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|bool
name|in_combined_parallel
init|=
name|is_combined_parallel
argument_list|(
name|region
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|v
argument_list|)
expr_stmt|;
name|istart0
operator|=
name|create_tmp_var
argument_list|(
name|long_integer_type_node
argument_list|,
literal|".istart0"
argument_list|)
expr_stmt|;
name|iend0
operator|=
name|create_tmp_var
argument_list|(
name|long_integer_type_node
argument_list|,
literal|".iend0"
argument_list|)
expr_stmt|;
name|iend
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|istart0
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|iend0
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|region
operator|->
name|cont
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|region
operator|->
name|exit
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|l0_bb
operator|=
name|create_empty_bb
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|l1_bb
operator|=
name|single_succ
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|l0
operator|=
name|tree_block_label
argument_list|(
name|l0_bb
argument_list|)
expr_stmt|;
name|l1
operator|=
name|tree_block_label
argument_list|(
name|l1_bb
argument_list|)
expr_stmt|;
name|cont_bb
operator|=
name|region
operator|->
name|cont
expr_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
if|if
condition|(
name|cont_bb
condition|)
block|{
name|l2_bb
operator|=
name|create_empty_bb
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|l3_bb
operator|=
name|single_succ
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|l2
operator|=
name|tree_block_label
argument_list|(
name|l2_bb
argument_list|)
expr_stmt|;
name|l3
operator|=
name|tree_block_label
argument_list|(
name|l3_bb
argument_list|)
expr_stmt|;
block|}
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_FOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_combined_parallel
condition|)
block|{
comment|/* If this is not a combined parallel loop, emit a call to 	 GOMP_loop_foo_start in ENTRY_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|iend0
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|istart0
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|chunk_size
condition|)
block|{
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|->
name|chunk_size
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|->
name|n2
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|built_in_decls
index|[
name|start_fn
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|cont_bb
condition|)
block|{
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l0
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l3
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Iteration setup for sequential loop goes in L0_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|istart0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|iend0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|iend
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|l0_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Handle the rare case where BODY doesn't ever return.  */
if|if
condition|(
name|cont_bb
operator|==
name|NULL
condition|)
block|{
name|remove_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|l0_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|l0_bb
argument_list|,
name|l1_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Code to control the increment and predicate for the sequential      loop goes in the first half of EXIT_BB (we split EXIT_BB so      that we can inherit all the edges going out of the loop      body).  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|fd
operator|->
name|cond_code
argument_list|,
name|boolean_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|iend
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l1
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_CONTINUE
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Emit code to get the next parallel iteration in L2_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|iend0
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|istart0
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|built_in_decls
index|[
name|next_fn
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l0
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l3
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|l2_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Add the loop cleanup function.  */
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_RETURN_NOWAIT
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_LOOP_END_NOWAIT
index|]
expr_stmt|;
else|else
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_LOOP_END
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Connect the new blocks.  */
name|remove_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_combined_parallel
condition|)
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|l2_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
else|else
block|{
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|l0_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|l3_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
block|}
name|make_edge
argument_list|(
name|l0_bb
argument_list|,
name|l1_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|remove_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|cont_bb
argument_list|)
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cont_bb
argument_list|,
name|l1_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cont_bb
argument_list|,
name|l2_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|l2_bb
argument_list|,
name|l0_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|l2_bb
argument_list|,
name|l3_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_omp_for.  Generate code for a parallel    loop with static schedule and no specified chunk size.  Given    parameters:  	for (V = N1; V cond N2; V += STEP) BODY;     where COND is "<" or ">", we generate pseudocode  	if (cond is<) 	  adj = STEP - 1; 	else 	  adj = STEP + 1; 	n = (adj + N2 - N1) / STEP; 	q = n / nthreads; 	q += (q * nthreads != n); 	s0 = q * threadid; 	e0 = min(s0 + q, n); 	if (s0>= e0) goto L2; else goto L0;     L0: 	V = s0 * STEP + N1; 	e = e0 * STEP + N1;     L1: 	BODY; 	V += STEP; 	if (V cond e) goto L1;     L2: */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_for_static_nochunk
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|,
name|struct
name|omp_for_data
modifier|*
name|fd
parameter_list|)
block|{
name|tree
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|n
decl_stmt|,
name|q
decl_stmt|,
name|s0
decl_stmt|,
name|e0
decl_stmt|,
name|e
decl_stmt|,
name|t
decl_stmt|,
name|nthreads
decl_stmt|,
name|threadid
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|list
decl_stmt|;
name|basic_block
name|entry_bb
decl_stmt|,
name|exit_bb
decl_stmt|,
name|seq_start_bb
decl_stmt|,
name|body_bb
decl_stmt|,
name|cont_bb
decl_stmt|;
name|basic_block
name|fin_bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|v
argument_list|)
expr_stmt|;
name|entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|seq_start_bb
operator|=
name|create_empty_bb
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|body_bb
operator|=
name|single_succ
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|cont_bb
operator|=
name|region
operator|->
name|cont
expr_stmt|;
name|fin_bb
operator|=
name|single_succ
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
name|l0
operator|=
name|tree_block_label
argument_list|(
name|seq_start_bb
argument_list|)
expr_stmt|;
name|l1
operator|=
name|tree_block_label
argument_list|(
name|body_bb
argument_list|)
expr_stmt|;
name|l2
operator|=
name|tree_block_label
argument_list|(
name|fin_bb
argument_list|)
expr_stmt|;
comment|/* Iteration space partitioning goes in ENTRY_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_OMP_GET_NUM_THREADS
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|nthreads
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_OMP_GET_THREAD_NUM
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|threadid
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|fd
operator|->
name|n1
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|fd
operator|->
name|n1
argument_list|)
condition|)
name|fd
operator|->
name|n1
operator|=
name|get_formal_tmp_var
argument_list|(
name|fd
operator|->
name|n1
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|fd
operator|->
name|n2
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fd
operator|->
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|fd
operator|->
name|n2
argument_list|)
condition|)
name|fd
operator|->
name|n2
operator|=
name|get_formal_tmp_var
argument_list|(
name|fd
operator|->
name|n2
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|fd
operator|->
name|step
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|fd
operator|->
name|step
argument_list|)
condition|)
name|fd
operator|->
name|step
operator|=
name|get_formal_tmp_var
argument_list|(
name|fd
operator|->
name|step
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|(
name|fd
operator|->
name|cond_code
operator|==
name|LT_EXPR
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fd
operator|->
name|step
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n2
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_val
argument_list|(
name|t
argument_list|)
condition|)
name|n
operator|=
name|t
expr_stmt|;
else|else
name|n
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
name|nthreads
argument_list|)
expr_stmt|;
name|q
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|q
argument_list|,
name|nthreads
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|q
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|q
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|q
argument_list|,
name|threadid
argument_list|)
expr_stmt|;
name|s0
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|s0
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e0
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|s0
argument_list|,
name|e0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l2
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l0
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_FOR
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Setup code for sequential iteration goes in SEQ_START_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|e0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
name|e
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|seq_start_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* The code controlling the sequential loop replaces the OMP_CONTINUE.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|fd
operator|->
name|cond_code
argument_list|,
name|boolean_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l1
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_CONTINUE
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Replace the OMP_RETURN with a barrier, or nothing.  */
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OMP_RETURN_NOWAIT
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
condition|)
block|{
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|build_omp_barrier
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Connect all the blocks.  */
name|make_edge
argument_list|(
name|seq_start_bb
argument_list|,
name|body_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|remove_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|fin_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|seq_start_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cont_bb
argument_list|,
name|body_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|find_edge
argument_list|(
name|cont_bb
argument_list|,
name|fin_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALSE_VALUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_omp_for.  Generate code for a parallel    loop with static schedule and a specified chunk size.  Given    parameters:  	for (V = N1; V cond N2; V += STEP) BODY;     where COND is "<" or ">", we generate pseudocode  	if (cond is<) 	  adj = STEP - 1; 	else 	  adj = STEP + 1; 	n = (adj + N2 - N1) / STEP; 	trip = 0;     L0: 	s0 = (trip * nthreads + threadid) * CHUNK; 	e0 = min(s0 + CHUNK, n); 	if (s0< n) goto L1; else goto L4;     L1: 	V = s0 * STEP + N1; 	e = e0 * STEP + N1;     L2: 	BODY; 	V += STEP; 	if (V cond e) goto L2; else goto L3;     L3: 	trip += 1; 	goto L0;     L4: */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_for_static_chunk
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|,
name|struct
name|omp_for_data
modifier|*
name|fd
parameter_list|)
block|{
name|tree
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|l3
decl_stmt|,
name|l4
decl_stmt|,
name|n
decl_stmt|,
name|s0
decl_stmt|,
name|e0
decl_stmt|,
name|e
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|trip
decl_stmt|,
name|nthreads
decl_stmt|,
name|threadid
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|basic_block
name|entry_bb
decl_stmt|,
name|exit_bb
decl_stmt|,
name|body_bb
decl_stmt|,
name|seq_start_bb
decl_stmt|,
name|iter_part_bb
decl_stmt|;
name|basic_block
name|trip_update_bb
decl_stmt|,
name|cont_bb
decl_stmt|,
name|fin_bb
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|v
argument_list|)
expr_stmt|;
name|entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|iter_part_bb
operator|=
name|create_empty_bb
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|seq_start_bb
operator|=
name|create_empty_bb
argument_list|(
name|iter_part_bb
argument_list|)
expr_stmt|;
name|body_bb
operator|=
name|single_succ
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|cont_bb
operator|=
name|region
operator|->
name|cont
expr_stmt|;
name|trip_update_bb
operator|=
name|create_empty_bb
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|fin_bb
operator|=
name|single_succ
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
name|l0
operator|=
name|tree_block_label
argument_list|(
name|iter_part_bb
argument_list|)
expr_stmt|;
name|l1
operator|=
name|tree_block_label
argument_list|(
name|seq_start_bb
argument_list|)
expr_stmt|;
name|l2
operator|=
name|tree_block_label
argument_list|(
name|body_bb
argument_list|)
expr_stmt|;
name|l3
operator|=
name|tree_block_label
argument_list|(
name|trip_update_bb
argument_list|)
expr_stmt|;
name|l4
operator|=
name|tree_block_label
argument_list|(
name|fin_bb
argument_list|)
expr_stmt|;
comment|/* Trip and adjustment setup goes in ENTRY_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_OMP_GET_NUM_THREADS
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|nthreads
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_OMP_GET_THREAD_NUM
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|threadid
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|fd
operator|->
name|n1
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|fd
operator|->
name|n1
argument_list|)
condition|)
name|fd
operator|->
name|n1
operator|=
name|get_formal_tmp_var
argument_list|(
name|fd
operator|->
name|n1
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|fd
operator|->
name|n2
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fd
operator|->
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|fd
operator|->
name|n2
argument_list|)
condition|)
name|fd
operator|->
name|n2
operator|=
name|get_formal_tmp_var
argument_list|(
name|fd
operator|->
name|n2
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|fd
operator|->
name|step
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|fd
operator|->
name|step
argument_list|)
condition|)
name|fd
operator|->
name|step
operator|=
name|get_formal_tmp_var
argument_list|(
name|fd
operator|->
name|step
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|fd
operator|->
name|chunk_size
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fd
operator|->
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|fd
operator|->
name|chunk_size
argument_list|)
condition|)
name|fd
operator|->
name|chunk_size
operator|=
name|get_formal_tmp_var
argument_list|(
name|fd
operator|->
name|chunk_size
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|(
name|fd
operator|->
name|cond_code
operator|==
name|LT_EXPR
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fd
operator|->
name|step
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n2
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_val
argument_list|(
name|t
argument_list|)
condition|)
name|n
operator|=
name|t
expr_stmt|;
else|else
name|n
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trip
operator|=
name|get_initialized_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_FOR
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Iteration space partitioning goes in ITER_PART_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|trip
argument_list|,
name|nthreads
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|threadid
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|chunk_size
argument_list|)
expr_stmt|;
name|s0
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|s0
argument_list|,
name|fd
operator|->
name|chunk_size
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e0
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|s0
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l1
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l4
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|iter_part_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Setup code for sequential iteration goes in SEQ_START_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|e0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|fd
operator|->
name|n1
argument_list|)
expr_stmt|;
name|e
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|seq_start_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* The code controlling the sequential loop goes in CONT_BB,      replacing the OMP_CONTINUE.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|fd
operator|->
name|step
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|fd
operator|->
name|cond_code
argument_list|,
name|boolean_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_formal_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l2
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l3
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|cont_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_CONTINUE
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Trip update code goes into TRIP_UPDATE_BB.  */
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|trip
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|trip
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|trip_update_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Replace the OMP_RETURN with a barrier, or nothing.  */
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OMP_RETURN_NOWAIT
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
condition|)
block|{
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|build_omp_barrier
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Connect the new blocks.  */
name|remove_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|iter_part_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|iter_part_bb
argument_list|,
name|seq_start_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|iter_part_bb
argument_list|,
name|fin_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|seq_start_bb
argument_list|,
name|body_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|remove_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|cont_bb
argument_list|)
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cont_bb
argument_list|,
name|body_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cont_bb
argument_list|,
name|trip_update_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|trip_update_bb
argument_list|,
name|iter_part_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the OpenMP loop defined by REGION.  */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_for
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|omp_for_data
name|fd
decl_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|extract_omp_for_data
argument_list|(
name|last_stmt
argument_list|(
name|region
operator|->
name|entry
argument_list|)
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|region
operator|->
name|sched_kind
operator|=
name|fd
operator|.
name|sched_kind
expr_stmt|;
if|if
condition|(
name|fd
operator|.
name|sched_kind
operator|==
name|OMP_CLAUSE_SCHEDULE_STATIC
operator|&&
operator|!
name|fd
operator|.
name|have_ordered
operator|&&
name|region
operator|->
name|cont
operator|&&
name|region
operator|->
name|exit
condition|)
block|{
if|if
condition|(
name|fd
operator|.
name|chunk_size
operator|==
name|NULL
condition|)
name|expand_omp_for_static_nochunk
argument_list|(
name|region
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
else|else
name|expand_omp_for_static_chunk
argument_list|(
name|region
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|fn_index
init|=
name|fd
operator|.
name|sched_kind
operator|+
name|fd
operator|.
name|have_ordered
operator|*
literal|4
decl_stmt|;
name|int
name|start_ix
init|=
name|BUILT_IN_GOMP_LOOP_STATIC_START
operator|+
name|fn_index
decl_stmt|;
name|int
name|next_ix
init|=
name|BUILT_IN_GOMP_LOOP_STATIC_NEXT
operator|+
name|fn_index
decl_stmt|;
name|expand_omp_for_generic
argument_list|(
name|region
argument_list|,
operator|&
name|fd
argument_list|,
name|start_ix
argument_list|,
name|next_ix
argument_list|)
expr_stmt|;
block|}
name|pop_gimplify_context
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand code for an OpenMP sections directive.  In pseudo code, we generate  	v = GOMP_sections_start (n);     L0: 	switch (v) 	  { 	  case 0: 	    goto L2; 	  case 1: 	    section 1; 	    goto L1; 	  case 2: 	    ... 	  case n: 	    ... 	  default: 	    abort (); 	  }     L1: 	v = GOMP_sections_next (); 	goto L0;     L2: 	reduction;      If this is a combined parallel sections, replace the call to     GOMP_sections_start with 'goto L1'.  */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_sections
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|tree
name|label_vec
decl_stmt|,
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|sections_stmt
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|len
decl_stmt|;
name|basic_block
name|entry_bb
decl_stmt|,
name|exit_bb
decl_stmt|,
name|l0_bb
decl_stmt|,
name|l1_bb
decl_stmt|,
name|l2_bb
decl_stmt|,
name|default_bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|struct
name|omp_region
modifier|*
name|inner
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|l0_bb
operator|=
name|create_empty_bb
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|l0
operator|=
name|tree_block_label
argument_list|(
name|l0_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|region
operator|->
name|cont
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|region
operator|->
name|exit
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|l1_bb
operator|=
name|region
operator|->
name|cont
expr_stmt|;
if|if
condition|(
name|l1_bb
condition|)
block|{
name|l2_bb
operator|=
name|single_succ
argument_list|(
name|l1_bb
argument_list|)
expr_stmt|;
name|default_bb
operator|=
name|create_empty_bb
argument_list|(
name|l1_bb
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|l1
operator|=
name|tree_block_label
argument_list|(
name|l1_bb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l2_bb
operator|=
name|create_empty_bb
argument_list|(
name|l0_bb
argument_list|)
expr_stmt|;
name|default_bb
operator|=
name|l2_bb
expr_stmt|;
name|l1
operator|=
name|NULL
expr_stmt|;
block|}
name|l2
operator|=
name|tree_block_label
argument_list|(
name|l2_bb
argument_list|)
expr_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
name|v
operator|=
name|create_tmp_var
argument_list|(
name|unsigned_type_node
argument_list|,
literal|".section"
argument_list|)
expr_stmt|;
comment|/* We will build a switch() with enough cases for all the      OMP_SECTION regions, a '0' case to handle the end of more work      and a default case to abort if something goes wrong.  */
name|len
operator|=
name|EDGE_COUNT
argument_list|(
name|entry_bb
operator|->
name|succs
argument_list|)
expr_stmt|;
name|label_vec
operator|=
name|make_tree_vec
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* The call to GOMP_sections_start goes in ENTRY_BB, replacing the      OMP_SECTIONS statement.  */
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|sections_stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|sections_stmt
argument_list|)
operator|==
name|OMP_SECTIONS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_combined_parallel
argument_list|(
name|region
argument_list|)
condition|)
block|{
comment|/* If we are not inside a combined parallel+sections region, 	 call GOMP_sections_start.  */
name|t
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|u
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_SECTIONS_START
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* The switch() statement replacing OMP_SECTIONS goes in L0_BB.  */
name|si
operator|=
name|bsi_start
argument_list|(
name|l0_bb
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|SWITCH_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|,
name|label_vec
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|CASE_LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|l2
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
name|make_edge
argument_list|(
name|l0_bb
argument_list|,
name|l2_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert each OMP_SECTION into a CASE_LABEL_EXPR.  */
for|for
control|(
name|inner
operator|=
name|region
operator|->
name|inner
operator|,
name|i
operator|=
literal|1
init|;
name|inner
condition|;
name|inner
operator|=
name|inner
operator|->
name|next
operator|,
operator|++
name|i
control|)
block|{
name|basic_block
name|s_entry_bb
decl_stmt|,
name|s_exit_bb
decl_stmt|;
name|s_entry_bb
operator|=
name|inner
operator|->
name|entry
expr_stmt|;
name|s_exit_bb
operator|=
name|inner
operator|->
name|exit
expr_stmt|;
name|t
operator|=
name|tree_block_label
argument_list|(
name|s_entry_bb
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|u
operator|=
name|build3
argument_list|(
name|CASE_LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|u
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|i
argument_list|)
operator|=
name|u
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|s_entry_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_SECTION
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|<
name|len
operator|||
name|OMP_SECTION_LAST
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|e
operator|=
name|single_pred_edge
argument_list|(
name|s_entry_bb
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|redirect_edge_pred
argument_list|(
name|e
argument_list|,
name|l0_bb
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|s_entry_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
if|if
condition|(
name|s_exit_bb
operator|==
name|NULL
condition|)
continue|continue;
name|si
operator|=
name|bsi_last
argument_list|(
name|s_exit_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|s_exit_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
comment|/* Error handling code goes in DEFAULT_BB.  */
name|t
operator|=
name|tree_block_label
argument_list|(
name|default_bb
argument_list|)
expr_stmt|;
name|u
operator|=
name|build3
argument_list|(
name|CASE_LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|=
name|u
expr_stmt|;
name|make_edge
argument_list|(
name|l0_bb
argument_list|,
name|default_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|si
operator|=
name|bsi_start
argument_list|(
name|default_bb
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_TRAP
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Code to get the next section goes in L1_BB.  */
if|if
condition|(
name|l1_bb
condition|)
block|{
name|si
operator|=
name|bsi_last
argument_list|(
name|l1_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_CONTINUE
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_SECTIONS_NEXT
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup function replaces OMP_RETURN in EXIT_BB.  */
if|if
condition|(
name|exit_bb
condition|)
block|{
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_RETURN_NOWAIT
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_SECTIONS_END_NOWAIT
index|]
expr_stmt|;
else|else
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_SECTIONS_END
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Connect the new blocks.  */
if|if
condition|(
name|is_combined_parallel
argument_list|(
name|region
argument_list|)
condition|)
block|{
comment|/* If this was a combined parallel+sections region, we did not 	 emit a GOMP_sections_start in the entry block, so we just 	 need to jump to L1_BB to get the next section.  */
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|l1_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
else|else
name|make_edge
argument_list|(
name|entry_bb
argument_list|,
name|l0_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1_bb
condition|)
block|{
name|e
operator|=
name|single_succ_edge
argument_list|(
name|l1_bb
argument_list|)
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|l0_bb
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand code for an OpenMP single directive.  We've already expanded    much of the code, here we simply place the GOMP_barrier call.  */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_single
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|basic_block
name|entry_bb
decl_stmt|,
name|exit_bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|bool
name|need_barrier
init|=
name|false
decl_stmt|;
name|entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
comment|/* The terminal barrier at the end of a GOMP_single_copy sequence cannot      be removed.  We need to ensure that the thread that entered the single      does not exit before the data is copied out by the other threads.  */
if|if
condition|(
name|find_omp_clause
argument_list|(
name|OMP_SINGLE_CLAUSES
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
argument_list|,
name|OMP_CLAUSE_COPYPRIVATE
argument_list|)
condition|)
name|need_barrier
operator|=
name|true
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_SINGLE
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OMP_RETURN_NOWAIT
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|||
name|need_barrier
condition|)
block|{
name|tree
name|t
init|=
name|alloc_stmt_list
argument_list|()
decl_stmt|;
name|build_omp_barrier
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|si
argument_list|,
name|t
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|exit_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generic expansion for OpenMP synchronization directives: master,    ordered and critical.  All we need to do here is remove the entry    and exit markers for REGION.  */
end_comment

begin_function
specifier|static
name|void
name|expand_omp_synch
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
name|basic_block
name|entry_bb
decl_stmt|,
name|exit_bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|entry_bb
operator|=
name|region
operator|->
name|entry
expr_stmt|;
name|exit_bb
operator|=
name|region
operator|->
name|exit
expr_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|entry_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_SINGLE
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_MASTER
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_ORDERED
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_CRITICAL
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|entry_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
if|if
condition|(
name|exit_bb
condition|)
block|{
name|si
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|==
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|exit_bb
argument_list|)
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the parallel region tree rooted at REGION.  Expansion    proceeds in depth-first order.  Innermost regions are expanded    first.  This way, parallel regions that require a new function to    be created (e.g., OMP_PARALLEL) can be expanded without having any    internal dependencies in their body.  */
end_comment

begin_function
specifier|static
name|void
name|expand_omp
parameter_list|(
name|struct
name|omp_region
modifier|*
name|region
parameter_list|)
block|{
while|while
condition|(
name|region
condition|)
block|{
if|if
condition|(
name|region
operator|->
name|inner
condition|)
name|expand_omp
argument_list|(
name|region
operator|->
name|inner
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|region
operator|->
name|type
condition|)
block|{
case|case
name|OMP_PARALLEL
case|:
name|expand_omp_parallel
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|expand_omp_for
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTIONS
case|:
name|expand_omp_sections
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTION
case|:
comment|/* Individual omp sections are handled together with their 	     parent OMP_SECTIONS region.  */
break|break;
case|case
name|OMP_SINGLE
case|:
name|expand_omp_single
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
name|expand_omp_synch
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|region
operator|=
name|region
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper for build_omp_regions.  Scan the dominator tree starting at    block BB.  PARENT is the region that contains BB.  */
end_comment

begin_function
specifier|static
name|void
name|build_omp_regions_1
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|omp_region
modifier|*
name|parent
parameter_list|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|basic_block
name|son
decl_stmt|;
name|si
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
operator|&&
name|OMP_DIRECTIVE_P
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|omp_region
modifier|*
name|region
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|OMP_RETURN
condition|)
block|{
comment|/* STMT is the return point out of region PARENT.  Mark it 	     as the exit point and make PARENT the immediately 	     enclosing region.  */
name|gcc_assert
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|region
operator|=
name|parent
expr_stmt|;
name|region
operator|->
name|exit
operator|=
name|bb
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|outer
expr_stmt|;
comment|/* If REGION is a parallel region, determine whether it is 	     a combined parallel+workshare region.  */
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|OMP_PARALLEL
condition|)
name|determine_parallel_type
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|OMP_CONTINUE
condition|)
block|{
name|gcc_assert
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|cont
operator|=
name|bb
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, this directive becomes the parent for a new 	     region.  */
name|region
operator|=
name|new_omp_region
argument_list|(
name|bb
argument_list|,
name|code
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|=
name|region
expr_stmt|;
block|}
block|}
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|build_omp_regions_1
argument_list|(
name|son
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the CFG and build a tree of OMP regions.  Return the root of    the OMP region tree.  */
end_comment

begin_function
specifier|static
name|void
name|build_omp_regions
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|root_omp_region
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|build_omp_regions_1
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main entry point for expanding OMP-GIMPLE into runtime calls.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_expand_omp
parameter_list|(
name|void
parameter_list|)
block|{
name|build_omp_regions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|root_omp_region
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nOMP region tree\n\n"
argument_list|)
expr_stmt|;
name|dump_omp_region
argument_list|(
name|dump_file
argument_list|,
name|root_omp_region
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|remove_exit_barriers
argument_list|(
name|root_omp_region
argument_list|)
expr_stmt|;
name|expand_omp
argument_list|(
name|root_omp_region
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
name|free_omp_regions
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_expand_omp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_openmp
operator|!=
literal|0
operator|&&
name|errorcount
operator|==
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_expand_omp
init|=
block|{
literal|"ompexp"
block|,
comment|/* name */
name|gate_expand_omp
block|,
comment|/* gate */
name|execute_expand_omp
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_gimple_any
block|,
comment|/* properties_required */
name|PROP_gimple_lomp
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Routines to lower OpenMP directives into OMP-GIMPLE.  */
end_comment

begin_comment
comment|/* Lower the OpenMP sections directive in *STMT_P.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_sections
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|new_stmt
decl_stmt|,
name|stmt
decl_stmt|,
name|body
decl_stmt|,
name|bind
decl_stmt|,
name|block
decl_stmt|,
name|ilist
decl_stmt|,
name|olist
decl_stmt|,
name|new_body
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|dlist
decl_stmt|;
name|tree_stmt_iterator
name|tsi
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|len
decl_stmt|;
name|stmt
operator|=
operator|*
name|stmt_p
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|dlist
operator|=
name|NULL
expr_stmt|;
name|ilist
operator|=
name|NULL
expr_stmt|;
name|lower_rec_input_clauses
argument_list|(
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|ilist
argument_list|,
operator|&
name|dlist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_start
argument_list|(
name|OMP_SECTIONS_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|;
name|len
operator|++
operator|,
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
control|)
continue|continue;
name|tsi
operator|=
name|tsi_start
argument_list|(
name|OMP_SECTIONS_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
control|)
block|{
name|omp_context
modifier|*
name|sctx
decl_stmt|;
name|tree
name|sec_start
decl_stmt|,
name|sec_end
decl_stmt|;
name|sec_start
operator|=
name|tsi_stmt
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
name|sctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|sec_start
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|sctx
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|sec_start
argument_list|,
operator|&
name|body
argument_list|)
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|OMP_SECTION_BODY
argument_list|(
name|sec_start
argument_list|)
argument_list|,
name|sctx
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|OMP_SECTION_BODY
argument_list|(
name|sec_start
argument_list|)
argument_list|,
operator|&
name|body
argument_list|)
expr_stmt|;
name|OMP_SECTION_BODY
argument_list|(
name|sec_start
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|len
operator|-
literal|1
condition|)
block|{
name|tree
name|l
init|=
name|alloc_stmt_list
argument_list|()
decl_stmt|;
name|lower_lastprivate_clauses
argument_list|(
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|l
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|l
argument_list|,
operator|&
name|body
argument_list|)
expr_stmt|;
name|OMP_SECTION_LAST
argument_list|(
name|sec_start
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|sec_end
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|sec_end
argument_list|,
operator|&
name|body
argument_list|)
expr_stmt|;
block|}
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|body
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|olist
operator|=
name|NULL_TREE
expr_stmt|;
name|lower_reduction_clauses
argument_list|(
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|olist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|record_vars_into
argument_list|(
name|ctx
operator|->
name|block_vars
argument_list|,
name|ctx
operator|->
name|cb
operator|.
name|dst_fn
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|new_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|new_body
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|ilist
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|bind
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|OMP_CONTINUE
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|olist
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|dlist
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|maybe_catch_exception
argument_list|(
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|OMP_RETURN_NOWAIT
argument_list|(
name|t
argument_list|)
operator|=
operator|!
operator|!
name|find_omp_clause
argument_list|(
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|OMP_CLAUSE_NOWAIT
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|BIND_EXPR_BODY
argument_list|(
name|new_stmt
argument_list|)
operator|=
name|new_body
expr_stmt|;
name|OMP_SECTIONS_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|new_stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_omp_single.  Expand the simple form of    an OMP_SINGLE, without a copyprivate clause:       	if (GOMP_single_start ()) 	  BODY; 	[ GOMP_barrier (); ]	-> unless 'nowait' is present.    FIXME.  It may be better to delay expanding the logic of this until   pass_expand_omp.  The expanded logic may make the job more difficult   to a synchronization analysis pass.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_single_simple
parameter_list|(
name|tree
name|single_stmt
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_SINGLE_START
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|OMP_SINGLE_BODY
argument_list|(
name|single_stmt
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_omp_single.  Expand the simple form of    an OMP_SINGLE, with a copyprivate clause:  	#pragma omp single copyprivate (a, b, c)     Create a new structure to hold copies of 'a', 'b' and 'c' and emit:        { 	if ((copyout_p = GOMP_single_copy_start ()) == NULL) 	  { 	    BODY; 	    copyout.a = a; 	    copyout.b = b; 	    copyout.c = c; 	    GOMP_single_copy_end (&copyout); 	  } 	else 	  { 	    a = copyout_p->a; 	    b = copyout_p->b; 	    c = copyout_p->c; 	  } 	GOMP_barrier ();       }    FIXME.  It may be better to delay expanding the logic of this until   pass_expand_omp.  The expanded logic may make the job more difficult   to a synchronization analysis pass.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_single_copy
parameter_list|(
name|tree
name|single_stmt
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|ptr_type
decl_stmt|,
name|t
decl_stmt|,
name|args
decl_stmt|,
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|copyin_seq
decl_stmt|;
name|ctx
operator|->
name|sender_decl
operator|=
name|create_tmp_var
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|,
literal|".omp_copy_o"
argument_list|)
expr_stmt|;
name|ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|receiver_decl
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type
argument_list|,
literal|".omp_copy_i"
argument_list|)
expr_stmt|;
name|l0
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|l1
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|l2
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_SINGLE_COPY_START
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|ptr_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ctx
operator|->
name|receiver_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|ctx
operator|->
name|receiver_decl
argument_list|,
name|build_int_cst
argument_list|(
name|ptr_type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l0
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|l0
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|OMP_SINGLE_BODY
argument_list|(
name|single_stmt
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|copyin_seq
operator|=
name|NULL
expr_stmt|;
name|lower_copyprivate_clauses
argument_list|(
name|OMP_SINGLE_CLAUSES
argument_list|(
name|single_stmt
argument_list|)
argument_list|,
name|pre_p
argument_list|,
operator|&
name|copyin_seq
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|ctx
operator|->
name|sender_decl
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_SINGLE_COPY_END
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_and_jump
argument_list|(
operator|&
name|l2
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|copyin_seq
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|l2
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand code for an OpenMP single directive.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_single
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|bind
decl_stmt|,
name|block
decl_stmt|,
name|single_stmt
init|=
operator|*
name|stmt_p
decl_stmt|,
name|dlist
decl_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
name|lower_rec_input_clauses
argument_list|(
name|OMP_SINGLE_CLAUSES
argument_list|(
name|single_stmt
argument_list|)
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|,
operator|&
name|dlist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|OMP_SINGLE_BODY
argument_list|(
name|single_stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|single_stmt
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|record_type
condition|)
name|lower_omp_single_copy
argument_list|(
name|single_stmt
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
else|else
name|lower_omp_single_simple
argument_list|(
name|single_stmt
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_SINGLE_BODY
argument_list|(
name|single_stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|dlist
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|maybe_catch_exception
argument_list|(
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|OMP_RETURN_NOWAIT
argument_list|(
name|t
argument_list|)
operator|=
operator|!
operator|!
name|find_omp_clause
argument_list|(
name|OMP_SINGLE_CLAUSES
argument_list|(
name|single_stmt
argument_list|)
argument_list|,
name|OMP_CLAUSE_NOWAIT
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|bind
argument_list|)
expr_stmt|;
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
operator|=
name|chainon
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
argument_list|,
name|ctx
operator|->
name|block_vars
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand code for an OpenMP master directive.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_master
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|bind
decl_stmt|,
name|block
decl_stmt|,
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|,
name|lab
init|=
name|NULL
decl_stmt|,
name|x
decl_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_OMP_GET_THREAD_NUM
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|x
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|lab
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|OMP_MASTER_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|maybe_catch_exception
argument_list|(
operator|&
name|OMP_MASTER_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|OMP_MASTER_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_MASTER_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|OMP_RETURN_NOWAIT
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|bind
argument_list|)
expr_stmt|;
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
operator|=
name|chainon
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
argument_list|,
name|ctx
operator|->
name|block_vars
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand code for an OpenMP ordered directive.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_ordered
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|bind
decl_stmt|,
name|block
decl_stmt|,
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|,
name|x
decl_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_ORDERED_START
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|OMP_ORDERED_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|maybe_catch_exception
argument_list|(
operator|&
name|OMP_ORDERED_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|OMP_ORDERED_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_ORDERED_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_ORDERED_END
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|OMP_RETURN_NOWAIT
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|bind
argument_list|)
expr_stmt|;
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
operator|=
name|chainon
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
argument_list|,
name|ctx
operator|->
name|block_vars
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify an OMP_CRITICAL statement.  This is a relatively simple    substitution of a couple of function calls.  But in the NAMED case,    requires that languages coordinate a symbol name.  It is therefore    best put here in common code.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param1_is (tree), param2_is (tree))
argument_list|)
name|splay_tree
name|critical_name_mutexes
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|lower_omp_critical
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|bind
decl_stmt|,
name|block
decl_stmt|,
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|lock
decl_stmt|,
name|unlock
decl_stmt|,
name|name
decl_stmt|;
name|name
operator|=
name|OMP_CRITICAL_NAME
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|tree
name|decl
decl_stmt|,
name|args
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|critical_name_mutexes
condition|)
name|critical_name_mutexes
operator|=
name|splay_tree_new_ggc
argument_list|(
name|splay_tree_compare_pointers
argument_list|)
expr_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|critical_name_mutexes
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|new_str
decl_stmt|;
name|decl
operator|=
name|create_tmp_var_raw
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_str
operator|=
name|ACONCAT
argument_list|(
operator|(
literal|".gomp_critical_user_"
operator|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|,
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|new_str
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cgraph_varpool_finalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|critical_name_mutexes
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lock
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_CRITICAL_NAME_START
index|]
expr_stmt|;
name|lock
operator|=
name|build_function_call_expr
argument_list|(
name|lock
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|unlock
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_CRITICAL_NAME_END
index|]
expr_stmt|;
name|unlock
operator|=
name|build_function_call_expr
argument_list|(
name|unlock
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_CRITICAL_START
index|]
expr_stmt|;
name|lock
operator|=
name|build_function_call_expr
argument_list|(
name|lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|unlock
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_CRITICAL_END
index|]
expr_stmt|;
name|unlock
operator|=
name|build_function_call_expr
argument_list|(
name|unlock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|lock
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|OMP_CRITICAL_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|maybe_catch_exception
argument_list|(
operator|&
name|OMP_CRITICAL_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|OMP_CRITICAL_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_CRITICAL_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|unlock
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|OMP_RETURN_NOWAIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|bind
argument_list|)
expr_stmt|;
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
operator|=
name|chainon
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
argument_list|,
name|ctx
operator|->
name|block_vars
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|bind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_omp_for.  Generate code to emit the predicate    for a lastprivate clause.  Given a loop control predicate of (V    cond N2), we gate the clause on (!(V cond N2)).  The lowered form    is appended to *DLIST, iterator initialization is appended to    *BODY_P.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_for_lastprivate
parameter_list|(
name|struct
name|omp_for_data
modifier|*
name|fd
parameter_list|,
name|tree
modifier|*
name|body_p
parameter_list|,
name|tree
modifier|*
name|dlist
parameter_list|,
name|struct
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|clauses
decl_stmt|,
name|cond
decl_stmt|,
name|stmts
decl_stmt|,
name|vinit
decl_stmt|,
name|t
decl_stmt|;
name|enum
name|tree_code
name|cond_code
decl_stmt|;
name|cond_code
operator|=
name|fd
operator|->
name|cond_code
expr_stmt|;
name|cond_code
operator|=
name|cond_code
operator|==
name|LT_EXPR
condition|?
name|GE_EXPR
else|:
name|LE_EXPR
expr_stmt|;
comment|/* When possible, use a strict equality expression.  This can let VRP      type optimizations deduce the value and remove a copy.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|fd
operator|->
name|step
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|step
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|fd
operator|->
name|step
argument_list|)
decl_stmt|;
if|if
condition|(
name|step
operator|==
literal|1
operator|||
name|step
operator|==
operator|-
literal|1
condition|)
name|cond_code
operator|=
name|EQ_EXPR
expr_stmt|;
block|}
name|cond
operator|=
name|build2
argument_list|(
name|cond_code
argument_list|,
name|boolean_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|fd
operator|->
name|n2
argument_list|)
expr_stmt|;
name|clauses
operator|=
name|OMP_FOR_CLAUSES
argument_list|(
name|fd
operator|->
name|for_stmt
argument_list|)
expr_stmt|;
name|stmts
operator|=
name|NULL
expr_stmt|;
name|lower_lastprivate_clauses
argument_list|(
name|clauses
argument_list|,
name|cond
argument_list|,
operator|&
name|stmts
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
operator|!=
name|NULL
condition|)
block|{
name|append_to_statement_list
argument_list|(
name|stmts
argument_list|,
name|dlist
argument_list|)
expr_stmt|;
comment|/* Optimize: v = 0; is usually cheaper than v = some_other_constant.  */
name|vinit
operator|=
name|fd
operator|->
name|n1
expr_stmt|;
if|if
condition|(
name|cond_code
operator|==
name|EQ_EXPR
operator|&&
name|host_integerp
argument_list|(
name|fd
operator|->
name|n2
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|fd
operator|->
name|n2
argument_list|)
condition|)
name|vinit
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fd
operator|->
name|v
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the iterator variable, so that threads that don't execute 	 any iterations don't execute the lastprivate clauses by accident.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fd
operator|->
name|v
argument_list|,
name|vinit
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lower code for an OpenMP loop directive.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_for
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|stmt
decl_stmt|,
name|ilist
decl_stmt|,
name|dlist
decl_stmt|,
name|new_stmt
decl_stmt|,
modifier|*
name|body_p
decl_stmt|,
modifier|*
name|rhs_p
decl_stmt|;
name|struct
name|omp_for_data
name|fd
decl_stmt|;
name|stmt
operator|=
operator|*
name|stmt_p
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|OMP_FOR_PRE_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|OMP_FOR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* Move declaration of temporaries in the loop body before we make      it go away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OMP_FOR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|record_vars_into
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|OMP_FOR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|,
name|ctx
operator|->
name|cb
operator|.
name|dst_fn
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|new_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|body_p
operator|=
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|new_stmt
argument_list|)
expr_stmt|;
comment|/* The pre-body and input clauses go before the lowered OMP_FOR.  */
name|ilist
operator|=
name|NULL
expr_stmt|;
name|dlist
operator|=
name|NULL
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|OMP_FOR_PRE_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
name|lower_rec_input_clauses
argument_list|(
name|OMP_FOR_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|body_p
argument_list|,
operator|&
name|dlist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* Lower the header expressions.  At this point, we can assume that      the header is of the form:       	#pragma omp for (V = VAL1; V {<|>|<=|>=} VAL2; V = V [+-] VAL3)       We just need to make sure that VAL1, VAL2 and VAL3 are lowered      using the .omp_data_s mapping, if needed.  */
name|rhs_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|OMP_FOR_INIT
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
operator|*
name|rhs_p
argument_list|)
condition|)
operator|*
name|rhs_p
operator|=
name|get_formal_tmp_var
argument_list|(
operator|*
name|rhs_p
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
name|rhs_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|OMP_FOR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
operator|*
name|rhs_p
argument_list|)
condition|)
operator|*
name|rhs_p
operator|=
name|get_formal_tmp_var
argument_list|(
operator|*
name|rhs_p
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
name|rhs_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|OMP_FOR_INCR
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
operator|*
name|rhs_p
argument_list|)
condition|)
operator|*
name|rhs_p
operator|=
name|get_formal_tmp_var
argument_list|(
operator|*
name|rhs_p
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
comment|/* Once lowered, extract the bounds and clauses.  */
name|extract_omp_for_data
argument_list|(
name|stmt
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|lower_omp_for_lastprivate
argument_list|(
operator|&
name|fd
argument_list|,
name|body_p
argument_list|,
operator|&
name|dlist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|OMP_FOR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|OMP_CONTINUE
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
comment|/* After the loop, add exit clauses.  */
name|lower_reduction_clauses
argument_list|(
name|OMP_FOR_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|body_p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|dlist
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
name|maybe_catch_exception
argument_list|(
name|body_p
argument_list|)
expr_stmt|;
comment|/* Region exit marker goes at the end of the loop body.  */
name|t
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|OMP_RETURN_NOWAIT
argument_list|(
name|t
argument_list|)
operator|=
name|fd
operator|.
name|have_nowait
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|body_p
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|record_vars_into
argument_list|(
name|ctx
operator|->
name|block_vars
argument_list|,
name|ctx
operator|->
name|cb
operator|.
name|dst_fn
argument_list|)
expr_stmt|;
name|OMP_FOR_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|OMP_FOR_PRE_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|new_stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback for walk_stmts.  Check if *TP only contains OMP_FOR    or OMP_PARALLEL.  */
end_comment

begin_function
specifier|static
name|tree
name|check_combined_parallel
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
name|data
decl_stmt|;
name|int
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
operator|*
name|info
operator|=
operator|*
name|info
operator|==
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
operator|*
name|info
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Lower the OpenMP parallel directive in *STMT_P.  CTX holds context    information for the directive.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_parallel
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|tree
name|clauses
decl_stmt|,
name|par_bind
decl_stmt|,
name|par_body
decl_stmt|,
name|new_body
decl_stmt|,
name|bind
decl_stmt|;
name|tree
name|olist
decl_stmt|,
name|ilist
decl_stmt|,
name|par_olist
decl_stmt|,
name|par_ilist
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|child_fn
decl_stmt|,
name|t
decl_stmt|;
name|stmt
operator|=
operator|*
name|stmt_p
expr_stmt|;
name|clauses
operator|=
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|par_bind
operator|=
name|OMP_PARALLEL_BODY
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|par_body
operator|=
name|BIND_EXPR_BODY
argument_list|(
name|par_bind
argument_list|)
expr_stmt|;
name|child_fn
operator|=
name|ctx
operator|->
name|cb
operator|.
name|dst_fn
expr_stmt|;
if|if
condition|(
operator|!
name|OMP_PARALLEL_COMBINED
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|struct
name|walk_stmt_info
name|wi
decl_stmt|;
name|int
name|ws_num
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|wi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|.
name|callback
operator|=
name|check_combined_parallel
expr_stmt|;
name|wi
operator|.
name|info
operator|=
operator|&
name|ws_num
expr_stmt|;
name|wi
operator|.
name|val_only
operator|=
name|true
expr_stmt|;
name|walk_stmts
argument_list|(
operator|&
name|wi
argument_list|,
operator|&
name|par_bind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws_num
operator|==
literal|1
condition|)
name|OMP_PARALLEL_COMBINED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|par_olist
operator|=
name|NULL_TREE
expr_stmt|;
name|par_ilist
operator|=
name|NULL_TREE
expr_stmt|;
name|lower_rec_input_clauses
argument_list|(
name|clauses
argument_list|,
operator|&
name|par_ilist
argument_list|,
operator|&
name|par_olist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp
argument_list|(
operator|&
name|par_body
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|lower_reduction_clauses
argument_list|(
name|clauses
argument_list|,
operator|&
name|par_olist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* Declare all the variables created by mapping and the variables      declared in the scope of the parallel body.  */
name|record_vars_into
argument_list|(
name|ctx
operator|->
name|block_vars
argument_list|,
name|child_fn
argument_list|)
expr_stmt|;
name|record_vars_into
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|par_bind
argument_list|)
argument_list|,
name|child_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|record_type
condition|)
block|{
name|ctx
operator|->
name|sender_decl
operator|=
name|create_tmp_var
argument_list|(
name|ctx
operator|->
name|record_type
argument_list|,
literal|".omp_data_o"
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_DATA_ARG
argument_list|(
name|stmt
argument_list|)
operator|=
name|ctx
operator|->
name|sender_decl
expr_stmt|;
block|}
name|olist
operator|=
name|NULL_TREE
expr_stmt|;
name|ilist
operator|=
name|NULL_TREE
expr_stmt|;
name|lower_send_clauses
argument_list|(
name|clauses
argument_list|,
operator|&
name|ilist
argument_list|,
operator|&
name|olist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|lower_send_shared_vars
argument_list|(
operator|&
name|ilist
argument_list|,
operator|&
name|olist
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* Once all the expansions are done, sequence all the different      fragments inside OMP_PARALLEL_BODY.  */
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|ilist
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|new_body
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|record_type
condition|)
block|{
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|ctx
operator|->
name|sender_decl
argument_list|)
expr_stmt|;
comment|/* fixup_child_record_type might have changed receiver_decl's type.  */
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctx
operator|->
name|receiver_decl
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ctx
operator|->
name|receiver_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
block|}
name|append_to_statement_list
argument_list|(
name|par_ilist
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|par_body
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|par_olist
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|maybe_catch_exception
argument_list|(
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|OMP_RETURN
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|new_body
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|new_body
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|olist
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|bind
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass *TP back through the gimplifier within the context determined by WI.    This handles replacement of DECL_VALUE_EXPR, as well as adjusting the     flags on ADDR_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|lower_regimplify
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|struct
name|walk_stmt_info
modifier|*
name|wi
parameter_list|)
block|{
name|enum
name|gimplify_status
name|gs
decl_stmt|;
name|tree
name|pre
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|wi
operator|->
name|is_lhs
condition|)
name|gs
operator|=
name|gimplify_expr
argument_list|(
name|tp
argument_list|,
operator|&
name|pre
argument_list|,
name|NULL
argument_list|,
name|is_gimple_lvalue
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wi
operator|->
name|val_only
condition|)
name|gs
operator|=
name|gimplify_expr
argument_list|(
name|tp
argument_list|,
operator|&
name|pre
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
else|else
name|gs
operator|=
name|gimplify_expr
argument_list|(
name|tp
argument_list|,
operator|&
name|pre
argument_list|,
name|NULL
argument_list|,
name|is_gimple_formal_tmp_var
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|gs
operator|==
name|GS_ALL_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
name|tsi_link_before
argument_list|(
operator|&
name|wi
operator|->
name|tsi
argument_list|,
name|pre
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy EXP into a temporary.  Insert the initialization statement before TSI.  */
end_comment

begin_function
specifier|static
name|tree
name|init_tmp_var
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|stmt
decl_stmt|;
name|t
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|stmt
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but copy from the temporary and insert the statement    after the iterator.  */
end_comment

begin_function
specifier|static
name|tree
name|save_tmp_var
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|stmt
decl_stmt|;
name|t
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|exp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|stmt
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Callback for walk_stmts.  Lower the OpenMP directive pointed by TP.  */
end_comment

begin_function
specifier|static
name|tree
name|lower_omp_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
name|data
decl_stmt|;
name|omp_context
modifier|*
name|ctx
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
comment|/* If we have issued syntax errors, avoid doing any heavy lifting.      Just replace the OpenMP directives with a NOP to avoid      confusing RTL expansion.  */
if|if
condition|(
name|errorcount
operator|&&
name|OMP_DIRECTIVE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
case|case
name|OMP_PARALLEL
case|:
name|ctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|lower_omp_parallel
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|ctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp_for
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTIONS
case|:
name|ctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp_sections
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SINGLE
case|:
name|ctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp_single
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_MASTER
case|:
name|ctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp_master
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_ORDERED
case|:
name|ctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp_ordered
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CRITICAL
case|:
name|ctx
operator|=
name|maybe_lookup_ctx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|lower_omp_critical
argument_list|(
name|tp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|ctx
operator|&&
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|lower_regimplify
argument_list|(
operator|&
name|t
argument_list|,
name|wi
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|->
name|val_only
condition|)
block|{
if|if
condition|(
name|wi
operator|->
name|is_lhs
condition|)
name|t
operator|=
name|save_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|init_tmp_var
argument_list|(
name|t
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
block|}
operator|*
name|tp
operator|=
name|t
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|ctx
condition|)
name|lower_regimplify
argument_list|(
name|tp
argument_list|,
name|wi
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
if|if
condition|(
name|ctx
condition|)
name|lower_regimplify
argument_list|(
name|tp
argument_list|,
name|wi
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|ctx
condition|)
block|{
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|lower_regimplify
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|wi
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lower_omp
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|omp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|walk_stmt_info
name|wi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|wi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|.
name|callback
operator|=
name|lower_omp_1
expr_stmt|;
name|wi
operator|.
name|info
operator|=
name|ctx
expr_stmt|;
name|wi
operator|.
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|.
name|want_locations
operator|=
name|true
expr_stmt|;
name|walk_stmts
argument_list|(
operator|&
name|wi
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_lower_omp
parameter_list|(
name|void
parameter_list|)
block|{
name|all_contexts
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
name|delete_omp_context
argument_list|)
expr_stmt|;
name|scan_omp
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parallel_nesting_level
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_contexts
operator|->
name|root
condition|)
name|lower_omp
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_contexts
condition|)
block|{
name|splay_tree_delete
argument_list|(
name|all_contexts
argument_list|)
expr_stmt|;
name|all_contexts
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_lower_omp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_openmp
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_lower_omp
init|=
block|{
literal|"omplower"
block|,
comment|/* name */
name|gate_lower_omp
block|,
comment|/* gate */
name|execute_lower_omp
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_gimple_any
block|,
comment|/* properties_required */
name|PROP_gimple_lomp
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The following is a utility to diagnose OpenMP structured block violations.    It is not part of the "omplower" pass, as that's invoked too late.  It    should be invoked by the respective front ends after gimplification.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|all_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check for mismatched contexts and generate an error if needed.  Return    true if an error is detected.  */
end_comment

begin_function
specifier|static
name|bool
name|diagnose_sb_0
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|tree
name|branch_ctx
parameter_list|,
name|tree
name|label_ctx
parameter_list|)
block|{
name|bool
name|exit_p
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|(
name|label_ctx
condition|?
name|TREE_VALUE
argument_list|(
name|label_ctx
argument_list|)
else|:
name|NULL
operator|)
operator|==
name|branch_ctx
condition|)
return|return
name|false
return|;
comment|/* Try to avoid confusing the user by producing and error message      with correct "exit" or "enter" verbage.  We prefer "exit"      unless we can show that LABEL_CTX is nested within BRANCH_CTX.  */
if|if
condition|(
name|branch_ctx
operator|==
name|NULL
condition|)
name|exit_p
operator|=
name|false
expr_stmt|;
else|else
block|{
while|while
condition|(
name|label_ctx
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|label_ctx
argument_list|)
operator|==
name|branch_ctx
condition|)
block|{
name|exit_p
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|label_ctx
operator|=
name|TREE_CHAIN
argument_list|(
name|label_ctx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exit_p
condition|)
name|error
argument_list|(
literal|"invalid exit from OpenMP structured block"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid entry to OpenMP structured block"
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Pass 1: Create a minimal tree of OpenMP structured blocks, and record    where in the tree each label is found.  */
end_comment

begin_function
specifier|static
name|tree
name|diagnose_sb_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
name|data
decl_stmt|;
name|tree
name|context
init|=
operator|(
name|tree
operator|)
name|wi
operator|->
name|info
decl_stmt|;
name|tree
name|inner_context
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|OMP_PARALLEL
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
name|walk_tree
argument_list|(
operator|&
name|OMP_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_1
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
comment|/* The minimal context here is just a tree of statements.  */
name|inner_context
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|wi
operator|->
name|info
operator|=
name|inner_context
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|info
operator|=
name|context
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_1
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|inner_context
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|wi
operator|->
name|info
operator|=
name|inner_context
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_INIT
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_1
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_1
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_INCR
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_1
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|OMP_FOR_PRE_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|OMP_FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|info
operator|=
name|context
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
name|splay_tree_insert
argument_list|(
name|all_labels
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|context
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Pass 2: Check each branch and see if its context differs from that of    the destination label's context.  */
end_comment

begin_function
specifier|static
name|tree
name|diagnose_sb_2
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
name|data
decl_stmt|;
name|tree
name|context
init|=
operator|(
name|tree
operator|)
name|wi
operator|->
name|info
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|OMP_PARALLEL
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
name|walk_tree
argument_list|(
operator|&
name|OMP_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_2
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
name|wi
operator|->
name|info
operator|=
name|t
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|info
operator|=
name|context
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_2
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wi
operator|->
name|info
operator|=
name|t
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_INIT
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_2
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_2
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|OMP_FOR_INCR
argument_list|(
name|t
argument_list|)
argument_list|,
name|diagnose_sb_2
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|OMP_FOR_PRE_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|OMP_FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|info
operator|=
name|context
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
block|{
name|tree
name|lab
init|=
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lab
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
break|break;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|all_labels
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|lab
argument_list|)
expr_stmt|;
name|diagnose_sb_0
argument_list|(
name|tp
argument_list|,
name|context
argument_list|,
name|n
condition|?
operator|(
name|tree
operator|)
name|n
operator|->
name|value
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SWITCH_EXPR
case|:
block|{
name|tree
name|vec
init|=
name|SWITCH_LABELS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|lab
init|=
name|CASE_LABEL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|all_labels
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|lab
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnose_sb_0
argument_list|(
name|tp
argument_list|,
name|context
argument_list|,
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
condition|)
break|break;
block|}
block|}
break|break;
case|case
name|RETURN_EXPR
case|:
name|diagnose_sb_0
argument_list|(
name|tp
argument_list|,
name|context
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|diagnose_omp_structured_block_errors
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|save_current
init|=
name|current_function_decl
decl_stmt|;
name|struct
name|walk_stmt_info
name|wi
decl_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
name|all_labels
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|wi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|.
name|callback
operator|=
name|diagnose_sb_1
expr_stmt|;
name|walk_stmts
argument_list|(
operator|&
name|wi
argument_list|,
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|wi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|.
name|callback
operator|=
name|diagnose_sb_2
expr_stmt|;
name|wi
operator|.
name|want_locations
operator|=
name|true
expr_stmt|;
name|wi
operator|.
name|want_return_expr
operator|=
name|true
expr_stmt|;
name|walk_stmts
argument_list|(
operator|&
name|wi
argument_list|,
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|splay_tree_delete
argument_list|(
name|all_labels
argument_list|)
expr_stmt|;
name|all_labels
operator|=
name|NULL
expr_stmt|;
name|current_function_decl
operator|=
name|save_current
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-omp-low.h"
end_include

end_unit

