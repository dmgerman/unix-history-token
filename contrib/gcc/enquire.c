begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Everything you wanted to know about your machine and C compiler,    but didn't know who to ask.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VERSION
end_ifndef

begin_define
define|#
directive|define
name|VERSION
value|"4.3"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Author: Steven Pemberton, CWI, Amsterdam; steven@cwi.nl    Bugfixes and upgrades gratefully received.     Copyright (c) 1988, 1989, 1990 Steven Pemberton, CWI, Amsterdam.    All rights reserved.     Changes by Richard Stallman:    Undef CHAR_BIT, etc., if defined in stdio.h, Richard Stallman, Aug 90.    In EPROP, avoid a<= old if bad is set, Richard Stallman, May 91.    Use gstddef.h, not stddef.h, Richard Stallman, Nov 91.    Don't declare malloc, instead cast the value, Richard Stallman, Nov 91.    Include sys/types.h before signal.h, Apr 92.    Support NO_LONG_DOUBLE_IO in f_define and f_rep; new fn fake_f_rep, Apr 92.    Enclose -f output in #ifndef _FLOAT_H___, Richard Stallman, May 92.     Change by Jim Wilson:    Add #undef before every #define, Dec 92.    Use stddef.h not gstddef.h, Mar 94.     Changes by Paul Eggert, installed Feb 93:    (fake_f_rep): Clear all of u, initially.  Make the ints in u unsigned.    (f_define): Use ordinary constants for long double    if it's same width as double.  Make __convert_long_double_i unsigned.    Richard Stallman, May 93:    In F_check, check NO_LONG_DOUBLE_IO.     Changes by Stephen Moshier, installed Sep 93:    (FPROP): Recognize 80387 or 68881 XFmode format.     Change by Manfred Hollstein, installed Mar 98:    (bitpattern): Change type of variable i to unsigned int.      COMPILING    With luck and a following wind, just the following will work: 	cc enquire.c -o enquire    You may get some messages about unreachable code, which you can ignore.     If your compiler doesn't support:		add flag: 	signed char (eg pcc)			-DNO_SC 	unsigned char				-DNO_UC 	unsigned short and long			-DNO_UI 	void					-DNO_VOID 	signal(), or setjmp/longjmp()		-DNO_SIG 	%Lf in printf				-DNO_LONG_DOUBLE_IO     Try to compile first with no flags, and see if you get any errors -    you might be surprised. (Most non-ANSI compilers need -DNO_SC, though.)    Some compilers need a -f flag for floating point.     Don't use any optimisation flags: the program may not work if you do.    Though "while (a+1.0-a-1.0 == 0.0)" may look like "while(1)" to an    optimiser, to a floating-point unit there's a world of difference.     Some compilers offer various flags for different floating point    modes; it's worth trying all possible combinations of these.     Add -DID=\"name\" if you want the machine/flags identified in the output.     FAULTY COMPILERS    Because of bugs and/or inadequacies, some compilers need the following    defines:     If your C preprocessor doesn't have the predefined __FILE__ macro, and    you don't want to call this file enquire.c but, say, tell.c, add the    flag -DFILENAME=\"tell.c\" .     Some compilers won't accept the line "#include FILENAME".    Add flag -DNO_FILE. In that case, this file *must* be called enquire.c.     Some compilers can't cope with "#ifdef __FILE__". Use -DFILENAME=    or -DNO_FILE as above.     Some naughty compilers define __STDC__, but don't really support it.    Some define it as 0, in which case we treat it as undefined.    But if your compiler defines it, and isn't really ANSI C,    add flag -DNO_STDC. (To those compiler writers: for shame).     Some naughty compilers define __STDC__, but don't have the stddef.h    include file. Add flag -DNO_STDDEF.     Summary of naughty-compiler flags:    If your compiler doesn't support:		 add flag: 	__FILE__ (and you changed the filename)	-DFILENAME=\"name.c\" 	#ifdef __FILE__				-DNO_FILE or -DFILENAME=... 	#include FILENAME			-DNO_FILE 	__STDC__ (properly)			-DNO_STDC 	stddef.h				-DNO_STDDEF     Some systems crash when you try to malloc all store. To save users of    such defective systems too much grief, they may compile with -DNO_MEM,    which ignores that bit of the code.     While it is not our policy to support defective compilers, pity has been    taken on people with compilers that can't produce object files bigger than    32k (especially since it was an easy addition). Compile the program    into separate parts like this:        cc -DSEP -DPASS0 -o p0.o<other flags> enquire.c        cc -DSEP -DPASS1 -o p1.o<other flags> enquire.c        cc -DSEP -DPASS2 -o p2.o<other flags> enquire.c        cc -DSEP -DPASS3 -o p3.o<other flags> enquire.c        cc -o enquire p0.o p1.o p2.o p3.o     SYSTEM DEPENDENCIES    You may possibly need to add some calls to signal() for other sorts of    exception on your machine than SIGFPE, and SIGOVER. See lines beginning    #ifdef SIGxxx in main() (and communicate the differences to me!).     OUTPUT    Run without argument to get the information as English text. If run    with argument -l (e.g. enquire -l), output is a series of #define's for    the ANSI standard limits.h include file, excluding MB_MAX_CHAR. If run    with argument -f, output is a series of #define's for the ANSI standard    float.h include file (according to ANSI C Draft of Dec 7, 1988).    Flag -v gives verbose output: output includes the English text above    as C comments. The program exit(0)'s if everything went ok, otherwise    it exits with a positive number, telling how many problems there were.     VERIFYING THE COMPILER    If, having produced the float.h and limits.h header files, you want to    verify that the compiler reads them back correctly (there are a lot of    boundary cases, of course, like minimum and maximum numbers), you can    recompile enquire.c with -DVERIFY set (plus the other flags that you used    when compiling the version that produced the header files). This then    recompiles the program so that it #includes "limits.h" and "float.h",    and checks that the constants it finds there are the same as the    constants it produces. Run the resulting program with enquire -fl.    Very few compilers have passed without error.    NB: You *must* recompile with the same compiler and flags, otherwise    you may get odd results.     You can also use this option if your compiler already has both files,    and you want to confirm that this program produces the right results.     TROUBLESHOOTING.    This program is now quite trustworthy, and suspicious and wrong output    may well be caused by bugs in the compiler, not in the program (however    of course, this is not guaranteed, and no responsibility can be    accepted, etc.)     The program only works if overflows are ignored by the C system or    are catchable with signal().     If the program fails to run to completion (often with the error message    "Unexpected signal at point x"), this often turns out to be a bug in the    C compiler's run-time system. Check what was about to be printed, and    try to narrow the problem down.     Another possible problem is that you have compiled the program to produce    loss-of-precision arithmetic traps. The program cannot cope with these,    and you should re-compile without them. (They should never be the default).     Make sure you compiled with optimisation turned off.     Output preceded by *** WARNING: identifies behaviour of the C system    deemed incorrect by the program. Likely problems are that printf or    scanf don't cope properly with certain boundary numbers: this program    goes to a lot of trouble to calculate its values, and these values    are mostly boundary numbers. Experience has shown that often printf    cannot cope with these values, and so in an attempt to increase    confidence in the output, for each float and double that is printed,    the printed value is checked by using sscanf to read it back.        Care is taken that numbers are printed with enough digits to uniquely    identify them, and therefore that they can be read back identically.    If the number read back is different, then there is probably a bug in    printf or sscanf, and the program prints the warning message.    If the two numbers in the warning look identical, then printf is more    than likely rounding the last digit(s) incorrectly. To put you at ease    that the two really are different, the bit patterns of the two numbers    are also printed. The difference is very likely in the last bit.        Many scanf's read the minimum double back as 0.0, and similarly cause    overflow when reading the maximum double. This program quite ruthlessly    declares all these behaviours faulty. The point is that if you get    one of these warnings, the output may be wrong, so you should check    the result carefully if you intend to use the results. Of course, printf    and sscanf may both be wrong, and cancel each other out, so you should    check the output carefully anyway.     The warning that "a cast didn't work" refers to cases like this:        float f;       #define C 1.234567890123456789       f= C;       if (f != (float) C) printf ("Wrong!");     A faulty compiler will widen f to double and ignore the cast to float,    and because there is more accuracy in a double than a float, fail to    recognise that they are the same. In the actual case in point, f and C    are passed as parameters to a function that discovers they are not equal,    so it's just possible that the error was in the parameter passing,    not in the cast (see function Validate()).    For ANSI C, which has float constants, the error message is "constant has    wrong precision".     REPORTING PROBLEMS    If the program doesn't work for you for any reason that can't be    narrowed down to a problem in the C compiler, or it has to be changed in    order to get it to compile, or it produces suspicious output (like a very    low maximum float, for instance), please mail the problem and an example    of the incorrect output to steven@cwi.nl or ..!hp4nl!cwi.nl!steven, so that    improvements can be worked into future versions; cwi.nl is the European    backbone, and is connected to uunet and other fine hosts.     The program tries to catch and diagnose bugs in the compiler/run-time    system. I would be especially pleased to have reports of failures so    that I can improve this service.     I apologise unreservedly for the contorted use of the preprocessor...     THE SMALL PRINT    You may copy and distribute verbatim copies of this source file.     You may modify this source file, and copy and distribute such    modified versions, provided that you leave the copyright notice    at the top of the file and also cause the modified file to carry    prominent notices stating that you changed the files and the date    of any change; and cause the whole of any work that you distribute    or publish, that in whole or in part contains or is a derivative of    this program or any part thereof, to be licensed at no charge to    all third parties on terms identical to those here.     If you do have a fix to any problem, please send it to me, so that    other people can have the benefits.     While every effort has been taken to make this program as reliable as    possible, no responsibility can be taken for the correctness of the    output, nor suitability for any particular use.     This program is an offshoot of a project funded by public funds.    If you use this program for research or commercial use (i.e. more    than just for the fun of knowing about your compiler) mailing a short    note of acknowledgement may help keep enquire.c supported.     ACKNOWLEDGEMENTS    Many people have given time and ideas to making this program what it is.    To all of them thanks, and apologies for not mentioning them by name.     HISTORY    Originally started as a program to generate configuration constants    for a large piece of software we were writing, which later took on    a life of its own...    1.0 Length 6658!; end 1984?        Unix only. Only printed a dozen maximum int/double values.    2.0 Length 10535; Spring 1985        Prints values as #defines (about 20 of them)        More extensive floating point, using Cody and Waite        Handles signals better        Programs around optimisations        Handles Cybers    3.0 Length 12648; Aug 1987; prints about 42 values        Added PASS stuff, so treats float as well as double    4.0 Length 33891; Feb 1989; prints around 85 values        First GNU version (for gcc, where they call it hard-params.c)        Generates float.h and limits.h files        Handles long double        Generates warnings for dubious output    4.1 Length 47738; April 1989        Added VERIFY and TEST    4.2 Length 63442; Feb 1990        Added SEP        Fixed eps/epsneg        Added check for pseudo-unsigned chars        Added description for each #define output        Added check for absence of defines during verify        Added prototypes        Added NO_STDC and NO_FILE        Fixed alignments output    4.3 Length 75000; Oct 1990; around 114 lines of output        Function xmalloc defined, Richard Stallman, June 89.        Alignments computed from member offsets rather than structure sizes,           Richard Stallman, Oct 89.        Print whether char* and int* pointers have the same format;           also char * and function *.        Update to Draft C version Dec 7, 1988 	  - types of constants produced in limits.h 	    (whether to put a U after unsigned shorts and chars and 	     whether to output -1024 as (-1023-1)) 	  - values of SCHAR_MIN/MAX 	  - values of *_EPSILON (not the smallest but the effective smallest)        Added FILENAME, since standard C doesn't allow #define __FILE__        Renamed from config.c to enquire.c        Added size_t and ptrdiff_t enquiries        Added promotion enquiries        Added type checks of #defines        Added NO_STDDEF        Changed endian to allow for cases where not all bits are used        Sanity check for max integrals        Fixed definition of setjmp for -DNO_SIG        Moved #define ... 0.0L inside #ifdef STDC, in case some cpp's tokenize        Added NO_MEM */
end_comment

begin_comment
comment|/* Set FILENAME to the name of this file */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILENAME
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FILE
end_ifdef

begin_define
define|#
directive|define
name|FILENAME
value|"enquire.c"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__FILE__
end_ifdef

begin_comment
comment|/* It's a compiler bug if this fails. Compile with -DNO_FILE */
end_comment

begin_define
define|#
directive|define
name|FILENAME
value|__FILE__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FILENAME
value|"enquire.c"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FILE__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_FILE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FILENAME */
end_comment

begin_comment
comment|/* If PASS isn't defined, then this is the first pass over this file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PASS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SEP
end_ifndef

begin_define
define|#
directive|define
name|PASS
value|1
end_define

begin_define
define|#
directive|define
name|PASS0
value|1
end_define

begin_define
define|#
directive|define
name|PASS1
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SEP */
end_comment

begin_comment
comment|/* A description of the ANSI constants */
end_comment

begin_define
define|#
directive|define
name|D_CHAR_BIT
value|"Number of bits in a storage unit"
end_define

begin_define
define|#
directive|define
name|D_CHAR_MAX
value|"Maximum char"
end_define

begin_define
define|#
directive|define
name|D_CHAR_MIN
value|"Minimum char"
end_define

begin_define
define|#
directive|define
name|D_SCHAR_MAX
value|"Maximum signed char"
end_define

begin_define
define|#
directive|define
name|D_SCHAR_MIN
value|"Minimum signed char"
end_define

begin_define
define|#
directive|define
name|D_UCHAR_MAX
value|"Maximum unsigned char (minimum is always 0)"
end_define

begin_define
define|#
directive|define
name|D_INT_MAX
value|"Maximum %s"
end_define

begin_define
define|#
directive|define
name|D_INT_MIN
value|"Minimum %s"
end_define

begin_define
define|#
directive|define
name|D_UINT_MAX
value|"Maximum unsigned %s (minimum is always 0)"
end_define

begin_define
define|#
directive|define
name|D_FLT_ROUNDS
value|"Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown"
end_define

begin_define
define|#
directive|define
name|D_FLT_RADIX
value|"Radix of exponent representation"
end_define

begin_define
define|#
directive|define
name|D_MANT_DIG
value|"Number of base-FLT_RADIX digits in the significand of a %s"
end_define

begin_define
define|#
directive|define
name|D_DIG
value|"Number of decimal digits of precision in a %s"
end_define

begin_define
define|#
directive|define
name|D_MIN_EXP
value|"Minimum int x such that FLT_RADIX**(x-1) is a normalised %s"
end_define

begin_define
define|#
directive|define
name|D_MIN_10_EXP
value|"Minimum int x such that 10**x is a normalised %s"
end_define

begin_define
define|#
directive|define
name|D_MAX_EXP
value|"Maximum int x such that FLT_RADIX**(x-1) is a representable %s"
end_define

begin_define
define|#
directive|define
name|D_MAX_10_EXP
value|"Maximum int x such that 10**x is a representable %s"
end_define

begin_define
define|#
directive|define
name|D_MAX
value|"Maximum %s"
end_define

begin_define
define|#
directive|define
name|D_EPSILON
value|"Difference between 1.0 and the minimum %s greater than 1.0"
end_define

begin_define
define|#
directive|define
name|D_MIN
value|"Minimum normalised %s"
end_define

begin_comment
comment|/* Procedure just marks the functions that don't return a result */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_VOID
end_ifdef

begin_define
define|#
directive|define
name|Procedure
value|int
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Procedure
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some bad compilers define __STDC__, when they don't support it.    Compile with -DNO_STDC to get round this. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STDC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_comment
comment|/* If __STDC__ is 0, assume it isn't supported */
end_comment

begin_define
define|#
directive|define
name|STDC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stuff different for ANSI C, and old C:    ARGS and NOARGS are used for function prototypes.    Volatile is used to reduce the chance of optimisation,       and to prevent variables being put in registers (when setjmp/longjmp       wouldn't work as we want)    Long_double is the longest floating point type available.    stdc is used in tests like "if (stdc)", which is less ugly than #ifdef.    U is output after unsigned constants.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDC
end_ifdef

begin_define
define|#
directive|define
name|ARGS
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_define
define|#
directive|define
name|NOARGS
value|(void)
end_define

begin_define
define|#
directive|define
name|Volatile
value|volatile
end_define

begin_define
define|#
directive|define
name|Long_double
value|long double
end_define

begin_define
define|#
directive|define
name|stdc
value|1
end_define

begin_define
define|#
directive|define
name|U
value|"U"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Old style C */
end_comment

begin_define
define|#
directive|define
name|ARGS
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_define
define|#
directive|define
name|NOARGS
value|()
end_define

begin_define
define|#
directive|define
name|Volatile
value|static
end_define

begin_define
define|#
directive|define
name|Long_double
value|double
end_define

begin_define
define|#
directive|define
name|stdc
value|0
end_define

begin_define
define|#
directive|define
name|U
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_comment
comment|/* include files */
end_comment

begin_comment
comment|/* Stdio.h might include limits.h, and limits.h might include float.h, and    float.h is probably the float.h put together by the gcc makefile to    cause errors.  We use our special define to assure float.h that we don't    really need it.  */
end_comment

begin_define
define|#
directive|define
name|__GCC_FLOAT_NOT_NEEDED
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STDDEF
end_ifndef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* for size_t: if this fails, define NO_STDDEF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SIG
end_ifdef

begin_define
define|#
directive|define
name|jmp_buf
value|int
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Kludge around the possibility that<stdio.h> includes<limits.h> */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CHAR_BIT
end_ifdef

begin_undef
undef|#
directive|undef
name|CHAR_BIT
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_MAX
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_MIN
end_undef

begin_undef
undef|#
directive|undef
name|SCHAR_MAX
end_undef

begin_undef
undef|#
directive|undef
name|SCHAR_MIN
end_undef

begin_undef
undef|#
directive|undef
name|UCHAR_MAX
end_undef

begin_undef
undef|#
directive|undef
name|UCHAR_MIN
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_include
include|#
directive|include
file|"limits.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_FLOAT_H_WRAP
end_ifndef

begin_define
define|#
directive|define
name|SYS_FLOAT_H_WRAP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SYS_FLOAT_H_WRAP
operator|||
name|defined
name|VERIFY
end_if

begin_include
include|#
directive|include
file|"float.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Vprintf
value|if (V) printf
end_define

begin_define
define|#
directive|define
name|Unexpected
parameter_list|(
name|place
parameter_list|)
value|if (setjmp(lab)!=0) croak(place)
end_define

begin_define
define|#
directive|define
name|fabs
parameter_list|(
name|x
parameter_list|)
value|(((x)<0.0)?(-x):(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS0
end_ifdef

begin_comment
comment|/* Prototypes for what's to come: */
end_comment

begin_decl_stmt
name|int
name|false
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STDDEF
end_ifdef

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Old style prototype */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|malloc
name|ARGS
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Procedure
name|exit
name|ARGS
argument_list|(
operator|(
name|int
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f_rep
name|ARGS
argument_list|(
operator|(
name|int
name|precision
operator|,
name|Long_double
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fake_f_rep
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|type
operator|,
name|Long_double
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maximum_int
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cprop
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|basic
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|sprop
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|iprop
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|lprop
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|usprop
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|uiprop
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|ulprop
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fprop
name|ARGS
argument_list|(
operator|(
name|int
name|bits_per_byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dprop
name|ARGS
argument_list|(
operator|(
name|int
name|bits_per_byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ldprop
name|ARGS
argument_list|(
operator|(
name|int
name|bits_per_byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|efprop
name|ARGS
argument_list|(
operator|(
name|int
name|fprec
operator|,
name|int
name|dprec
operator|,
name|int
name|lprec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|edprop
name|ARGS
argument_list|(
operator|(
name|int
name|fprec
operator|,
name|int
name|dprec
operator|,
name|int
name|lprec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|eldprop
name|ARGS
argument_list|(
operator|(
name|int
name|fprec
operator|,
name|int
name|dprec
operator|,
name|int
name|lprec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setmode
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|farewell
name|ARGS
argument_list|(
operator|(
name|int
name|bugs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|describe
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|description
operator|,
name|char
operator|*
name|extra
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|missing
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|fmissing
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|check_defines
name|NOARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|bitpattern
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|unsigned
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ceil_log
name|ARGS
argument_list|(
operator|(
name|int
name|base
operator|,
name|Long_double
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|croak
name|ARGS
argument_list|(
operator|(
name|int
name|place
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|eek_a_bug
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|problem
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|endian
name|ARGS
argument_list|(
operator|(
name|int
name|bits_per_byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exponent
name|ARGS
argument_list|(
operator|(
name|Long_double
name|x
operator|,
name|double
operator|*
name|fract
operator|,
name|int
operator|*
name|exp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|floor_log
name|ARGS
argument_list|(
operator|(
name|int
name|base
operator|,
name|Long_double
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|f_define
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|desc
operator|,
name|char
operator|*
name|extra
operator|,
name|char
operator|*
name|sort
operator|,
name|char
operator|*
name|name
operator|,
name|int
name|prec
operator|,
name|Long_double
name|val
operator|,
name|Long_double
name|req
operator|,
name|char
operator|*
name|mark
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|i_define
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|desc
operator|,
name|char
operator|*
name|extra
operator|,
name|char
operator|*
name|sort
operator|,
name|char
operator|*
name|name
operator|,
name|long
name|val
operator|,
name|long
name|lim
operator|,
name|long
name|req
operator|,
name|char
operator|*
name|mark
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Procedure
name|u_define
name|ARGS
argument_list|(
operator|(
name|char
operator|*
name|desc
operator|,
name|char
operator|*
name|extra
operator|,
name|char
operator|*
name|sort
operator|,
name|char
operator|*
name|name
operator|,
name|unsigned
name|long
name|val
operator|,
name|unsigned
name|long
name|req
operator|,
name|char
operator|*
name|mark
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SIG
end_ifdef

begin_comment
comment|/* There's no signal(), or setjmp/longjmp() */
end_comment

begin_comment
comment|/* Dummy routines instead */
end_comment

begin_decl_stmt
name|int
name|setjmp
name|ARGS
argument_list|(
operator|(
name|int
name|lab
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lab
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|setjmp
parameter_list|(
name|lab
parameter_list|)
name|int
name|lab
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|Procedure
name|signal
argument_list|(
name|i
argument_list|,
name|p
argument_list|)
name|int
name|i
decl_stmt|,
argument_list|(
operator|*
name|p
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{}
end_block

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|jmp_buf
name|lab
decl_stmt|;
end_decl_stmt

begin_function
name|Procedure
name|overflow
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* what to do on over/underflow */
name|signal
argument_list|(
name|sig
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NO_SIG*/
end_comment

begin_decl_stmt
name|int
name|V
init|=
literal|0
decl_stmt|,
comment|/* verbose */
name|L
init|=
literal|0
decl_stmt|,
comment|/* produce limits.h */
name|F
init|=
literal|0
decl_stmt|,
comment|/* produce float.h  */
name|bugs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of (possible) bugs in the output */
end_comment

begin_decl_stmt
name|char
name|co
index|[
literal|4
index|]
decl_stmt|,
name|oc
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Comment starter and ender symbols */
end_comment

begin_decl_stmt
name|int
name|bits_per_byte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the number of bits per unit returned by sizeof() */
end_comment

begin_decl_stmt
name|int
name|flt_rounds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The calculated value of FLT_ROUNDS */
end_comment

begin_decl_stmt
name|int
name|flt_radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The calculated value of FLT_RADIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Set the fp modes on a SUN with 68881 chip, to check that different    rounding modes etc. get properly detected.    Compile with -f68881 for cc, -m68881 for gcc, and with additional flag    -DTEST. Run with additional parameter +hex-number, to set the 68881 mode    register to hex-number */
end_comment

begin_comment
comment|/* Bits 0x30 = rounding mode */
end_comment

begin_define
define|#
directive|define
name|ROUND_BITS
value|0x30
end_define

begin_define
define|#
directive|define
name|TO_NEAREST
value|0x00
end_define

begin_define
define|#
directive|define
name|TO_ZERO
value|0x10
end_define

begin_define
define|#
directive|define
name|TO_MINUS_INF
value|0x20
end_define

begin_define
define|#
directive|define
name|TO_PLUS_INF
value|0x30
end_define

begin_comment
comment|/* The SUN FP user's guide seems to be wrong here */
end_comment

begin_comment
comment|/* Bits 0xc0 = extended rounding */
end_comment

begin_define
define|#
directive|define
name|EXT_BITS
value|0xc0
end_define

begin_define
define|#
directive|define
name|ROUND_EXTENDED
value|0x00
end_define

begin_define
define|#
directive|define
name|ROUND_SINGLE
value|0x40
end_define

begin_define
define|#
directive|define
name|ROUND_DOUBLE
value|0x80
end_define

begin_comment
comment|/* Enabled traps */
end_comment

begin_define
define|#
directive|define
name|EXE_INEX1
value|0x100
end_define

begin_define
define|#
directive|define
name|EXE_INEX2
value|0x200
end_define

begin_define
define|#
directive|define
name|EXE_DZ
value|0x400
end_define

begin_define
define|#
directive|define
name|EXE_UNFL
value|0x800
end_define

begin_define
define|#
directive|define
name|EXE_OVFL
value|0x1000
end_define

begin_define
define|#
directive|define
name|EXE_OPERR
value|0x2000
end_define

begin_define
define|#
directive|define
name|EXE_SNAN
value|0x4000
end_define

begin_define
define|#
directive|define
name|EXE_BSUN
value|0x8000
end_define

begin_comment
comment|/* Only used for testing, on a Sun with 68881 chip */
end_comment

begin_comment
comment|/* Print the FP mode */
end_comment

begin_macro
name|printmode
argument_list|(
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|new
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fpmode_
argument_list|(
operator|&
name|new
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"New fp mode:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Round toward "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new
operator|&
name|ROUND_BITS
condition|)
block|{
case|case
name|TO_NEAREST
case|:
name|printf
argument_list|(
literal|"nearest"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TO_ZERO
case|:
name|printf
argument_list|(
literal|"zero"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TO_MINUS_INF
case|:
name|printf
argument_list|(
literal|"minus infinity"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TO_PLUS_INF
case|:
name|printf
argument_list|(
literal|"plus infinity"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n  Extended rounding precision: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new
operator|&
name|EXT_BITS
condition|)
block|{
case|case
name|ROUND_EXTENDED
case|:
name|printf
argument_list|(
literal|"extended"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROUND_SINGLE
case|:
name|printf
argument_list|(
literal|"single"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROUND_DOUBLE
case|:
name|printf
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n  Enabled exceptions:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_INEX1
condition|)
name|printf
argument_list|(
literal|" inex1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_INEX2
condition|)
name|printf
argument_list|(
literal|" inex2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_DZ
condition|)
name|printf
argument_list|(
literal|" dz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_UNFL
condition|)
name|printf
argument_list|(
literal|" unfl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_OVFL
condition|)
name|printf
argument_list|(
literal|" ovfl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_OPERR
condition|)
name|printf
argument_list|(
literal|" operr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_SNAN
condition|)
name|printf
argument_list|(
literal|" snan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_BSUN
condition|)
name|printf
argument_list|(
literal|" bsun"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Only used for testing, on a Sun with 68881 chip */
end_comment

begin_comment
comment|/* Set the FP mode */
end_comment

begin_function
name|int
name|setmode
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|mode
init|=
literal|0
decl_stmt|,
name|dig
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|dig
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|dig
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|dig
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|1
return|;
name|mode
operator|=
name|mode
operator|<<
literal|4
operator||
name|dig
expr_stmt|;
block|}
name|printmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setmode
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't set mode: not compiled with TEST\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Procedure
name|farewell
parameter_list|(
name|bugs
parameter_list|)
name|int
name|bugs
decl_stmt|;
block|{
if|if
condition|(
name|bugs
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%sFor hints on dealing with the "
argument_list|,
name|co
argument_list|)
expr_stmt|;
if|if
condition|(
name|bugs
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"problem"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d problems"
argument_list|,
name|bugs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" above\n   see the section 'TROUBLESHOOTING' in the file "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
name|FILENAME
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|bugs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The program has received a signal where it wasn't expecting one */
end_comment

begin_function
name|Procedure
name|croak
parameter_list|(
name|place
parameter_list|)
name|int
name|place
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"*** Unexpected signal at point %d\n"
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|farewell
argument_list|(
name|bugs
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* An exit isn't essential here, but avoids loops */
block|}
end_function

begin_comment
comment|/* This is here in case alloca.c is used, which calls this.  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Virtual memory exceeded\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|bugs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_decl_stmt
name|int
name|maxint
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|maximum_int
parameter_list|()
block|{
comment|/* Find the maximum integer */
name|Volatile
name|int
name|newi
decl_stmt|,
name|int_max
decl_stmt|,
name|two
init|=
literal|2
decl_stmt|;
comment|/* Calculate maxint ***********************************/
comment|/* Calculate 2**n-1 until overflow - then use the previous value  */
name|newi
operator|=
literal|1
expr_stmt|;
name|int_max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields int_max */
while|while
condition|(
name|newi
operator|>
name|int_max
condition|)
block|{
name|int_max
operator|=
name|newi
expr_stmt|;
name|newi
operator|=
name|newi
operator|*
name|two
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|int_max
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|dprec
decl_stmt|,
name|fprec
decl_stmt|,
name|lprec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|bad
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGFPE
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGOVER
name|signal
argument_list|(
name|SIGOVER
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Add more calls as necessary */
name|Unexpected
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
operator|(
name|s
operator|++
operator|)
condition|)
block|{
case|case
literal|'v'
case|:
name|V
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|L
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|F
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|bad
operator|=
name|setmode
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-vlf]\n  v=Verbose l=Limits.h f=Float.h\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|L
operator|||
name|F
condition|)
block|{
name|co
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|oc
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|co
index|[
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|oc
index|[
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|co
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
name|oc
index|[
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
name|co
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|oc
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|co
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|oc
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|V
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|L
condition|)
name|printf
argument_list|(
literal|"%slimits.h%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|printf
argument_list|(
literal|"%sfloat.h%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
block|{
name|printf
argument_list|(
literal|"#ifndef _FLOAT_H___\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define _FLOAT_H___\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYS_FLOAT_H_WRAP
condition|)
name|printf
argument_list|(
literal|"#include_next<float.h>\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ID
name|printf
argument_list|(
literal|"%sProduced on %s by enquire version %s, CWI, Amsterdam%s\n"
argument_list|,
name|co
argument_list|,
name|ID
argument_list|,
name|VERSION
argument_list|,
name|oc
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%sProduced by enquire version %s, CWI, Amsterdam%s\n"
argument_list|,
name|co
argument_list|,
name|VERSION
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VERIFY
name|printf
argument_list|(
literal|"%sVerification phase%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_SIG
name|Vprintf
argument_list|(
literal|"%sCompiled without signal(): %s%s\n"
argument_list|,
name|co
argument_list|,
literal|"there's nothing that can be done if overflow occurs"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_SC
name|Vprintf
argument_list|(
literal|"%sCompiled without signed char%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_UC
name|Vprintf
argument_list|(
literal|"%Compiled without unsigned char%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_UI
name|Vprintf
argument_list|(
literal|"%Compiled without unsigned short or long%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__STDC__
name|Vprintf
argument_list|(
literal|"%sCompiler claims to be ANSI C level %d%s\n"
argument_list|,
name|co
argument_list|,
name|__STDC__
argument_list|,
name|oc
argument_list|)
expr_stmt|;
else|#
directive|else
name|Vprintf
argument_list|(
literal|"%sCompiler does not claim to be ANSI C%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|check_defines
argument_list|()
expr_stmt|;
name|maxint
operator|=
name|maximum_int
argument_list|()
expr_stmt|;
name|bits_per_byte
operator|=
name|basic
argument_list|()
expr_stmt|;
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
operator|||
name|V
condition|)
block|{
name|fprec
operator|=
name|fprop
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
name|dprec
operator|=
name|dprop
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
name|lprec
operator|=
name|ldprop
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
name|efprop
argument_list|(
name|fprec
argument_list|,
name|dprec
argument_list|,
name|lprec
argument_list|)
expr_stmt|;
name|edprop
argument_list|(
name|fprec
argument_list|,
name|dprec
argument_list|,
name|lprec
argument_list|)
expr_stmt|;
name|eldprop
argument_list|(
name|fprec
argument_list|,
name|dprec
argument_list|,
name|lprec
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_MEM
if|if
condition|(
name|V
condition|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|long
name|total
decl_stmt|;
comment|/* An extra goody: the approximate amount of data-space */
comment|/* Allocate store until no more available */
comment|/* Different implementations have a different argument type 		   to malloc. Here we assume that it's the same type as 		   that which sizeof() returns */
name|size
operator|=
literal|1
operator|<<
operator|(
operator|(
name|bits_per_byte
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|2
operator|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|malloc
argument_list|(
operator|(
name|false
argument_list|()
condition|?
sizeof|sizeof
argument_list|(
name|int
argument_list|)
else|:
name|size
operator|)
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|total
operator|+=
operator|(
name|size
operator|/
literal|2
operator|)
expr_stmt|;
block|}
name|size
operator|/=
literal|2
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sMemory allocable ~= %ld Kbytes%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|total
operator|+
literal|511
operator|)
operator|/
literal|512
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|F
condition|)
block|{
name|printf
argument_list|(
literal|"#endif %s _FLOAT_H___%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|farewell
argument_list|(
name|bugs
argument_list|)
expr_stmt|;
return|return
name|bugs
return|;
comment|/* To keep compilers and lint happy */
block|}
end_function

begin_function
name|Procedure
name|eek_a_bug
parameter_list|(
name|problem
parameter_list|)
name|char
modifier|*
name|problem
decl_stmt|;
block|{
comment|/* The program has discovered a problem */
name|printf
argument_list|(
literal|"\n%s*** WARNING: %s%s\n"
argument_list|,
name|co
argument_list|,
name|problem
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Procedure
name|describe
parameter_list|(
name|description
parameter_list|,
name|extra
parameter_list|)
name|char
modifier|*
name|description
decl_stmt|,
decl|*
name|extra
decl_stmt|;
end_function

begin_block
block|{
comment|/* Produce the description for a #define */
name|printf
argument_list|(
literal|"   %s"
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|description
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Procedure
name|i_define
parameter_list|(
name|desc
parameter_list|,
name|extra
parameter_list|,
name|sort
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|,
name|lim
parameter_list|,
name|req
parameter_list|,
name|mark
parameter_list|)
name|char
modifier|*
name|desc
decl_stmt|,
decl|*
name|extra
decl_stmt|,
modifier|*
name|sort
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|val
decl_stmt|,
name|lim
decl_stmt|,
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mark
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|SYS_FLOAT_H_WRAP
operator|&&
name|F
operator|&&
name|val
operator|==
name|req
condition|)
return|return;
comment|/* Produce a #define for a signed int type */
name|describe
argument_list|(
name|desc
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#undef %s%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"#define %s%s %ld%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|+
name|lim
operator|<
literal|0
condition|)
block|{
comment|/* We may not produce a constant like -1024 if the max 		   allowable value is 1023. It has then to be output as 		   -1023-1. lim is the max allowable value.  */
name|printf
argument_list|(
literal|"#define %s%s (%ld%s%ld%s)\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
operator|-
name|lim
argument_list|,
name|mark
argument_list|,
name|val
operator|+
name|lim
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"#define %s%s (%ld%s)\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERIFY
if|if
condition|(
name|val
operator|!=
name|req
condition|)
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n"
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       Compiler has %ld for value%s\n\n"
argument_list|,
name|req
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Procedure
name|u_define
parameter_list|(
name|desc
parameter_list|,
name|extra
parameter_list|,
name|sort
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|mark
parameter_list|)
name|char
modifier|*
name|desc
decl_stmt|,
decl|*
name|extra
decl_stmt|,
modifier|*
name|sort
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|long
name|val
decl_stmt|,
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mark
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Produce a #define for an unsigned value */
name|describe
argument_list|(
name|desc
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#undef %s%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define %s%s %lu%s%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|U
argument_list|,
name|mark
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
if|if
condition|(
name|val
operator|!=
name|req
condition|)
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n"
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       Compiler has %lu for value%s\n\n"
argument_list|,
name|req
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Procedure
name|f_define
parameter_list|(
name|desc
parameter_list|,
name|extra
parameter_list|,
name|sort
parameter_list|,
name|name
parameter_list|,
name|precision
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|mark
parameter_list|)
name|char
modifier|*
name|desc
decl_stmt|,
decl|*
name|extra
decl_stmt|,
modifier|*
name|sort
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|precision
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Long_double
name|val
decl_stmt|,
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mark
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|SYS_FLOAT_H_WRAP
operator|&&
name|F
operator|&&
name|val
operator|==
name|req
condition|)
return|return;
comment|/* Produce a #define for a float/double/long double */
name|describe
argument_list|(
name|desc
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#undef %s%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdc
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_LONG_DOUBLE_IO
specifier|static
name|int
name|union_defined
init|=
literal|0
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|sort
argument_list|,
literal|"LDBL"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|union_defined
condition|)
block|{
name|printf
argument_list|(
literal|"#ifndef __LDBL_UNION__\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define __LDBL_UNION__\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"union __convert_long_double {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  unsigned __convert_long_double_i[4];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  long double __convert_long_double_d;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|union_defined
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"#define %s%s %s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|fake_f_rep
argument_list|(
literal|"long double"
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"#define %s%s %s%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
name|val
argument_list|)
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"#define %s%s %s%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
name|val
argument_list|)
argument_list|,
name|mark
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|mark
operator|==
literal|'F'
condition|)
block|{
comment|/* non-ANSI C has no float constants, so cast the constant */
name|printf
argument_list|(
literal|"#define %s%s ((float)%s)\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"#define %s%s %s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|floor_log
parameter_list|(
name|base
parameter_list|,
name|x
parameter_list|)
name|int
name|base
decl_stmt|;
name|Long_double
name|x
decl_stmt|;
block|{
comment|/* return floor(log base(x)) */
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|>=
name|base
condition|)
block|{
name|r
operator|++
expr_stmt|;
name|x
operator|/=
name|base
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|ceil_log
parameter_list|(
name|base
parameter_list|,
name|x
parameter_list|)
name|int
name|base
decl_stmt|;
name|Long_double
name|x
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|>
literal|1.0
condition|)
block|{
name|r
operator|++
expr_stmt|;
name|x
operator|/=
name|base
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|exponent
parameter_list|(
name|x
parameter_list|,
name|fract
parameter_list|,
name|exp
parameter_list|)
name|Long_double
name|x
decl_stmt|;
name|double
modifier|*
name|fract
decl_stmt|;
name|int
modifier|*
name|exp
decl_stmt|;
block|{
comment|/* Split x into a fraction and a power of ten; 	   returns 0 if x is unusable, 1 otherwise. 	   Only used for error messages about faulty output. 	*/
name|int
name|r
init|=
literal|0
decl_stmt|,
name|neg
init|=
literal|0
decl_stmt|;
name|Long_double
name|old
decl_stmt|;
operator|*
name|fract
operator|=
literal|0.0
expr_stmt|;
operator|*
name|exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0.0
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|neg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0.0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|>=
literal|10.0
condition|)
block|{
while|while
condition|(
name|x
operator|>=
literal|10.0
condition|)
block|{
name|old
operator|=
name|x
expr_stmt|;
name|r
operator|++
expr_stmt|;
name|x
operator|/=
literal|10.0
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|x
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|x
operator|<
literal|1.0
condition|)
block|{
name|old
operator|=
name|x
expr_stmt|;
name|r
operator|--
expr_stmt|;
name|x
operator|*=
literal|10.0
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|x
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|neg
condition|)
operator|*
name|fract
operator|=
operator|(
name|double
operator|)
operator|-
name|x
expr_stmt|;
else|else
operator|*
name|fract
operator|=
operator|(
name|double
operator|)
name|x
expr_stmt|;
operator|*
name|exp
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a value of type TYPE with value VAL,    assuming that sprintf can't handle this type properly (without truncation).    We create an expression that uses type casting to create the value from    a bit pattern.  */
end_comment

begin_function
name|char
modifier|*
name|fake_f_rep
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
name|Long_double
name|val
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
union|union
block|{
name|unsigned
name|int
name|i
index|[
literal|4
index|]
decl_stmt|;
name|Long_double
name|ld
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|u
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|u
operator|.
name|i
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|ld
operator|=
name|val
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(__extension__ ((union __convert_long_double) {__convert_long_double_i: {0x%x, 0x%x, 0x%x, 0x%x}}).__convert_long_double_d)"
argument_list|,
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|2
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|f_rep
parameter_list|(
name|precision
parameter_list|,
name|val
parameter_list|)
name|int
name|precision
decl_stmt|;
name|Long_double
name|val
decl_stmt|;
block|{
comment|/* Return the floating representation of val */
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_LONG_DOUBLE_IO
if|if
condition|(
literal|1
condition|)
else|#
directive|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|double
name|d
init|=
name|val
decl_stmt|;
comment|/* Assume they're the same, and use non-stdc format */
comment|/* This is for stdc compilers using non-stdc libraries */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*e"
argument_list|,
name|precision
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It had better support Le then */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*Le"
argument_list|,
name|precision
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|Procedure
name|bitpattern
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
comment|/* Printf the bit-pattern of p */
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|size
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bits_per_byte
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|c
operator|>>
name|j
operator|)
operator|&
literal|1
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|size
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|Order
parameter_list|(
name|x
parameter_list|,
name|px
parameter_list|,
name|mode
parameter_list|)
define|\
value|printf("%s%s ", co, mode); for (i=0; i<sizeof(x); i++) px[i]= ab[i]; \    for (i=1; i<=sizeof(x); i++) { c=((x>>(bits_per_byte*(sizeof(x)-i)))&mask);\       putchar(c==0 ? '?' : (char)c); }\    printf("%s\n", oc);
end_define

begin_function
name|Procedure
name|endian
parameter_list|(
name|bits_per_byte
parameter_list|)
name|int
name|bits_per_byte
decl_stmt|;
block|{
comment|/* Printf the byte-order used on this machine */
comment|/*unsigned*/
name|short
name|s
init|=
literal|0
decl_stmt|;
comment|/*unsigned*/
name|int
name|j
init|=
literal|0
decl_stmt|;
comment|/*unsigned*/
name|long
name|l
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ps
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|s
decl_stmt|,
modifier|*
name|pj
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|j
decl_stmt|,
modifier|*
name|pl
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l
decl_stmt|,
modifier|*
name|ab
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|(
name|unsigned
operator|)
name|bits_per_byte
condition|;
name|i
operator|++
control|)
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
if|if
condition|(
name|V
condition|)
block|{
name|printf
argument_list|(
literal|"%sCHARACTER ORDER%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Order
argument_list|(
name|s
argument_list|,
name|ps
argument_list|,
literal|"short:"
argument_list|)
expr_stmt|;
name|Order
argument_list|(
name|j
argument_list|,
name|pj
argument_list|,
literal|"int:  "
argument_list|)
expr_stmt|;
name|Order
argument_list|(
name|l
argument_list|,
name|pl
argument_list|,
literal|"long: "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Procedure
name|missing
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s*** #define %s missing from limits.h%s\n"
argument_list|,
name|co
argument_list|,
name|s
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Procedure
name|fmissing
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s*** #define %s missing from float.h%s\n"
argument_list|,
name|co
argument_list|,
name|s
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* To try and fool optimisers */
end_comment

begin_function
name|int
name|false
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Promoted
parameter_list|(
name|x
parameter_list|)
value|(false()?(x):(-1))
end_define

begin_define
define|#
directive|define
name|is_signed
parameter_list|(
name|x
parameter_list|)
value|(Promoted(x)< 0)
end_define

begin_define
define|#
directive|define
name|sign_of
parameter_list|(
name|x
parameter_list|)
value|((x)?"signed":"unsigned")
end_define

begin_define
define|#
directive|define
name|Signed
value|1
end_define

begin_define
define|#
directive|define
name|Unsigned
value|0
end_define

begin_define
define|#
directive|define
name|sgn
parameter_list|(
name|x
parameter_list|)
value|((is_signed(x))?Signed:Unsigned)
end_define

begin_define
define|#
directive|define
name|showtype
parameter_list|(
name|t
parameter_list|,
name|x
parameter_list|)
value|Vprintf("%s%s %s %s%s\n", co, t, sign_of(is_signed(x)), type_of(sizeof(x)), oc)
end_define

begin_function
name|char
modifier|*
name|type_of
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
literal|"char/short/int"
return|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
return|return
literal|"char/short"
return|;
return|return
literal|"char"
return|;
block|}
if|if
condition|(
name|x
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
literal|"short/int"
return|;
return|return
literal|"short"
return|;
block|}
if|if
condition|(
name|x
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
return|return
literal|"int/long"
return|;
return|return
literal|"int"
return|;
block|}
if|if
condition|(
name|x
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
return|return
literal|"long"
return|;
return|return
literal|"unknown-type"
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ftype_of
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
block|{
return|return
literal|"float"
return|;
block|}
if|if
condition|(
name|x
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
condition|)
return|return
literal|"(long)double"
return|;
return|return
literal|"double"
return|;
block|}
if|if
condition|(
name|x
operator|==
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
condition|)
block|{
return|return
literal|"long double"
return|;
block|}
return|return
literal|"unknown-type"
return|;
block|}
end_function

begin_function
name|Procedure
name|typerr
parameter_list|(
name|name
parameter_list|,
name|esign
parameter_list|,
name|esize
parameter_list|,
name|sign
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|esign
decl_stmt|,
name|esize
decl_stmt|,
name|sign
decl_stmt|,
name|size
decl_stmt|;
block|{
name|Vprintf
argument_list|(
literal|"*** %s has wrong type: expected %s %s, found %s %s\n"
argument_list|,
name|name
argument_list|,
name|sign_of
argument_list|(
name|esign
argument_list|)
argument_list|,
name|type_of
argument_list|(
name|esize
argument_list|)
argument_list|,
name|sign_of
argument_list|(
name|sign
argument_list|)
argument_list|,
name|type_of
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Procedure
name|ftyperr
parameter_list|(
name|name
parameter_list|,
name|esize
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|esize
decl_stmt|,
name|size
decl_stmt|;
block|{
name|Vprintf
argument_list|(
literal|"*** %s has wrong type: expected %s, found %s\n"
argument_list|,
name|name
argument_list|,
name|ftype_of
argument_list|(
name|esize
argument_list|)
argument_list|,
name|ftype_of
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|promotions
parameter_list|()
block|{
name|int
name|si
init|=
literal|0
decl_stmt|;
name|long
name|sl
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|short
name|ss
decl_stmt|;
name|unsigned
name|short
name|us
decl_stmt|;
name|Vprintf
argument_list|(
literal|"\n%sPROMOTIONS%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* Possible warnings here; no problem */
operator|(
sizeof|sizeof
argument_list|(
name|Promoted
argument_list|(
name|si
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|Promoted
argument_list|(
name|sl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|Promoted
argument_list|(
name|ss
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|Promoted
argument_list|(
name|ui
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|Promoted
argument_list|(
name|ul
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|Promoted
argument_list|(
name|us
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|||
name|is_signed
argument_list|(
name|ui
argument_list|)
operator|||
name|is_signed
argument_list|(
name|ul
argument_list|)
operator|||
operator|!
name|is_signed
argument_list|(
name|si
argument_list|)
operator|||
operator|!
name|is_signed
argument_list|(
name|sl
argument_list|)
condition|)
block|{
name|eek_a_bug
argument_list|(
literal|"promotions don't work properly in conditional expressions\n"
argument_list|)
expr_stmt|;
block|}
name|showtype
argument_list|(
literal|"unsigned short promotes to"
argument_list|,
name|Promoted
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|showtype
argument_list|(
literal|"long+unsigned gives"
argument_list|,
name|sl
operator|+
name|ui
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|checktype
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
value|if((sgn(x)!=s)||(sizeof(x)!=sizeof(t))) typerr(n, s, sizeof(t), sign_of(x), sizeof(x));
end_define

begin_define
define|#
directive|define
name|fchecktype
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|if (sizeof(x) != sizeof(t)) ftyperr(n, sizeof(x), sizeof(t));
end_define

begin_function
name|Procedure
name|check_defines
parameter_list|()
block|{
comment|/* ensure that all #defines are present and have the correct type */
ifdef|#
directive|ifdef
name|VERIFY
name|int
name|usign
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_UI
name|usign
operator|=
name|Signed
expr_stmt|;
else|#
directive|else
comment|/* Implementations promote unsigned short differently */
name|usign
operator|=
name|is_signed
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|L
condition|)
block|{
ifdef|#
directive|ifdef
name|CHAR_BIT
name|checktype
argument_list|(
name|CHAR_BIT
argument_list|,
literal|"CHAR_BIT"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"CHAR_BIT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CHAR_MAX
name|checktype
argument_list|(
name|CHAR_MAX
argument_list|,
literal|"CHAR_MAX"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"CHAR_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CHAR_MIN
name|checktype
argument_list|(
name|CHAR_MIN
argument_list|,
literal|"CHAR_MIN"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"CHAR_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCHAR_MAX
name|checktype
argument_list|(
name|SCHAR_MAX
argument_list|,
literal|"SCHAR_MAX"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"SCHAR_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCHAR_MIN
name|checktype
argument_list|(
name|SCHAR_MIN
argument_list|,
literal|"SCHAR_MIN"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"SCHAR_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UCHAR_MAX
name|checktype
argument_list|(
name|UCHAR_MAX
argument_list|,
literal|"UCHAR_MAX"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"UCHAR_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHRT_MAX
name|checktype
argument_list|(
name|SHRT_MAX
argument_list|,
literal|"SHRT_MAX"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"SHRT_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHRT_MIN
name|checktype
argument_list|(
name|SHRT_MIN
argument_list|,
literal|"SHRT_MIN"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"SHRT_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INT_MAX
name|checktype
argument_list|(
name|INT_MAX
argument_list|,
literal|"INT_MAX"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"INT_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INT_MIN
name|checktype
argument_list|(
name|INT_MIN
argument_list|,
literal|"INT_MIN"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"INT_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LONG_MAX
name|checktype
argument_list|(
name|LONG_MAX
argument_list|,
literal|"LONG_MAX"
argument_list|,
name|Signed
argument_list|,
name|long
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"LONG_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LONG_MIN
name|checktype
argument_list|(
name|LONG_MIN
argument_list|,
literal|"LONG_MIN"
argument_list|,
name|Signed
argument_list|,
name|long
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"LONG_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USHRT_MAX
name|checktype
argument_list|(
name|USHRT_MAX
argument_list|,
literal|"USHRT_MAX"
argument_list|,
name|usign
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"USHRT_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UINT_MAX
name|checktype
argument_list|(
name|UINT_MAX
argument_list|,
literal|"UINT_MAX"
argument_list|,
name|Unsigned
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"UINT_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ULONG_MAX
name|checktype
argument_list|(
name|ULONG_MAX
argument_list|,
literal|"ULONG_MAX"
argument_list|,
name|Unsigned
argument_list|,
name|long
argument_list|)
expr_stmt|;
else|#
directive|else
name|missing
argument_list|(
literal|"ULONG_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* if (L) */
if|if
condition|(
name|F
condition|)
block|{
ifdef|#
directive|ifdef
name|FLT_RADIX
name|checktype
argument_list|(
name|FLT_RADIX
argument_list|,
literal|"FLT_RADIX"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_RADIX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_MANT_DIG
name|checktype
argument_list|(
name|FLT_MANT_DIG
argument_list|,
literal|"FLT_MANT_DIG"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_MANT_DIG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_DIG
name|checktype
argument_list|(
name|FLT_DIG
argument_list|,
literal|"FLT_DIG"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_DIG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_ROUNDS
name|checktype
argument_list|(
name|FLT_ROUNDS
argument_list|,
literal|"FLT_ROUNDS"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_ROUNDS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_EPSILON
name|fchecktype
argument_list|(
name|FLT_EPSILON
argument_list|,
literal|"FLT_EPSILON"
argument_list|,
name|float
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_EPSILON"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_MIN_EXP
name|checktype
argument_list|(
name|FLT_MIN_EXP
argument_list|,
literal|"FLT_MIN_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_MIN_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_MIN
name|fchecktype
argument_list|(
name|FLT_MIN
argument_list|,
literal|"FLT_MIN"
argument_list|,
name|float
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_MIN_10_EXP
name|checktype
argument_list|(
name|FLT_MIN_10_EXP
argument_list|,
literal|"FLT_MIN_10_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_MIN_10_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_MAX_EXP
name|checktype
argument_list|(
name|FLT_MAX_EXP
argument_list|,
literal|"FLT_MAX_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_MAX_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_MAX
name|fchecktype
argument_list|(
name|FLT_MAX
argument_list|,
literal|"FLT_MAX"
argument_list|,
name|float
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLT_MAX_10_EXP
name|checktype
argument_list|(
name|FLT_MAX_10_EXP
argument_list|,
literal|"FLT_MAX_10_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"FLT_MAX_10_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_MANT_DIG
name|checktype
argument_list|(
name|DBL_MANT_DIG
argument_list|,
literal|"DBL_MANT_DIG"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_MANT_DIG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_DIG
name|checktype
argument_list|(
name|DBL_DIG
argument_list|,
literal|"DBL_DIG"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_DIG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_EPSILON
name|fchecktype
argument_list|(
name|DBL_EPSILON
argument_list|,
literal|"DBL_EPSILON"
argument_list|,
name|double
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_EPSILON"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_MIN_EXP
name|checktype
argument_list|(
name|DBL_MIN_EXP
argument_list|,
literal|"DBL_MIN_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_MIN_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_MIN
name|fchecktype
argument_list|(
name|DBL_MIN
argument_list|,
literal|"DBL_MIN"
argument_list|,
name|double
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_MIN_10_EXP
name|checktype
argument_list|(
name|DBL_MIN_10_EXP
argument_list|,
literal|"DBL_MIN_10_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_MIN_10_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_MAX_EXP
name|checktype
argument_list|(
name|DBL_MAX_EXP
argument_list|,
literal|"DBL_MAX_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_MAX_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_MAX
name|fchecktype
argument_list|(
name|DBL_MAX
argument_list|,
literal|"DBL_MAX"
argument_list|,
name|double
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBL_MAX_10_EXP
name|checktype
argument_list|(
name|DBL_MAX_10_EXP
argument_list|,
literal|"DBL_MAX_10_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"DBL_MAX_10_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STDC
ifdef|#
directive|ifdef
name|LDBL_MANT_DIG
name|checktype
argument_list|(
name|LDBL_MANT_DIG
argument_list|,
literal|"LDBL_MANT_DIG"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_MANT_DIG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_DIG
name|checktype
argument_list|(
name|LDBL_DIG
argument_list|,
literal|"LDBL_DIG"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_DIG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_EPSILON
name|fchecktype
argument_list|(
argument|LDBL_EPSILON
argument_list|,
literal|"LDBL_EPSILON"
argument_list|,
argument|long double
argument_list|)
empty_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_EPSILON"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_MIN_EXP
name|checktype
argument_list|(
name|LDBL_MIN_EXP
argument_list|,
literal|"LDBL_MIN_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_MIN_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_MIN
name|fchecktype
argument_list|(
argument|LDBL_MIN
argument_list|,
literal|"LDBL_MIN"
argument_list|,
argument|long double
argument_list|)
empty_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_MIN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_MIN_10_EXP
name|checktype
argument_list|(
name|LDBL_MIN_10_EXP
argument_list|,
literal|"LDBL_MIN_10_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_MIN_10_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_MAX_EXP
name|checktype
argument_list|(
name|LDBL_MAX_EXP
argument_list|,
literal|"LDBL_MAX_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_MAX_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_MAX
name|fchecktype
argument_list|(
argument|LDBL_MAX
argument_list|,
literal|"LDBL_MAX"
argument_list|,
argument|long double
argument_list|)
empty_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_MAX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LDBL_MAX_10_EXP
name|checktype
argument_list|(
name|LDBL_MAX_10_EXP
argument_list|,
literal|"LDBL_MAX_10_EXP"
argument_list|,
name|Signed
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|fmissing
argument_list|(
literal|"LDBL_MAX_10_EXP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* STDC */
block|}
comment|/* if (F) */
endif|#
directive|endif
comment|/* VERIFY */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|SCHAR_MAX
value|char_max
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SCHAR_MIN
end_ifndef

begin_define
define|#
directive|define
name|SCHAR_MIN
value|char_min
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|char_max
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERIFY */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|char_bit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|CHAR_MAX
value|char_max
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_MIN
end_ifndef

begin_define
define|#
directive|define
name|CHAR_MIN
value|char_min
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|SCHAR_MAX
value|char_max
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SCHAR_MIN
end_ifndef

begin_define
define|#
directive|define
name|SCHAR_MIN
value|char_min
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|char_max
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cprop
parameter_list|()
block|{
comment|/* Properties of type char */
name|Volatile
name|char
name|c
decl_stmt|,
name|char_max
decl_stmt|,
name|char_min
decl_stmt|;
name|Volatile
name|int
name|bits_per_byte
decl_stmt|,
name|c_signed
decl_stmt|;
name|long
name|char_bit
decl_stmt|;
name|Unexpected
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Calculate number of bits per character *************************/
name|c
operator|=
literal|1
expr_stmt|;
name|bits_per_byte
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
name|c
operator|<<
literal|1
expr_stmt|;
name|bits_per_byte
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
name|c
operator|=
call|(
name|char
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|c
operator|)
operator|<
literal|0
condition|)
name|c_signed
operator|=
literal|1
expr_stmt|;
else|else
name|c_signed
operator|=
literal|0
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%schar = %d bits, %ssigned%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|c
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|c_signed
condition|?
literal|""
else|:
literal|"un"
operator|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|char_bit
operator|=
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|c
argument_list|)
operator|*
name|bits_per_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
name|i_define
argument_list|(
name|D_CHAR_BIT
argument_list|,
literal|""
argument_list|,
literal|"CHAR"
argument_list|,
literal|"_BIT"
argument_list|,
name|char_bit
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|CHAR_BIT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|char_max
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|bits_per_byte
operator|<=
literal|16
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_max */
while|while
condition|(
name|c
operator|>
name|char_max
condition|)
block|{
name|char_max
operator|=
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sCharacter overflow generates a trap!%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
name|char_min
operator|=
literal|0
expr_stmt|;
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_min */
while|while
condition|(
name|c
operator|<
name|char_min
condition|)
block|{
name|char_min
operator|=
name|c
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* An exhaustive search here is impracticable ;-)  */
name|c
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits_per_byte
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|char_max
operator|=
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
name|char_max
condition|)
name|char_max
operator|=
operator|~
literal|0
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|char_min
operator|=
literal|0
expr_stmt|;
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|char_min
condition|)
block|{
name|c
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits_per_byte
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|c
operator|=
operator|-
name|c
expr_stmt|;
name|char_min
operator|=
name|c
expr_stmt|;
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|char_min
condition|)
name|char_min
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c_signed
operator|&&
name|char_min
operator|==
literal|0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sBEWARE! Chars are pseudo-unsigned:%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%s   %s%s%s\n"
argument_list|,
literal|"They contain only nonnegative values, "
argument_list|,
literal|"but sign extend when used as integers."
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
block|{
comment|/* Because of the integer promotions, you must use a U after 		   the MAX_CHARS in the following cases */
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|&&
operator|!
name|c_signed
condition|)
block|{
name|u_define
argument_list|(
name|D_CHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"CHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|CHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i_define
argument_list|(
name|D_CHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"CHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|CHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|i_define
argument_list|(
name|D_CHAR_MIN
argument_list|,
literal|""
argument_list|,
literal|"CHAR"
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|char_min
argument_list|,
operator|(
name|long
operator|)
name|maxint
argument_list|,
operator|(
name|long
operator|)
name|CHAR_MIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_signed
condition|)
block|{
name|i_define
argument_list|(
name|D_SCHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"SCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
name|D_SCHAR_MIN
argument_list|,
literal|""
argument_list|,
literal|"SCHAR"
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|char_min
argument_list|,
operator|(
name|long
operator|)
name|maxint
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|u_define
argument_list|(
name|D_UCHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"UCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|UCHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i_define
argument_list|(
name|D_UCHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"UCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|UCHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c_signed
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_UC
name|Volatile
name|unsigned
name|char
name|c
decl_stmt|,
name|char_max
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|char_max
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_max */
while|while
condition|(
name|c
operator|>
name|char_max
condition|)
block|{
name|char_max
operator|=
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|u_define
argument_list|(
name|D_UCHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"UCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|UCHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i_define
argument_list|(
name|D_UCHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"UCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|UCHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_SC
comment|/* Define NO_SC if this gives a syntax error */
name|Volatile
name|signed
name|char
name|c
decl_stmt|,
name|char_max
decl_stmt|,
name|char_min
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|char_max
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_max */
while|while
condition|(
name|c
operator|>
name|char_max
condition|)
block|{
name|char_max
operator|=
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
name|c
operator|=
literal|0
expr_stmt|;
name|char_min
operator|=
literal|0
expr_stmt|;
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_min */
while|while
condition|(
name|c
operator|<
name|char_min
condition|)
block|{
name|char_min
operator|=
name|c
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
name|D_SCHAR_MIN
argument_list|,
literal|""
argument_list|,
literal|"SCHAR"
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|char_min
argument_list|,
operator|(
name|long
operator|)
name|maxint
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
name|D_SCHAR_MAX
argument_list|,
literal|""
argument_list|,
literal|"SCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MAX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NO_SC */
block|}
block|}
return|return
name|bits_per_byte
return|;
block|}
end_function

begin_function
name|int
name|basic
parameter_list|()
block|{
comment|/* The properties of the basic types. 	   Returns number of bits per sizeof unit */
name|Volatile
name|int
name|bits_per_byte
decl_stmt|;
typedef|typedef
name|int
name|function
parameter_list|()
function_decl|;
name|int
name|variable
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|Vprintf
argument_list|(
literal|"%sSIZES%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bits_per_byte
operator|=
name|cprop
argument_list|()
expr_stmt|;
comment|/* Shorts, ints and longs *****************************************/
name|Vprintf
argument_list|(
literal|"%sshort=%d int=%d long=%d float=%d double=%d bits %s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdc
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%slong double=%d bits%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%schar*=%d bits%s%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|?
literal|" BEWARE! larger than int!"
else|:
literal|""
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sint* =%d bits%s%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|?
literal|" BEWARE! larger than int!"
else|:
literal|""
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sfunc*=%d bits%s%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|function
operator|*
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|function
operator|*
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|?
literal|" BEWARE! larger than int!"
else|:
literal|""
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
condition|)
name|printf
argument_list|(
literal|"%s%s %s %s%s\n"
argument_list|,
name|co
argument_list|,
literal|"Type size_t is"
argument_list|,
operator|(
operator|(
operator|(
operator|(
name|false
argument_list|()
condition|?
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
else|:
operator|(
operator|-
literal|1
operator|)
operator|)
operator|<
literal|0
operator|)
operator|)
condition|?
literal|"signed"
else|:
literal|"unsigned"
operator|)
argument_list|,
name|type_of
argument_list|(
sizeof|sizeof
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
literal|0
argument_list|)
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|showtype
argument_list|(
literal|"Type size_t is"
argument_list|,
sizeof|sizeof
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Alignment constants ********************************************/
define|#
directive|define
name|alignment
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|((long)((char *)&((struct{char c; TYPE d;}*)0)->d - (char *) 0))
name|Vprintf
argument_list|(
literal|"\n%sALIGNMENTS%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%schar=%ld short=%ld int=%ld long=%ld%s\n"
argument_list|,
name|co
argument_list|,
name|alignment
argument_list|(
name|char
argument_list|)
argument_list|,
name|alignment
argument_list|(
name|short
argument_list|)
argument_list|,
name|alignment
argument_list|(
name|int
argument_list|)
argument_list|,
name|alignment
argument_list|(
name|long
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sfloat=%ld double=%ld%s\n"
argument_list|,
name|co
argument_list|,
name|alignment
argument_list|(
name|float
argument_list|)
argument_list|,
name|alignment
argument_list|(
name|double
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdc
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%slong double=%ld%s\n"
argument_list|,
name|co
argument_list|,
name|alignment
argument_list|(
name|Long_double
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%schar*=%ld int*=%ld func*=%ld%s\n"
argument_list|,
name|co
argument_list|,
name|alignment
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|alignment
argument_list|(
name|int
operator|*
argument_list|)
argument_list|,
name|alignment
argument_list|(
name|function
operator|*
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Ten little endians *********************************************/
name|endian
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
comment|/* Pointers *******************************************************/
name|Vprintf
argument_list|(
literal|"\n%sPROPERTIES OF POINTERS%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|variable
operator|==
call|(
name|long
call|)
argument_list|(
name|int
operator|*
argument_list|)
operator|&
name|variable
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sChar and int pointer formats seem identical%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sChar and int pointer formats are different%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|variable
operator|==
call|(
name|long
call|)
argument_list|(
name|function
operator|*
argument_list|)
operator|&
name|variable
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sChar and function pointer formats seem identical%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sChar and function pointer formats are different%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|V
condition|)
block|{
if|if
condition|(
literal|"abcd"
operator|==
literal|"abcd"
condition|)
name|printf
argument_list|(
literal|"%sStrings are shared%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%sStrings are not shared%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
literal|0
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
name|showtype
argument_list|(
literal|"Type ptrdiff_t is"
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"\n%sPROPERTIES OF INTEGRAL TYPES%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|sprop
argument_list|()
expr_stmt|;
name|iprop
argument_list|()
expr_stmt|;
name|lprop
argument_list|()
expr_stmt|;
name|usprop
argument_list|()
expr_stmt|;
name|uiprop
argument_list|()
expr_stmt|;
name|ulprop
argument_list|()
expr_stmt|;
name|promotions
argument_list|()
expr_stmt|;
name|Unexpected
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return
name|bits_per_byte
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not PASS0 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SEP
end_ifdef

begin_decl_stmt
specifier|extern
name|jmp_buf
name|lab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|V
decl_stmt|,
name|L
decl_stmt|,
name|F
decl_stmt|,
name|bugs
decl_stmt|,
name|bits_per_byte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|co
index|[]
decl_stmt|,
name|oc
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|f_rep
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SEP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef PASS0 */
end_comment

begin_comment
comment|/* As I said, I apologise for the contortions below. The functions are    expanded by the preprocessor twice or three times (for float and double,    and maybe for long double, and for short, int and long). That way,    I never make a change to one that I forget to make to the other.    You can look on it as C's fault for not supporting multi-line macro's.    This whole file is read 3 times by the preprocessor, with PASSn set for    n=1, 2 or 3, to decide which parts to reprocess. */
end_comment

begin_comment
comment|/* #undef on an already undefined thing is (wrongly) flagged as an error    by some compilers, therefore the #ifdef that follows: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Number
end_ifdef

begin_undef
undef|#
directive|undef
name|Number
end_undef

begin_undef
undef|#
directive|undef
name|THING
end_undef

begin_undef
undef|#
directive|undef
name|Thing
end_undef

begin_undef
undef|#
directive|undef
name|thing
end_undef

begin_undef
undef|#
directive|undef
name|FPROP
end_undef

begin_undef
undef|#
directive|undef
name|Fname
end_undef

begin_undef
undef|#
directive|undef
name|Store
end_undef

begin_undef
undef|#
directive|undef
name|Sum
end_undef

begin_undef
undef|#
directive|undef
name|Diff
end_undef

begin_undef
undef|#
directive|undef
name|Mul
end_undef

begin_undef
undef|#
directive|undef
name|Div
end_undef

begin_undef
undef|#
directive|undef
name|ZERO
end_undef

begin_undef
undef|#
directive|undef
name|HALF
end_undef

begin_undef
undef|#
directive|undef
name|ONE
end_undef

begin_undef
undef|#
directive|undef
name|TWO
end_undef

begin_undef
undef|#
directive|undef
name|THREE
end_undef

begin_undef
undef|#
directive|undef
name|FOUR
end_undef

begin_undef
undef|#
directive|undef
name|Self
end_undef

begin_undef
undef|#
directive|undef
name|F_check
end_undef

begin_undef
undef|#
directive|undef
name|Validate
end_undef

begin_undef
undef|#
directive|undef
name|EPROP
end_undef

begin_undef
undef|#
directive|undef
name|MARK
end_undef

begin_comment
comment|/* These are the float.h constants */
end_comment

begin_undef
undef|#
directive|undef
name|F_RADIX
end_undef

begin_undef
undef|#
directive|undef
name|F_MANT_DIG
end_undef

begin_undef
undef|#
directive|undef
name|F_DIG
end_undef

begin_undef
undef|#
directive|undef
name|F_ROUNDS
end_undef

begin_undef
undef|#
directive|undef
name|F_EPSILON
end_undef

begin_undef
undef|#
directive|undef
name|F_MIN_EXP
end_undef

begin_undef
undef|#
directive|undef
name|F_MIN
end_undef

begin_undef
undef|#
directive|undef
name|F_MIN_10_EXP
end_undef

begin_undef
undef|#
directive|undef
name|F_MAX_EXP
end_undef

begin_undef
undef|#
directive|undef
name|F_MAX
end_undef

begin_undef
undef|#
directive|undef
name|F_MAX_10_EXP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Integer
end_ifdef

begin_undef
undef|#
directive|undef
name|Integer
end_undef

begin_undef
undef|#
directive|undef
name|INT
end_undef

begin_undef
undef|#
directive|undef
name|IPROP
end_undef

begin_undef
undef|#
directive|undef
name|Iname
end_undef

begin_undef
undef|#
directive|undef
name|UPROP
end_undef

begin_undef
undef|#
directive|undef
name|Uname
end_undef

begin_undef
undef|#
directive|undef
name|OK_UI
end_undef

begin_undef
undef|#
directive|undef
name|IMARK
end_undef

begin_undef
undef|#
directive|undef
name|I_MAX
end_undef

begin_undef
undef|#
directive|undef
name|I_MIN
end_undef

begin_undef
undef|#
directive|undef
name|U_MAX
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS1
end_ifdef

begin_comment
comment|/* Define the things we're going to use this pass */
end_comment

begin_define
define|#
directive|define
name|Number
value|float
end_define

begin_define
define|#
directive|define
name|THING
value|"FLOAT"
end_define

begin_define
define|#
directive|define
name|Thing
value|"Float"
end_define

begin_define
define|#
directive|define
name|thing
value|"float"
end_define

begin_define
define|#
directive|define
name|Fname
value|"FLT"
end_define

begin_define
define|#
directive|define
name|FPROP
value|fprop
end_define

begin_define
define|#
directive|define
name|Store
value|fStore
end_define

begin_define
define|#
directive|define
name|Sum
value|fSum
end_define

begin_define
define|#
directive|define
name|Diff
value|fDiff
end_define

begin_define
define|#
directive|define
name|Mul
value|fMul
end_define

begin_define
define|#
directive|define
name|Div
value|fDiv
end_define

begin_define
define|#
directive|define
name|ZERO
value|0.0
end_define

begin_define
define|#
directive|define
name|HALF
value|0.5
end_define

begin_define
define|#
directive|define
name|ONE
value|1.0
end_define

begin_define
define|#
directive|define
name|TWO
value|2.0
end_define

begin_define
define|#
directive|define
name|THREE
value|3.0
end_define

begin_define
define|#
directive|define
name|FOUR
value|4.0
end_define

begin_define
define|#
directive|define
name|Self
value|fSelf
end_define

begin_define
define|#
directive|define
name|F_check
value|fCheck
end_define

begin_define
define|#
directive|define
name|MARK
value|"F"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_define
define|#
directive|define
name|Validate
parameter_list|(
name|prec
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|same
parameter_list|)
value|fValidate(prec, val, req, same)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EPROP
value|efprop
end_define

begin_define
define|#
directive|define
name|Integer
value|short
end_define

begin_define
define|#
directive|define
name|INT
value|"short"
end_define

begin_define
define|#
directive|define
name|IPROP
value|sprop
end_define

begin_define
define|#
directive|define
name|Iname
value|"SHRT"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UI
end_ifndef

begin_define
define|#
directive|define
name|OK_UI
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IMARK
value|""
end_define

begin_define
define|#
directive|define
name|UPROP
value|usprop
end_define

begin_define
define|#
directive|define
name|Uname
value|"USHRT"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SHRT_MAX
end_ifdef

begin_define
define|#
directive|define
name|I_MAX
value|SHRT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SHRT_MIN
end_ifdef

begin_define
define|#
directive|define
name|I_MIN
value|SHRT_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USHRT_MAX
end_ifdef

begin_define
define|#
directive|define
name|U_MAX
value|USHRT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_RADIX
end_ifdef

begin_define
define|#
directive|define
name|F_RADIX
value|FLT_RADIX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_MANT_DIG
end_ifdef

begin_define
define|#
directive|define
name|F_MANT_DIG
value|FLT_MANT_DIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_DIG
end_ifdef

begin_define
define|#
directive|define
name|F_DIG
value|FLT_DIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_ROUNDS
end_ifdef

begin_define
define|#
directive|define
name|F_ROUNDS
value|FLT_ROUNDS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_EPSILON
end_ifdef

begin_define
define|#
directive|define
name|F_EPSILON
value|FLT_EPSILON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_MIN_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MIN_EXP
value|FLT_MIN_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_MIN
end_ifdef

begin_define
define|#
directive|define
name|F_MIN
value|FLT_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_MIN_10_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|FLT_MIN_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_MAX_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MAX_EXP
value|FLT_MAX_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_MAX
end_ifdef

begin_define
define|#
directive|define
name|F_MAX
value|FLT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLT_MAX_10_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|FLT_MAX_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS2
end_ifdef

begin_define
define|#
directive|define
name|Number
value|double
end_define

begin_define
define|#
directive|define
name|THING
value|"DOUBLE"
end_define

begin_define
define|#
directive|define
name|Thing
value|"Double"
end_define

begin_define
define|#
directive|define
name|thing
value|"double"
end_define

begin_define
define|#
directive|define
name|Fname
value|"DBL"
end_define

begin_define
define|#
directive|define
name|FPROP
value|dprop
end_define

begin_define
define|#
directive|define
name|Store
value|dStore
end_define

begin_define
define|#
directive|define
name|Sum
value|dSum
end_define

begin_define
define|#
directive|define
name|Diff
value|dDiff
end_define

begin_define
define|#
directive|define
name|Mul
value|dMul
end_define

begin_define
define|#
directive|define
name|Div
value|dDiv
end_define

begin_define
define|#
directive|define
name|ZERO
value|0.0
end_define

begin_define
define|#
directive|define
name|HALF
value|0.5
end_define

begin_define
define|#
directive|define
name|ONE
value|1.0
end_define

begin_define
define|#
directive|define
name|TWO
value|2.0
end_define

begin_define
define|#
directive|define
name|THREE
value|3.0
end_define

begin_define
define|#
directive|define
name|FOUR
value|4.0
end_define

begin_define
define|#
directive|define
name|Self
value|dSelf
end_define

begin_define
define|#
directive|define
name|F_check
value|dCheck
end_define

begin_define
define|#
directive|define
name|MARK
value|""
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_define
define|#
directive|define
name|Validate
parameter_list|(
name|prec
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|same
parameter_list|)
value|dValidate(prec, val, req, same)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EPROP
value|edprop
end_define

begin_define
define|#
directive|define
name|Integer
value|int
end_define

begin_define
define|#
directive|define
name|INT
value|"int"
end_define

begin_define
define|#
directive|define
name|IPROP
value|iprop
end_define

begin_define
define|#
directive|define
name|Iname
value|"INT"
end_define

begin_define
define|#
directive|define
name|OK_UI
value|1
end_define

begin_comment
comment|/* Unsigned int is always possible */
end_comment

begin_define
define|#
directive|define
name|IMARK
value|""
end_define

begin_define
define|#
directive|define
name|UPROP
value|uiprop
end_define

begin_define
define|#
directive|define
name|Uname
value|"UINT"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INT_MAX
end_ifdef

begin_define
define|#
directive|define
name|I_MAX
value|INT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INT_MIN
end_ifdef

begin_define
define|#
directive|define
name|I_MIN
value|INT_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UINT_MAX
end_ifdef

begin_define
define|#
directive|define
name|U_MAX
value|UINT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MANT_DIG
end_ifdef

begin_define
define|#
directive|define
name|F_MANT_DIG
value|DBL_MANT_DIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_DIG
end_ifdef

begin_define
define|#
directive|define
name|F_DIG
value|DBL_DIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_EPSILON
end_ifdef

begin_define
define|#
directive|define
name|F_EPSILON
value|DBL_EPSILON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MIN_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MIN_EXP
value|DBL_MIN_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MIN
end_ifdef

begin_define
define|#
directive|define
name|F_MIN
value|DBL_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MIN_10_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|DBL_MIN_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MAX_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MAX_EXP
value|DBL_MAX_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MAX
end_ifdef

begin_define
define|#
directive|define
name|F_MAX
value|DBL_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MAX_10_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|DBL_MAX_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS3
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|STDC
end_ifdef

begin_define
define|#
directive|define
name|Number
value|long double
end_define

begin_define
define|#
directive|define
name|ZERO
value|0.0L
end_define

begin_define
define|#
directive|define
name|HALF
value|0.5L
end_define

begin_define
define|#
directive|define
name|ONE
value|1.0L
end_define

begin_define
define|#
directive|define
name|TWO
value|2.0L
end_define

begin_define
define|#
directive|define
name|THREE
value|3.0L
end_define

begin_define
define|#
directive|define
name|FOUR
value|4.0L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|THING
value|"LONG DOUBLE"
end_define

begin_define
define|#
directive|define
name|Thing
value|"Long double"
end_define

begin_define
define|#
directive|define
name|thing
value|"long double"
end_define

begin_define
define|#
directive|define
name|Fname
value|"LDBL"
end_define

begin_define
define|#
directive|define
name|FPROP
value|ldprop
end_define

begin_define
define|#
directive|define
name|Store
value|ldStore
end_define

begin_define
define|#
directive|define
name|Sum
value|ldSum
end_define

begin_define
define|#
directive|define
name|Diff
value|ldDiff
end_define

begin_define
define|#
directive|define
name|Mul
value|ldMul
end_define

begin_define
define|#
directive|define
name|Div
value|ldDiv
end_define

begin_define
define|#
directive|define
name|Self
value|ldSelf
end_define

begin_define
define|#
directive|define
name|F_check
value|ldCheck
end_define

begin_define
define|#
directive|define
name|MARK
value|"L"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_define
define|#
directive|define
name|Validate
parameter_list|(
name|prec
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|same
parameter_list|)
value|ldValidate(prec, val, req, same)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EPROP
value|eldprop
end_define

begin_define
define|#
directive|define
name|Integer
value|long
end_define

begin_define
define|#
directive|define
name|INT
value|"long"
end_define

begin_define
define|#
directive|define
name|IPROP
value|lprop
end_define

begin_define
define|#
directive|define
name|Iname
value|"LONG"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UI
end_ifndef

begin_define
define|#
directive|define
name|OK_UI
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IMARK
value|"L"
end_define

begin_define
define|#
directive|define
name|UPROP
value|ulprop
end_define

begin_define
define|#
directive|define
name|Uname
value|"ULONG"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LONG_MAX
end_ifdef

begin_define
define|#
directive|define
name|I_MAX
value|LONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LONG_MIN
end_ifdef

begin_define
define|#
directive|define
name|I_MIN
value|LONG_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ULONG_MAX
end_ifdef

begin_define
define|#
directive|define
name|U_MAX
value|ULONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_MANT_DIG
end_ifdef

begin_define
define|#
directive|define
name|F_MANT_DIG
value|LDBL_MANT_DIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_DIG
end_ifdef

begin_define
define|#
directive|define
name|F_DIG
value|LDBL_DIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_EPSILON
end_ifdef

begin_define
define|#
directive|define
name|F_EPSILON
value|LDBL_EPSILON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_MIN_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MIN_EXP
value|LDBL_MIN_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_MIN
end_ifdef

begin_define
define|#
directive|define
name|F_MIN
value|LDBL_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_MIN_10_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|LDBL_MIN_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_MAX_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MAX_EXP
value|LDBL_MAX_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_MAX
end_ifdef

begin_define
define|#
directive|define
name|F_MAX
value|LDBL_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDBL_MAX_10_EXP
end_ifdef

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|LDBL_MAX_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS3 */
end_comment

begin_define
define|#
directive|define
name|UNDEFINED
value|(-2)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|I_MAX
end_ifndef

begin_define
define|#
directive|define
name|I_MAX
value|((unsigned long) UNDEFINED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|I_MIN
end_ifndef

begin_define
define|#
directive|define
name|I_MIN
value|((unsigned long) UNDEFINED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|U_MAX
end_ifndef

begin_define
define|#
directive|define
name|U_MAX
value|((unsigned long) UNDEFINED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_RADIX
end_ifndef

begin_define
define|#
directive|define
name|F_RADIX
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_MANT_DIG
end_ifndef

begin_define
define|#
directive|define
name|F_MANT_DIG
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_DIG
end_ifndef

begin_define
define|#
directive|define
name|F_DIG
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_ROUNDS
end_ifndef

begin_define
define|#
directive|define
name|F_ROUNDS
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_EPSILON
end_ifndef

begin_define
define|#
directive|define
name|F_EPSILON
value|((Number) UNDEFINED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_MIN_EXP
end_ifndef

begin_define
define|#
directive|define
name|F_MIN_EXP
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_MIN
end_ifndef

begin_define
define|#
directive|define
name|F_MIN
value|((Number) UNDEFINED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_MIN_10_EXP
end_ifndef

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_MAX_EXP
end_ifndef

begin_define
define|#
directive|define
name|F_MAX_EXP
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_MAX
end_ifndef

begin_define
define|#
directive|define
name|F_MAX
value|((Number) UNDEFINED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_MAX_10_EXP
end_ifndef

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|UNDEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VERIFY
end_ifndef

begin_define
define|#
directive|define
name|Validate
parameter_list|(
name|prec
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|same
parameter_list|)
value|{;}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Integer
end_ifdef

begin_function
name|Procedure
name|IPROP
parameter_list|()
block|{
comment|/* the properties of short, int, and long */
name|Volatile
name|Integer
name|newi
decl_stmt|,
name|int_max
decl_stmt|,
name|maxeri
decl_stmt|,
name|int_min
decl_stmt|,
name|minneri
decl_stmt|;
name|Volatile
name|int
name|ibits
decl_stmt|,
name|ipower
decl_stmt|,
name|two
init|=
literal|2
decl_stmt|;
comment|/* Calculate max short/int/long ***********************************/
comment|/* Calculate 2**n-1 until overflow - then use the previous value  */
name|newi
operator|=
literal|1
expr_stmt|;
name|int_max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields int_max */
for|for
control|(
name|ipower
operator|=
literal|0
init|;
name|newi
operator|>
name|int_max
condition|;
name|ipower
operator|++
control|)
block|{
name|int_max
operator|=
name|newi
expr_stmt|;
name|newi
operator|=
name|newi
operator|*
name|two
operator|+
literal|1
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sOverflow of a%s %s does not generate a trap%s\n"
argument_list|,
name|co
argument_list|,
name|INT
index|[
literal|0
index|]
operator|==
literal|'i'
condition|?
literal|"n"
else|:
literal|""
argument_list|,
name|INT
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sOverflow of a%s %s generates a trap%s\n"
argument_list|,
name|co
argument_list|,
name|INT
index|[
literal|0
index|]
operator|==
literal|'i'
condition|?
literal|"n"
else|:
literal|""
argument_list|,
name|INT
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* Minimum value: assume either two's or one's complement *********/
name|int_min
operator|=
operator|-
name|int_max
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields int_min */
if|if
condition|(
name|int_min
operator|-
literal|1
operator|<
name|int_min
condition|)
name|int_min
operator|--
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Now for those daft Cybers */
name|maxeri
operator|=
literal|0
expr_stmt|;
name|newi
operator|=
name|int_max
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields maxeri */
for|for
control|(
name|ibits
operator|=
name|ipower
init|;
name|newi
operator|>
name|maxeri
condition|;
name|ibits
operator|++
control|)
block|{
name|maxeri
operator|=
name|newi
expr_stmt|;
name|newi
operator|=
name|newi
operator|+
name|newi
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|minneri
operator|=
operator|-
name|maxeri
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields minneri */
if|if
condition|(
name|minneri
operator|-
literal|1
operator|<
name|minneri
condition|)
name|minneri
operator|--
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMaximum %s = %ld (= 2**%d-1)%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|int_max
argument_list|,
name|ipower
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMinimum %s = %ld%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|int_min
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
name|i_define
argument_list|(
name|D_INT_MAX
argument_list|,
name|INT
argument_list|,
name|Iname
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|int_max
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|I_MAX
argument_list|,
name|IMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
name|i_define
argument_list|(
name|D_INT_MIN
argument_list|,
name|INT
argument_list|,
name|Iname
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|int_min
argument_list|,
call|(
name|long
call|)
argument_list|(
name|PASS
operator|==
literal|1
condition|?
name|maxint
else|:
name|int_max
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|I_MIN
argument_list|,
name|IMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|int_max
operator|<
literal|0
condition|)
block|{
comment|/* It has happened */
name|eek_a_bug
argument_list|(
literal|"signed integral comparison faulty?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxeri
operator|>
name|int_max
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sThere is a larger %s, %ld (= 2**%d-1), %s %s%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|maxeri
argument_list|,
name|ibits
argument_list|,
literal|"but only for addition, not multiplication"
argument_list|,
literal|"(I smell a Cyber!)"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minneri
operator|<
name|int_min
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sThere is a smaller %s, %ld, %s %s%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|minneri
argument_list|,
literal|"but only for addition, not multiplication"
argument_list|,
literal|"(I smell a Cyber!)"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Procedure
name|UPROP
parameter_list|()
block|{
comment|/* The properties of unsigned short/int/long */
ifdef|#
directive|ifdef
name|OK_UI
name|Volatile
name|unsigned
name|Integer
name|u_max
decl_stmt|,
name|newi
decl_stmt|,
name|two
decl_stmt|;
name|newi
operator|=
literal|1
expr_stmt|;
name|u_max
operator|=
literal|0
expr_stmt|;
name|two
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields u_max */
while|while
condition|(
name|newi
operator|>
name|u_max
condition|)
block|{
name|u_max
operator|=
name|newi
expr_stmt|;
name|newi
operator|=
name|newi
operator|*
name|two
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMaximum unsigned %s = %lu%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|u_max
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Oh woe: new standard C defines value preserving promotions */
if|if
condition|(
name|L
condition|)
block|{
if|if
condition|(
name|PASS
operator|==
literal|1
operator|&&
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
comment|/* Special only for short */
name|i_define
argument_list|(
name|D_UINT_MAX
argument_list|,
name|INT
argument_list|,
name|Uname
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|u_max
argument_list|,
literal|0L
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|U_MAX
argument_list|,
name|IMARK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_define
argument_list|(
name|D_UINT_MAX
argument_list|,
name|INT
argument_list|,
name|Uname
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|u_max
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|U_MAX
argument_list|,
name|IMARK
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Integer */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Number
end_ifdef

begin_comment
comment|/* The following routines are intended to defeat any attempt at optimisation    or use of extended precision, and to defeat faulty narrowing casts.    The weird prototypes are because of widening incompatibilities. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDC
end_ifdef

begin_define
define|#
directive|define
name|ARGS1
parameter_list|(
name|atype
parameter_list|,
name|a
parameter_list|)
value|(atype a)
end_define

begin_define
define|#
directive|define
name|ARGS2
parameter_list|(
name|atype
parameter_list|,
name|a
parameter_list|,
name|btype
parameter_list|,
name|b
parameter_list|)
value|(atype a, btype b)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARGS1
parameter_list|(
name|atype
parameter_list|,
name|a
parameter_list|)
value|(a) atype a;
end_define

begin_define
define|#
directive|define
name|ARGS2
parameter_list|(
name|atype
parameter_list|,
name|a
parameter_list|,
name|btype
parameter_list|,
name|b
parameter_list|)
value|(a, b) atype a; btype b;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Procedure
name|Store
name|ARGS2
parameter_list|(
name|Number
parameter_list|,
name|a
parameter_list|,
name|Number
modifier|*
parameter_list|,
name|b
parameter_list|)
block|{
operator|*
name|b
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_function
name|Number
name|Sum
name|ARGS2
parameter_list|(
name|Number
parameter_list|,
name|a
parameter_list|,
name|Number
parameter_list|,
name|b
parameter_list|)
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|+
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Diff
name|ARGS2
parameter_list|(
name|Number
parameter_list|,
name|a
parameter_list|,
name|Number
parameter_list|,
name|b
parameter_list|)
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|-
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Mul
name|ARGS2
parameter_list|(
name|Number
parameter_list|,
name|a
parameter_list|,
name|Number
parameter_list|,
name|b
parameter_list|)
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|*
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Div
name|ARGS2
parameter_list|(
name|Number
parameter_list|,
name|a
parameter_list|,
name|Number
parameter_list|,
name|b
parameter_list|)
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|/
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Self
name|ARGS1
parameter_list|(
name|Number
parameter_list|,
name|a
parameter_list|)
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|Procedure
name|F_check
name|ARGS
argument_list|(
operator|(
name|int
name|precision
operator|,
name|Long_double
name|val1
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|Procedure
name|F_check
parameter_list|(
name|precision
parameter_list|,
name|val1
parameter_list|)
name|int
name|precision
decl_stmt|;
name|Long_double
name|val1
decl_stmt|;
block|{
comment|/* You don't think I'm going to go to all the trouble of writing 	   a program that works out what all sorts of values are, only to 	   have printf go and print the wrong values out, do you? 	   No, you're right, so this function tries to see if printf 	   has written the right value, by reading it back again. 	   This introduces a new problem of course: suppose printf writes 	   the correct value, and scanf reads it back wrong... oh well. 	   But I'm adamant about this: the precision given is enough 	   to uniquely identify the printed number, therefore I insist 	   that sscanf read the number back identically. Harsh yes, but 	   sometimes you've got to be cruel to be kind. 	*/
name|Number
name|val
decl_stmt|,
name|new
decl_stmt|,
name|diff
decl_stmt|;
name|double
name|rem
decl_stmt|;
name|int
name|e
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|char
modifier|*
name|f2
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_LONG_DOUBLE_IO
name|double
name|new1
decl_stmt|;
comment|/* On the Sun 3, sscanf clobbers 4 words, 	   which leads to a crash when this function tries to return.  */
name|f2
operator|=
literal|"%le"
expr_stmt|;
comment|/* Input */
comment|/* It is no use checking long doubles if we can't 	   read and write them.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Number
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
return|return;
else|#
directive|else
name|Long_double
name|new1
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
condition|)
block|{
comment|/* Assume they're the same, and use non-stdc format */
comment|/* This is for stdc compilers using non-stdc libraries */
name|f2
operator|=
literal|"%le"
expr_stmt|;
comment|/* Input */
block|}
else|else
block|{
comment|/* It had better support Le then */
name|f2
operator|=
literal|"%Le"
expr_stmt|;
block|}
endif|#
directive|endif
name|val
operator|=
name|val1
expr_stmt|;
name|rep
operator|=
name|f_rep
argument_list|(
name|precision
argument_list|,
operator|(
name|Long_double
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sscanf
argument_list|(
name|rep
argument_list|,
name|f2
argument_list|,
operator|&
name|new1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"sscanf caused a trap"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s    scanning: %s format: %s%s\n\n"
argument_list|,
name|co
argument_list|,
name|rep
argument_list|,
name|f2
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* See if new is usable */
name|new
operator|=
name|new1
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0.0
condition|)
block|{
name|diff
operator|=
name|val
operator|/
name|new
operator|-
literal|1.0
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.1
condition|)
name|diff
operator|=
literal|1.0
expr_stmt|;
comment|/* That should be enough to generate a trap */
block|}
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"sscanf returned an unusable number"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s    scanning: %s with format: %s%s\n\n"
argument_list|,
name|co
argument_list|,
name|rep
argument_list|,
name|f2
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|13
argument_list|)
expr_stmt|;
return|return;
block|}
name|Unexpected
argument_list|(
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|val
condition|)
block|{
name|eek_a_bug
argument_list|(
literal|"Possibly bad output from printf above"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exponent
argument_list|(
operator|(
name|Long_double
operator|)
name|val
argument_list|,
operator|&
name|rem
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s    but value was an unusable number%s\n\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s    expected value around %.*fe%d, bit pattern:\n    "
argument_list|,
name|co
argument_list|,
name|precision
argument_list|,
name|rem
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bitpattern
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s    sscanf gave           %s, bit pattern:\n    "
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
operator|(
name|Long_double
operator|)
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|bitpattern
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|new
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|diff
operator|=
name|val
operator|-
name|new
expr_stmt|;
name|printf
argument_list|(
literal|"%s    difference= %s%s\n\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
operator|(
name|Long_double
operator|)
name|diff
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
comment|/* else forget it */
name|Unexpected
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_function
name|Procedure
name|Validate
parameter_list|(
name|prec
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|same
parameter_list|)
name|int
name|prec
decl_stmt|,
name|same
decl_stmt|;
name|Long_double
name|val
decl_stmt|,
name|req
decl_stmt|;
block|{
comment|/* Check that the compiler has read a #define value correctly */
name|Unexpected
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same
condition|)
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n"
argument_list|,
name|co
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for the case that req == nan */
name|printf
argument_list|(
literal|"       Compiler has %s for value%s\n"
argument_list|,
name|f_rep
argument_list|(
name|prec
argument_list|,
name|req
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"       Compiler has %s for value%s\n"
argument_list|,
literal|"an unusable number"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|F_check
argument_list|(
name|prec
argument_list|,
operator|(
name|Long_double
operator|)
name|req
argument_list|)
expr_stmt|;
block|}
comment|/*else forget it*/
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|>
literal|0.0
operator|&&
name|val
operator|>
literal|0.0
condition|)
block|{
name|printf
argument_list|(
literal|"%s    difference= %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|prec
argument_list|,
name|val
operator|-
name|req
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*else forget it*/
name|Unexpected
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
name|req
condition|)
block|{
if|if
condition|(
name|stdc
condition|)
name|eek_a_bug
argument_list|(
literal|"constant has the wrong precision"
argument_list|)
expr_stmt|;
else|else
name|eek_a_bug
argument_list|(
literal|"the cast didn't work"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERIFY */
end_comment

begin_function
name|int
name|FPROP
parameter_list|(
name|bits_per_byte
parameter_list|)
name|int
name|bits_per_byte
decl_stmt|;
block|{
comment|/* Properties of floating types, using algorithms by Cody and Waite 	   from MA Malcolm, as modified by WM Gentleman and SB Marovich. 	   Further extended by S Pemberton.  	   Returns the number of digits in the fraction. 	*/
name|Volatile
name|int
name|i
decl_stmt|,
name|f_radix
decl_stmt|,
name|iexp
decl_stmt|,
name|irnd
decl_stmt|,
name|mrnd
decl_stmt|,
name|f_rounds
decl_stmt|,
name|f_mant_dig
decl_stmt|,
name|iz
decl_stmt|,
name|k
decl_stmt|,
name|inf
decl_stmt|,
name|machep
decl_stmt|,
name|f_max_exp
decl_stmt|,
name|f_min_exp
decl_stmt|,
name|mx
decl_stmt|,
name|negeps
decl_stmt|,
name|mantbits
decl_stmt|,
name|digs
decl_stmt|,
name|f_dig
decl_stmt|,
name|trap
decl_stmt|,
name|hidden
decl_stmt|,
name|normal
decl_stmt|,
name|f_min_10_exp
decl_stmt|,
name|f_max_10_exp
decl_stmt|;
name|Volatile
name|Number
name|a
decl_stmt|,
name|b
decl_stmt|,
name|base
decl_stmt|,
name|basein
decl_stmt|,
name|basem1
decl_stmt|,
name|f_epsilon
decl_stmt|,
name|epsneg
decl_stmt|,
name|eps
decl_stmt|,
name|epsp1
decl_stmt|,
name|etop
decl_stmt|,
name|ebot
decl_stmt|,
name|f_max
decl_stmt|,
name|newxmax
decl_stmt|,
name|f_min
decl_stmt|,
name|xminner
decl_stmt|,
name|y
decl_stmt|,
name|y1
decl_stmt|,
name|z
decl_stmt|,
name|z1
decl_stmt|,
name|z2
decl_stmt|;
name|Unexpected
argument_list|(
literal|18
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sPROPERTIES OF %s%s\n"
argument_list|,
name|co
argument_list|,
name|THING
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Base and size of significand **************************************/
comment|/* First repeatedly double until adding 1 has no effect.	  */
comment|/* For instance, if base is 10, with 3 significant digits	  */
comment|/* it will try 1, 2, 4, 8, ... 512, 1024, and stop there,	  */
comment|/* since 1024 is only representable as 1020.			  */
name|a
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* inexact trap? */
do|do
block|{
name|a
operator|=
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|ONE
argument_list|)
argument_list|,
name|a
argument_list|)
argument_list|,
name|ONE
argument_list|)
operator|==
name|ZERO
condition|)
do|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Program got loss-of-precision trap!\n"
argument_list|)
expr_stmt|;
comment|/* And supporting those is just TOO much trouble! */
name|farewell
argument_list|(
name|bugs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|19
argument_list|)
expr_stmt|;
comment|/* Now double until you find a number that can be added to the	  */
comment|/* above number. For 1020 this is 8 or 16, depending whether the  */
comment|/* result is rounded or truncated.				  */
comment|/* In either case the result is 1030. 1030-1020= the base, 10.	  */
name|b
operator|=
literal|1.0
expr_stmt|;
do|do
block|{
name|b
operator|=
name|Sum
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|base
operator|=
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|,
name|a
argument_list|)
operator|)
operator|==
name|ZERO
condition|)
do|;
name|f_radix
operator|=
name|base
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sBase = %d%s\n"
argument_list|,
name|co
argument_list|,
name|f_radix
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Sanity check; if base<2, I can't guarantee the rest will work  */
if|if
condition|(
name|f_radix
operator|<
literal|2
condition|)
block|{
name|eek_a_bug
argument_list|(
literal|"Function return or parameter passing faulty? (This is a guess.)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|PASS
operator|==
literal|1
condition|)
block|{
comment|/* only for FLT */
name|flt_radix
operator|=
name|f_radix
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|D_FLT_RADIX
argument_list|,
literal|""
argument_list|,
literal|"FLT"
argument_list|,
literal|"_RADIX"
argument_list|,
operator|(
name|long
operator|)
name|f_radix
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|F_RADIX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f_radix
operator|!=
name|flt_radix
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s*** WARNING: %s %s (%d) %s%s\n"
argument_list|,
name|co
argument_list|,
name|thing
argument_list|,
literal|"arithmetic has a different radix"
argument_list|,
name|f_radix
argument_list|,
literal|"from float"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
comment|/* Now the number of digits precision */
name|f_mant_dig
operator|=
literal|0
expr_stmt|;
name|b
operator|=
literal|1.0
expr_stmt|;
do|do
block|{
name|f_mant_dig
operator|++
expr_stmt|;
name|b
operator|=
name|Mul
argument_list|(
name|b
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|b
argument_list|,
name|ONE
argument_list|)
argument_list|,
name|b
argument_list|)
argument_list|,
name|ONE
argument_list|)
operator|==
name|ZERO
condition|)
do|;
name|f_dig
operator|=
name|floor_log
argument_list|(
literal|10
argument_list|,
call|(
name|Long_double
call|)
argument_list|(
name|b
operator|/
name|base
argument_list|)
argument_list|)
operator|+
operator|(
name|base
operator|==
literal|10
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sSignificant base digits = %d %s %d %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_mant_dig
argument_list|,
literal|"(= at least"
argument_list|,
name|f_dig
argument_list|,
literal|"decimal digits)"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|D_MANT_DIG
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_MANT_DIG"
argument_list|,
operator|(
name|long
operator|)
name|f_mant_dig
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|F_MANT_DIG
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|D_DIG
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_DIG"
argument_list|,
operator|(
name|long
operator|)
name|f_dig
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|F_DIG
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|digs
operator|=
name|ceil_log
argument_list|(
literal|10
argument_list|,
operator|(
name|Long_double
operator|)
name|b
argument_list|)
expr_stmt|;
comment|/* the number of digits to printf */
comment|/* Rounding *******************************************************/
name|basem1
operator|=
name|Diff
argument_list|(
name|base
argument_list|,
name|HALF
argument_list|)
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
name|a
argument_list|)
operator|!=
name|ZERO
condition|)
block|{
if|if
condition|(
name|f_radix
operator|==
literal|2
condition|)
name|basem1
operator|=
literal|0.375
expr_stmt|;
else|else
name|basem1
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
name|a
argument_list|)
operator|!=
name|ZERO
condition|)
name|irnd
operator|=
literal|2
expr_stmt|;
comment|/* away from 0 */
else|else
name|irnd
operator|=
literal|1
expr_stmt|;
comment|/* to nearest */
block|}
else|else
name|irnd
operator|=
literal|0
expr_stmt|;
comment|/* towards 0 */
name|basem1
operator|=
name|Diff
argument_list|(
name|base
argument_list|,
name|HALF
argument_list|)
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
operator|-
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
operator|-
name|a
argument_list|)
operator|!=
name|ZERO
condition|)
block|{
if|if
condition|(
name|f_radix
operator|==
literal|2
condition|)
name|basem1
operator|=
literal|0.375
expr_stmt|;
else|else
name|basem1
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
operator|-
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
operator|-
name|a
argument_list|)
operator|!=
name|ZERO
condition|)
name|mrnd
operator|=
literal|2
expr_stmt|;
comment|/* away from 0*/
else|else
name|mrnd
operator|=
literal|1
expr_stmt|;
comment|/* to nearest */
block|}
else|else
name|mrnd
operator|=
literal|0
expr_stmt|;
comment|/* towards 0 */
name|f_rounds
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Unknown rounding */
if|if
condition|(
name|irnd
operator|==
literal|0
operator|&&
name|mrnd
operator|==
literal|0
condition|)
name|f_rounds
operator|=
literal|0
expr_stmt|;
comment|/* zero = chops */
if|if
condition|(
name|irnd
operator|==
literal|1
operator|&&
name|mrnd
operator|==
literal|1
condition|)
name|f_rounds
operator|=
literal|1
expr_stmt|;
comment|/* nearest */
if|if
condition|(
name|irnd
operator|==
literal|2
operator|&&
name|mrnd
operator|==
literal|0
condition|)
name|f_rounds
operator|=
literal|2
expr_stmt|;
comment|/* +inf */
if|if
condition|(
name|irnd
operator|==
literal|0
operator|&&
name|mrnd
operator|==
literal|2
condition|)
name|f_rounds
operator|=
literal|3
expr_stmt|;
comment|/* -inf */
if|if
condition|(
name|f_rounds
operator|!=
operator|-
literal|1
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sArithmetic rounds towards "
argument_list|,
name|co
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|f_rounds
condition|)
block|{
case|case
literal|0
case|:
name|Vprintf
argument_list|(
literal|"zero (i.e. it chops)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|Vprintf
argument_list|(
literal|"nearest"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Vprintf
argument_list|(
literal|"+infinity"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Vprintf
argument_list|(
literal|"-infinity"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Vprintf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
break|break;
block|}
name|Vprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Hmm, try to give some help here */
name|Vprintf
argument_list|(
literal|"%sArithmetic rounds oddly: %s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%s    Negative numbers %s%s\n"
argument_list|,
name|co
argument_list|,
name|mrnd
operator|==
literal|0
condition|?
literal|"towards zero"
else|:
name|mrnd
operator|==
literal|1
condition|?
literal|"to nearest"
else|:
literal|"away from zero"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%s    Positive numbers %s%s\n"
argument_list|,
name|co
argument_list|,
name|irnd
operator|==
literal|0
condition|?
literal|"towards zero"
else|:
name|irnd
operator|==
literal|1
condition|?
literal|"to nearest"
else|:
literal|"away from zero"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
comment|/* An extra goody */
if|if
condition|(
name|f_radix
operator|==
literal|2
operator|&&
name|f_rounds
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|ONE
argument_list|)
argument_list|,
name|a
argument_list|)
operator|!=
name|ZERO
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s   Tie breaking rounds up%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|THREE
argument_list|)
argument_list|,
name|a
argument_list|)
operator|==
name|FOUR
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s   Tie breaking rounds to even%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%s   Tie breaking rounds down%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PASS
operator|==
literal|1
condition|)
block|{
comment|/* only for FLT */
name|flt_rounds
operator|=
name|f_rounds
expr_stmt|;
comment|/* Prefer system float.h definition of F_ROUNDS, 		   since it's more likely to be right than our "1".  */
if|if
condition|(
name|F
operator|&&
operator|(
operator|!
name|SYS_FLOAT_H_WRAP
operator|||
name|F_ROUNDS
operator|==
name|UNDEFINED
operator|)
condition|)
name|i_define
argument_list|(
name|D_FLT_ROUNDS
argument_list|,
literal|""
argument_list|,
literal|"FLT"
argument_list|,
literal|"_ROUNDS"
argument_list|,
operator|(
name|long
operator|)
name|f_rounds
argument_list|,
literal|1L
argument_list|,
operator|(
name|long
operator|)
name|F_ROUNDS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f_rounds
operator|!=
name|flt_rounds
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s*** WARNING: %s %s (%d) %s%s\n"
argument_list|,
name|co
argument_list|,
name|thing
argument_list|,
literal|"arithmetic rounds differently"
argument_list|,
name|f_rounds
argument_list|,
literal|"from float"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
comment|/* Various flavours of epsilon ************************************/
name|negeps
operator|=
name|f_mant_dig
operator|+
name|f_mant_dig
expr_stmt|;
name|basein
operator|=
literal|1.0
operator|/
name|base
expr_stmt|;
name|a
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|negeps
condition|;
name|i
operator|++
control|)
name|a
operator|*=
name|basein
expr_stmt|;
name|b
operator|=
name|a
expr_stmt|;
while|while
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
name|ONE
argument_list|,
name|a
argument_list|)
argument_list|,
name|ONE
argument_list|)
operator|==
name|ZERO
condition|)
block|{
name|a
operator|*=
name|base
expr_stmt|;
name|negeps
operator|--
expr_stmt|;
block|}
name|negeps
operator|=
operator|-
name|negeps
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sSmallest x such that 1.0-base**x != 1.0 = %d%s\n"
argument_list|,
name|co
argument_list|,
name|negeps
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|etop
operator|=
name|ONE
expr_stmt|;
name|ebot
operator|=
name|ZERO
expr_stmt|;
name|eps
operator|=
name|Sum
argument_list|(
name|ebot
argument_list|,
name|Div
argument_list|(
name|Diff
argument_list|(
name|etop
argument_list|,
name|ebot
argument_list|)
argument_list|,
name|TWO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find the smallest epsneg (1-epsneg != 1) by binary search. 	   ebot and etop are the current bounds */
while|while
condition|(
name|eps
operator|!=
name|ebot
operator|&&
name|eps
operator|!=
name|etop
condition|)
block|{
name|epsp1
operator|=
name|Diff
argument_list|(
name|ONE
argument_list|,
name|eps
argument_list|)
expr_stmt|;
if|if
condition|(
name|epsp1
operator|<
name|ONE
condition|)
name|etop
operator|=
name|eps
expr_stmt|;
else|else
name|ebot
operator|=
name|eps
expr_stmt|;
name|eps
operator|=
name|Sum
argument_list|(
name|ebot
argument_list|,
name|Div
argument_list|(
name|Diff
argument_list|(
name|etop
argument_list|,
name|ebot
argument_list|)
argument_list|,
name|TWO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|eps
operator|=
name|etop
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|Diff
argument_list|(
name|ONE
argument_list|,
name|etop
argument_list|)
operator|>=
name|ONE
operator|||
name|Diff
argument_list|(
name|ONE
argument_list|,
name|ebot
argument_list|)
operator|!=
name|ONE
condition|)
block|{
name|eek_a_bug
argument_list|(
literal|"internal error calculating epsneg"
argument_list|)
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sSmallest x such that 1.0-x != 1.0 = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|eps
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|eps
argument_list|)
expr_stmt|;
name|epsneg
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|f_radix
operator|!=
literal|2
operator|)
operator|&&
name|irnd
condition|)
block|{
comment|/*	a=(a*(1.0+a))/(1.0+1.0); => */
name|a
operator|=
name|Div
argument_list|(
name|Mul
argument_list|(
name|a
argument_list|,
name|Sum
argument_list|(
name|ONE
argument_list|,
name|a
argument_list|)
argument_list|)
argument_list|,
name|Sum
argument_list|(
name|ONE
argument_list|,
name|ONE
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	if ((1.0-a)-1.0 != 0.0) epsneg=a; => */
if|if
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
name|ONE
argument_list|,
name|a
argument_list|)
argument_list|,
name|ONE
argument_list|)
operator|!=
name|ZERO
condition|)
name|epsneg
operator|=
name|a
expr_stmt|;
block|}
comment|/* epsneg is used later */
name|Unexpected
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|machep
operator|=
operator|-
name|f_mant_dig
operator|-
name|f_mant_dig
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|ONE
argument_list|,
name|a
argument_list|)
argument_list|,
name|ONE
argument_list|)
operator|==
name|ZERO
condition|)
block|{
name|a
operator|*=
name|base
expr_stmt|;
name|machep
operator|++
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sSmallest x such that 1.0+base**x != 1.0 = %d%s\n"
argument_list|,
name|co
argument_list|,
name|machep
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|etop
operator|=
name|ONE
expr_stmt|;
name|ebot
operator|=
name|ZERO
expr_stmt|;
name|eps
operator|=
name|Sum
argument_list|(
name|ebot
argument_list|,
name|Div
argument_list|(
name|Diff
argument_list|(
name|etop
argument_list|,
name|ebot
argument_list|)
argument_list|,
name|TWO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find the smallest eps (1+eps != 1) by binary search. 	   ebot and etop are the current bounds */
while|while
condition|(
name|eps
operator|!=
name|ebot
operator|&&
name|eps
operator|!=
name|etop
condition|)
block|{
name|epsp1
operator|=
name|Sum
argument_list|(
name|ONE
argument_list|,
name|eps
argument_list|)
expr_stmt|;
if|if
condition|(
name|epsp1
operator|>
name|ONE
condition|)
name|etop
operator|=
name|eps
expr_stmt|;
else|else
name|ebot
operator|=
name|eps
expr_stmt|;
name|eps
operator|=
name|Sum
argument_list|(
name|ebot
argument_list|,
name|Div
argument_list|(
name|Diff
argument_list|(
name|etop
argument_list|,
name|ebot
argument_list|)
argument_list|,
name|TWO
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Sanity check */
if|if
condition|(
name|Sum
argument_list|(
name|ONE
argument_list|,
name|etop
argument_list|)
operator|<=
name|ONE
operator|||
name|Sum
argument_list|(
name|ONE
argument_list|,
name|ebot
argument_list|)
operator|!=
name|ONE
condition|)
block|{
name|eek_a_bug
argument_list|(
literal|"internal error calculating eps"
argument_list|)
expr_stmt|;
block|}
name|f_epsilon
operator|=
name|etop
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sSmallest x such that 1.0+x != 1.0 = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|f_epsilon
operator|=
name|Diff
argument_list|(
name|Sum
argument_list|(
name|ONE
argument_list|,
name|f_epsilon
argument_list|)
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
comment|/* New C standard defn */
name|Vprintf
argument_list|(
literal|"%s(Above number + 1.0) - 1.0 = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
call|(
name|Long_double
call|)
argument_list|(
name|f_epsilon
argument_list|)
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Possible loss of precision warnings here from non-stdc compilers */
if|if
condition|(
name|F
condition|)
name|f_define
argument_list|(
name|D_EPSILON
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_EPSILON"
argument_list|,
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|,
operator|(
name|Long_double
operator|)
name|F_EPSILON
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
operator|||
name|F
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|21
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|Validate
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|,
operator|(
name|Long_double
operator|)
name|F_EPSILON
argument_list|,
name|f_epsilon
operator|==
name|Self
argument_list|(
name|F_EPSILON
argument_list|)
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|22
argument_list|)
expr_stmt|;
comment|/* Extra chop info *************************************************/
if|if
condition|(
name|f_rounds
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Diff
argument_list|(
name|Mul
argument_list|(
name|Sum
argument_list|(
name|ONE
argument_list|,
name|f_epsilon
argument_list|)
argument_list|,
name|ONE
argument_list|)
argument_list|,
name|ONE
argument_list|)
operator|!=
name|ZERO
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sAlthough arithmetic chops, it uses guard digits%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Size of and minimum normalised exponent ************************/
name|y
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|z
operator|=
name|basein
expr_stmt|;
name|z1
operator|=
operator|(
literal|1.0
operator|+
name|f_epsilon
operator|)
operator|/
name|base
expr_stmt|;
comment|/* Coarse search for the largest power of two */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for underflow trap */
comment|/* Yields i, k, y, y1 */
do|do
block|{
name|y
operator|=
name|z
expr_stmt|;
name|y1
operator|=
name|z1
expr_stmt|;
name|z
operator|=
name|Mul
argument_list|(
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z1
operator|=
name|Mul
argument_list|(
name|z1
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|a
operator|=
name|Mul
argument_list|(
name|z
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
name|z2
operator|=
name|Div
argument_list|(
name|z1
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|z2
operator|!=
name|y1
condition|)
break|break;
if|if
condition|(
operator|(
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
name|ZERO
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|z
argument_list|)
operator|>=
name|y
operator|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|k
operator|+=
name|k
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%s%s underflow generates a trap%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|23
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_radix
operator|!=
literal|10
condition|)
block|{
name|iexp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* for the sign */
name|mx
operator|=
name|k
operator|+
name|k
expr_stmt|;
block|}
else|else
block|{
name|iexp
operator|=
literal|2
expr_stmt|;
name|iz
operator|=
name|f_radix
expr_stmt|;
while|while
condition|(
name|k
operator|>=
name|iz
condition|)
block|{
name|iz
operator|*=
name|f_radix
expr_stmt|;
name|iexp
operator|++
expr_stmt|;
block|}
name|mx
operator|=
name|iz
operator|+
name|iz
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Fine tune starting with y and y1 */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for underflow trap */
comment|/* Yields k, f_min */
do|do
block|{
name|f_min
operator|=
name|y
expr_stmt|;
name|z1
operator|=
name|y1
expr_stmt|;
name|y
operator|=
name|Div
argument_list|(
name|y
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|y1
operator|=
name|Div
argument_list|(
name|y1
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|a
operator|=
name|Mul
argument_list|(
name|y
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
name|z2
operator|=
name|Mul
argument_list|(
name|y1
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|z2
operator|!=
name|z1
condition|)
break|break;
if|if
condition|(
operator|(
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
name|ZERO
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|y
argument_list|)
operator|>=
name|f_min
operator|)
condition|)
break|break;
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
name|Unexpected
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|f_min_exp
operator|=
operator|(
operator|-
name|k
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mx
operator|<=
name|k
operator|+
name|k
operator|-
literal|3
operator|)
operator|&&
operator|(
name|f_radix
operator|!=
literal|10
operator|)
condition|)
block|{
name|mx
operator|+=
name|mx
expr_stmt|;
name|iexp
operator|+=
literal|1
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sNumber of bits used for exponent = %d%s\n"
argument_list|,
name|co
argument_list|,
name|iexp
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMinimum normalised exponent = %d%s\n"
argument_list|,
name|co
argument_list|,
name|f_min_exp
operator|-
literal|1
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|D_MIN_EXP
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_MIN_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_min_exp
argument_list|,
operator|(
name|long
operator|)
name|maxint
argument_list|,
operator|(
name|long
operator|)
name|F_MIN_EXP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sMinimum normalised positive number = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"printf can't print the smallest normalised number"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* Possible loss of precision warnings here from non-stdc compilers */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F
condition|)
name|f_define
argument_list|(
name|D_MIN
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_MIN"
argument_list|,
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|,
operator|(
name|Long_double
operator|)
name|F_MIN
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
operator|||
name|F
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"xxx_MIN caused a trap"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F
condition|)
name|Validate
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|,
operator|(
name|Long_double
operator|)
name|F_MIN
argument_list|,
name|f_min
operator|==
name|Self
argument_list|(
name|F_MIN
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n    %s %s\n\n"
argument_list|,
name|co
argument_list|,
literal|"Compiler has an unusable number for value"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|a
operator|=
literal|1.0
expr_stmt|;
name|f_min_10_exp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|a
operator|>
name|f_min
operator|*
literal|10.0
condition|)
block|{
name|a
operator|/=
literal|10.0
expr_stmt|;
name|f_min_10_exp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|D_MIN_10_EXP
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_MIN_10_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_min_10_exp
argument_list|,
operator|(
name|long
operator|)
name|maxint
argument_list|,
operator|(
name|long
operator|)
name|F_MIN_10_EXP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Minimum exponent ************************************************/
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for underflow trap */
comment|/* Yields xminner */
do|do
block|{
name|xminner
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|Div
argument_list|(
name|y
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|a
operator|=
name|Mul
argument_list|(
name|y
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
name|ZERO
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|y
argument_list|)
operator|>=
name|xminner
operator|)
condition|)
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
name|Unexpected
argument_list|(
literal|27
argument_list|)
expr_stmt|;
if|if
condition|(
name|xminner
operator|!=
literal|0.0
operator|&&
name|xminner
operator|!=
name|f_min
condition|)
block|{
name|normal
operator|=
literal|0
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sThe smallest numbers are not kept normalised%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sSmallest unnormalised positive number = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|xminner
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|xminner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"printf can't print the smallest unnormalised number."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|28
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
literal|1
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sThe smallest numbers are normalised%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
comment|/* Maximum exponent ************************************************/
name|f_max_exp
operator|=
literal|2
expr_stmt|;
name|f_max
operator|=
literal|1.0
expr_stmt|;
name|newxmax
operator|=
name|base
operator|+
literal|1.0
expr_stmt|;
name|inf
operator|=
literal|0
expr_stmt|;
name|trap
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|f_max
operator|<
name|newxmax
condition|)
block|{
name|f_max
operator|=
name|newxmax
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields inf, f_max_exp */
name|newxmax
operator|=
name|Mul
argument_list|(
name|newxmax
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Div
argument_list|(
name|newxmax
argument_list|,
name|base
argument_list|)
operator|!=
name|f_max
condition|)
block|{
name|inf
operator|=
literal|1
expr_stmt|;
comment|/* ieee infinity */
break|break;
block|}
name|f_max_exp
operator|++
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|29
argument_list|)
expr_stmt|;
if|if
condition|(
name|trap
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s overflow generates a trap%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inf
condition|)
name|Vprintf
argument_list|(
literal|"%sThere is an 'infinite' value%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMaximum exponent = %d%s\n"
argument_list|,
name|co
argument_list|,
name|f_max_exp
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|D_MAX_EXP
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_MAX_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_max_exp
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|F_MAX_EXP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Largest number ***************************************************/
name|f_max
operator|=
name|Diff
argument_list|(
name|ONE
argument_list|,
name|epsneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mul
argument_list|(
name|f_max
argument_list|,
name|ONE
argument_list|)
operator|!=
name|f_max
condition|)
name|f_max
operator|=
name|Diff
argument_list|(
name|ONE
argument_list|,
name|Mul
argument_list|(
name|base
argument_list|,
name|epsneg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|f_max_exp
condition|;
name|i
operator|++
control|)
name|f_max
operator|=
name|Mul
argument_list|(
name|f_max
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sMaximum number = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"printf can't print the largest double."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Possible loss of precision warnings here from non-stdc compilers */
if|if
condition|(
name|F
condition|)
name|f_define
argument_list|(
name|D_MAX
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_MAX"
argument_list|,
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|,
operator|(
name|Long_double
operator|)
name|F_MAX
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
operator|||
name|F
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"xxx_MAX caused a trap"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F
condition|)
name|Validate
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|,
operator|(
name|Long_double
operator|)
name|F_MAX
argument_list|,
name|f_max
operator|==
name|Self
argument_list|(
name|F_MAX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n    %s %s\n\n"
argument_list|,
name|co
argument_list|,
literal|"Compiler has an unusable number for value"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|a
operator|=
literal|1.0
expr_stmt|;
name|f_max_10_exp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|a
operator|<
name|f_max
operator|/
literal|10.0
condition|)
block|{
name|a
operator|*=
literal|10.0
expr_stmt|;
name|f_max_10_exp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|D_MAX_10_EXP
argument_list|,
name|thing
argument_list|,
name|Fname
argument_list|,
literal|"_MAX_10_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_max_10_exp
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
name|F_MAX_10_EXP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Hidden bit + sanity check ****************************************/
if|if
condition|(
name|f_radix
operator|!=
literal|10
condition|)
block|{
name|hidden
operator|=
literal|0
expr_stmt|;
name|mantbits
operator|=
name|floor_log
argument_list|(
literal|2
argument_list|,
operator|(
name|Long_double
operator|)
name|f_radix
argument_list|)
operator|*
name|f_mant_dig
expr_stmt|;
if|if
condition|(
name|mantbits
operator|==
literal|64
operator|&&
name|iexp
operator|==
literal|15
operator|&&
name|f_max_exp
operator|+
name|f_min_exp
operator|>
literal|0
comment|/* ??? f_min_exp may be wrong.  */
operator|&&
name|mantbits
operator|+
name|iexp
operator|+
literal|17
operator|==
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|Number
argument_list|)
operator|*
name|bits_per_byte
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sArithmetic probably doesn't use a hidden bit%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sIt's probably 80387 or 68881 extended real%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
goto|goto
name|is_extended
goto|;
block|}
if|if
condition|(
name|mantbits
operator|+
name|iexp
operator|==
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|Number
argument_list|)
operator|*
name|bits_per_byte
condition|)
block|{
name|hidden
operator|=
literal|1
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sArithmetic uses a hidden bit%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mantbits
operator|+
name|iexp
operator|+
literal|1
operator|==
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|Number
argument_list|)
operator|*
name|bits_per_byte
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sArithmetic doesn't use a hidden bit%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n%s%s\n    %s %s %s!%s\n\n"
argument_list|,
name|co
argument_list|,
literal|"*** Something fishy here!"
argument_list|,
literal|"Exponent size + significand size doesn't match"
argument_list|,
literal|"with the size of a"
argument_list|,
name|thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hidden
operator|&&
name|f_radix
operator|==
literal|2
operator|&&
name|f_max_exp
operator|+
name|f_min_exp
operator|==
literal|3
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sIt looks like %s length IEEE format%s\n"
argument_list|,
name|co
argument_list|,
name|f_mant_dig
operator|==
literal|24
condition|?
literal|"single"
else|:
name|f_mant_dig
operator|==
literal|53
condition|?
literal|"double"
else|:
name|f_mant_dig
operator|>
literal|53
condition|?
literal|"extended"
else|:
literal|"some"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|is_extended
label|:
if|if
condition|(
name|f_rounds
operator|!=
literal|1
operator|||
name|normal
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s   though "
argument_list|,
name|co
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_rounds
operator|!=
literal|1
condition|)
block|{
name|Vprintf
argument_list|(
literal|"the rounding is unusual"
argument_list|)
expr_stmt|;
if|if
condition|(
name|normal
condition|)
name|Vprintf
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|normal
condition|)
name|Vprintf
argument_list|(
literal|"the normalisation is unusual"
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sIt doesn't look like IEEE format%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* regardless of verbosity */
return|return
name|f_mant_dig
return|;
block|}
end_function

begin_function
name|Procedure
name|EPROP
parameter_list|(
name|fprec
parameter_list|,
name|dprec
parameter_list|,
name|lprec
parameter_list|)
name|int
name|fprec
decl_stmt|,
name|dprec
decl_stmt|,
name|lprec
decl_stmt|;
block|{
comment|/* See if expressions are evaluated in extended precision. 	   Some compilers optimise even if you don't want it, 	   and then this function fails to produce the right result. 	   We try to diagnose this if it happens. 	*/
name|Volatile
name|int
name|eprec
decl_stmt|;
name|Volatile
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|base
decl_stmt|,
name|old
decl_stmt|;
name|Volatile
name|Number
name|d
decl_stmt|,
name|oldd
decl_stmt|,
name|dbase
decl_stmt|,
name|one
decl_stmt|,
name|zero
decl_stmt|;
name|Volatile
name|int
name|bad
init|=
literal|0
decl_stmt|;
comment|/* Size of significand **************************************/
name|a
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields nothing */
do|do
block|{
name|old
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|+
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
operator|(
name|a
operator|+
literal|1.0
operator|)
operator|-
name|a
operator|)
operator|-
literal|1.0
operator|)
operator|==
literal|0.0
operator|&&
name|a
operator|>
name|old
condition|)
do|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* Avoid the comparison if bad is set, 	   to avoid trouble on the convex.  */
if|if
condition|(
operator|!
name|bad
operator|&&
operator|(
name|a
operator|<=
name|old
operator|)
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bad
condition|)
block|{
name|b
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields nothing */
do|do
block|{
name|old
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|+
name|b
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|base
operator|=
operator|(
operator|(
name|a
operator|+
name|b
operator|)
operator|-
name|a
operator|)
operator|)
operator|==
literal|0.0
operator|&&
name|b
operator|>
name|old
condition|)
do|;
if|if
condition|(
name|b
operator|<=
name|old
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad
condition|)
block|{
name|eprec
operator|=
literal|0
expr_stmt|;
name|d
operator|=
literal|1.0
expr_stmt|;
name|dbase
operator|=
name|base
expr_stmt|;
name|one
operator|=
literal|1.0
expr_stmt|;
name|zero
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields nothing */
do|do
block|{
name|eprec
operator|++
expr_stmt|;
name|oldd
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|*
name|dbase
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
operator|(
name|d
operator|+
name|one
operator|)
operator|-
name|d
operator|)
operator|-
name|one
operator|)
operator|==
name|zero
operator|&&
name|d
operator|>
name|oldd
condition|)
do|;
if|if
condition|(
name|d
operator|<=
name|oldd
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sCan't determine precision for %s expressions:\n%s%s\n"
argument_list|,
name|co
argument_list|,
name|thing
argument_list|,
literal|"   check that you compiled without optimisation!"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eprec
operator|==
name|dprec
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in double precision%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eprec
operator|==
name|fprec
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in float precision%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eprec
operator|==
name|lprec
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in long double precision%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in a %s %s %d %s%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|eprec
operator|>
name|dprec
condition|?
literal|"higher"
else|:
literal|"lower"
argument_list|,
literal|"precision than double,\n   using"
argument_list|,
name|eprec
argument_list|,
literal|"base digits"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not Number */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FPROP
end_ifdef

begin_comment
comment|/* Then create dummy routines for long double */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|FPROP
parameter_list|(
name|bits_per_byte
parameter_list|)
name|int
name|bits_per_byte
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EPROP
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Procedure
name|EPROP
parameter_list|(
name|fprec
parameter_list|,
name|dprec
parameter_list|,
name|lprec
parameter_list|)
name|int
name|fprec
decl_stmt|,
name|dprec
decl_stmt|,
name|lprec
decl_stmt|;
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef Number */
end_comment

begin_comment
comment|/* Increment the pass number */
end_comment

begin_undef
undef|#
directive|undef
name|PASS
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|PASS2
end_ifdef

begin_undef
undef|#
directive|undef
name|PASS2
end_undef

begin_define
define|#
directive|define
name|PASS
value|3
end_define

begin_define
define|#
directive|define
name|PASS3
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS1
end_ifdef

begin_undef
undef|#
directive|undef
name|PASS1
end_undef

begin_define
define|#
directive|define
name|PASS
value|2
end_define

begin_define
define|#
directive|define
name|PASS2
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS0
end_ifdef

begin_undef
undef|#
directive|undef
name|PASS0
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS
end_ifdef

begin_comment
comment|/* then rescan this file */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FILE
end_ifdef

begin_include
include|#
directive|include
file|"enquire.c"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
include|FILENAME
end_include

begin_comment
comment|/* if this line fails to compile, define NO_FILE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS */
end_comment

end_unit

