begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPU mode switching    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* We want target macros for the mode switching code to be able to refer    to instruction attribute values.  */
end_comment

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPTIMIZE_MODE_SWITCHING
end_ifdef

begin_comment
comment|/* The algorithm for setting the modes consists of scanning the insn list    and finding all the insns which require a specific mode.  Each insn gets    a unique struct seginfo element.  These structures are inserted into a list    for each basic block.  For each entity, there is an array of bb_info over    the flow graph basic blocks (local var 'bb_info'), and contains a list    of all insns within that basic block, in the order they are encountered.     For each entity, any basic block WITHOUT any insns requiring a specific    mode are given a single entry, without a mode.  (Each basic block    in the flow graph must have at least one entry in the segment table.)     The LCM algorithm is then run over the flow graph to determine where to    place the sets to the highest-priority value in respect of first the first    insn in any one block.  Any adjustments required to the transparency    vectors are made, then the next iteration starts for the next-lower    priority mode, till for each entity all modes are exhausted.     More details are located in the code for optimize_mode_switching().  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This structure contains the information for each insn which requires    either single or double mode to be set.    MODE is the mode this insn must be executed in.    INSN_PTR is the insn to be executed (may be the note that marks the    beginning of a basic block).    BBNUM is the flow graph basic block this insn occurs in.    NEXT is the next insn in the same basic block.  */
end_comment

begin_struct
struct|struct
name|seginfo
block|{
name|int
name|mode
decl_stmt|;
name|rtx
name|insn_ptr
decl_stmt|;
name|int
name|bbnum
decl_stmt|;
name|struct
name|seginfo
modifier|*
name|next
decl_stmt|;
name|HARD_REG_SET
name|regs_live
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bb_info
block|{
name|struct
name|seginfo
modifier|*
name|seginfo
decl_stmt|;
name|int
name|computing
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* These bitmaps are used for the LCM algorithm.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|antic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|comp
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|seginfo
modifier|*
name|new_seginfo
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|HARD_REG_SET
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_seginfo
parameter_list|(
name|struct
name|bb_info
modifier|*
parameter_list|,
name|struct
name|seginfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_dies
parameter_list|(
name|rtx
parameter_list|,
name|HARD_REG_SET
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_preds_opaque
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* This function will allocate a new BBINFO structure, initialized    with the MODE, INSN, and basic block BB parameters.  */
end_comment

begin_function
specifier|static
name|struct
name|seginfo
modifier|*
name|new_seginfo
parameter_list|(
name|int
name|mode
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|bb
parameter_list|,
name|HARD_REG_SET
name|regs_live
parameter_list|)
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|XNEW
argument_list|(
expr|struct
name|seginfo
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|ptr
operator|->
name|insn_ptr
operator|=
name|insn
expr_stmt|;
name|ptr
operator|->
name|bbnum
operator|=
name|bb
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|ptr
operator|->
name|regs_live
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Add a seginfo element to the end of a list.    HEAD is a pointer to the list beginning.    INFO is the structure to be linked in.  */
end_comment

begin_function
specifier|static
name|void
name|add_seginfo
parameter_list|(
name|struct
name|bb_info
modifier|*
name|head
parameter_list|,
name|struct
name|seginfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|seginfo
operator|==
name|NULL
condition|)
name|head
operator|->
name|seginfo
operator|=
name|info
expr_stmt|;
else|else
block|{
name|ptr
operator|=
name|head
operator|->
name|seginfo
expr_stmt|;
while|while
condition|(
name|ptr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make all predecessors of basic block B opaque, recursively, till we hit    some that are already non-transparent, or an edge where aux is set; that    denotes that a mode set is to be done on that edge.    J is the bit number in the bitmaps that corresponds to the entity that    we are currently handling mode-switching for.  */
end_comment

begin_function
specifier|static
name|void
name|make_preds_opaque
parameter_list|(
name|basic_block
name|b
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|b->preds
argument_list|)
block|{
name|basic_block
name|pb
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|aux
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|pb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
name|RESET_BIT
argument_list|(
name|transp
index|[
name|pb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|make_preds_opaque
argument_list|(
name|pb
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record in LIVE that register REG died.  */
end_comment

begin_function
specifier|static
name|void
name|reg_dies
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|HARD_REG_SET
name|live
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|nregs
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
operator|-
literal|1
init|;
name|nregs
operator|>=
literal|0
condition|;
name|nregs
operator|--
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|live
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record in LIVE that register REG became live.    This is called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|live
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|nregs
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
operator|-
literal|1
init|;
name|nregs
operator|>=
literal|0
condition|;
name|nregs
operator|--
control|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|live
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure if MODE_ENTRY is defined the MODE_EXIT is defined    and vice versa.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MODE_ENTRY
argument_list|)
operator|!=
name|defined
argument_list|(
name|MODE_EXIT
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"Both MODE_ENTRY and MODE_EXIT must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MODE_ENTRY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MODE_EXIT
argument_list|)
end_if

begin_comment
comment|/* Split the fallthrough edge to the exit block, so that we can note    that there NORMAL_MODE is required.  Return the new block if it's    inserted before the exit block.  Otherwise return null.  */
end_comment

begin_function
specifier|static
name|basic_block
name|create_pre_exit
parameter_list|(
name|int
name|n_entities
parameter_list|,
name|int
modifier|*
name|entity_map
parameter_list|,
specifier|const
name|int
modifier|*
name|num_modes
parameter_list|)
block|{
name|edge
name|eg
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|pre_exit
decl_stmt|;
comment|/* The only non-call predecessor at this stage is a block with a      fallthrough edge; there can be at most one, but there could be      none at all, e.g. when exit is called.  */
name|pre_exit
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|eg
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
name|eg
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|basic_block
name|src_bb
init|=
name|eg
operator|->
name|src
decl_stmt|;
name|regset
name|live_at_end
init|=
name|src_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|,
name|ret_reg
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|pre_exit
argument_list|)
expr_stmt|;
comment|/* If this function returns a value at the end, we have to 	   insert the final mode switch before the return value copy 	   to its hard register.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|)
operator|==
literal|1
operator|&&
name|NONJUMP_INSN_P
argument_list|(
operator|(
name|last_insn
operator|=
name|BB_END
argument_list|(
name|src_bb
argument_list|)
operator|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last_insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
operator|(
name|ret_reg
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|last_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|ret_start
init|=
name|REGNO
argument_list|(
name|ret_reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|hard_regno_nregs
index|[
name|ret_start
index|]
index|[
name|GET_MODE
argument_list|(
name|ret_reg
argument_list|)
index|]
decl_stmt|;
name|int
name|ret_end
init|=
name|ret_start
operator|+
name|nregs
decl_stmt|;
name|int
name|short_block
init|=
literal|0
decl_stmt|;
name|int
name|maybe_builtin_apply
init|=
literal|0
decl_stmt|;
name|int
name|forced_late_switch
init|=
literal|0
decl_stmt|;
name|rtx
name|before_return_copy
decl_stmt|;
do|do
block|{
name|rtx
name|return_copy
init|=
name|PREV_INSN
argument_list|(
name|last_insn
argument_list|)
decl_stmt|;
name|rtx
name|return_copy_pat
decl_stmt|,
name|copy_reg
decl_stmt|;
name|int
name|copy_start
decl_stmt|,
name|copy_num
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|return_copy
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|return_copy
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|return_copy
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|return_copy
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|maybe_builtin_apply
operator|=
literal|1
expr_stmt|;
name|last_insn
operator|=
name|return_copy
expr_stmt|;
continue|continue;
block|}
comment|/* If the return register is not (in its entirety) 		       likely spilled, the return copy might be 		       partially or completely optimized away.  */
name|return_copy_pat
operator|=
name|single_set
argument_list|(
name|return_copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|return_copy_pat
condition|)
block|{
name|return_copy_pat
operator|=
name|PATTERN
argument_list|(
name|return_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|return_copy_pat
argument_list|)
operator|!=
name|CLOBBER
condition|)
break|break;
block|}
name|copy_reg
operator|=
name|SET_DEST
argument_list|(
name|return_copy_pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_reg
argument_list|)
operator|==
name|REG
condition|)
name|copy_start
operator|=
name|REGNO
argument_list|(
name|copy_reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|copy_reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|copy_start
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|copy_reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|copy_start
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
break|break;
name|copy_num
operator|=
name|hard_regno_nregs
index|[
name|copy_start
index|]
index|[
name|GET_MODE
argument_list|(
name|copy_reg
argument_list|)
index|]
expr_stmt|;
comment|/* If the return register is not likely spilled, - as is 		       the case for floating point on SH4 - then it might 		       be set by an arithmetic operation that needs a 		       different mode than the exit block.  */
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|e
init|=
name|entity_map
index|[
name|j
index|]
decl_stmt|;
name|int
name|mode
init|=
name|MODE_NEEDED
argument_list|(
name|e
argument_list|,
name|return_copy
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|num_modes
index|[
name|e
index|]
operator|&&
name|mode
operator|!=
name|MODE_EXIT
argument_list|(
name|e
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
comment|/* For the SH4, floating point loads depend on fpscr, 			   thus we might need to put the final mode switch 			   after the return value copy.  That is still OK, 			   because a floating point return value does not 			   conflict with address reloads.  */
if|if
condition|(
name|copy_start
operator|>=
name|ret_start
operator|&&
name|copy_start
operator|+
name|copy_num
operator|<=
name|ret_end
operator|&&
name|OBJECT_P
argument_list|(
name|SET_SRC
argument_list|(
name|return_copy_pat
argument_list|)
argument_list|)
condition|)
name|forced_late_switch
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copy_start
operator|>=
name|ret_start
operator|&&
name|copy_start
operator|+
name|copy_num
operator|<=
name|ret_end
condition|)
name|nregs
operator|-=
name|copy_num
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|maybe_builtin_apply
operator|||
operator|!
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|copy_start
argument_list|)
condition|)
break|break;
name|last_insn
operator|=
name|return_copy
expr_stmt|;
block|}
comment|/* ??? Exception handling can lead to the return value 		   copy being already separated from the return value use, 		   as in  unwind-dw2.c . 		   Similarly, conditionally returning without a value, 		   and conditionally using builtin_return can lead to an 		   isolated use.  */
if|if
condition|(
name|return_copy
operator|==
name|BB_HEAD
argument_list|(
name|src_bb
argument_list|)
condition|)
block|{
name|short_block
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|last_insn
operator|=
name|return_copy
expr_stmt|;
block|}
do|while
condition|(
name|nregs
condition|)
do|;
comment|/* If we didn't see a full return value copy, verify that there 	       is a plausible reason for this.  If some, but not all of the 	       return register is likely spilled, we can expect that there 	       is a copy for the likely spilled part.  */
name|gcc_assert
argument_list|(
operator|!
name|nregs
operator|||
name|forced_late_switch
operator|||
name|short_block
operator|||
operator|!
operator|(
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|ret_start
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|nregs
operator|!=
name|hard_regno_nregs
index|[
name|ret_start
index|]
index|[
name|GET_MODE
argument_list|(
name|ret_reg
argument_list|)
index|]
operator|)
comment|/* For multi-hard-register floating point 		   	   values, sometimes the likely-spilled part 		   	   is ordinarily copied first, then the other 		   	   part is set with an arithmetic operation. 		   	   This doesn't actually cause reload 		   	   failures, so let it pass.  */
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|ret_reg
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|nregs
operator|!=
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|last_insn
argument_list|)
condition|)
block|{
name|before_return_copy
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
comment|/* Instructions preceding LAST_INSN in the same block might 		   require a different mode than MODE_EXIT, so if we might 		   have such instructions, keep them in a separate block 		   from pre_exit.  */
if|if
condition|(
name|last_insn
operator|!=
name|BB_HEAD
argument_list|(
name|src_bb
argument_list|)
condition|)
name|src_bb
operator|=
name|split_block
argument_list|(
name|src_bb
argument_list|,
name|PREV_INSN
argument_list|(
name|before_return_copy
argument_list|)
argument_list|)
operator|->
name|dest
expr_stmt|;
block|}
else|else
name|before_return_copy
operator|=
name|last_insn
expr_stmt|;
name|pre_exit
operator|=
name|split_block
argument_list|(
name|src_bb
argument_list|,
name|before_return_copy
argument_list|)
operator|->
name|src
expr_stmt|;
block|}
else|else
block|{
name|pre_exit
operator|=
name|split_edge
argument_list|(
name|eg
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|pre_exit
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|live_at_end
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|pre_exit
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|live_at_end
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pre_exit
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Find all insns that need a particular mode setting, and insert the    necessary mode switches.  Return true if we did work.  */
end_comment

begin_function
specifier|static
name|int
name|optimize_mode_switching
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|e
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|need_commit
init|=
literal|0
decl_stmt|;
name|sbitmap
modifier|*
name|kill
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
specifier|static
specifier|const
name|int
name|num_modes
index|[]
init|=
name|NUM_MODES_FOR_MODE_SWITCHING
decl_stmt|;
define|#
directive|define
name|N_ENTITIES
value|ARRAY_SIZE (num_modes)
name|int
name|entity_map
index|[
name|N_ENTITIES
index|]
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
index|[
name|N_ENTITIES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|n_entities
decl_stmt|;
name|int
name|max_num_modes
init|=
literal|0
decl_stmt|;
name|bool
name|emited
init|=
name|false
decl_stmt|;
name|basic_block
name|post_entry
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|pre_exit
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|clear_bb_flags
argument_list|()
expr_stmt|;
for|for
control|(
name|e
operator|=
name|N_ENTITIES
operator|-
literal|1
operator|,
name|n_entities
operator|=
literal|0
init|;
name|e
operator|>=
literal|0
condition|;
name|e
operator|--
control|)
if|if
condition|(
name|OPTIMIZE_MODE_SWITCHING
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|int
name|entry_exit_extra
init|=
literal|0
decl_stmt|;
comment|/* Create the list of segments within each basic block. 	   If NORMAL_MODE is defined, allow for two extra 	   blocks split from the entry and exit block.  */
if|#
directive|if
name|defined
argument_list|(
name|MODE_ENTRY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MODE_EXIT
argument_list|)
name|entry_exit_extra
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
name|bb_info
index|[
name|n_entities
index|]
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|bb_info
argument_list|,
name|last_basic_block
operator|+
name|entry_exit_extra
argument_list|)
expr_stmt|;
name|entity_map
index|[
name|n_entities
operator|++
index|]
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|num_modes
index|[
name|e
index|]
operator|>
name|max_num_modes
condition|)
name|max_num_modes
operator|=
name|num_modes
index|[
name|e
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n_entities
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|MODE_ENTRY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MODE_EXIT
argument_list|)
comment|/* Split the edge from the entry block, so that we can note that      there NORMAL_MODE is supplied.  */
name|post_entry
operator|=
name|split_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
name|pre_exit
operator|=
name|create_pre_exit
argument_list|(
name|n_entities
argument_list|,
name|entity_map
argument_list|,
name|num_modes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create the bitmap vectors.  */
name|antic
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|transp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|e
init|=
name|entity_map
index|[
name|j
index|]
decl_stmt|;
name|int
name|no_mode
init|=
name|num_modes
index|[
name|e
index|]
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|info
init|=
name|bb_info
index|[
name|j
index|]
decl_stmt|;
comment|/* Determine what the first use (if any) need for a mode of entity E is. 	 This will be the mode that is anticipatable for this block. 	 Also compute the initial transparency settings.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|;
name|int
name|last_mode
init|=
name|no_mode
decl_stmt|;
name|HARD_REG_SET
name|live_now
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live_now
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
comment|/* Pretend the mode is clobbered across abnormal edges.  */
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
break|break;
if|if
condition|(
name|e
condition|)
block|{
name|ptr
operator|=
name|new_seginfo
argument_list|(
name|no_mode
argument_list|,
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
name|add_seginfo
argument_list|(
name|info
operator|+
name|bb
operator|->
name|index
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|mode
init|=
name|MODE_NEEDED
argument_list|(
name|e
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|no_mode
operator|&&
name|mode
operator|!=
name|last_mode
condition|)
block|{
name|last_mode
operator|=
name|mode
expr_stmt|;
name|ptr
operator|=
name|new_seginfo
argument_list|(
name|mode
argument_list|,
name|insn
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
name|add_seginfo
argument_list|(
name|info
operator|+
name|bb
operator|->
name|index
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MODE_AFTER
name|last_mode
operator|=
name|MODE_AFTER
argument_list|(
name|last_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Update LIVE_NOW.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|reg_dies
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_becomes_live
argument_list|,
operator|&
name|live_now
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
condition|)
name|reg_dies
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
block|}
block|}
name|info
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|computing
operator|=
name|last_mode
expr_stmt|;
comment|/* Check for blocks without ANY mode requirements.  */
if|if
condition|(
name|last_mode
operator|==
name|no_mode
condition|)
block|{
name|ptr
operator|=
name|new_seginfo
argument_list|(
name|no_mode
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
name|add_seginfo
argument_list|(
name|info
operator|+
name|bb
operator|->
name|index
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|MODE_ENTRY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MODE_EXIT
argument_list|)
block|{
name|int
name|mode
init|=
name|MODE_ENTRY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|no_mode
condition|)
block|{
name|bb
operator|=
name|post_entry
expr_stmt|;
comment|/* By always making this nontransparent, we save 	       an extra check in make_preds_opaque.  We also 	       need this to avoid confusing pre_edge_lcm when 	       antic is cleared but transp and comp are set.  */
name|RESET_BIT
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* Insert a fake computing definition of MODE into entry 	       blocks which compute no mode. This represents the mode on 	       entry.  */
name|info
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|computing
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|pre_exit
condition|)
name|info
index|[
name|pre_exit
operator|->
name|index
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|=
name|MODE_EXIT
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NORMAL_MODE */
block|}
name|kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_num_modes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|current_mode
index|[
name|N_ENTITIES
index|]
decl_stmt|;
name|sbitmap
modifier|*
name|delete
decl_stmt|;
name|sbitmap
modifier|*
name|insert
decl_stmt|;
comment|/* Set the anticipatable and computing arrays.  */
name|sbitmap_vector_zero
argument_list|(
name|antic
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|comp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|m
init|=
name|current_mode
index|[
name|j
index|]
operator|=
name|MODE_PRIORITY_TO_MODE
argument_list|(
name|entity_map
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|info
init|=
name|bb_info
index|[
name|j
index|]
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|info
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|==
name|m
condition|)
name|SET_BIT
argument_list|(
name|antic
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|computing
operator|==
name|m
condition|)
name|SET_BIT
argument_list|(
name|comp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Calculate the optimal locations for the 	 placement mode switches to modes with priority I.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|sbitmap_not
argument_list|(
name|kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|edge_list
operator|=
name|pre_edge_lcm
argument_list|(
name|n_entities
argument_list|,
name|transp
argument_list|,
name|comp
argument_list|,
name|antic
argument_list|,
name|kill
argument_list|,
operator|&
name|insert
argument_list|,
operator|&
name|delete
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
comment|/* Insert all mode sets that have been inserted by lcm.  */
name|int
name|no_mode
init|=
name|num_modes
index|[
name|entity_map
index|[
name|j
index|]
index|]
decl_stmt|;
comment|/* Wherever we have moved a mode setting upwards in the flow graph, 	     the blocks between the new setting site and the now redundant 	     computation ceases to be transparent for any lower-priority 	     mode of the same entity.  First set the aux field of each 	     insertion site edge non-transparent, then propagate the new 	     non-transparency from the redundant computation upwards till 	     we hit an insertion site or an already non-transparent block.  */
for|for
control|(
name|e
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
operator|-
literal|1
init|;
name|e
operator|>=
literal|0
condition|;
name|e
operator|--
control|)
block|{
name|edge
name|eg
init|=
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|basic_block
name|src_bb
decl_stmt|;
name|HARD_REG_SET
name|live_at_edge
decl_stmt|;
name|rtx
name|mode_set
decl_stmt|;
name|eg
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|insert
index|[
name|e
index|]
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
name|eg
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
name|mode
operator|=
name|current_mode
index|[
name|j
index|]
expr_stmt|;
name|src_bb
operator|=
name|eg
operator|->
name|src
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live_at_edge
argument_list|,
name|src_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|EMIT_MODE_SET
argument_list|(
name|entity_map
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|live_at_edge
argument_list|)
expr_stmt|;
name|mode_set
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Do not bother to insert empty sequence.  */
if|if
condition|(
name|mode_set
operator|==
name|NULL_RTX
condition|)
continue|continue;
comment|/* We should not get an abnormal edge here.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|eg
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
argument_list|)
expr_stmt|;
name|need_commit
operator|=
literal|1
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|mode_set
argument_list|,
name|eg
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|delete
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|make_preds_opaque
argument_list|(
name|bb
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* Cancel the 'deleted' mode set.  */
name|bb_info
index|[
name|j
index|]
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|=
name|no_mode
expr_stmt|;
block|}
block|}
name|sbitmap_vector_free
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|insert
argument_list|)
expr_stmt|;
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
block|}
comment|/* Now output the remaining mode sets in all the segments.  */
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|no_mode
init|=
name|num_modes
index|[
name|entity_map
index|[
name|j
index|]
index|]
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|bb_info
index|[
name|j
index|]
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|seginfo
init|;
name|ptr
condition|;
name|ptr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|mode
operator|!=
name|no_mode
condition|)
block|{
name|rtx
name|mode_set
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|EMIT_MODE_SET
argument_list|(
name|entity_map
index|[
name|j
index|]
argument_list|,
name|ptr
operator|->
name|mode
argument_list|,
name|ptr
operator|->
name|regs_live
argument_list|)
expr_stmt|;
name|mode_set
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Insert MODE_SET only if it is nonempty.  */
if|if
condition|(
name|mode_set
operator|!=
name|NULL_RTX
condition|)
block|{
name|emited
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|ptr
operator|->
name|insn_ptr
argument_list|)
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|ptr
operator|->
name|insn_ptr
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
name|emit_insn_after
argument_list|(
name|mode_set
argument_list|,
name|ptr
operator|->
name|insn_ptr
argument_list|)
expr_stmt|;
else|else
name|emit_insn_before
argument_list|(
name|mode_set
argument_list|,
name|ptr
operator|->
name|insn_ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bb_info
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Finished. Free up all the things we've allocated.  */
name|sbitmap_vector_free
argument_list|(
name|kill
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|antic
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_commit
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MODE_ENTRY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MODE_EXIT
argument_list|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_NO_INSN_DEL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|need_commit
operator|&&
operator|!
name|emited
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|update_life_info_in_dirty_blocks
argument_list|(
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
operator|(
name|PROP_DEATH_NOTES
operator||
name|PROP_KILL_DEAD_CODE
operator||
name|PROP_SCAN_DEAD_CODE
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPTIMIZE_MODE_SWITCHING */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_mode_switching
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPTIMIZE_MODE_SWITCHING
return|return
name|true
return|;
else|#
directive|else
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_mode_switching
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPTIMIZE_MODE_SWITCHING
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|optimize_mode_switching
argument_list|()
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* OPTIMIZE_MODE_SWITCHING */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_mode_switching
init|=
block|{
literal|"mode-sw"
block|,
comment|/* name */
name|gate_mode_switching
block|,
comment|/* gate */
name|rest_of_handle_mode_switching
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_MODE_SWITCH
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

