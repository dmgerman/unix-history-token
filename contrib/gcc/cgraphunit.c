begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Callgraph based interprocedural optimizations.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Jan Hubicka  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This module implements main driver of compilation process as well as    few basic interprocedural optimizers.     The main scope of this file is to act as an interface in between    tree based frontends and the backend (and middle end)     The front-end is supposed to use following functionality:      - cgraph_finalize_function        This function is called once front-end has parsed whole body of function       and it is certain that the function body nor the declaration will change.        (There is one exception needed for implementing GCC extern inline function.)      - cgraph_varpool_finalize_variable        This function has same behavior as the above but is used for static       variables.      - cgraph_finalize_compilation_unit        This function is called once compilation unit is finalized and it will       no longer change.        In the unit-at-a-time the call-graph construction and local function       analysis takes place here.  Bodies of unreachable functions are released       to conserve memory usage.        ???  The compilation unit in this point of view should be compilation       unit as defined by the language - for instance C frontend allows multiple       compilation units to be parsed at once and it should call function each       time parsing is done so we save memory.      - cgraph_optimize        In this unit-at-a-time compilation the intra procedural analysis takes       place here.  In particular the static functions whose address is never       taken are marked as local.  Backend can then use this information to       modify calling conventions, do better inlining or similar optimizations.      - cgraph_assemble_pending_functions     - cgraph_varpool_assemble_pending_variables        In non-unit-at-a-time mode these functions can be used to force compilation       of functions or variables that are known to be needed at given stage       of compilation      - cgraph_mark_needed_node     - cgraph_varpool_mark_needed_node        When function or variable is referenced by some hidden way (for instance       via assembly code and marked by attribute "used"), the call-graph data structure       must be updated accordingly by this function.      - analyze_expr callback        This function is responsible for lowering tree nodes not understood by       generic code into understandable ones or alternatively marking       callgraph and varpool nodes referenced by the as needed.        ??? On the tree-ssa genericizing should take place here and we will avoid       need for these hooks (replacing them by genericizing hook)      - expand_function callback        This function is used to expand function and pass it into RTL back-end.       Front-end should not make any assumptions about when this function can be       called.  In particular cgraph_assemble_pending_functions,       cgraph_varpool_assemble_pending_variables, cgraph_finalize_function,       cgraph_varpool_finalize_function, cgraph_optimize can cause arbitrarily       previously finalized functions to be expanded.      We implement two compilation modes.        - unit-at-a-time:  In this mode analyzing of all functions is deferred 	to cgraph_finalize_compilation_unit and expansion into cgraph_optimize.  	In cgraph_finalize_compilation_unit the reachable functions are 	analyzed.  During analysis the call-graph edges from reachable 	functions are constructed and their destinations are marked as 	reachable.  References to functions and variables are discovered too 	and variables found to be needed output to the assembly file.  Via 	mark_referenced call in assemble_variable functions referenced by 	static variables are noticed too.  	The intra-procedural information is produced and its existence 	indicated by global_info_ready.  Once this flag is set it is impossible 	to change function from !reachable to reachable and thus 	assemble_variable no longer call mark_referenced.  	Finally the call-graph is topologically sorted and all reachable functions 	that has not been completely inlined or are not external are output.  	??? It is possible that reference to function or variable is optimized 	out.  We can not deal with this nicely because topological order is not 	suitable for it.  For tree-ssa we may consider another pass doing 	optimization and re-discovering reachable functions.  	??? Reorganize code so variables are output very last and only if they 	really has been referenced by produced code, so we catch more cases 	where reference has been optimized out.        - non-unit-at-a-time  	All functions are variables are output as early as possible to conserve 	memory consumption.  This may or may not result in less memory used but 	it is still needed for some legacy code that rely on particular ordering 	of things output from the compiler.  	Varpool data structures are not used and variables are output directly.  	Functions are output early using call of 	cgraph_assemble_pending_function from cgraph_finalize_function.  The 	decision on whether function is needed is made more conservative so 	uninlininable static functions are needed too.  During the call-graph 	construction the edge destinations are not marked as reachable and it 	is completely relied upn assemble_variable to mark them.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ipa-prop.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_function_decl
specifier|static
name|void
name|cgraph_expand_all_functions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_mark_functions_to_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_expand_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|record_reference
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_output_pending_asms
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_increase_alignment
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Lists all assembled variables to be sent to debugger output later on.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|cgraph_varpool_node
operator|*
name|cgraph_varpool_assembled_nodes_queue
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Records tree nodes seen in record_reference.  Simply using    walk_tree_without_duplicates doesn't guarantee each node is visited    once because it gets a new htab upon each recursive call from    record_reference itself.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pointer_set_t
modifier|*
name|visited_nodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|cgraph_dump_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine if function DECL is needed.  That is, visible to something    either outside this translation unit, something magic in the system    configury, or (if not doing unit-at-a-time) to something we havn't    seen yet.  */
end_comment

begin_function
specifier|static
name|bool
name|decide_is_function_needed
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|origin
decl_stmt|;
if|if
condition|(
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|node
operator|->
name|local
operator|.
name|externally_visible
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If the user told us it is used, then it must be so.  */
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|externally_visible
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
operator|&&
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* ??? If the assembler name is set by hand, it is possible to assemble      the name later after finalizing the function and the fact is noticed      in assemble_name then.  This is arguably a bug.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If we decided it was needed before, but at the time we didn't have      the body of the function available, then it's still needed.  We have      to go back and re-check its dependencies now.  */
if|if
condition|(
name|node
operator|->
name|needed
condition|)
return|return
name|true
return|;
comment|/* Externally visible functions must be output.  The exception is      COMDAT functions that must be output only when they are needed.       When not optimizing, also output the static functions. (see      PR24561), but don't do so for always_inline functions, functions      declared inline and nested functions.  These was optimized out      in the original implementation and it is unclear whether we want      to change the behavior here.  */
if|if
condition|(
operator|(
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
operator|!
name|optimize
operator|&&
operator|!
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|node
operator|->
name|origin
operator|)
operator|)
operator|&&
operator|!
name|flag_whole_program
operator|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Constructors and destructors are reachable from the runtime by      some mechanism.  */
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
return|return
name|false
return|;
comment|/* If not doing unit at a time, then we'll only defer this function      if its marked for inlining.  Otherwise we want to emit it now.  */
comment|/* "extern inline" functions are never output locally.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Nested functions of extern inline function shall not be emit unless      we inlined the origin.  */
for|for
control|(
name|origin
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
init|;
name|origin
condition|;
name|origin
operator|=
name|decl_function_context
argument_list|(
name|origin
argument_list|)
control|)
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|origin
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We want to emit COMDAT functions only when absolutely necessary.  */
if|if
condition|(
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
operator|!
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
comment|/* When declared inline, defer even the uninlinable functions. 	     This allows them to be eliminated when unused.  */
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
operator|||
operator|!
name|cgraph_default_inline_p
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
operator|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Walk the decls we marked as necessary and see if they reference new    variables or functions and add them into the worklists.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_varpool_analyze_pending_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_CGRAPH
argument_list|)
expr_stmt|;
while|while
condition|(
name|cgraph_varpool_first_unanalyzed_node
condition|)
block|{
name|tree
name|decl
init|=
name|cgraph_varpool_first_unanalyzed_node
operator|->
name|decl
decl_stmt|;
name|cgraph_varpool_first_unanalyzed_node
operator|->
name|analyzed
operator|=
name|true
expr_stmt|;
name|cgraph_varpool_first_unanalyzed_node
operator|=
name|cgraph_varpool_first_unanalyzed_node
operator|->
name|next_needed
expr_stmt|;
comment|/* Compute the alignment early so function body expanders are 	 already informed about increased alignment.  */
name|align_variable
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|visited_nodes
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|record_reference
argument_list|,
name|NULL
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|NULL
expr_stmt|;
block|}
name|changed
operator|=
name|true
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_CGRAPH
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Optimization of function bodies might've rendered some variables as    unnecessary so we want to avoid these from being compiled.     This is done by pruning the queue and keeping only the variables that    really appear needed (ie they are either externally visible or referenced    by compiled function). Re-doing the reachability analysis on variables    brings back the remaining variables referenced by these.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_varpool_remove_unreferenced_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|next
decl_stmt|,
modifier|*
name|node
init|=
name|cgraph_varpool_nodes_queue
decl_stmt|;
name|cgraph_varpool_reset_queue
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
while|while
condition|(
name|node
condition|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|next
operator|=
name|node
operator|->
name|next_needed
expr_stmt|;
name|node
operator|->
name|needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|finalized
operator|&&
operator|(
operator|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|||
name|node
operator|->
name|force_output
operator|||
name|decide_is_variable_needed
argument_list|(
name|node
argument_list|,
name|decl
argument_list|)
comment|/* ??? Cgraph does not yet rule the world with an iron hand, 		 and does not control the emission of debug information. 		 After a variable has its DECL_RTL set, we must assume that 		 it may be referenced by the debug information, and we can 		 no longer elide it.  */
operator|||
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
comment|/* Make sure we mark alias targets as used targets.  */
name|finish_aliases_1
argument_list|()
expr_stmt|;
name|cgraph_varpool_analyze_pending_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When not doing unit-at-a-time, output all functions enqueued.    Return true when such a functions were found.  */
end_comment

begin_function
name|bool
name|cgraph_assemble_pending_functions
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|output
init|=
name|false
decl_stmt|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
return|return
name|false
return|;
name|cgraph_output_pending_asms
argument_list|()
expr_stmt|;
while|while
condition|(
name|cgraph_nodes_queue
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
init|=
name|cgraph_nodes_queue
decl_stmt|;
name|cgraph_nodes_queue
operator|=
name|cgraph_nodes_queue
operator|->
name|next_needed
expr_stmt|;
name|n
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|global
operator|.
name|inlined_to
operator|&&
operator|!
name|n
operator|->
name|alias
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|n
operator|->
name|decl
argument_list|)
condition|)
block|{
name|cgraph_expand_function
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|output
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Process CGRAPH_EXPAND_QUEUE, these are functions created during      the expansion process.  Note that this queue may grow as its      being processed, as the new functions may generate new ones.  */
while|while
condition|(
name|cgraph_expand_queue
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
init|=
name|cgraph_expand_queue
decl_stmt|;
name|cgraph_expand_queue
operator|=
name|cgraph_expand_queue
operator|->
name|next_needed
expr_stmt|;
name|n
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
name|cgraph_finalize_function
argument_list|(
name|n
operator|->
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|output
operator|=
name|true
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
end_function

begin_comment
comment|/* As an GCC extension we allow redefinition of the function.  The    semantics when both copies of bodies differ is not well defined.    We replace the old body with new body so in unit at a time mode    we always use new body, while in normal mode we may end up with    old body inlined into some functions and new body expanded and    inlined in others.     ??? It may make more sense to use one body for inlining and other    body for expanding the function but this is difficult to do.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_reset_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
comment|/* If node->output is set, then this is a unit-at-a-time compilation      and we have already begun whole-unit analysis.  This is *not*      testing for whether we've already emitted the function.  That      case can be sort-of legitimately seen with real function      redefinition errors.  I would argue that the front end should      never present us with such a case, but don't enforce that for now.  */
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|output
argument_list|)
expr_stmt|;
comment|/* Reset our data structures so we can analyze the function again.  */
name|memset
argument_list|(
operator|&
name|node
operator|->
name|local
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
operator|->
name|global
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|global
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
operator|->
name|rtl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|analyzed
operator|=
name|false
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|redefined_extern_inline
operator|=
name|true
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|finalized
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|n
operator|=
name|cgraph_nodes
init|;
name|n
condition|;
name|n
operator|=
name|next
control|)
block|{
name|next
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|global
operator|.
name|inlined_to
operator|==
name|node
condition|)
name|cgraph_remove_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|cgraph_node_remove_callees
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* We may need to re-queue the node for assembling in case      we already proceeded it and ignored as not needed.  */
if|if
condition|(
name|node
operator|->
name|reachable
operator|&&
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|cgraph_nodes_queue
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next_needed
control|)
if|if
condition|(
name|n
operator|==
name|node
condition|)
break|break;
if|if
condition|(
operator|!
name|n
condition|)
name|node
operator|->
name|reachable
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cgraph_lower_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|lowered
condition|)
return|return;
name|tree_lowering_passes
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|lowered
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APPLE LOCAL begin radar 6305545 */
end_comment

begin_comment
comment|/** lower_if_nested_functions - This routine is called from cplus side only.     Its purpose is to lower block helper (or any other nested function)     which may have been nested in a constructor or destructor. We have to     do this because structors are cloned and are not lowered themselves (which     is the only way to lower the nested functions). */
end_comment

begin_function
name|void
name|lower_if_nested_functions
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|lower_nested_functions
argument_list|(
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APPLE LOCAL end radar 6305545 */
end_comment

begin_comment
comment|/* DECL has been parsed.  Take it, queue it, compile it at the whim of the    logic in effect.  If NESTED is true, then our caller cannot stand to have    the garbage collector run at the moment.  We would need to either create    a new GC context, or just not compile right now.  */
end_comment

begin_function
name|void
name|cgraph_finalize_function
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|nested
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
init|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|finalized
condition|)
name|cgraph_reset_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|notice_global_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|finalized
operator|=
name|true
expr_stmt|;
name|node
operator|->
name|lowered
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
operator|->
name|cfg
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nested
condition|)
comment|/* APPLE LOCAL radar 6305545 */
name|lower_nested_functions
argument_list|(
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|nested
argument_list|)
expr_stmt|;
comment|/* If not unit at a time, then we need to create the call graph      now, so that called functions can be queued and emitted now.  */
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|cgraph_analyze_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|cgraph_decide_inlining_incrementally
argument_list|(
name|node
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decide_is_function_needed
argument_list|(
name|node
argument_list|,
name|decl
argument_list|)
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Since we reclaim unreachable nodes at the end of every language      level unit, we need to be conservative about possible entry points      there.  */
if|if
condition|(
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|cgraph_mark_reachable_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* If not unit at a time, go ahead and emit everything we've found      to be reachable at this time.  */
if|if
condition|(
operator|!
name|nested
condition|)
block|{
if|if
condition|(
operator|!
name|cgraph_assemble_pending_functions
argument_list|()
condition|)
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
comment|/* If we've not yet emitted decl, tell the debug info about it.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Possibly warn about unused parameters.  */
if|if
condition|(
name|warn_unused_parameter
condition|)
name|do_warn_unused_parameter
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk tree and record all calls.  Called via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|record_reference
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
comment|/* ??? Really, we should mark this decl as *potentially* referenced 	 by this function and re-examine whether the decl is actually used 	 after rtl has been generated.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cgraph_varpool_mark_needed_node
argument_list|(
name|cgraph_varpool_node
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang_hooks
operator|.
name|callgraph
operator|.
name|analyze_expr
condition|)
return|return
name|lang_hooks
operator|.
name|callgraph
operator|.
name|analyze_expr
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|data
argument_list|)
return|;
block|}
break|break;
case|case
name|FDESC_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|flag_unit_at_a_time
condition|)
block|{
comment|/* Record dereferences to the functions.  This makes the 	     functions reachable unconditionally.  */
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Save some cycles by not walking types and declaration as we 	 won't find anything useful there anyway.  */
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|>=
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
name|lang_hooks
operator|.
name|callgraph
operator|.
name|analyze_expr
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|data
argument_list|)
return|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create cgraph edges for function calls inside BODY from NODE.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_create_edges
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|function
modifier|*
name|this_cfun
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|body
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|step
decl_stmt|;
name|visited_nodes
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
comment|/* Reach the trees by walking over the CFG, and note the      enclosing basic-blocks in the call edges.  */
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|this_cfun
argument_list|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|call
operator|&&
operator|(
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
operator|)
condition|)
block|{
name|cgraph_create_edge
argument_list|(
name|node
argument_list|,
name|cgraph_node
argument_list|(
name|decl
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|1
argument_list|)
argument_list|,
name|record_reference
argument_list|,
name|node
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|record_reference
argument_list|,
name|node
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
else|else
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|record_reference
argument_list|,
name|node
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
comment|/* Look for initializers of constant variables and private statics.  */
for|for
control|(
name|step
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|body
argument_list|)
operator|->
name|unexpanded_var_list
init|;
name|step
condition|;
name|step
operator|=
name|TREE_CHAIN
argument_list|(
name|step
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|step
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|flag_unit_at_a_time
condition|)
name|cgraph_varpool_finalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|record_reference
argument_list|,
name|node
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
name|pointer_set_destroy
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Give initial reasons why inlining would fail.  Those gets    either NULLified or usually overwritten by more precise reason    later.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_inline_failed
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|inlined_to
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|->
name|inline_failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|redefined_extern_inline
condition|)
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"redefined extern inline functions are not "
literal|"considered for inlining"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
condition|)
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not inlinable"
argument_list|)
expr_stmt|;
else|else
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not considered for inlining"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rebuild call edges from current function after a passes not aware    of cgraph updating.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rebuild_cgraph_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
init|=
name|cgraph_node
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|cgraph_node_remove_callees
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|count
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|count
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|call
operator|&&
operator|(
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
operator|)
condition|)
name|cgraph_create_edge
argument_list|(
name|node
argument_list|,
name|cgraph_node
argument_list|(
name|decl
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|)
expr_stmt|;
block|}
name|initialize_inline_failed
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|global
operator|.
name|inlined_to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_rebuild_cgraph_edges
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rebuild_cgraph_edges
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Verify cgraph nodes of given cgraph node.  */
end_comment

begin_function
name|void
name|verify_cgraph_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|main_clone
decl_stmt|;
name|struct
name|function
modifier|*
name|this_cfun
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
decl_stmt|;
name|basic_block
name|this_block
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bool
name|error_found
init|=
name|false
decl_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_CGRAPH_VERIFY
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|aux
condition|)
block|{
name|error
argument_list|(
literal|"aux field set for edge %s->%s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|caller
argument_list|)
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Execution count is negative"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
block|{
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"caller edge count is negative"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|!=
operator|(
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|inlined_to
condition|?
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|inlined_to
else|:
name|e
operator|->
name|caller
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"inlined_to pointer is wrong"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|callers
operator|->
name|next_caller
condition|)
block|{
name|error
argument_list|(
literal|"multiple inline callers"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|inlined_to
condition|)
block|{
name|error
argument_list|(
literal|"inlined_to pointer set for noninline callers"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|node
operator|->
name|callers
operator|&&
name|node
operator|->
name|global
operator|.
name|inlined_to
condition|)
block|{
name|error
argument_list|(
literal|"inlined_to pointer is set but no predecessors found"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|==
name|node
condition|)
block|{
name|error
argument_list|(
literal|"inlined_to pointer refers to itself"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|main_clone
operator|=
name|cgraph_node
argument_list|(
name|node
operator|->
name|decl
argument_list|)
init|;
name|main_clone
condition|;
name|main_clone
operator|=
name|main_clone
operator|->
name|next_clone
control|)
if|if
condition|(
name|main_clone
operator|==
name|node
condition|)
break|break;
if|if
condition|(
operator|!
name|cgraph_node
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"node not found in cgraph_hash"
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|||
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|)
condition|)
block|{
if|if
condition|(
name|this_cfun
operator|->
name|cfg
condition|)
block|{
comment|/* The nodes we're interested in are never shared, so walk 	     the tree ignoring duplicates.  */
name|visited_nodes
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
comment|/* Reach the trees by walking over the CFG, and note the 	     enclosing basic-blocks in the call edges.  */
name|FOR_EACH_BB_FN
argument_list|(
argument|this_block
argument_list|,
argument|this_cfun
argument_list|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|this_block
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|call
operator|&&
operator|(
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
operator|)
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
init|=
name|cgraph_edge
argument_list|(
name|node
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|aux
condition|)
block|{
name|error
argument_list|(
literal|"shared call_stmt:"
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|decl
operator|!=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
operator|->
name|decl
operator|&&
name|e
operator|->
name|inline_failed
condition|)
block|{
name|error
argument_list|(
literal|"edge points to wrong declaration:"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" Instead of:"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"missing callgraph edge for call stmt:"
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
name|pointer_set_destroy
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* No CFG available?!  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|aux
condition|)
block|{
name|error
argument_list|(
literal|"edge %s->%s has no corresponding call_stmt"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|caller
argument_list|)
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|e
operator|->
name|call_stmt
argument_list|)
expr_stmt|;
name|error_found
operator|=
name|true
expr_stmt|;
block|}
name|e
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error_found
condition|)
block|{
name|dump_cgraph_node
argument_list|(
name|stderr
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"verify_cgraph_node failed"
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_CGRAPH_VERIFY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify whole cgraph structure.  */
end_comment

begin_function
name|void
name|verify_cgraph
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|sorrycount
operator|||
name|errorcount
condition|)
return|return;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|verify_cgraph_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output one variable, if necessary.  Return whether we output it.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_varpool_assemble_decl
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|node
operator|->
name|alias
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|assemble_variable
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Output all variables enqueued to be assembled.  */
end_comment

begin_function
name|bool
name|cgraph_varpool_assemble_pending_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return
name|false
return|;
comment|/* EH might mark decls as needed during expansion.  This should be safe since      we don't create references to new function, but it should not be used      elsewhere.  */
name|cgraph_varpool_analyze_pending_decls
argument_list|()
expr_stmt|;
while|while
condition|(
name|cgraph_varpool_nodes_queue
condition|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
init|=
name|cgraph_varpool_nodes_queue
decl_stmt|;
name|cgraph_varpool_nodes_queue
operator|=
name|cgraph_varpool_nodes_queue
operator|->
name|next_needed
expr_stmt|;
if|if
condition|(
name|cgraph_varpool_assemble_decl
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|node
operator|->
name|next_needed
operator|=
name|cgraph_varpool_assembled_nodes_queue
expr_stmt|;
name|cgraph_varpool_assembled_nodes_queue
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|finalized
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|node
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* cgraph_varpool_nodes_queue is now empty, clear the pointer to the last      element in the queue.  */
name|cgraph_varpool_last_needed_node
operator|=
name|NULL
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Output all variables enqueued to be assembled.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_varpool_output_debug_info
parameter_list|(
name|void
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcount
operator|==
literal|0
operator|&&
name|sorrycount
operator|==
literal|0
condition|)
while|while
condition|(
name|cgraph_varpool_assembled_nodes_queue
condition|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
init|=
name|cgraph_varpool_assembled_nodes_queue
decl_stmt|;
comment|/* Local static variables are never seen by check_global_declarations 	   so we need to output debug info by hand.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
operator|==
name|BLOCK
operator|||
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|errorcount
operator|==
literal|0
operator|&&
name|sorrycount
operator|==
literal|0
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|global_decl
call|)
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
name|cgraph_varpool_assembled_nodes_queue
operator|=
name|node
operator|->
name|next_needed
expr_stmt|;
name|node
operator|->
name|next_needed
operator|=
literal|0
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all asm statements we have stored up to be output.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_output_pending_asms
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_asm_node
modifier|*
name|can
decl_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
for|for
control|(
name|can
operator|=
name|cgraph_asm_nodes
init|;
name|can
condition|;
name|can
operator|=
name|can
operator|->
name|next
control|)
name|assemble_asm
argument_list|(
name|can
operator|->
name|asm_str
argument_list|)
expr_stmt|;
name|cgraph_asm_nodes
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the function scheduled to be output.  */
end_comment

begin_function
name|void
name|cgraph_analyze_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
name|push_cfun
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|cgraph_lower_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* First kill forward declaration so reverse inlining works properly.  */
name|cgraph_create_edges
argument_list|(
name|node
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|inlinable
operator|=
name|tree_inlinable_function_p
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
name|node
operator|->
name|local
operator|.
name|self_insns
operator|=
name|estimate_num_insns
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|inlinable
condition|)
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|=
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|disregard_inline_limits
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|initialize_inline_failed
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_really_no_inline
operator|&&
operator|!
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
name|node
operator|->
name|local
operator|.
name|inlinable
operator|=
literal|0
expr_stmt|;
comment|/* Inlining characteristics are maintained by the cgraph_mark_inline.  */
name|node
operator|->
name|global
operator|.
name|insns
operator|=
name|node
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
name|node
operator|->
name|analyzed
operator|=
name|true
expr_stmt|;
name|pop_cfun
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for externally_visible and used attributes and mark cgraph nodes    accordingly.     We cannot mark the nodes at the point the attributes are processed (in    handle_*_attribute) because the copy of the declarations available at that    point may not be canonical.  For example, in:      void f();     void f() __attribute__((used));     the declaration we see in handle_used_attribute will be the second    declaration -- but the front end will subsequently merge that declaration    with the original declaration and discard the second declaration.     Furthermore, we can't mark these nodes in cgraph_finalize_function because:      void f() {}     void f() __attribute__((externally_visible));     is valid.     So, we walk the nodes at the end of the translation unit, applying the    attributes at that point.  */
end_comment

begin_function
specifier|static
name|void
name|process_function_and_variable_attributes
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|first
parameter_list|,
name|struct
name|cgraph_varpool_node
modifier|*
name|first_var
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
operator|!=
name|first
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|mark_decl_referenced
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|finalized
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"externally_visible"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%J%<externally_visible%> attribute have effect only on public objects"
argument_list|,
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|finalized
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|externally_visible
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|vnode
operator|=
name|cgraph_varpool_nodes
init|;
name|vnode
operator|!=
name|first_var
condition|;
name|vnode
operator|=
name|vnode
operator|->
name|next
control|)
block|{
name|tree
name|decl
init|=
name|vnode
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|mark_decl_referenced
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnode
operator|->
name|finalized
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|vnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"externally_visible"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|vnode
operator|->
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%J%<externally_visible%> attribute have effect only on public objects"
argument_list|,
name|vnode
operator|->
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|vnode
operator|->
name|finalized
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|vnode
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|externally_visible
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Analyze the whole compilation unit once it is parsed completely.  */
end_comment

begin_function
name|void
name|cgraph_finalize_compilation_unit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Keep track of already processed nodes when called multiple times for      intermodule optimization.  */
specifier|static
name|struct
name|cgraph_node
modifier|*
name|first_analyzed
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|first_processed
init|=
name|first_analyzed
decl_stmt|;
specifier|static
name|struct
name|cgraph_varpool_node
modifier|*
name|first_analyzed_var
decl_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
name|finish_aliases_1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|cgraph_output_pending_asms
argument_list|()
expr_stmt|;
name|cgraph_assemble_pending_functions
argument_list|()
expr_stmt|;
name|cgraph_varpool_output_debug_info
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nAnalyzing compilation unit"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|timevar_push
argument_list|(
name|TV_CGRAPH
argument_list|)
expr_stmt|;
name|process_function_and_variable_attributes
argument_list|(
name|first_processed
argument_list|,
name|first_analyzed_var
argument_list|)
expr_stmt|;
name|first_processed
operator|=
name|cgraph_nodes
expr_stmt|;
name|first_analyzed_var
operator|=
name|cgraph_varpool_nodes
expr_stmt|;
name|cgraph_varpool_analyze_pending_decls
argument_list|()
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Initial entry points:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
operator|!=
name|first_analyzed
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|needed
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate reachability flag and lower representation of all reachable      functions.  In the future, lowering will introduce new functions and      new entry points on the way (by template instantiation and virtual      method table generation for instance).  */
while|while
condition|(
name|cgraph_nodes_queue
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
name|tree
name|decl
init|=
name|cgraph_nodes_queue
operator|->
name|decl
decl_stmt|;
name|node
operator|=
name|cgraph_nodes_queue
expr_stmt|;
name|cgraph_nodes_queue
operator|=
name|cgraph_nodes_queue
operator|->
name|next_needed
expr_stmt|;
name|node
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
comment|/* ??? It is possible to create extern inline function and later using 	 weak alias attribute to kill its body. See 	 gcc.c-torture/compile/20011119-1.c  */
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cgraph_reset_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|analyzed
operator|&&
name|node
operator|->
name|reachable
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|cgraph_analyze_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callees
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|edge
operator|->
name|callee
operator|->
name|reachable
condition|)
name|cgraph_mark_reachable_node
argument_list|(
name|edge
operator|->
name|callee
argument_list|)
expr_stmt|;
comment|/* We finalize local static variables during constructing callgraph          edges.  Process their attributes too.  */
name|process_function_and_variable_attributes
argument_list|(
name|first_processed
argument_list|,
name|first_analyzed_var
argument_list|)
expr_stmt|;
name|first_processed
operator|=
name|cgraph_nodes
expr_stmt|;
name|first_analyzed_var
operator|=
name|cgraph_varpool_nodes
expr_stmt|;
name|cgraph_varpool_analyze_pending_decls
argument_list|()
expr_stmt|;
block|}
comment|/* Collect entry points to the unit.  */
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Unit entry points:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
operator|!=
name|first_analyzed
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|needed
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n\nInitial "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nReclaiming functions:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
operator|!=
name|first_analyzed
condition|;
name|node
operator|=
name|next
control|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|finalized
operator|&&
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
name|cgraph_reset_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|reachable
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|cgraph_remove_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|node
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|local
operator|.
name|finalized
operator|||
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|->
name|analyzed
operator|==
name|node
operator|->
name|local
operator|.
name|finalized
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n\nReclaimed "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
name|first_analyzed
operator|=
name|cgraph_nodes
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CGRAPH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Figure out what functions we want to assemble.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_mark_functions_to_output
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|output
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
break|break;
comment|/* We need to output all local functions that are used and not 	 always inlined, as well as those that are reachable from 	 outside the current compilation unit.  */
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|&&
operator|(
name|node
operator|->
name|needed
operator|||
operator|(
name|e
operator|&&
name|node
operator|->
name|reachable
operator|)
operator|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|node
operator|->
name|output
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* We should've reclaimed all functions that are not needed.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|dump_cgraph_node
argument_list|(
name|stderr
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"failed to reclaim unneeded function"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|gcc_assert
argument_list|(
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|||
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Expand function specified by NODE.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_expand_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
comment|/* We ought to not compile any inline clones.  */
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|global
operator|.
name|inlined_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
name|announce_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cgraph_lower_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Generate RTL for the body of DECL.  */
name|lang_hooks
operator|.
name|callgraph
operator|.
name|expand_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Make sure that BE didn't give up on compiling.  */
comment|/* ??? Can happen with nested function of extern inline.  */
name|gcc_assert
argument_list|(
name|TREE_ASM_WRITTEN
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_preserve_function_body_p
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Eliminate all call edges.  This is important so the call_expr no longer 	 points to the dead function body.  */
name|cgraph_node_remove_callees
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|cgraph_function_flags_ready
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */
end_comment

begin_function
name|bool
name|cgraph_inline_p
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
operator|*
name|reason
operator|=
name|e
operator|->
name|inline_failed
expr_stmt|;
return|return
operator|!
name|e
operator|->
name|inline_failed
return|;
block|}
end_function

begin_comment
comment|/* Expand all functions that must be output.     Attempt to topologically sort the nodes so function is output when    all called functions are already assembled to allow data to be    propagated across the callgraph.  Use a stack to get smaller distance    between a function and its callees (later we may choose to use a more    sophisticated algorithm for function reordering; we will likely want    to use subsections to make the output functions appear in top-down    order).  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_expand_all_functions
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
init|=
name|XCNEWVEC
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|,
name|cgraph_n_nodes
argument_list|)
decl_stmt|;
name|int
name|order_pos
init|=
literal|0
decl_stmt|,
name|new_order_pos
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|order_pos
operator|=
name|cgraph_postorder
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|order_pos
operator|==
name|cgraph_n_nodes
argument_list|)
expr_stmt|;
comment|/* Garbage collector may remove inline clones we eliminate during      optimization.  So we must be sure to not reference them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|order
index|[
name|i
index|]
operator|->
name|output
condition|)
name|order
index|[
name|new_order_pos
operator|++
index|]
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|new_order_pos
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|output
condition|)
block|{
name|gcc_assert
argument_list|(
name|node
operator|->
name|reachable
argument_list|)
expr_stmt|;
name|node
operator|->
name|output
operator|=
literal|0
expr_stmt|;
name|cgraph_expand_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|order
argument_list|)
expr_stmt|;
comment|/* Process CGRAPH_EXPAND_QUEUE, these are functions created during      the expansion process.  Note that this queue may grow as its      being processed, as the new functions may generate new ones.  */
while|while
condition|(
name|cgraph_expand_queue
condition|)
block|{
name|node
operator|=
name|cgraph_expand_queue
expr_stmt|;
name|cgraph_expand_queue
operator|=
name|cgraph_expand_queue
operator|->
name|next_needed
expr_stmt|;
name|node
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|output
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|lowered
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|->
name|cfg
operator|!=
name|NULL
expr_stmt|;
name|cgraph_expand_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is used to sort the node types by the cgraph order number.  */
end_comment

begin_struct
struct|struct
name|cgraph_order_sort
block|{
enum|enum
block|{
name|ORDER_UNDEFINED
init|=
literal|0
block|,
name|ORDER_FUNCTION
block|,
name|ORDER_VAR
block|,
name|ORDER_ASM
block|}
name|kind
enum|;
union|union
block|{
name|struct
name|cgraph_node
modifier|*
name|f
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|v
decl_stmt|;
name|struct
name|cgraph_asm_node
modifier|*
name|a
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Output all functions, variables, and asm statements in the order    according to their order fields, which is the order in which they    appeared in the file.  This implements -fno-toplevel-reorder.  In    this mode we may output functions and variables which don't really    need to be output.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_output_in_order
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|max
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|struct
name|cgraph_order_sort
modifier|*
name|nodes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|pf
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|pv
decl_stmt|;
name|struct
name|cgraph_asm_node
modifier|*
name|pa
decl_stmt|;
name|max
operator|=
name|cgraph_order
expr_stmt|;
name|size
operator|=
name|max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_order_sort
argument_list|)
expr_stmt|;
name|nodes
operator|=
operator|(
expr|struct
name|cgraph_order_sort
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nodes
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cgraph_varpool_analyze_pending_decls
argument_list|()
expr_stmt|;
for|for
control|(
name|pf
operator|=
name|cgraph_nodes
init|;
name|pf
condition|;
name|pf
operator|=
name|pf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pf
operator|->
name|output
condition|)
block|{
name|i
operator|=
name|pf
operator|->
name|order
expr_stmt|;
name|gcc_assert
argument_list|(
name|nodes
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|ORDER_UNDEFINED
argument_list|)
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|kind
operator|=
name|ORDER_FUNCTION
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|u
operator|.
name|f
operator|=
name|pf
expr_stmt|;
block|}
block|}
for|for
control|(
name|pv
operator|=
name|cgraph_varpool_nodes_queue
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|next_needed
control|)
block|{
name|i
operator|=
name|pv
operator|->
name|order
expr_stmt|;
name|gcc_assert
argument_list|(
name|nodes
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|ORDER_UNDEFINED
argument_list|)
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|kind
operator|=
name|ORDER_VAR
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|u
operator|.
name|v
operator|=
name|pv
expr_stmt|;
block|}
for|for
control|(
name|pa
operator|=
name|cgraph_asm_nodes
init|;
name|pa
condition|;
name|pa
operator|=
name|pa
operator|->
name|next
control|)
block|{
name|i
operator|=
name|pa
operator|->
name|order
expr_stmt|;
name|gcc_assert
argument_list|(
name|nodes
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|ORDER_UNDEFINED
argument_list|)
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|kind
operator|=
name|ORDER_ASM
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|u
operator|.
name|a
operator|=
name|pa
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|nodes
index|[
name|i
index|]
operator|.
name|kind
condition|)
block|{
case|case
name|ORDER_FUNCTION
case|:
name|nodes
index|[
name|i
index|]
operator|.
name|u
operator|.
name|f
operator|->
name|output
operator|=
literal|0
expr_stmt|;
name|cgraph_expand_function
argument_list|(
name|nodes
index|[
name|i
index|]
operator|.
name|u
operator|.
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDER_VAR
case|:
name|cgraph_varpool_assemble_decl
argument_list|(
name|nodes
index|[
name|i
index|]
operator|.
name|u
operator|.
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDER_ASM
case|:
name|assemble_asm
argument_list|(
name|nodes
index|[
name|i
index|]
operator|.
name|u
operator|.
name|a
operator|->
name|asm_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDER_UNDEFINED
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|cgraph_asm_nodes
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark visibility of all functions.     A local function is one whose calls can occur only in the current    compilation unit and all its calls are explicit, so we can change    its calling convention.  We simply mark all static functions whose    address is not taken as local.     We also change the TREE_PUBLIC flag of all declarations that are public    in language point of view but we want to overwrite this default    via visibilities for the backend point of view.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_function_and_variable_visibility
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|node
operator|->
name|reachable
operator|&&
operator|(
name|DECL_COMDAT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|||
operator|(
operator|!
name|flag_whole_program
operator|&&
name|TREE_PUBLIC
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|node
operator|->
name|local
operator|.
name|externally_visible
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|externally_visible
operator|&&
name|node
operator|->
name|analyzed
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|flag_whole_program
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|node
operator|->
name|local
operator|.
name|local
operator|=
operator|(
operator|!
name|node
operator|->
name|needed
operator|&&
name|node
operator|->
name|analyzed
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|node
operator|->
name|local
operator|.
name|externally_visible
operator|)
expr_stmt|;
block|}
for|for
control|(
name|vnode
operator|=
name|cgraph_varpool_nodes_queue
init|;
name|vnode
condition|;
name|vnode
operator|=
name|vnode
operator|->
name|next_needed
control|)
block|{
if|if
condition|(
name|vnode
operator|->
name|needed
operator|&&
operator|!
name|flag_whole_program
operator|&&
operator|(
name|DECL_COMDAT
argument_list|(
name|vnode
operator|->
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|vnode
operator|->
name|decl
argument_list|)
operator|)
condition|)
name|vnode
operator|->
name|externally_visible
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|vnode
operator|->
name|externally_visible
condition|)
block|{
name|gcc_assert
argument_list|(
name|flag_whole_program
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|vnode
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|vnode
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_STATIC
argument_list|(
name|vnode
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Because we have to be conservative on the boundaries of source      level units, it is possible that we marked some functions in      reachable just because they might be used later via external      linkage, but after making them local they are really unreachable      now.  */
name|cgraph_remove_unreachable_nodes
argument_list|(
name|true
argument_list|,
name|cgraph_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nMarking local functions:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|local
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nMarking externally visible functions:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|externally_visible
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|cgraph_function_flags_ready
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when function body of DECL still needs to be kept around    for later re-use.  */
end_comment

begin_function
name|bool
name|cgraph_preserve_function_body_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|cgraph_global_info_ready
condition|)
return|return
operator|(
name|flag_really_no_inline
condition|?
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|disregard_inline_limits
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|)
return|;
comment|/* Look if there is any clone around.  */
for|for
control|(
name|node
operator|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next_clone
control|)
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|inlined_to
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipa_passes
parameter_list|(
name|void
parameter_list|)
block|{
name|cfun
operator|=
name|NULL
expr_stmt|;
name|tree_register_cfg_hooks
argument_list|()
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|execute_ipa_pass_list
argument_list|(
name|all_ipa_passes
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform simple optimizations based on callgraph.  */
end_comment

begin_function
name|void
name|cgraph_optimize
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_cgraph
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|cgraph_output_pending_asms
argument_list|()
expr_stmt|;
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
name|cgraph_varpool_output_debug_info
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Frontend may output common variables after the unit has been finalized.      It is safe to deal with them here as they are always zero initialized.  */
name|cgraph_varpool_analyze_pending_decls
argument_list|()
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_CGRAPHOPT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Performing interprocedural optimizations\n"
argument_list|)
expr_stmt|;
name|cgraph_function_and_variable_visibility
argument_list|()
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Marked "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Don't run the IPA passes if there was any error or sorry messages.  */
if|if
condition|(
name|errorcount
operator|==
literal|0
operator|&&
name|sorrycount
operator|==
literal|0
condition|)
name|ipa_passes
argument_list|()
expr_stmt|;
comment|/* This pass remove bodies of extern inline functions we never inlined.      Do this later so other IPA passes see what is really going on.  */
name|cgraph_remove_unreachable_nodes
argument_list|(
name|false
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|cgraph_increase_alignment
argument_list|()
expr_stmt|;
name|cgraph_global_info_ready
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Optimized "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
name|dump_varpool
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_CGRAPHOPT
argument_list|)
expr_stmt|;
comment|/* Output everything.  */
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Assembling functions:\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_cgraph
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cgraph_mark_functions_to_output
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_toplevel_reorder
condition|)
name|cgraph_output_in_order
argument_list|()
expr_stmt|;
else|else
block|{
name|cgraph_output_pending_asms
argument_list|()
expr_stmt|;
name|cgraph_expand_all_functions
argument_list|()
expr_stmt|;
name|cgraph_varpool_remove_unreferenced_decls
argument_list|()
expr_stmt|;
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
name|cgraph_varpool_output_debug_info
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nFinal "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_cgraph
argument_list|()
expr_stmt|;
comment|/* Double check that all inline clones are gone and that all      function bodies have been released from memory.  */
if|if
condition|(
name|flag_unit_at_a_time
operator|&&
operator|!
operator|(
name|sorrycount
operator|||
name|errorcount
operator|)
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|bool
name|error_found
init|=
name|false
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
operator|(
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|||
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error_found
operator|=
name|true
expr_stmt|;
name|dump_cgraph_node
argument_list|(
name|stderr
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error_found
condition|)
name|internal_error
argument_list|(
literal|"nodes with no released memory found"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Increase alignment of global arrays to improve vectorization potential.    TODO:    - Consider also structs that have an array field.    - Use ipa analysis to prune arrays that can't be vectorized?      This should involve global alignment analysis and in the future also      array padding.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_increase_alignment
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_section_anchors
operator|&&
name|flag_tree_vectorize
condition|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
decl_stmt|;
comment|/* Increase the alignment of all global arrays for vectorization.  */
for|for
control|(
name|vnode
operator|=
name|cgraph_varpool_nodes_queue
init|;
name|vnode
condition|;
name|vnode
operator|=
name|vnode
operator|->
name|next_needed
control|)
block|{
name|tree
name|vectype
decl_stmt|,
name|decl
init|=
name|vnode
operator|->
name|decl
decl_stmt|;
name|unsigned
name|int
name|alignment
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
continue|continue;
name|vectype
operator|=
name|get_vectype_for_scalar_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vectype
condition|)
continue|continue;
name|alignment
operator|=
name|TYPE_ALIGN
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|>=
name|alignment
condition|)
continue|continue;
if|if
condition|(
name|vect_can_force_dr_alignment_p
argument_list|(
name|decl
argument_list|,
name|alignment
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Increasing alignment of decl: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|cgraph_dump_file
argument_list|,
name|decl
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate and emit a static constructor or destructor.  WHICH must be    one of 'I' or 'D'.  BODY should be a STATEMENT_LIST containing    GENERIC statements.  */
end_comment

begin_function
name|void
name|cgraph_build_static_cdtor
parameter_list|(
name|char
name|which
parameter_list|,
name|tree
name|body
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|static
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|char
name|which_buf
index|[
literal|16
index|]
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|name
decl_stmt|,
name|resdecl
decl_stmt|;
name|sprintf
argument_list|(
name|which_buf
argument_list|,
literal|"%c_%d"
argument_list|,
name|which
argument_list|,
name|counter
operator|++
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_file_function_name
argument_list|(
name|which_buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|name
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
name|resdecl
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|resdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|resdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
operator|=
name|resdecl
expr_stmt|;
name|allocate_struct_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
operator|=
name|body
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|targetm
operator|.
name|have_ctors_dtors
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|input_location
expr_stmt|;
name|cfun
operator|->
name|function_end_locus
operator|=
name|input_location
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|'I'
case|:
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gimplify_function_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* ??? We will get called LATE in the compilation process.  */
if|if
condition|(
name|cgraph_global_info_ready
condition|)
block|{
name|tree_lowering_passes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|tree_rest_of_compilation
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|cgraph_finalize_function
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|have_ctors_dtors
condition|)
block|{
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
if|if
condition|(
name|which
operator|==
literal|'I'
condition|)
name|fn
operator|=
name|targetm
operator|.
name|asm_out
operator|.
name|constructor
expr_stmt|;
else|else
name|fn
operator|=
name|targetm
operator|.
name|asm_out
operator|.
name|destructor
expr_stmt|;
name|fn
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_cgraph
parameter_list|(
name|void
parameter_list|)
block|{
name|cgraph_dump_file
operator|=
name|dump_begin
argument_list|(
name|TDI_cgraph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The edges representing the callers of the NEW_VERSION node were    fixed by cgraph_function_versioning (), now the call_expr in their    respective tree code should be updated to call the NEW_VERSION.  */
end_comment

begin_function
specifier|static
name|void
name|update_call_expr
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|new_version
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|gcc_assert
argument_list|(
name|new_version
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|new_version
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
comment|/* Update the call expr on the edges        to call the new version.  */
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|get_call_expr_in
argument_list|(
name|e
operator|->
name|call_stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|new_version
operator|->
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new cgraph node which is the new version of    OLD_VERSION node.  REDIRECT_CALLERS holds the callers    edges which should be redirected to point to    NEW_VERSION.  ALL the callees edges of OLD_VERSION    are cloned to the new version node.  Return the new    version node.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cgraph_node
modifier|*
name|cgraph_copy_node_for_versioning
argument_list|(
expr|struct
name|cgraph_node
operator|*
name|old_version
argument_list|,
name|tree
name|new_decl
argument_list|,
name|VEC
argument_list|(
name|cgraph_edge_p
argument_list|,
name|heap
argument_list|)
operator|*
name|redirect_callers
argument_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|new_version
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|new_e
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|next_callee
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|old_version
argument_list|)
expr_stmt|;
name|new_version
operator|=
name|cgraph_node
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|new_version
operator|->
name|analyzed
operator|=
name|true
expr_stmt|;
name|new_version
operator|->
name|local
operator|=
name|old_version
operator|->
name|local
expr_stmt|;
name|new_version
operator|->
name|global
operator|=
name|old_version
operator|->
name|global
expr_stmt|;
name|new_version
operator|->
name|rtl
operator|=
name|new_version
operator|->
name|rtl
expr_stmt|;
name|new_version
operator|->
name|reachable
operator|=
name|true
expr_stmt|;
name|new_version
operator|->
name|count
operator|=
name|old_version
operator|->
name|count
expr_stmt|;
comment|/* Clone the old node callees.  Recursive calls are       also cloned.  */
for|for
control|(
name|e
operator|=
name|old_version
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
name|new_e
operator|=
name|cgraph_clone_edge
argument_list|(
name|e
argument_list|,
name|new_version
argument_list|,
name|e
operator|->
name|call_stmt
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|loop_nest
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|new_e
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
block|}
comment|/* Fix recursive calls.       If OLD_VERSION has a recursive call after the       previous edge cloning, the new version will have an edge       pointing to the old version, which is wrong;       Redirect it to point to the new version. */
for|for
control|(
name|e
operator|=
name|new_version
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|next_callee
control|)
block|{
name|next_callee
operator|=
name|e
operator|->
name|next_callee
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|callee
operator|==
name|old_version
condition|)
name|cgraph_redirect_edge_callee
argument_list|(
name|e
argument_list|,
name|new_version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_callee
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|cgraph_edge_p
argument_list|,
name|redirect_callers
argument_list|,
name|i
argument_list|,
name|e
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Redirect calls to the old version node to point to its new 	  version.  */
name|cgraph_redirect_edge_callee
argument_list|(
name|e
argument_list|,
name|new_version
argument_list|)
expr_stmt|;
block|}
return|return
name|new_version
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Perform function versioning.     Function versioning includes copying of the tree and     a callgraph update (creating a new cgraph node and updating     its callees and callers).      REDIRECT_CALLERS varray includes the edges to be redirected     to the new version.      TREE_MAP is a mapping of tree nodes we want to replace with     new ones (according to results of prior analysis).     OLD_VERSION_NODE is the node that is versioned.     It returns the new version's cgraph node.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_node
modifier|*
name|cgraph_function_versioning
argument_list|(
expr|struct
name|cgraph_node
operator|*
name|old_version_node
argument_list|,
name|VEC
argument_list|(
name|cgraph_edge_p
argument_list|,
name|heap
argument_list|)
operator|*
name|redirect_callers
argument_list|,
name|varray_type
name|tree_map
argument_list|)
block|{
name|tree
name|old_decl
init|=
name|old_version_node
operator|->
name|decl
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|new_version_node
init|=
name|NULL
decl_stmt|;
name|tree
name|new_decl
decl_stmt|;
if|if
condition|(
operator|!
name|tree_versionable_function_p
argument_list|(
name|old_decl
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Make a new FUNCTION_DECL tree node for the      new version. */
name|new_decl
operator|=
name|copy_node
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
comment|/* Create the new version's call-graph node.      and update the edges of the new node. */
name|new_version_node
operator|=
name|cgraph_copy_node_for_versioning
argument_list|(
name|old_version_node
argument_list|,
name|new_decl
argument_list|,
name|redirect_callers
argument_list|)
expr_stmt|;
comment|/* Copy the OLD_VERSION_NODE function tree to the new version.  */
name|tree_function_versioning
argument_list|(
name|old_decl
argument_list|,
name|new_decl
argument_list|,
name|tree_map
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Update the call_expr on the edges to call the new version node. */
name|update_call_expr
argument_list|(
name|new_version_node
argument_list|)
expr_stmt|;
comment|/* Update the new version's properties.      Make The new version visible only within this translation unit.      ??? We cannot use COMDAT linkage because there is no      ABI support for this.  */
name|DECL_EXTERNAL
argument_list|(
name|new_version_node
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|new_version_node
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|new_version_node
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|new_version_node
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|new_version_node
operator|->
name|local
operator|.
name|externally_visible
operator|=
literal|0
expr_stmt|;
name|new_version_node
operator|->
name|local
operator|.
name|local
operator|=
literal|1
expr_stmt|;
name|new_version_node
operator|->
name|lowered
operator|=
name|true
expr_stmt|;
return|return
name|new_version_node
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Produce separate function body for inline clones so the offline copy can be    modified without affecting them.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|save_inline_function_body
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|first_clone
decl_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|==
name|cgraph_node
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|cgraph_lower_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* In non-unit-at-a-time we construct full fledged clone we never output to      assembly file.  This clone is pointed out by inline_decl of original function      and inlining infrastructure knows how to deal with this.  */
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|first_clone
operator|=
name|cgraph_clone_node
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|count
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|first_clone
operator|->
name|needed
operator|=
literal|0
expr_stmt|;
name|first_clone
operator|->
name|reachable
operator|=
literal|1
expr_stmt|;
comment|/* Recursively clone all bodies.  */
for|for
control|(
name|e
operator|=
name|first_clone
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
name|cgraph_clone_inlined_nodes
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|first_clone
operator|=
name|node
operator|->
name|next_clone
expr_stmt|;
name|first_clone
operator|->
name|decl
operator|=
name|copy_node
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|next_clone
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
name|node
operator|->
name|inline_decl
operator|=
name|first_clone
operator|->
name|decl
expr_stmt|;
name|first_clone
operator|->
name|prev_clone
operator|=
name|NULL
expr_stmt|;
name|cgraph_insert_node_to_hashtable
argument_list|(
name|first_clone
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|first_clone
operator|==
name|cgraph_node
argument_list|(
name|first_clone
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the OLD_VERSION_NODE function tree to the new version.  */
name|tree_function_versioning
argument_list|(
name|node
operator|->
name|decl
argument_list|,
name|first_clone
operator|->
name|decl
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|first_clone
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|first_clone
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|first_clone
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|first_clone
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|node
operator|=
name|first_clone
operator|->
name|next_clone
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next_clone
control|)
name|node
operator|->
name|decl
operator|=
name|first_clone
operator|->
name|decl
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_cgraph_node
argument_list|(
name|first_clone
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|first_clone
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cgraphunit.h"
end_include

end_unit

