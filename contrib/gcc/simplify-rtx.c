begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL simplification functions for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* Simplification and canonicalization of RTL.  */
end_comment

begin_comment
comment|/* Nonzero if X has the form (PLUS frame-pointer integer).  We check for    virtual regs here because the simplify_*_operation routines are called    by integrate.c, which is called before virtual register instantiation.     ?!? FIXED_BASE_PLUS_P and NONZERO_BASE_PLUS_P need to move into     a header file so that their definitions can be shared with the    simplification routines in simplify-rtx.c.  Until then, do not    change these macros without also changing the copy in simplify-rtx.c.  */
end_comment

begin_define
define|#
directive|define
name|FIXED_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((X) == frame_pointer_rtx || (X) == hard_frame_pointer_rtx	\    || ((X) == arg_pointer_rtx&& fixed_regs[ARG_POINTER_REGNUM])\    || (X) == virtual_stack_vars_rtx				\    || (X) == virtual_incoming_args_rtx				\    || (GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT \&& (XEXP (X, 0) == frame_pointer_rtx			\ 	   || XEXP (X, 0) == hard_frame_pointer_rtx		\ 	   || ((X) == arg_pointer_rtx				\&& fixed_regs[ARG_POINTER_REGNUM])		\ 	   || XEXP (X, 0) == virtual_stack_vars_rtx		\ 	   || XEXP (X, 0) == virtual_incoming_args_rtx))	\    || GET_CODE (X) == ADDRESSOF)
end_define

begin_comment
comment|/* Similar, but also allows reference to the stack pointer.     This used to include FIXED_BASE_PLUS_P, however, we can't assume that    arg_pointer_rtx by itself is nonzero, because on at least one machine,    the i960, the arg pointer is zero when it is unused.  */
end_comment

begin_define
define|#
directive|define
name|NONZERO_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((X) == frame_pointer_rtx || (X) == hard_frame_pointer_rtx	\    || (X) == virtual_stack_vars_rtx				\    || (X) == virtual_incoming_args_rtx				\    || (GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT \&& (XEXP (X, 0) == frame_pointer_rtx			\ 	   || XEXP (X, 0) == hard_frame_pointer_rtx		\ 	   || ((X) == arg_pointer_rtx				\&& fixed_regs[ARG_POINTER_REGNUM])		\ 	   || XEXP (X, 0) == virtual_stack_vars_rtx		\ 	   || XEXP (X, 0) == virtual_incoming_args_rtx))	\    || (X) == stack_pointer_rtx					\    || (X) == virtual_stack_dynamic_rtx				\    || (X) == virtual_outgoing_args_rtx				\    || (GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT \&& (XEXP (X, 0) == stack_pointer_rtx			\ 	   || XEXP (X, 0) == virtual_stack_dynamic_rtx		\ 	   || XEXP (X, 0) == virtual_outgoing_args_rtx))	\    || GET_CODE (X) == ADDRESSOF)
end_define

begin_comment
comment|/* Much code operates on (low, high) pairs; the low value is an    unsigned wide int, the high value a signed wide int.  We    occasionally need to sign extend from low to high as if low were a    signed wide int.  */
end_comment

begin_define
define|#
directive|define
name|HWI_SIGN_EXTEND
parameter_list|(
name|low
parameter_list|)
define|\
value|((((HOST_WIDE_INT) low)< 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))
end_define

begin_decl_stmt
specifier|static
name|rtx
name|neg_const_int
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|simplify_plus_minus_op_data_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_plus_minus
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_fold_consts
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|simplify_unary_real
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|simplify_binary_real
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|simplify_binary_is2orm1
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Negate a CONST_INT rtx, truncating (because a conversion from a    maximally negative number can overflow).  */
end_comment

begin_function
specifier|static
name|rtx
name|neg_const_int
parameter_list|(
name|mode
parameter_list|,
name|i
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|i
decl_stmt|;
block|{
return|return
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|i
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a binary operation by properly ordering the operands and     seeing if the expression folds.  */
end_comment

begin_function
name|rtx
name|simplify_gen_binary
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Put complex operands first and constants second if commutative.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
comment|/* If this simplifies, do it.  */
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* Handle addition and subtraction of CONST_INT specially.  Otherwise,      just form the operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|op1
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a MEM referencing the constant pool, return the real value.    Otherwise return X.  */
end_comment

begin_function
name|rtx
name|avoid_constant_pool_reference
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|c
decl_stmt|,
name|addr
decl_stmt|;
name|enum
name|machine_mode
name|cmode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|x
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|x
return|;
name|c
operator|=
name|get_pool_constant
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|cmode
operator|=
name|get_pool_mode
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If we're accessing the constant in a different mode than it was      originally stored, attempt to fix that up via subreg simplifications.      If that fails we have no choice but to return the original memory.  */
if|if
condition|(
name|cmode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|c
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|c
argument_list|,
name|cmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
condition|?
name|c
else|:
name|x
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a unary operation by first seeing if it folds and otherwise making    the specified operation.  */
end_comment

begin_function
name|rtx
name|simplify_gen_unary
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op
parameter_list|,
name|op_mode
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If this simplifies, use it.  */
if|if
condition|(
operator|(
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|op_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise for ternary operations.  */
end_comment

begin_function
name|rtx
name|simplify_gen_ternary
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0_mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|op0_mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If this simplifies, use it.  */
if|if
condition|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
return|return
name|gen_rtx_fmt_eee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Likewise, for relational operations.    CMP_MODE specifies mode comparison is done in.   */
end_comment

begin_function
name|rtx
name|simplify_gen_relational
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|cmp_mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|cmp_mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|cmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* Put complex operands first and constants second.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
operator|,
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace all occurrences of OLD in X with NEW and try to simplify the    resulting RTX.  Return a new RTX which is as simplified as possible.  */
end_comment

begin_function
name|rtx
name|simplify_replace_rtx
parameter_list|(
name|x
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|old
decl_stmt|;
name|rtx
name|new
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* If X is OLD, return NEW.  Otherwise, if this is an expression, try      to build a new expression substituting recursively.  If we can't do      anything, return our input.  */
if|if
condition|(
name|x
operator|==
name|old
condition|)
return|return
name|new
return|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op
init|=
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|old
condition|?
name|new
else|:
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
operator|)
decl_stmt|;
return|return
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|op_mode
argument_list|)
return|;
block|}
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
argument_list|,
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
argument_list|)
return|;
case|case
literal|'<'
case|:
block|{
name|enum
name|machine_mode
name|op_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|op0
init|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
decl_stmt|;
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
operator|(
name|op_mode
operator|!=
name|VOIDmode
condition|?
name|op_mode
else|:
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
case|case
literal|'3'
case|:
case|case
literal|'b'
case|:
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
decl_stmt|;
return|return
name|simplify_gen_ternary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
operator|(
name|op_mode
operator|!=
name|VOIDmode
condition|?
name|op_mode
else|:
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|)
argument_list|,
name|op0
argument_list|,
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
argument_list|,
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|'x'
case|:
comment|/* The only case we try to handle is a SUBREG.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|exp
decl_stmt|;
name|exp
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|simplify_replace_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
name|x
operator|=
name|exp
expr_stmt|;
block|}
return|return
name|x
return|;
default|default:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
argument_list|)
return|;
return|return
name|x
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
end_if

begin_comment
comment|/* Subroutine of simplify_unary_operation, called via do_float_handler.    Handles simplification of unary ops on floating point values.  */
end_comment

begin_struct
struct|struct
name|simplify_unary_real_args
block|{
name|rtx
name|operand
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|bool
name|want_integer
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|REAL_VALUE_ABS
parameter_list|(
name|d_
parameter_list|)
define|\
value|(REAL_VALUE_NEGATIVE (d_) ? REAL_VALUE_NEGATE (d_) : (d_))
end_define

begin_function
specifier|static
name|void
name|simplify_unary_real
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|struct
name|simplify_unary_real_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|simplify_unary_real_args
operator|*
operator|)
name|p
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|args
operator|->
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|want_integer
condition|)
block|{
name|HOST_WIDE_INT
name|i
decl_stmt|;
switch|switch
condition|(
name|args
operator|->
name|code
condition|)
block|{
case|case
name|FIX
case|:
name|i
operator|=
name|REAL_VALUE_FIX
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
name|i
operator|=
name|REAL_VALUE_UNSIGNED_FIX
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|args
operator|->
name|result
operator|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|i
argument_list|,
name|args
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|args
operator|->
name|code
condition|)
block|{
case|case
name|SQRT
case|:
comment|/* We don't attempt to optimize this.  */
name|args
operator|->
name|result
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|ABS
case|:
name|d
operator|=
name|REAL_VALUE_ABS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|d
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|d
operator|=
name|real_value_truncate
argument_list|(
name|args
operator|->
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
comment|/* All this does is change the mode.  */
break|break;
case|case
name|FIX
case|:
name|d
operator|=
name|REAL_VALUE_RNDZINT
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
name|d
operator|=
name|REAL_VALUE_UNSIGNED_RNDZINT
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|args
operator|->
name|result
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Try to simplify a unary operation CODE whose output mode is to be    MODE with input operand OP whose mode was originally OP_MODE.    Return zero if no simplification can be made.  */
end_comment

begin_function
name|rtx
name|simplify_unary_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op
parameter_list|,
name|op_mode
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
block|{
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|trueop
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* The order of these tests is critical so that, for example, we don't      check the wrong mode (input vs. output) for a conversion operation,      such as FIX.  At some point, this should be simplified.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|code
operator|==
name|FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_VALUE_FROM_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|hv
operator|<
literal|0
condition|)
block|{
name|d
operator|=
call|(
name|double
call|)
argument_list|(
operator|~
name|hv
argument_list|)
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|~
name|lv
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
operator|-
name|d
operator|-
literal|1.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|(
name|double
operator|)
name|hv
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|lv
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REAL_ARITHMETIC */
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|UNSIGNED_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We don't know how to interpret negative-looking numbers in 	     this case, so don't try to fold those.  */
if|if
condition|(
name|hv
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
empty_stmt|;
else|else
name|hv
operator|=
literal|0
operator|,
name|lv
operator|&=
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_VALUE_FROM_UNSIGNED_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|hv
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|lv
expr_stmt|;
endif|#
directive|endif
comment|/* REAL_ARITHMETIC */
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|arg0
init|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|val
operator|=
operator|~
name|arg0
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|val
operator|=
operator|-
name|arg0
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|val
operator|=
operator|(
name|arg0
operator|>=
literal|0
condition|?
name|arg0
else|:
operator|-
name|arg0
operator|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
comment|/* Don't use ffs here.  Instead, get low order bit and then its 	     number.  If arg0 is zero, this will return 0, as desired.  */
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
name|exact_log2
argument_list|(
name|arg0
operator|&
operator|(
operator|-
name|arg0
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|val
operator|=
name|arg0
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
if|if
condition|(
name|width
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
if|if
condition|(
name|width
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SQRT
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|SS_TRUNCATE
case|:
case|case
name|US_TRUNCATE
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|val
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/* We can do some operations on integer CONST_DOUBLEs.  Also allow      for a DImode operation on a CONST_INT.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|lv
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|hv
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
operator|,
name|h1
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|lv
operator|=
operator|~
name|l1
expr_stmt|;
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|FFS
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
name|lv
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|h1
operator|&
operator|(
operator|-
name|h1
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|lv
operator|=
name|exact_log2
argument_list|(
name|l1
operator|&
operator|(
operator|-
name|l1
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
comment|/* This is just a change-of-mode, so do nothing.  */
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
else|else
block|{
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|lv
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|lv
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SQRT
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|struct
name|simplify_unary_real_args
name|args
decl_stmt|;
name|args
operator|.
name|operand
operator|=
name|trueop
expr_stmt|;
name|args
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|args
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|args
operator|.
name|want_integer
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|simplify_unary_real
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
return|return
name|args
operator|.
name|result
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
name|struct
name|simplify_unary_real_args
name|args
decl_stmt|;
name|args
operator|.
name|operand
operator|=
name|trueop
expr_stmt|;
name|args
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|args
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|args
operator|.
name|want_integer
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|simplify_unary_real
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
return|return
name|args
operator|.
name|result
return|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* This was formerly used only for non-IEEE float.      eggert@twinsun.com says it is safe for IEEE also.  */
else|else
block|{
name|enum
name|rtx_code
name|reversed
decl_stmt|;
comment|/* There are some simplifications we can do even if the operands 	 aren't constant.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
comment|/* (not (not X)) == X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (not (eq X Y)) == (ne X Y), etc.  */
if|if
condition|(
name|mode
operator|==
name|BImode
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|reversed
operator|=
name|reversed_comparison_code
argument_list|(
name|op
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|UNKNOWN
operator|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|reversed
argument_list|,
name|op_mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|NEG
case|:
comment|/* (neg (neg X)) == X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* (sign_extend (truncate (minus (label_ref L1) (label_ref L2)))) 	     becomes just the MINUS if its mode is MODE.  This allows 	     folding switch statements on machines using casesi (such as 	     the VAX).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|)
operator|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
endif|#
directive|endif
break|break;
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>
literal|0
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|)
operator|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
end_if

begin_comment
comment|/* Subroutine of simplify_binary_operation, called via do_float_handler.    Handles simplification of binary ops on floating point values.  */
end_comment

begin_struct
struct|struct
name|simplify_binary_real_args
block|{
name|rtx
name|trueop0
decl_stmt|,
name|trueop1
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|simplify_binary_real
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|f0
decl_stmt|,
name|f1
decl_stmt|,
name|value
decl_stmt|;
name|struct
name|simplify_binary_real_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|simplify_binary_real_args
operator|*
operator|)
name|p
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f0
argument_list|,
name|args
operator|->
name|trueop0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f1
argument_list|,
name|args
operator|->
name|trueop1
argument_list|)
expr_stmt|;
name|f0
operator|=
name|real_value_truncate
argument_list|(
name|args
operator|->
name|mode
argument_list|,
name|f0
argument_list|)
expr_stmt|;
name|f1
operator|=
name|real_value_truncate
argument_list|(
name|args
operator|->
name|mode
argument_list|,
name|f1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|args
operator|->
name|code
operator|==
name|DIV
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f1
argument_list|,
name|dconst0
argument_list|)
condition|)
block|{
name|args
operator|->
name|result
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|REAL_ARITHMETIC
argument_list|(
name|value
argument_list|,
name|rtx_to_tree_code
argument_list|(
name|args
operator|->
name|code
argument_list|)
argument_list|,
name|f0
argument_list|,
name|f1
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|args
operator|->
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|value
operator|=
name|f0
operator|+
name|f1
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|value
operator|=
name|f0
operator|-
name|f1
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|value
operator|=
name|f0
operator|*
name|f1
expr_stmt|;
break|break;
case|case
name|DIV
case|:
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|f1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|value
operator|=
name|f0
operator|/
name|f1
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|value
operator|=
name|MIN
argument_list|(
name|f0
argument_list|,
name|f1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|value
operator|=
name|MAX
argument_list|(
name|f0
argument_list|,
name|f1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|value
operator|=
name|real_value_truncate
argument_list|(
name|args
operator|->
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|args
operator|->
name|result
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|value
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Another subroutine called via do_float_handler.  This one tests    the floating point value given against 2. and -1.  */
end_comment

begin_struct
struct|struct
name|simplify_binary_is2orm1_args
block|{
name|rtx
name|value
decl_stmt|;
name|bool
name|is_2
decl_stmt|;
name|bool
name|is_m1
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|simplify_binary_is2orm1
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|struct
name|simplify_binary_is2orm1_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|simplify_binary_is2orm1_args
operator|*
operator|)
name|p
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|args
operator|->
name|value
argument_list|)
expr_stmt|;
name|args
operator|->
name|is_2
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst2
argument_list|)
expr_stmt|;
name|args
operator|->
name|is_m1
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconstm1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simplify a binary operation CODE with result mode MODE, operating on OP0    and OP1.  Return 0 if no simplification is possible.     Don't use this for relational operations such as EQ or LT.    Use simplify_relational_operation instead.  */
end_comment

begin_function
name|rtx
name|simplify_binary_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg0s
decl_stmt|,
name|arg1s
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|trueop0
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|rtx
name|trueop1
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* Relational operations don't work here.  We must know the mode      of the operands in order to do the comparison correctly.      Assuming a full word can give incorrect results.      Consider comparing 128 with -128 in QImode.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Make sure the constant is second.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|trueop0
operator|,
name|trueop0
operator|=
name|trueop1
operator|,
name|trueop1
operator|=
name|tem
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|struct
name|simplify_binary_real_args
name|args
decl_stmt|;
name|args
operator|.
name|trueop0
operator|=
name|trueop0
expr_stmt|;
name|args
operator|.
name|trueop1
operator|=
name|trueop1
expr_stmt|;
name|args
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|args
operator|.
name|code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|simplify_binary_real
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
return|return
name|args
operator|.
name|result
return|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
comment|/* We can fold some multi-word operations.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|lv
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|hv
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop0
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
operator|,
name|h1
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l2
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop1
argument_list|)
operator|,
name|h2
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
else|else
name|l2
operator|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|,
name|h2
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MINUS
case|:
comment|/* A - B == A + (-B).  */
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
name|l2
operator|=
name|lv
operator|,
name|h2
operator|=
name|hv
expr_stmt|;
comment|/* .. fall through ...  */
case|case
name|PLUS
case|:
name|add_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|mul_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
comment|/* We'd need to include tree.h to do this and it doesn't seem worth 	     it.  */
return|return
literal|0
return|;
case|case
name|AND
case|:
name|lv
operator|=
name|l1
operator|&
name|l2
operator|,
name|hv
operator|=
name|h1
operator|&
name|h2
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|lv
operator|=
name|l1
operator||
name|l2
operator|,
name|hv
operator|=
name|h1
operator||
name|h2
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|lv
operator|=
name|l1
operator|^
name|l2
operator|,
name|hv
operator|=
name|h1
operator|^
name|h2
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|h1
operator|<
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|h1
operator|>
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|l2
operator|&=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|,
name|h2
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|h2
operator|!=
literal|0
operator|||
name|l2
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
condition|)
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
name|code
operator|==
name|ASHIFTRT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ROTATE
condition|)
name|lrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
comment|/* code == ROTATERT */
name|rrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
name|width
operator|==
literal|0
condition|)
block|{
comment|/* Even if we can't compute a constant result, 	 there are some cases worth simplifying.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* In IEEE floating point, x+0 is not the same as x.  Similarly 	     for the other optimizations below.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* ((-a) + b) -> (b - a) and similarly for (a + (-b)) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (~a) + 1 -> -a */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|trueop1
operator|==
name|const1_rtx
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Handle both-operands-constant cases.  We can only add 	     CONST_INTs to constants since the sum of relocatable symbols 	     can't be handled by most assemblers.  Don't add CONST_INT 	     to CONST_INT since overflow won't be computed properly if wider 	     than HOST_BITS_PER_WIDE_INT.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|INTVAL
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
comment|/* See if this is something like X * C - X or vice versa or 	     if the multiplication is written as a shift.  If so, we can 	     distribute and make a new multiply, shift, or maybe just 	     have X (if C is 2 in the example above).  But don't make 	     real multiply if we didn't have one before.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0
init|=
literal|1
decl_stmt|,
name|coeff1
init|=
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
name|int
name|had_mult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff0
operator|=
operator|-
literal|1
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff1
operator|=
operator|-
literal|1
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff1
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|GEN_INT
argument_list|(
name|coeff0
operator|+
name|coeff1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|had_mult
operator|)
condition|?
literal|0
else|:
name|tem
return|;
block|}
block|}
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	     simplify this by the associative law.  	     Don't use the associative law for floating point. 	     The inaccuracy makes it nonassociative, 	     and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|COMPARE
case|:
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Convert (compare FOO (const_int 0)) to FOO unless we aren't 	     using cc0, in which case we want to leave it as a COMPARE 	     so we can distinguish it from a register-register-copy.  	     In IEEE floating point, x-0 is not the same as x.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
endif|#
directive|endif
comment|/* Convert (compare (gt (flags) 0) (lt (flags) 0)) to (flags).  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GTU
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LTU
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|rtx
name|xop00
init|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop10
init|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|xop10
argument_list|)
operator|==
name|CC0
condition|)
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|xop10
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|xop10
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|xop00
argument_list|)
operator|==
name|REGNO
argument_list|(
name|xop10
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|xop00
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|xop10
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
endif|#
directive|endif
return|return
name|xop00
return|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* None of these optimizations can be done for IEEE 	     floating point.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
comment|/* We can't assume x-x is 0 even with non-IEEE floating point, 	     but since it is zero except in very strange circumstances, we 	     will treat it as zero with -funsafe-math-optimizations.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Change subtraction from zero into negation.  */
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
return|;
comment|/* (-1 - a) is ~a.  */
if|if
condition|(
name|trueop0
operator|==
name|constm1_rtx
condition|)
return|return
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Subtracting 0 has no effect.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* See if this is something like X * C - X or vice versa or 	     if the multiplication is written as a shift.  If so, we can 	     distribute and make a new multiply, shift, or maybe just 	     have X (if C is 2 in the example above).  But don't make 	     real multiply if we didn't have one before.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0
init|=
literal|1
decl_stmt|,
name|coeff1
init|=
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
name|int
name|had_mult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff0
operator|=
operator|-
literal|1
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff1
operator|=
operator|-
literal|1
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff1
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|GEN_INT
argument_list|(
name|coeff0
operator|-
name|coeff1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|had_mult
operator|)
condition|?
literal|0
else|:
name|tem
return|;
block|}
block|}
comment|/* (a - (-b)) -> (a + b).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	     simplify this by the associative law.  	     Don't use the associative law for floating point. 	     The inaccuracy makes it nonassociative, 	     and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* Don't let a relocatable value get a negative coeff.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
comment|/* (x - (x& y)) -> (x& ~y) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|AND
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|trueop1
operator|==
name|constm1_rtx
condition|)
block|{
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|tem
condition|?
name|tem
else|:
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
block|}
comment|/* In IEEE floating point, x*0 is not always 0.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for nans. 	     However, ANSI says we can drop signals, 	     so we can do this anyway.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Convert multiply by constant power of two into shift unless 	     we are still generating RTL.  This test is a kludge.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|val
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
comment|/* If the mode is larger than the host word size, and the 		 uppermost bit is set, then this isn't a power of two due 		 to implicit sign extension.  */
operator|&&
operator|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|val
operator|!=
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
operator|!
name|rtx_equal_function_value_matters
condition|)
return|return
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|struct
name|simplify_binary_is2orm1_args
name|args
decl_stmt|;
name|args
operator|.
name|value
operator|=
name|trueop1
expr_stmt|;
if|if
condition|(
operator|!
name|do_float_handler
argument_list|(
name|simplify_binary_is2orm1
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* x*2 is x+x and x*(-1) is -x */
if|if
condition|(
name|args
operator|.
name|is_2
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|args
operator|.
name|is_m1
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
block|}
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* A | (~A) -> -1 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|constm1_rtx
return|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
if|if
condition|(
name|trueop0
operator|==
name|trueop1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|trueop0
operator|==
name|trueop1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|op0
return|;
comment|/* A& (~A) -> 0 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|UDIV
case|:
comment|/* Convert divide by power of two into shift (divide by 1 handled 	     below).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|arg1
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|DIV
case|:
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* On some platforms DIV uses narrower mode than its 		 operands.  */
name|rtx
name|x
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
else|else
return|return
name|op0
return|;
block|}
comment|/* In IEEE floating point, 0/x is not always 0.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
comment|/* Change division by a constant into multiplication.  Only do 	     this with -funsafe-math-optimizations.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|trueop1
operator|!=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_unsafe_math_optimizations
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst0
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
name|REAL_ARITHMETIC
argument_list|(
name|d
argument_list|,
name|rtx_to_tree_code
argument_list|(
name|DIV
argument_list|)
argument_list|,
name|dconst1
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
literal|1.
operator|/
name|d
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|UMOD
case|:
comment|/* Handle modulus by power of two (mod with 1 handled below).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|MOD
case|:
if|if
condition|(
operator|(
name|trueop0
operator|==
name|const0_rtx
operator|||
name|trueop1
operator|==
name|const1_rtx
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
comment|/* Rotating ~0 always results in ~0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* ... fall through ...  */
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|trueop0
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
name|trueop1
operator|==
name|constm1_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|SS_PLUS
case|:
case|case
name|US_PLUS
case|:
case|case
name|SS_MINUS
case|:
case|case
name|US_MINUS
case|:
comment|/* ??? There are simplifications that can be done.  */
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Get the integer argument values in two forms:      zero-extended in ARG0, ARG1 and sign-extended in ARG0S, ARG1S.  */
name|arg0
operator|=
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|arg0
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg1
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg0s
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|arg0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|arg1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
else|else
block|{
name|arg0s
operator|=
name|arg0
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
block|}
comment|/* Compute the value of the arithmetic.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|val
operator|=
name|arg0s
operator|+
name|arg1s
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|val
operator|=
name|arg0s
operator|-
name|arg1s
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|val
operator|=
name|arg0s
operator|*
name|arg1s
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|/
name|arg1s
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|%
name|arg1s
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|/
name|arg1
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|%
name|arg1
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|val
operator|=
name|arg0
operator|&
name|arg1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|val
operator|=
name|arg0
operator||
name|arg1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|val
operator|=
name|arg0
operator|^
name|arg1
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
comment|/* If shift count is undefined, don't fold it; let the machine do 	 what it wants.  But truncate it if the machine will do that.  */
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|arg0s
operator|>>
name|arg1
expr_stmt|;
comment|/* Bootstrap compiler may not have sign extended the right shift. 	 Manually extend the sign to insure bootstrap cc matches gcc.  */
if|if
condition|(
name|arg0s
operator|<
literal|0
operator|&&
name|arg1
operator|>
literal|0
condition|)
name|val
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
comment|/* Do nothing here.  */
return|return
literal|0
return|;
case|case
name|SMIN
case|:
name|val
operator|=
name|arg0s
operator|<=
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|<=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|val
operator|=
name|arg0s
operator|>
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|val
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a PLUS or MINUS, at least one of whose operands may be another    PLUS or MINUS.     Rather than test for specific case, we do this by a brute-force method    and do all possible simplifications until no more changes occur.  Then    we rebuild the operation.  */
end_comment

begin_struct
struct|struct
name|simplify_plus_minus_op_data
block|{
name|rtx
name|op
decl_stmt|;
name|int
name|neg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|simplify_plus_minus_op_data_cmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|;
specifier|const
name|void
modifier|*
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|simplify_plus_minus_op_data
modifier|*
name|d1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|simplify_plus_minus_op_data
modifier|*
name|d2
init|=
name|p2
decl_stmt|;
return|return
operator|(
name|commutative_operand_precedence
argument_list|(
name|d2
operator|->
name|op
argument_list|)
operator|-
name|commutative_operand_precedence
argument_list|(
name|d1
operator|->
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|simplify_plus_minus
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|struct
name|simplify_plus_minus_op_data
name|ops
index|[
literal|8
index|]
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|n_ops
init|=
literal|2
decl_stmt|,
name|input_ops
init|=
literal|2
decl_stmt|,
name|input_consts
init|=
literal|0
decl_stmt|,
name|n_consts
decl_stmt|;
name|int
name|first
decl_stmt|,
name|negate
decl_stmt|,
name|changed
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ops
argument_list|)
expr_stmt|;
comment|/* Set up the two operands and then expand them until nothing has been      changed.  If we run out of room in our array, give up; this should      almost never happen.  */
name|ops
index|[
literal|0
index|]
operator|.
name|op
operator|=
name|op0
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|.
name|op
operator|=
name|op1
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|.
name|neg
operator|=
operator|(
name|code
operator|==
name|MINUS
operator|)
expr_stmt|;
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|this_op
init|=
name|ops
index|[
name|i
index|]
operator|.
name|op
decl_stmt|;
name|int
name|this_neg
init|=
name|ops
index|[
name|i
index|]
operator|.
name|neg
decl_stmt|;
name|enum
name|rtx_code
name|this_code
init|=
name|GET_CODE
argument_list|(
name|this_op
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|this_code
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|n_ops
operator|==
literal|7
condition|)
return|return
literal|0
return|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|neg
operator|=
operator|(
name|this_code
operator|==
name|MINUS
operator|)
operator|^
name|this_neg
expr_stmt|;
name|n_ops
operator|++
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input_ops
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
operator|!
name|this_neg
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input_consts
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NOT
case|:
comment|/* ~a -> (-a - 1) */
if|if
condition|(
name|n_ops
operator|!=
literal|7
condition|)
block|{
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|constm1_rtx
expr_stmt|;
name|ops
index|[
name|n_ops
operator|++
index|]
operator|.
name|neg
operator|=
name|this_neg
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
operator|!
name|this_neg
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|this_neg
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|this_op
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
comment|/* If we only have two operands, we can't do anything.  */
if|if
condition|(
name|n_ops
operator|<=
literal|2
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Now simplify each pair of operands until nothing changes.  The first      time through just simplify constants against each other.  */
name|first
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|changed
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|-
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_ops
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|lhs
init|=
name|ops
index|[
name|i
index|]
operator|.
name|op
decl_stmt|,
name|rhs
init|=
name|ops
index|[
name|j
index|]
operator|.
name|op
decl_stmt|;
name|int
name|lneg
init|=
name|ops
index|[
name|i
index|]
operator|.
name|neg
decl_stmt|,
name|rneg
init|=
name|ops
index|[
name|j
index|]
operator|.
name|neg
decl_stmt|;
if|if
condition|(
name|lhs
operator|!=
literal|0
operator|&&
name|rhs
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|first
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|lhs
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|rhs
argument_list|)
operator|)
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|ncode
init|=
name|PLUS
decl_stmt|;
if|if
condition|(
name|lneg
operator|!=
name|rneg
condition|)
block|{
name|ncode
operator|=
name|MINUS
expr_stmt|;
if|if
condition|(
name|lneg
condition|)
name|tem
operator|=
name|lhs
operator|,
name|lhs
operator|=
name|rhs
operator|,
name|rhs
operator|=
name|tem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
name|tem
operator|=
name|lhs
operator|,
name|lhs
operator|=
name|rhs
operator|,
name|rhs
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|ncode
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* Reject "simplifications" that just wrap the two  		   arguments in a CONST.  Failure to do so can result 		   in infinite recursion with simplify_binary_operation 		   when it calls us to simplify CONST operations.  */
if|if
condition|(
name|tem
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ncode
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|lhs
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|rhs
operator|)
comment|/* Don't allow -x + -1 -> ~x simplifications in the 		       first pass.  This allows us the chance to combine 		       the -1 with other constants.  */
operator|&&
operator|!
operator|(
name|first
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOT
operator|&&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|==
name|rhs
operator|)
condition|)
block|{
name|lneg
operator|&=
name|rneg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NEG
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|,
name|lneg
operator|=
operator|!
name|lneg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|lneg
condition|)
name|tem
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
operator|,
name|lneg
operator|=
literal|0
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|tem
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
name|lneg
expr_stmt|;
name|ops
index|[
name|j
index|]
operator|.
name|op
operator|=
name|NULL_RTX
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|changed
condition|)
do|;
comment|/* Pack all the operands to the lower-numbered entries.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_ops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|j
index|]
operator|.
name|op
condition|)
name|ops
index|[
name|i
operator|++
index|]
operator|=
name|ops
index|[
name|j
index|]
expr_stmt|;
name|n_ops
operator|=
name|i
expr_stmt|;
comment|/* Sort the operations based on swap_commutative_operands_p.  */
name|qsort
argument_list|(
name|ops
argument_list|,
name|n_ops
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ops
argument_list|)
argument_list|,
name|simplify_plus_minus_op_data_cmp
argument_list|)
expr_stmt|;
comment|/* We suppressed creation of trivial CONST expressions in the      combination loop to avoid recursion.  Create one manually now.      The combination loop should have ensured that there is exactly      one CONST_INT, and the sort will have ensured that it is last      in the array and that any other constant will be next-to-last.  */
if|if
condition|(
name|n_ops
operator|>
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONSTANT_P
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
argument_list|)
condition|)
block|{
name|rtx
name|value
init|=
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|neg
operator|^
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|neg
condition|)
name|value
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
operator|=
name|plus_constant
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
argument_list|,
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|n_ops
operator|--
expr_stmt|;
block|}
comment|/* Count the number of CONSTs that we generated.  */
name|n_consts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|n_consts
operator|++
expr_stmt|;
comment|/* Give up if we didn't reduce the number of operands we had.  Make      sure we count a CONST as two operands.  If we have the same      number of operands, but have made more CONSTs than before, this      is also an improvement, so accept it.  */
if|if
condition|(
name|n_ops
operator|+
name|n_consts
operator|>
name|input_ops
operator|||
operator|(
name|n_ops
operator|+
name|n_consts
operator|==
name|input_ops
operator|&&
name|n_consts
operator|<=
name|input_consts
operator|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Put a non-negated operand first.  If there aren't any, make all      operands positive and negate the whole thing later.  */
name|negate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|&&
name|ops
index|[
name|i
index|]
operator|.
name|neg
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|n_ops
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|negate
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|ops
index|[
name|i
index|]
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|tem
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now make the result by performing the requested operations.  */
name|result
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|ops
index|[
name|i
index|]
operator|.
name|neg
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|mode
argument_list|,
name|result
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
return|return
name|negate
condition|?
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|result
argument_list|)
else|:
name|result
return|;
block|}
end_function

begin_struct
struct|struct
name|cfc_args
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* Input */
name|int
name|equal
decl_stmt|,
name|op0lt
decl_stmt|,
name|op1lt
decl_stmt|;
comment|/* Output */
name|int
name|unordered
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|check_fold_consts
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|cfc_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|cfc_args
operator|*
operator|)
name|data
decl_stmt|;
name|REAL_VALUE_TYPE
name|d0
decl_stmt|,
name|d1
decl_stmt|;
comment|/* We may possibly raise an exception while reading the value.  */
name|args
operator|->
name|unordered
operator|=
literal|1
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d0
argument_list|,
name|args
operator|->
name|op0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d1
argument_list|,
name|args
operator|->
name|op1
argument_list|)
expr_stmt|;
comment|/* Comparisons of Inf versus Inf are ordered.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d0
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
condition|)
return|return;
name|args
operator|->
name|equal
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|args
operator|->
name|op0lt
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|args
operator|->
name|op1lt
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|args
operator|->
name|unordered
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like simplify_binary_operation except used for relational operators.    MODE is the mode of the operands, not that of the result.  If MODE    is VOIDmode, both operands must also be VOIDmode and we compare the    operands in "infinite precision".     If no simplification is possible, this function returns zero.  Otherwise,    it returns either const_true_rtx or const0_rtx.  */
end_comment

begin_function
name|rtx
name|simplify_relational_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|int
name|equal
decl_stmt|,
name|op0lt
decl_stmt|,
name|op0ltu
decl_stmt|,
name|op1lt
decl_stmt|,
name|op1ltu
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|trueop0
decl_stmt|;
name|rtx
name|trueop1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If op0 is a compare, extract the comparison arguments from it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trueop0
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|trueop1
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* We can't simplify MODE_CC values since we don't know what the      actual comparison is.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|op0
operator|==
name|cc0_rtx
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
comment|/* Make sure the constant is second.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|trueop0
operator|,
name|trueop0
operator|=
name|trueop1
operator|,
name|trueop1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* For integer comparisons of A and B maybe we can simplify A - B and can      then simplify a comparison of that with zero.  If A and B are both either      a register or a CONST_INT, this can't help; testing for these cases will      prevent infinite recursion here and speed things up.       If CODE is an unsigned comparison, then we can never do this optimization,      because it gives an incorrect result if the subtraction wraps around zero.      ANSI C defines unsigned operations such that they never overflow, and      thus such cases can not be ignored.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|!=
name|const0_rtx
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|&&
name|code
operator|!=
name|GTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|LEU
condition|)
return|return
name|simplify_relational_operation
argument_list|(
name|signed_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|const0_rtx
argument_list|)
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|==
name|ORDERED
condition|)
return|return
name|const_true_rtx
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|==
name|UNORDERED
condition|)
return|return
name|const0_rtx
return|;
comment|/* For non-IEEE floating-point, if the two operands are equal, we know the      result.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
name|equal
operator|=
literal|1
operator|,
name|op0lt
operator|=
literal|0
operator|,
name|op0ltu
operator|=
literal|0
operator|,
name|op1lt
operator|=
literal|0
operator|,
name|op1ltu
operator|=
literal|0
expr_stmt|;
comment|/* If the operands are floating-point constants, see if we can fold      the result.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|struct
name|cfc_args
name|args
decl_stmt|;
comment|/* Setup input for check_fold_consts() */
name|args
operator|.
name|op0
operator|=
name|trueop0
expr_stmt|;
name|args
operator|.
name|op1
operator|=
name|trueop1
expr_stmt|;
if|if
condition|(
operator|!
name|do_float_handler
argument_list|(
name|check_fold_consts
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
name|args
operator|.
name|unordered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|unordered
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNEQ
case|:
case|case
name|UNLT
case|:
case|case
name|UNGT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGE
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
return|return
name|const_true_rtx
return|;
case|case
name|EQ
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTGT
case|:
case|case
name|ORDERED
case|:
return|return
name|const0_rtx
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Receive output from check_fold_consts() */
name|equal
operator|=
name|args
operator|.
name|equal
expr_stmt|;
name|op0lt
operator|=
name|op0ltu
operator|=
name|args
operator|.
name|op0lt
expr_stmt|;
name|op1lt
operator|=
name|op1ltu
operator|=
name|args
operator|.
name|op1lt
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
comment|/* Otherwise, see if the operands are both integers.  */
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|l0s
decl_stmt|,
name|h0s
decl_stmt|,
name|l1s
decl_stmt|,
name|h1s
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l0u
decl_stmt|,
name|h0u
decl_stmt|,
name|l1u
decl_stmt|,
name|h1u
decl_stmt|;
comment|/* Get the two words comprising each integer constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l0u
operator|=
name|l0s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l0u
operator|=
name|l0s
operator|=
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l0s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l1u
operator|=
name|l1s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l1u
operator|=
name|l1s
operator|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1s
argument_list|)
expr_stmt|;
block|}
comment|/* If WIDTH is nonzero and smaller than HOST_BITS_PER_WIDE_INT, 	 we have to sign or zero-extend the values.  */
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|l0u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|l1u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
if|if
condition|(
name|l1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|h0u
operator|=
name|h1u
operator|=
literal|0
operator|,
name|h0s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l0s
argument_list|)
operator|,
name|h1s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1s
argument_list|)
expr_stmt|;
name|equal
operator|=
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|==
name|l1u
operator|)
expr_stmt|;
name|op0lt
operator|=
operator|(
name|h0s
operator|<
name|h1s
operator|||
operator|(
name|h0s
operator|==
name|h1s
operator|&&
name|l0u
operator|<
name|l1u
operator|)
operator|)
expr_stmt|;
name|op1lt
operator|=
operator|(
name|h1s
operator|<
name|h0s
operator|||
operator|(
name|h1s
operator|==
name|h0s
operator|&&
name|l1u
operator|<
name|l0u
operator|)
operator|)
expr_stmt|;
name|op0ltu
operator|=
operator|(
name|h0u
operator|<
name|h1u
operator|||
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|<
name|l1u
operator|)
operator|)
expr_stmt|;
name|op1ltu
operator|=
operator|(
name|h1u
operator|<
name|h0u
operator|||
operator|(
name|h1u
operator|==
name|h0u
operator|&&
name|l1u
operator|<
name|l0u
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Otherwise, there are some code-specific tests we can make.  */
else|else
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
comment|/* References to the frame plus a constant or labels cannot 	     be zero, but a SYMBOL_REF can due to #pragma weak.  */
if|if
condition|(
operator|(
operator|(
name|NONZERO_BASE_PLUS_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|trueop1
operator|==
name|const0_rtx
operator|)
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|LABEL_REF
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* On some machines, the ap reg can be 0 sometimes.  */
operator|&&
name|op0
operator|!=
name|arg_pointer_rtx
endif|#
directive|endif
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
operator|(
operator|(
name|NONZERO_BASE_PLUS_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|trueop1
operator|==
name|const0_rtx
operator|)
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|LABEL_REF
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|op0
operator|!=
name|arg_pointer_rtx
endif|#
directive|endif
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|GEU
case|:
comment|/* Unsigned values are never negative.  */
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|LEU
case|:
comment|/* Unsigned values are never greater than the largest 	     unsigned value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
comment|/* If we reach here, EQUAL, OP0LT, OP0LTU, OP1LT, and OP1LTU are set      as appropriate.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
return|return
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
return|return
operator|!
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
return|return
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GT
case|:
case|case
name|UNGT
case|:
return|return
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LTU
case|:
return|return
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GTU
case|:
return|return
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
return|return
name|equal
operator|||
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GE
case|:
case|case
name|UNGE
case|:
return|return
name|equal
operator|||
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LEU
case|:
return|return
name|equal
operator|||
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GEU
case|:
return|return
name|equal
operator|||
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|ORDERED
case|:
return|return
name|const_true_rtx
return|;
case|case
name|UNORDERED
case|:
return|return
name|const0_rtx
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify CODE, an operation with result mode MODE and three operands,    OP0, OP1, and OP2.  OP0_MODE was the mode of OP0 before it became    a constant.  Return 0 if no simplifications is possible.  */
end_comment

begin_function
name|rtx
name|simplify_ternary_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0_mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|op0_mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* VOIDmode means "infinite" precision.  */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<=
name|width
operator|)
operator|&&
name|width
operator|<=
operator|(
name|unsigned
operator|)
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Extracting a bit-field from a constant */
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|val
operator|>>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op0_mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
expr_stmt|;
else|else
name|val
operator|>>=
name|INTVAL
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|INTVAL
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* First zero-extend.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If desired, propagate sign bit.  */
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|~
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Clear the bits that don't belong in our mode, 	     unless they and our sign bit are all one. 	     So we get either a reasonable negative value or a reasonable 	     unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|op0
operator|!=
name|const0_rtx
condition|?
name|op1
else|:
name|op2
return|;
comment|/* Convert a == b ? b : a to "a".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NE
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op2
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|EQ
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|)
condition|)
return|return
name|op2
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|cmp_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|op0_mode
expr_stmt|;
name|temp
operator|=
name|simplify_relational_operation
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if any simplifications were possible.  */
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
return|return
name|op2
return|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|const1_rtx
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|temp
condition|)
name|op0
operator|=
name|temp
expr_stmt|;
comment|/* Look for happy constants in op1 and op2.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|t
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|f
init|=
name|INTVAL
argument_list|(
name|op2
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|STORE_FLAG_VALUE
operator|&&
name|f
operator|==
literal|0
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|0
operator|&&
name|f
operator|==
name|STORE_FLAG_VALUE
condition|)
block|{
name|enum
name|rtx_code
name|tmp
decl_stmt|;
name|tmp
operator|=
name|reversed_comparison_code
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|UNKNOWN
condition|)
break|break;
name|code
operator|=
name|tmp
expr_stmt|;
block|}
else|else
break|break;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)    Return 0 if no simplifications is possible.  */
end_comment

begin_function
name|rtx
name|simplify_subreg
parameter_list|(
name|outermode
parameter_list|,
name|op
parameter_list|,
name|innermode
parameter_list|,
name|byte
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|unsigned
name|int
name|byte
decl_stmt|;
name|enum
name|machine_mode
name|outermode
decl_stmt|,
name|innermode
decl_stmt|;
block|{
comment|/* Little bit of sanity checking.  */
if|if
condition|(
name|innermode
operator|==
name|VOIDmode
operator|||
name|outermode
operator|==
name|VOIDmode
operator|||
name|innermode
operator|==
name|BLKmode
operator|||
name|outermode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|innermode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|byte
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|||
name|byte
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|outermode
operator|==
name|innermode
operator|&&
operator|!
name|byte
condition|)
return|return
name|op
return|;
comment|/* Attempt to simplify constant to non-SUBREG expression.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|part
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|val
init|=
literal|0
decl_stmt|;
comment|/* ??? This code is partly redundant with code below, but can handle 	 the subregs of floats and similar corner cases. 	 Later it we should move all simplification code here and rewrite 	 GEN_LOWPART_IF_POSSIBLE, GEN_HIGHPART, OPERAND_SUBWORD and friends 	 using SIMPLIFY_SUBREG.  */
if|if
condition|(
name|subreg_lowpart_offset
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
operator|==
name|byte
condition|)
block|{
name|rtx
name|new
init|=
name|gen_lowpart_if_possible
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
comment|/* Similar comment as above apply here.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|outermode
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
name|rtx
name|new
init|=
name|constant_subword
argument_list|(
name|op
argument_list|,
operator|(
name|byte
operator|/
name|UNITS_PER_WORD
operator|)
argument_list|,
name|innermode
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
name|offset
operator|=
name|byte
operator|*
name|BITS_PER_UNIT
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
condition|)
break|break;
comment|/* We can't handle this case yet.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|NULL_RTX
return|;
name|part
operator|=
name|offset
operator|>=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
if|if
condition|(
operator|(
name|BITS_PER_WORD
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|BYTES_BIG_ENDIAN
operator|)
operator|||
operator|(
name|BITS_PER_WORD
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|WORDS_BIG_ENDIAN
operator|)
condition|)
name|part
operator|=
operator|!
name|part
expr_stmt|;
name|val
operator|=
name|part
condition|?
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|offset
operator|%=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
comment|/* We've already picked the word we want from a double, so  	     pretend this is actually an integer.  */
name|innermode
operator|=
name|mode_for_size
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CONST_INT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|val
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We don't handle synthetizing of non-integral constants yet.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|outermode
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|||
name|WORDS_BIG_ENDIAN
condition|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|offset
operator|=
operator|(
name|offset
operator|+
name|BITS_PER_WORD
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|-
literal|2
operator|*
operator|(
name|offset
operator|%
name|BITS_PER_WORD
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|val
operator|<
literal|0
operator|)
condition|?
name|constm1_rtx
else|:
name|const0_rtx
return|;
else|else
block|{
name|val
operator|>>=
name|offset
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|outermode
argument_list|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
block|}
comment|/* Changing mode twice with SUBREG => just change it once,      or not at all if changing back op starting mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|enum
name|machine_mode
name|innermostmode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|final_offset
init|=
name|byte
operator|+
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|outermode
operator|==
name|innermostmode
operator|&&
name|byte
operator|==
literal|0
operator|&&
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
return|;
comment|/* The SUBREG_BYTE represents offset, as if the value were stored 	 in memory.  Irritating exception is paradoxical subreg, where 	 we define SUBREG_BYTE to be 0.  On big endian machines, this 	 value should be negative.  For a moment, undo this exception.  */
if|if
condition|(
name|byte
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
comment|/* See whether resulting subreg will be paradoxical.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
comment|/* In nonparadoxical subregs we can't handle negative offsets.  */
if|if
condition|(
name|final_offset
operator|<
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Bail out in case resulting subreg would be incorrect.  */
if|if
condition|(
name|final_offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|||
operator|(
name|unsigned
operator|)
name|final_offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
comment|/* In paradoxical subreg, see if we are still looking on lower part. 	     If so, our SUBREG_BYTE will be 0.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|final_offset
condition|)
name|final_offset
operator|=
literal|0
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
block|}
comment|/* Recurse for futher possible simplifications.  */
name|new
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
name|final_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|final_offset
argument_list|)
return|;
block|}
comment|/* SUBREG of a hard register => just change the register number      and/or mode.  If the hard register is not valid in that mode,      suppress this simplification.  If the hard register is the stack,      frame, or argument pointer, leave this as a SUBREG.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|rtx_equal_function_value_matters
operator|)
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
operator|&&
operator|!
operator|(
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|innermode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|innermode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
name|reload_completed
operator|&&
operator|!
name|frame_pointer_needed
operator|)
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
name|int
name|final_regno
init|=
name|subreg_hard_regno
argument_list|(
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|byte
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? We do allow it if the current REG is not valid for 	 its mode.  This is a kludge to work around how float/complex 	 arguments are passed on 32-bit Sparc and should be fixed.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|final_regno
argument_list|,
name|outermode
argument_list|)
operator|||
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|,
name|innermode
argument_list|)
condition|)
block|{
name|rtx
name|x
init|=
name|gen_rtx_REG
argument_list|(
name|outermode
argument_list|,
name|final_regno
argument_list|)
decl_stmt|;
comment|/* Propagate original regno.  We don't have any way to specify 	     the offset inside orignal regno, so do so only for lowpart. 	     The information is used only by alias analysis that can not 	     grog partial register anyway.  */
if|if
condition|(
name|subreg_lowpart_offset
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
operator|==
name|byte
condition|)
name|ORIGINAL_REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
comment|/* If we have a SUBREG of a register that we are replacing and we are      replacing it with a MEM, make a new MEM and try replacing the      SUBREG with it.  Don't do this if the MEM has a mode-dependent address      or if we would be widening it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Allow splitting of volatile memory references in case we don't          have instruction to move the whole thing.  */
operator|&&
operator|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|innermode
argument_list|)
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|adjust_address_nv
argument_list|(
name|op
argument_list|,
name|outermode
argument_list|,
name|byte
argument_list|)
return|;
comment|/* Handle complex values represented as CONCAT      of real and imaginary part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|int
name|is_realpart
init|=
name|byte
operator|<
name|GET_MODE_UNIT_SIZE
argument_list|(
name|innermode
argument_list|)
decl_stmt|;
name|rtx
name|part
init|=
name|is_realpart
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|final_offset
decl_stmt|;
name|rtx
name|res
decl_stmt|;
name|final_offset
operator|=
name|byte
operator|%
operator|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|innermode
argument_list|)
operator|)
expr_stmt|;
name|res
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|part
argument_list|,
name|GET_MODE
argument_list|(
name|part
argument_list|)
argument_list|,
name|final_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
comment|/* We can at least simplify it by referring directly to the relevant part.  */
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|part
argument_list|,
name|final_offset
argument_list|)
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Make a SUBREG operation or equivalent if it folds.  */
end_comment

begin_function
name|rtx
name|simplify_gen_subreg
parameter_list|(
name|outermode
parameter_list|,
name|op
parameter_list|,
name|innermode
parameter_list|,
name|byte
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|unsigned
name|int
name|byte
decl_stmt|;
name|enum
name|machine_mode
name|outermode
decl_stmt|,
name|innermode
decl_stmt|;
block|{
name|rtx
name|new
decl_stmt|;
comment|/* Little bit of sanity checking.  */
if|if
condition|(
name|innermode
operator|==
name|VOIDmode
operator|||
name|outermode
operator|==
name|VOIDmode
operator|||
name|innermode
operator|==
name|BLKmode
operator|||
name|outermode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|innermode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|byte
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|||
name|byte
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|QUEUED
condition|)
return|return
name|NULL_RTX
return|;
name|new
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|byte
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simplify X, an rtx expression.     Return the simplified expression or NULL if no simplifications    were possible.     This is the preferred entry point into the simplification routines;    however, we still allow passes to call the more specific routines.     Right now GCC has three (yes, three) major bodies of RTL simplficiation    code that need to be unified.  	1. fold_rtx in cse.c.  This code uses various CSE specific 	   information to aid in RTL simplification.  	2. simplify_rtx in combine.c.  Similar to fold_rtx, except that 	   it uses combine specific information to aid in RTL 	   simplification.  	3. The routines in this file.      Long term we want to only have one body of simplification code; to    get to that state I recommend the following steps:  	1. Pour over fold_rtx& simplify_rtx and move any simplifications 	   which are not pass dependent state into these routines.  	2. As code is moved by #1, change fold_rtx& simplify_rtx to 	   use this routine whenever possible.  	3. Allow for pass dependent state to be provided to these 	   routines and add simplifications based on the pass dependent 	   state.  Remove code from cse.c& combine.c that becomes 	   redundant/dead.      It will take time, but ultimately the compiler will be easier to     maintain and improve.  It's totally silly that when we add a     simplification that it needs to be added to 4 places (3 for RTL     simplification and 1 for tree simplification.  */
end_comment

begin_function
name|rtx
name|simplify_rtx
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'c'
case|:
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
return|return
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|'2'
case|:
return|return
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
literal|'3'
case|:
case|case
literal|'b'
case|:
return|return
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
literal|'<'
case|:
return|return
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
operator|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
literal|'x'
case|:
comment|/* The only case we try to handle is a SUBREG.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
return|return
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
return|return
name|NULL
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

end_unit

