begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL simplification functions for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Simplification and canonicalization of RTL.  */
end_comment

begin_comment
comment|/* Much code operates on (low, high) pairs; the low value is an    unsigned wide int, the high value a signed wide int.  We    occasionally need to sign extend from low to high as if low were a    signed wide int.  */
end_comment

begin_define
define|#
directive|define
name|HWI_SIGN_EXTEND
parameter_list|(
name|low
parameter_list|)
define|\
value|((((HOST_WIDE_INT) low)< 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))
end_define

begin_function_decl
specifier|static
name|rtx
name|neg_const_int
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|simplify_plus_minus_op_data_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_plus_minus
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_immed_subreg
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|associative_constant_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_associative_operation
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Negate a CONST_INT rtx, truncating (because a conversion from a    maximally negative number can overflow).  */
end_comment

begin_function
specifier|static
name|rtx
name|neg_const_int
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|i
parameter_list|)
block|{
return|return
name|gen_int_mode
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|i
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a binary operation by properly ordering the operands and    seeing if the expression folds.  */
end_comment

begin_function
name|rtx
name|simplify_gen_binary
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Put complex operands first and constants second if commutative.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
comment|/* If this simplifies, do it.  */
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* Handle addition and subtraction specially.  Otherwise, just form      the operation.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
condition|)
block|{
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a MEM referencing the constant pool, return the real value.    Otherwise return X.  */
end_comment

begin_function
name|rtx
name|avoid_constant_pool_reference
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|c
decl_stmt|,
name|tmp
decl_stmt|,
name|addr
decl_stmt|;
name|enum
name|machine_mode
name|cmode
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
break|break;
case|case
name|FLOAT_EXTEND
case|:
comment|/* Handle float extensions of constant pool references.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|tmp
operator|&&
name|GET_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
return|return
name|x
return|;
default|default:
return|return
name|x
return|;
block|}
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call target hook to avoid the effects of -fpic etc....  */
name|addr
operator|=
call|(
modifier|*
name|targetm
operator|.
name|delegitimize_address
call|)
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|x
return|;
name|c
operator|=
name|get_pool_constant
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|cmode
operator|=
name|get_pool_mode
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If we're accessing the constant in a different mode than it was      originally stored, attempt to fix that up via subreg simplifications.      If that fails we have no choice but to return the original memory.  */
if|if
condition|(
name|cmode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|c
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|c
argument_list|,
name|cmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
condition|?
name|c
else|:
name|x
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a unary operation by first seeing if it folds and otherwise making    the specified operation.  */
end_comment

begin_function
name|rtx
name|simplify_gen_unary
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|op_mode
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If this simplifies, use it.  */
if|if
condition|(
operator|(
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|op_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise for ternary operations.  */
end_comment

begin_function
name|rtx
name|simplify_gen_ternary
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|op0_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If this simplifies, use it.  */
if|if
condition|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
return|return
name|gen_rtx_fmt_eee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is a MEM referencing the constant pool.  */
end_comment

begin_function
name|bool
name|constant_pool_reference_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|avoid_constant_pool_reference
argument_list|(
name|x
argument_list|)
operator|!=
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Likewise, for relational operations.    CMP_MODE specifies mode comparison is done in.   */
end_comment

begin_function
name|rtx
name|simplify_gen_relational
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|cmp_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_mode
operator|!=
name|VOIDmode
operator|&&
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|cmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|val
decl_stmt|;
if|if
condition|(
name|tem
operator|==
name|const0_rtx
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
name|tem
operator|!=
name|const_true_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|tem
return|;
block|}
block|}
comment|/* For the following tests, ensure const0_rtx is op1.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|||
operator|(
name|op0
operator|==
name|const0_rtx
operator|&&
name|op1
operator|!=
name|const0_rtx
operator|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
operator|,
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* If op0 is a compare, extract the comparison arguments from it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* If op0 is a comparison, extract the comparison arguments form it.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|NE
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|op0
return|;
return|return
name|simplify_gen_relational
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
block|{
name|enum
name|rtx_code
name|new
init|=
name|reversed_comparison_code
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|UNKNOWN
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|new
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace all occurrences of OLD in X with NEW and try to simplify the    resulting RTX.  Return a new RTX which is as simplified as possible.  */
end_comment

begin_function
name|rtx
name|simplify_replace_rtx
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|old
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
comment|/* If X is OLD, return NEW.  Otherwise, if this is an expression, try      to build a new expression substituting recursively.  If we can't do      anything, return our input.  */
if|if
condition|(
name|x
operator|==
name|old
condition|)
return|return
name|new
return|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|op0
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op_mode
argument_list|)
return|;
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
literal|'<'
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|op0
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|op1
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
literal|'3'
case|:
case|case
literal|'b'
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|op0
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|op2
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_ternary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
case|case
literal|'x'
case|:
comment|/* The only case we try to handle is a SUBREG.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
name|op0
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op0
condition|?
name|op0
else|:
name|x
return|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|op0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LO_SUM
condition|)
block|{
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* (lo_sum (high x) x) -> x  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|HIGH
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|old
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|old
argument_list|)
condition|)
return|return
name|new
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to simplify a unary operation CODE whose output mode is to be    MODE with input operand OP whose mode was originally OP_MODE.    Return zero if no simplification can be made.  */
end_comment

begin_function
name|rtx
name|simplify_unary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|op_mode
parameter_list|)
block|{
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|trueop
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VEC_DUPLICATE
condition|)
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|trueop
expr_stmt|;
else|else
block|{
name|enum
name|machine_mode
name|inmode
init|=
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
decl_stmt|;
name|int
name|in_elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|inmode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|in_n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|/
name|in_elt_size
operator|)
decl_stmt|;
if|if
condition|(
name|in_n_elts
operator|>=
name|n_elts
operator|||
name|n_elts
operator|%
name|in_n_elts
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|trueop
argument_list|,
name|i
operator|%
name|in_n_elts
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op_mode
argument_list|)
return|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|opmode
init|=
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
decl_stmt|;
name|int
name|op_elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|opmode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|op_n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|opmode
argument_list|)
operator|/
name|op_elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|op_n_elts
operator|!=
name|n_elts
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|CONST_VECTOR_ELT
argument_list|(
name|trueop
argument_list|,
name|i
argument_list|)
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|opmode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
comment|/* The order of these tests is critical so that, for example, we don't      check the wrong mode (input vs. output) for a conversion operation,      such as FIX.  At some point, this should be simplified.  */
if|if
condition|(
name|code
operator|==
name|FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|UNSIGNED_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We don't know how to interpret negative-looking numbers in 	     this case, so don't try to fold those.  */
if|if
condition|(
name|hv
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
empty_stmt|;
else|else
name|hv
operator|=
literal|0
operator|,
name|lv
operator|&=
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_UNSIGNED_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|arg0
init|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|val
operator|=
operator|~
name|arg0
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|val
operator|=
operator|-
name|arg0
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|val
operator|=
operator|(
name|arg0
operator|>=
literal|0
condition|?
name|arg0
else|:
operator|-
name|arg0
operator|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
comment|/* Don't use ffs here.  Instead, get low order bit and then its 	     number.  If arg0 is zero, this will return 0, as desired.  */
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
name|exact_log2
argument_list|(
name|arg0
operator|&
operator|(
operator|-
name|arg0
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|CLZ
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|&&
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
condition|)
empty_stmt|;
else|else
name|val
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|arg0
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CTZ
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
condition|)
block|{
comment|/* Even if the value at zero is undefined, we have to come 		 up with some replacement.  Seems good enough.  */
if|if
condition|(
operator|!
name|CTZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
condition|)
name|val
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|exact_log2
argument_list|(
name|arg0
operator|&
operator|-
name|arg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|POPCOUNT
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg0
condition|)
name|val
operator|++
operator|,
name|arg0
operator|&=
name|arg0
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PARITY
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg0
condition|)
name|val
operator|++
operator|,
name|arg0
operator|&=
name|arg0
operator|-
literal|1
expr_stmt|;
name|val
operator|&=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|val
operator|=
name|arg0
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
comment|/* When zero-extending a CONST_INT, we need to know its              original mode.  */
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
if|if
condition|(
name|width
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
if|if
condition|(
name|width
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SQRT
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|SS_TRUNCATE
case|:
case|case
name|US_TRUNCATE
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|val
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/* We can do some operations on integer CONST_DOUBLEs.  Also allow      for a DImode operation on a CONST_INT.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|lv
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|hv
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|trueop
argument_list|)
operator|,
name|h1
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|lv
operator|=
operator|~
name|l1
expr_stmt|;
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|FFS
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|h1
operator|==
literal|0
condition|)
name|lv
operator|=
literal|0
expr_stmt|;
else|else
name|lv
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|h1
operator|&
operator|-
name|h1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|lv
operator|=
name|exact_log2
argument_list|(
name|l1
operator|&
operator|-
name|l1
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|CLZ
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|h1
argument_list|)
operator|-
literal|1
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|l1
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|lv
argument_list|)
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTZ
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|exact_log2
argument_list|(
name|l1
operator|&
operator|-
name|l1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|h1
operator|&
operator|-
name|h1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CTZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|lv
argument_list|)
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|POPCOUNT
case|:
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l1
condition|)
name|lv
operator|++
operator|,
name|l1
operator|&=
name|l1
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|h1
condition|)
name|lv
operator|++
operator|,
name|h1
operator|&=
name|h1
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PARITY
case|:
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l1
condition|)
name|lv
operator|++
operator|,
name|l1
operator|&=
name|l1
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|h1
condition|)
name|lv
operator|++
operator|,
name|h1
operator|&=
name|h1
operator|-
literal|1
expr_stmt|;
name|lv
operator|&=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
comment|/* This is just a change-of-mode, so do nothing.  */
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
else|else
block|{
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|lv
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|lv
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SQRT
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|,
name|t
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|trueop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SQRT
case|:
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|real_isnan
argument_list|(
operator|&
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
name|real_sqrt
argument_list|(
operator|&
name|t
argument_list|,
name|mode
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|d
operator|=
name|REAL_VALUE_ABS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|d
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
comment|/* All this does is change the mode.  */
break|break;
case|case
name|FIX
case|:
name|real_arithmetic
argument_list|(
operator|&
name|d
argument_list|,
name|FIX_TRUNC_EXPR
argument_list|,
operator|&
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
block|{
name|long
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|real_to_target
argument_list|(
name|tmp
argument_list|,
operator|&
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tmp
index|[
name|i
index|]
operator|=
operator|~
name|tmp
index|[
name|i
index|]
expr_stmt|;
name|real_from_target
argument_list|(
operator|&
name|d
argument_list|,
name|tmp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|<=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
comment|/* Although the overflow semantics of RTL's FIX and UNSIGNED_FIX 	 operators are intentionally left unspecified (to ease implementation 	 by target backends), for consistency, this routine implements the 	 same semantics for constant folding as used by the middle-end.  */
name|HOST_WIDE_INT
name|xh
decl_stmt|,
name|xl
decl_stmt|,
name|th
decl_stmt|,
name|tl
decl_stmt|;
name|REAL_VALUE_TYPE
name|x
decl_stmt|,
name|t
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|x
argument_list|,
name|trueop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIX
case|:
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Test against the signed upper bound.  */
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|th
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|real_from_integer
argument_list|(
operator|&
name|t
argument_list|,
name|VOIDmode
argument_list|,
name|tl
argument_list|,
name|th
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|t
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|xh
operator|=
name|th
expr_stmt|;
name|xl
operator|=
name|tl
expr_stmt|;
break|break;
block|}
comment|/* Test against the signed lower bound.  */
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
name|tl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|th
operator|=
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|real_from_integer
argument_list|(
operator|&
name|t
argument_list|,
name|VOIDmode
argument_list|,
name|tl
argument_list|,
name|th
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|xh
operator|=
name|th
expr_stmt|;
name|xl
operator|=
name|tl
expr_stmt|;
break|break;
block|}
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|xh
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|||
name|REAL_VALUE_NEGATIVE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Test against the unsigned upper bound.  */
if|if
condition|(
name|width
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|th
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|real_from_integer
argument_list|(
operator|&
name|t
argument_list|,
name|VOIDmode
argument_list|,
name|tl
argument_list|,
name|th
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|t
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|xh
operator|=
name|th
expr_stmt|;
name|xl
operator|=
name|tl
expr_stmt|;
break|break;
block|}
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|xh
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|xl
argument_list|,
name|xh
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* This was formerly used only for non-IEEE float.      eggert@twinsun.com says it is safe for IEEE also.  */
else|else
block|{
name|enum
name|rtx_code
name|reversed
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* There are some simplifications we can do even if the operands 	 aren't constant.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
comment|/* (not (not X)) == X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (not (eq X Y)) == (ne X Y), etc.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|mode
operator|==
name|BImode
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|reversed
operator|=
name|reversed_comparison_code
argument_list|(
name|op
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|UNKNOWN
operator|)
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|reversed
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (not (plus X -1)) can become (neg X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Similarly, (not (neg X)) is (plus X -1).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
comment|/* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|XOR
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
comment|/* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for 	     operands other than 1, but that is not valid.  We could do a 	     similar simplification for (not (lshiftrt C X)) where C is 	     just the sign bit, but this doesn't seem common enough to 	     bother with.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|const1_rtx
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|ROTATE
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* If STORE_FLAG_VALUE is -1, (not (comparison X Y)) can be done 	     by reversing the comparison code if valid.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison_code
argument_list|(
name|op
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|UNKNOWN
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|reversed
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (not (ashiftrt foo C)) where C is the number of bits in FOO 	     minus 1 is (ge foo (const_int 0)) if STORE_FLAG_VALUE is -1, 	     so we can perform the above simplification.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|GE
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
break|break;
case|case
name|NEG
case|:
comment|/* (neg (neg X)) == X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (neg (plus X 1)) can become (not X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Similarly, (neg (not X)) is (plus X 1).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
comment|/* (neg (minus X Y)) can become (minus Y X).  This transformation 	     isn't safe for modes with signed zeros, since if X and Y are 	     both +0, (minus Y X) is the same as (minus X Y).  If the 	     rounding mode is towards +infinity (or -infinity) then the two 	     expressions will be rounded differently.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* (neg (plus A C)) is simplified to (minus -C A).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* (neg (plus A B)) is canonicalized to (minus (neg A) B).  */
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (neg (mult A B)) becomes (mult (neg A) B). 	     This works even for floating-point values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* NEG commutes with ASHIFT since it is multiplication.  Only do 	     this if we can then eliminate the NEG (e.g., if the operand 	     is a constant).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* (sign_extend (truncate (minus (label_ref L1) (label_ref L2)))) 	     becomes just the MINUS if its mode is MODE.  This allows 	     folding switch statements on machines using casesi (such as 	     the VAX).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Check for a sign extension of a subreg of a promoted 	     variable, where the promotion is sign-extended, and the 	     target mode is the same as the variable's promotion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|)
operator|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
endif|#
directive|endif
break|break;
case|case
name|ZERO_EXTEND
case|:
comment|/* Check for a zero extension of a subreg of a promoted 	     variable, where the promotion is zero-extended, and the 	     target mode is the same as the variable's promotion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>
literal|0
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|)
operator|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of simplify_associative_operation.  Return true if rtx OP    is a suitable integer or floating point immediate constant.  */
end_comment

begin_function
specifier|static
name|bool
name|associative_constant_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|true
return|;
name|op
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of simplify_binary_operation to simplify an associative    binary operation CODE with result mode MODE, operating on OP0 and OP1.    Return 0 if no simplification is possible.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_associative_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Simplify (x op c1) op c2 as x op (c1 op c2).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|code
operator|&&
name|associative_constant_p
argument_list|(
name|op1
argument_list|)
operator|&&
name|associative_constant_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
name|tem
return|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
block|}
comment|/* Simplify (x op c1) op (y op c2) as (x op y) op (c1 op c2).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|code
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|code
operator|&&
name|associative_constant_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|associative_constant_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|c
init|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|c
argument_list|)
return|;
block|}
comment|/* Canonicalize (x op c) op y as (x op y) op c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|code
operator|&&
name|associative_constant_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Canonicalize x op (y op c) as (x op y) op c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|code
operator|&&
name|associative_constant_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simplify a binary operation CODE with result mode MODE, operating on OP0    and OP1.  Return 0 if no simplification is possible.     Don't use this for relational operations such as EQ or LT.    Use simplify_relational_operation instead.  */
end_comment

begin_function
name|rtx
name|simplify_binary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|HOST_WIDE_INT
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg0s
decl_stmt|,
name|arg1s
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|trueop0
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|rtx
name|trueop1
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* Relational operations don't work here.  We must know the mode      of the operands in order to do the comparison correctly.      Assuming a full word can give incorrect results.      Consider comparing 128 with -128 in QImode.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Make sure the constant is second.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|trueop0
operator|,
name|trueop0
operator|=
name|trueop1
operator|,
name|trueop1
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|code
operator|!=
name|VEC_CONCAT
operator|&&
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|op0mode
init|=
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
decl_stmt|;
name|int
name|op0_elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|op0mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|op0_n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|op0mode
argument_list|)
operator|/
name|op0_elt_size
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|op1mode
init|=
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
decl_stmt|;
name|int
name|op1_elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|op1mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|op1_n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|op1mode
argument_list|)
operator|/
name|op1_elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|op0_n_elts
operator|!=
name|n_elts
operator|||
name|op1_n_elts
operator|!=
name|n_elts
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|CONST_VECTOR_ELT
argument_list|(
name|trueop0
argument_list|,
name|i
argument_list|)
argument_list|,
name|CONST_VECTOR_ELT
argument_list|(
name|trueop1
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
condition|)
block|{
name|long
name|tmp0
index|[
literal|4
index|]
decl_stmt|;
name|long
name|tmp1
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|real_to_target
argument_list|(
name|tmp0
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|tmp1
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|code
operator|==
name|AND
condition|)
name|tmp0
index|[
name|i
index|]
operator|&=
name|tmp1
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|IOR
condition|)
name|tmp0
index|[
name|i
index|]
operator||=
name|tmp1
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|XOR
condition|)
name|tmp0
index|[
name|i
index|]
operator|^=
name|tmp1
index|[
name|i
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|real_from_target
argument_list|(
operator|&
name|r
argument_list|,
name|tmp0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
else|else
block|{
name|REAL_VALUE_TYPE
name|f0
decl_stmt|,
name|f1
decl_stmt|,
name|value
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f0
argument_list|,
name|trueop0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f1
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
name|f0
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|)
expr_stmt|;
name|f1
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|f1
argument_list|)
expr_stmt|;
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|REAL_VALUE_ISNAN
argument_list|(
name|f0
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|f1
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|DIV
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f1
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|(
name|flag_trapping_math
operator|||
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|&&
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_trapping_math
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|f0
argument_list|)
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|f1
argument_list|)
condition|)
block|{
name|int
name|s0
init|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|f0
argument_list|)
decl_stmt|;
name|int
name|s1
init|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|f1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* Inf + -Inf = NaN plus exception.  */
if|if
condition|(
name|s0
operator|!=
name|s1
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|MINUS
case|:
comment|/* Inf - Inf = NaN plus exception.  */
if|if
condition|(
name|s0
operator|==
name|s1
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|DIV
case|:
comment|/* Inf / Inf = NaN plus exception.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|MULT
operator|&&
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|&&
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_trapping_math
operator|&&
operator|(
operator|(
name|REAL_VALUE_ISINF
argument_list|(
name|f0
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f1
argument_list|,
name|dconst0
argument_list|)
operator|)
operator|||
operator|(
name|REAL_VALUE_ISINF
argument_list|(
name|f1
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f0
argument_list|,
name|dconst0
argument_list|)
operator|)
operator|)
condition|)
comment|/* Inf * 0 = NaN plus exception.  */
return|return
literal|0
return|;
name|REAL_ARITHMETIC
argument_list|(
name|value
argument_list|,
name|rtx_to_tree_code
argument_list|(
name|code
argument_list|)
argument_list|,
name|f0
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|value
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|value
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
comment|/* We can fold some multi-word operations.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|lv
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|hv
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop0
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
operator|,
name|h1
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l2
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop1
argument_list|)
operator|,
name|h2
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
else|else
name|l2
operator|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|,
name|h2
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MINUS
case|:
comment|/* A - B == A + (-B).  */
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
name|l2
operator|=
name|lv
operator|,
name|h2
operator|=
name|hv
expr_stmt|;
comment|/* Fall through....  */
case|case
name|PLUS
case|:
name|add_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|mul_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
comment|/* We'd need to include tree.h to do this and it doesn't seem worth 	     it.  */
return|return
literal|0
return|;
case|case
name|AND
case|:
name|lv
operator|=
name|l1
operator|&
name|l2
operator|,
name|hv
operator|=
name|h1
operator|&
name|h2
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|lv
operator|=
name|l1
operator||
name|l2
operator|,
name|hv
operator|=
name|h1
operator||
name|h2
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|lv
operator|=
name|l1
operator|^
name|l2
operator|,
name|hv
operator|=
name|h1
operator|^
name|h2
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|h1
operator|<
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|h1
operator|>
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|l2
operator|&=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|,
name|h2
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|h2
operator|!=
literal|0
operator|||
name|l2
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
condition|)
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
name|code
operator|==
name|ASHIFTRT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ROTATE
condition|)
name|lrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
comment|/* code == ROTATERT */
name|rrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
name|width
operator|==
literal|0
condition|)
block|{
comment|/* Even if we can't compute a constant result, 	 there are some cases worth simplifying.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* Maybe simplify x + 0 to x.  The two expressions are equivalent 	     when x is NaN, infinite, or finite and nonzero.  They aren't 	     when x is -0 and the rounding mode is not towards -infinity, 	     since (-0) + 0 is then 0.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* ((-a) + b) -> (b - a) and similarly for (a + (-b)).  These 	     transformations are safe even for IEEE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (~a) + 1 -> -a */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|trueop1
operator|==
name|const1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Handle both-operands-constant cases.  We can only add 	     CONST_INTs to constants since the sum of relocatable symbols 	     can't be handled by most assemblers.  Don't add CONST_INT 	     to CONST_INT since overflow won't be computed properly if wider 	     than HOST_BITS_PER_WIDE_INT.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|INTVAL
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
comment|/* See if this is something like X * C - X or vice versa or 	     if the multiplication is written as a shift.  If so, we can 	     distribute and make a new multiply, shift, or maybe just 	     have X (if C is 2 in the example above).  But don't make 	     real multiply if we didn't have one before.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0
init|=
literal|1
decl_stmt|,
name|coeff1
init|=
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
name|int
name|had_mult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff0
operator|=
operator|-
literal|1
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff1
operator|=
operator|-
literal|1
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff1
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|GEN_INT
argument_list|(
name|coeff0
operator|+
name|coeff1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|had_mult
operator|)
condition|?
literal|0
else|:
name|tem
return|;
block|}
block|}
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	     simplify this by the associative law. 	     Don't use the associative law for floating point. 	     The inaccuracy makes it nonassociative, 	     and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* Reassociate floating point addition only when the user 	     specifies unsafe math optimizations.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
break|break;
case|case
name|COMPARE
case|:
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Convert (compare FOO (const_int 0)) to FOO unless we aren't 	     using cc0, in which case we want to leave it as a COMPARE 	     so we can distinguish it from a register-register-copy.  	     In IEEE floating point, x-0 is not the same as x.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
endif|#
directive|endif
comment|/* Convert (compare (gt (flags) 0) (lt (flags) 0)) to (flags).  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GTU
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LTU
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|rtx
name|xop00
init|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop10
init|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|xop10
argument_list|)
operator|==
name|CC0
condition|)
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|xop10
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|xop10
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|xop00
argument_list|)
operator|==
name|REGNO
argument_list|(
name|xop10
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|xop00
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|xop10
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
endif|#
directive|endif
return|return
name|xop00
return|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* We can't assume x-x is 0 even with non-IEEE floating point, 	     but since it is zero except in very strange circumstances, we 	     will treat it as zero with -funsafe-math-optimizations.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Change subtraction from zero into negation.  (0 - x) is the 	     same as -x when x is NaN, infinite, or finite and nonzero. 	     But if the mode has signed zeros, and does not round towards 	     -infinity, then 0 - 0 is 0, not -0.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
return|;
comment|/* (-1 - a) is ~a.  */
if|if
condition|(
name|trueop0
operator|==
name|constm1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Subtracting 0 has no effect unless the mode has signed zeros 	     and supports rounding towards -infinity.  In such a case, 	     0 - 0 is -0.  */
if|if
condition|(
operator|!
operator|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* See if this is something like X * C - X or vice versa or 	     if the multiplication is written as a shift.  If so, we can 	     distribute and make a new multiply, shift, or maybe just 	     have X (if C is 2 in the example above).  But don't make 	     real multiply if we didn't have one before.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0
init|=
literal|1
decl_stmt|,
name|coeff1
init|=
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
name|int
name|had_mult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff0
operator|=
operator|-
literal|1
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff1
operator|=
operator|-
literal|1
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff1
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|GEN_INT
argument_list|(
name|coeff0
operator|-
name|coeff1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|had_mult
operator|)
condition|?
literal|0
else|:
name|tem
return|;
block|}
block|}
comment|/* (a - (-b)) -> (a + b).  True even for IEEE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (-x - c) may be simplified as (-c - x).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	     simplify this by the associative law. 	     Don't use the associative law for floating point. 	     The inaccuracy makes it nonassociative, 	     and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* Don't let a relocatable value get a negative coeff.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
comment|/* (x - (x& y)) -> (x& ~y) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|AND
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|trueop1
operator|==
name|constm1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Maybe simplify x * 0 to 0.  The reduction is not valid if 	     x is NaN, since x * 0 is then also NaN.  Nor is it valid 	     when the mode has signed zeros, since multiplying a negative 	     number by 0 will give -0, not 0.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for 	     signalling NaNs.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Convert multiply by constant power of two into shift unless 	     we are still generating RTL.  This test is a kludge.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|val
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
comment|/* If the mode is larger than the host word size, and the 		 uppermost bit is set, then this isn't a power of two due 		 to implicit sign extension.  */
operator|&&
operator|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|val
operator|!=
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
operator|!
name|rtx_equal_function_value_matters
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
comment|/* x*2 is x+x and x*(-1) is -x */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst2
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconstm1
argument_list|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Reassociate multiplication, but for floating point MULTs 	     only when the user specifies unsafe math optimizations.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* A | (~A) -> -1 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|constm1_rtx
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|trueop0
operator|==
name|trueop1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|const0_rtx
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|trueop0
operator|==
name|trueop1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|op0
return|;
comment|/* A& (~A) -> 0 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|const0_rtx
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|UDIV
case|:
comment|/* Convert divide by power of two into shift (divide by 1 handled 	     below).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|arg1
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Fall through....  */
case|case
name|DIV
case|:
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* On some platforms DIV uses narrower mode than its 		 operands.  */
name|rtx
name|x
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
else|else
return|return
name|op0
return|;
block|}
comment|/* Maybe change 0 / x to 0.  This transformation isn't safe for 	     modes with NaNs, since 0 / 0 will then be NaN rather than 0. 	     Nor is it safe for modes with signed zeros, since dividing 	     0 by a negative number gives -0, not 0.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Change division by a constant into multiplication.  Only do 	     this with -funsafe-math-optimizations.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|trueop1
operator|!=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_unsafe_math_optimizations
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst0
argument_list|)
condition|)
block|{
name|REAL_ARITHMETIC
argument_list|(
name|d
argument_list|,
name|rtx_to_tree_code
argument_list|(
name|DIV
argument_list|)
argument_list|,
name|dconst1
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|tem
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|UMOD
case|:
comment|/* Handle modulus by power of two (mod with 1 handled below).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Fall through....  */
case|case
name|MOD
case|:
if|if
condition|(
operator|(
name|trueop0
operator|==
name|const0_rtx
operator|||
name|trueop1
operator|==
name|const1_rtx
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
comment|/* Rotating ~0 always results in ~0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Fall through....  */
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|trueop0
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
name|trueop1
operator|==
name|constm1_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|SS_PLUS
case|:
case|case
name|US_PLUS
case|:
case|case
name|SS_MINUS
case|:
case|case
name|US_MINUS
case|:
comment|/* ??? There are simplifications that can be done.  */
return|return
literal|0
return|;
case|case
name|VEC_SELECT
case|:
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|||
operator|(
name|mode
operator|!=
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|!=
name|PARALLEL
operator|||
name|XVECLEN
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
return|return
name|CONST_VECTOR_ELT
argument_list|(
name|trueop0
argument_list|,
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|n_elts
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|trueop0
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|VEC_CONCAT
case|:
block|{
name|enum
name|machine_mode
name|op0_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
else|:
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|op1_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
else|:
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|op0_mode
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|op1_mode
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|VECTOR_MODE_P
argument_list|(
name|op0_mode
argument_list|)
operator|&&
operator|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_INNER
argument_list|(
name|op0_mode
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|op0_mode
argument_list|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|!=
name|op0_mode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|VECTOR_MODE_P
argument_list|(
name|op1_mode
argument_list|)
operator|&&
operator|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_INNER
argument_list|(
name|op1_mode
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|op1_mode
argument_list|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|!=
name|op1_mode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_VECTOR
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_VECTOR
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|in_n_elts
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|op0_mode
argument_list|)
condition|)
name|in_n_elts
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|op0_mode
argument_list|)
operator|/
name|elt_size
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|in_n_elts
condition|)
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|op0_mode
argument_list|)
condition|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|trueop0
expr_stmt|;
else|else
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|trueop0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|op1_mode
argument_list|)
condition|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|trueop1
expr_stmt|;
else|else
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|trueop1
argument_list|,
name|i
operator|-
name|in_n_elts
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Get the integer argument values in two forms:      zero-extended in ARG0, ARG1 and sign-extended in ARG0S, ARG1S.  */
name|arg0
operator|=
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|arg0
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg1
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg0s
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|arg0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|arg1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
else|else
block|{
name|arg0s
operator|=
name|arg0
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
block|}
comment|/* Compute the value of the arithmetic.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|val
operator|=
name|arg0s
operator|+
name|arg1s
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|val
operator|=
name|arg0s
operator|-
name|arg1s
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|val
operator|=
name|arg0s
operator|*
name|arg1s
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|/
name|arg1s
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|%
name|arg1s
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|/
name|arg1
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|%
name|arg1
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|val
operator|=
name|arg0
operator|&
name|arg1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|val
operator|=
name|arg0
operator||
name|arg1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|val
operator|=
name|arg0
operator|^
name|arg1
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
comment|/* If shift count is undefined, don't fold it; let the machine do 	 what it wants.  But truncate it if the machine will do that.  */
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|arg0s
operator|>>
name|arg1
expr_stmt|;
comment|/* Bootstrap compiler may not have sign extended the right shift. 	 Manually extend the sign to insure bootstrap cc matches gcc.  */
if|if
condition|(
name|arg0s
operator|<
literal|0
operator|&&
name|arg1
operator|>
literal|0
condition|)
name|val
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
comment|/* Do nothing here.  */
return|return
literal|0
return|;
case|case
name|SMIN
case|:
name|val
operator|=
name|arg0s
operator|<=
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|<=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|val
operator|=
name|arg0s
operator|>
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|SS_PLUS
case|:
case|case
name|US_PLUS
case|:
case|case
name|SS_MINUS
case|:
case|case
name|US_MINUS
case|:
comment|/* ??? There are simplifications that can be done.  */
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|val
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a PLUS or MINUS, at least one of whose operands may be another    PLUS or MINUS.     Rather than test for specific case, we do this by a brute-force method    and do all possible simplifications until no more changes occur.  Then    we rebuild the operation.     If FORCE is true, then always generate the rtx.  This is used to    canonicalize stuff emitted from simplify_gen_binary.  Note that this    can still fail if the rtx is too complex.  It won't fail just because    the result is not 'simpler' than the input, however.  */
end_comment

begin_struct
struct|struct
name|simplify_plus_minus_op_data
block|{
name|rtx
name|op
decl_stmt|;
name|int
name|neg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|simplify_plus_minus_op_data_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|simplify_plus_minus_op_data
modifier|*
name|d1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|simplify_plus_minus_op_data
modifier|*
name|d2
init|=
name|p2
decl_stmt|;
return|return
operator|(
name|commutative_operand_precedence
argument_list|(
name|d2
operator|->
name|op
argument_list|)
operator|-
name|commutative_operand_precedence
argument_list|(
name|d1
operator|->
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|simplify_plus_minus
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|simplify_plus_minus_op_data
name|ops
index|[
literal|8
index|]
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|n_ops
init|=
literal|2
decl_stmt|,
name|input_ops
init|=
literal|2
decl_stmt|,
name|input_consts
init|=
literal|0
decl_stmt|,
name|n_consts
decl_stmt|;
name|int
name|first
decl_stmt|,
name|changed
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
name|ops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ops
argument_list|)
expr_stmt|;
comment|/* Set up the two operands and then expand them until nothing has been      changed.  If we run out of room in our array, give up; this should      almost never happen.  */
name|ops
index|[
literal|0
index|]
operator|.
name|op
operator|=
name|op0
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|.
name|op
operator|=
name|op1
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|.
name|neg
operator|=
operator|(
name|code
operator|==
name|MINUS
operator|)
expr_stmt|;
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|this_op
init|=
name|ops
index|[
name|i
index|]
operator|.
name|op
decl_stmt|;
name|int
name|this_neg
init|=
name|ops
index|[
name|i
index|]
operator|.
name|neg
decl_stmt|;
name|enum
name|rtx_code
name|this_code
init|=
name|GET_CODE
argument_list|(
name|this_op
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|this_code
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|n_ops
operator|==
literal|7
condition|)
return|return
name|NULL_RTX
return|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|neg
operator|=
operator|(
name|this_code
operator|==
name|MINUS
operator|)
operator|^
name|this_neg
expr_stmt|;
name|n_ops
operator|++
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input_ops
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
operator|!
name|this_neg
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CONST
case|:
if|if
condition|(
name|n_ops
operator|<
literal|7
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|neg
operator|=
name|this_neg
expr_stmt|;
name|n_ops
operator|++
expr_stmt|;
name|input_consts
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NOT
case|:
comment|/* ~a -> (-a - 1) */
if|if
condition|(
name|n_ops
operator|!=
literal|7
condition|)
block|{
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|constm1_rtx
expr_stmt|;
name|ops
index|[
name|n_ops
operator|++
index|]
operator|.
name|neg
operator|=
name|this_neg
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
operator|!
name|this_neg
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|this_neg
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|this_op
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
comment|/* If we only have two operands, we can't do anything.  */
if|if
condition|(
name|n_ops
operator|<=
literal|2
operator|&&
operator|!
name|force
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Count the number of CONSTs we didn't split above.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|input_consts
operator|++
expr_stmt|;
comment|/* Now simplify each pair of operands until nothing changes.  The first      time through just simplify constants against each other.  */
name|first
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|changed
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|-
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_ops
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|lhs
init|=
name|ops
index|[
name|i
index|]
operator|.
name|op
decl_stmt|,
name|rhs
init|=
name|ops
index|[
name|j
index|]
operator|.
name|op
decl_stmt|;
name|int
name|lneg
init|=
name|ops
index|[
name|i
index|]
operator|.
name|neg
decl_stmt|,
name|rneg
init|=
name|ops
index|[
name|j
index|]
operator|.
name|neg
decl_stmt|;
if|if
condition|(
name|lhs
operator|!=
literal|0
operator|&&
name|rhs
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|first
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|lhs
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|rhs
argument_list|)
operator|)
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|ncode
init|=
name|PLUS
decl_stmt|;
if|if
condition|(
name|lneg
operator|!=
name|rneg
condition|)
block|{
name|ncode
operator|=
name|MINUS
expr_stmt|;
if|if
condition|(
name|lneg
condition|)
name|tem
operator|=
name|lhs
operator|,
name|lhs
operator|=
name|rhs
operator|,
name|rhs
operator|=
name|tem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
name|tem
operator|=
name|lhs
operator|,
name|lhs
operator|=
name|rhs
operator|,
name|rhs
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|ncode
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* Reject "simplifications" that just wrap the two 		   arguments in a CONST.  Failure to do so can result 		   in infinite recursion with simplify_binary_operation 		   when it calls us to simplify CONST operations.  */
if|if
condition|(
name|tem
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ncode
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|lhs
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|rhs
operator|)
comment|/* Don't allow -x + -1 -> ~x simplifications in the 		       first pass.  This allows us the chance to combine 		       the -1 with other constants.  */
operator|&&
operator|!
operator|(
name|first
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOT
operator|&&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|==
name|rhs
operator|)
condition|)
block|{
name|lneg
operator|&=
name|rneg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NEG
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|,
name|lneg
operator|=
operator|!
name|lneg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|lneg
condition|)
name|tem
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
operator|,
name|lneg
operator|=
literal|0
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|tem
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
name|lneg
expr_stmt|;
name|ops
index|[
name|j
index|]
operator|.
name|op
operator|=
name|NULL_RTX
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|changed
condition|)
do|;
comment|/* Pack all the operands to the lower-numbered entries.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_ops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|j
index|]
operator|.
name|op
condition|)
name|ops
index|[
name|i
operator|++
index|]
operator|=
name|ops
index|[
name|j
index|]
expr_stmt|;
name|n_ops
operator|=
name|i
expr_stmt|;
comment|/* Sort the operations based on swap_commutative_operands_p.  */
name|qsort
argument_list|(
name|ops
argument_list|,
name|n_ops
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ops
argument_list|)
argument_list|,
name|simplify_plus_minus_op_data_cmp
argument_list|)
expr_stmt|;
comment|/* Create (minus -C X) instead of (neg (const (plus X C))).  */
if|if
condition|(
name|n_ops
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
literal|1
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONSTANT_P
argument_list|(
name|ops
index|[
literal|0
index|]
operator|.
name|op
argument_list|)
operator|&&
name|ops
index|[
literal|0
index|]
operator|.
name|neg
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|ops
index|[
literal|1
index|]
operator|.
name|op
argument_list|,
name|ops
index|[
literal|0
index|]
operator|.
name|op
argument_list|)
return|;
comment|/* We suppressed creation of trivial CONST expressions in the      combination loop to avoid recursion.  Create one manually now.      The combination loop should have ensured that there is exactly      one CONST_INT, and the sort will have ensured that it is last      in the array and that any other constant will be next-to-last.  */
if|if
condition|(
name|n_ops
operator|>
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONSTANT_P
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
argument_list|)
condition|)
block|{
name|rtx
name|value
init|=
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|neg
operator|^
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|neg
condition|)
name|value
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
operator|=
name|plus_constant
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
argument_list|,
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|n_ops
operator|--
expr_stmt|;
block|}
comment|/* Count the number of CONSTs that we generated.  */
name|n_consts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|n_consts
operator|++
expr_stmt|;
comment|/* Give up if we didn't reduce the number of operands we had.  Make      sure we count a CONST as two operands.  If we have the same      number of operands, but have made more CONSTs than before, this      is also an improvement, so accept it.  */
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|n_ops
operator|+
name|n_consts
operator|>
name|input_ops
operator|||
operator|(
name|n_ops
operator|+
name|n_consts
operator|==
name|input_ops
operator|&&
name|n_consts
operator|<=
name|input_consts
operator|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Put a non-negated operand first, if possible.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|&&
name|ops
index|[
name|i
index|]
operator|.
name|neg
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|n_ops
condition|)
name|ops
index|[
literal|0
index|]
operator|.
name|op
operator|=
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|ops
index|[
literal|0
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|ops
index|[
name|i
index|]
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|tem
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now make the result by performing the requested operations.  */
name|result
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|ops
index|[
name|i
index|]
operator|.
name|neg
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|mode
argument_list|,
name|result
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like simplify_binary_operation except used for relational operators.    MODE is the mode of the operands, not that of the result.  If MODE    is VOIDmode, both operands must also be VOIDmode and we compare the    operands in "infinite precision".     If no simplification is possible, this function returns zero.  Otherwise,    it returns either const_true_rtx or const0_rtx.  */
end_comment

begin_function
name|rtx
name|simplify_relational_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|int
name|equal
decl_stmt|,
name|op0lt
decl_stmt|,
name|op0ltu
decl_stmt|,
name|op1lt
decl_stmt|,
name|op1ltu
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|trueop0
decl_stmt|;
name|rtx
name|trueop1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If op0 is a compare, extract the comparison arguments from it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trueop0
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|trueop1
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* We can't simplify MODE_CC values since we don't know what the      actual comparison is.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|||
name|CC0_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Make sure the constant is second.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|trueop0
operator|,
name|trueop0
operator|=
name|trueop1
operator|,
name|trueop1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* For integer comparisons of A and B maybe we can simplify A - B and can      then simplify a comparison of that with zero.  If A and B are both either      a register or a CONST_INT, this can't help; testing for these cases will      prevent infinite recursion here and speed things up.       If CODE is an unsigned comparison, then we can never do this optimization,      because it gives an incorrect result if the subtraction wraps around zero.      ANSI C defines unsigned operations such that they never overflow, and      thus such cases can not be ignored.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|!=
name|const0_rtx
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
comment|/* We cannot do this for == or != if tem is a nonzero address.  */
operator|&&
operator|(
operator|(
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
operator|)
operator|||
operator|!
name|nonzero_address_p
argument_list|(
name|tem
argument_list|)
operator|)
operator|&&
name|code
operator|!=
name|GTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|LEU
condition|)
return|return
name|simplify_relational_operation
argument_list|(
name|signed_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|const0_rtx
argument_list|)
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|==
name|ORDERED
condition|)
return|return
name|const_true_rtx
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|==
name|UNORDERED
condition|)
return|return
name|const0_rtx
return|;
comment|/* For modes without NaNs, if the two operands are equal, we know the      result except if they have side-effects.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|trueop0
argument_list|)
condition|)
name|equal
operator|=
literal|1
operator|,
name|op0lt
operator|=
literal|0
operator|,
name|op0ltu
operator|=
literal|0
operator|,
name|op1lt
operator|=
literal|0
operator|,
name|op1ltu
operator|=
literal|0
expr_stmt|;
comment|/* If the operands are floating-point constants, see if we can fold      the result.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d0
decl_stmt|,
name|d1
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d0
argument_list|,
name|trueop0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d1
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
comment|/* Comparisons are unordered iff at least one of the values is NaN.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d0
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNEQ
case|:
case|case
name|UNLT
case|:
case|case
name|UNGT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGE
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
return|return
name|const_true_rtx
return|;
case|case
name|EQ
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTGT
case|:
case|case
name|ORDERED
case|:
return|return
name|const0_rtx
return|;
default|default:
return|return
literal|0
return|;
block|}
name|equal
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|op0lt
operator|=
name|op0ltu
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|op1lt
operator|=
name|op1ltu
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, see if the operands are both integers.  */
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|l0s
decl_stmt|,
name|h0s
decl_stmt|,
name|l1s
decl_stmt|,
name|h1s
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l0u
decl_stmt|,
name|h0u
decl_stmt|,
name|l1u
decl_stmt|,
name|h1u
decl_stmt|;
comment|/* Get the two words comprising each integer constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l0u
operator|=
name|l0s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l0u
operator|=
name|l0s
operator|=
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l0s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l1u
operator|=
name|l1s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l1u
operator|=
name|l1s
operator|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1s
argument_list|)
expr_stmt|;
block|}
comment|/* If WIDTH is nonzero and smaller than HOST_BITS_PER_WIDE_INT, 	 we have to sign or zero-extend the values.  */
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|l0u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|l1u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
if|if
condition|(
name|l1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|h0u
operator|=
name|h1u
operator|=
literal|0
operator|,
name|h0s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l0s
argument_list|)
operator|,
name|h1s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1s
argument_list|)
expr_stmt|;
name|equal
operator|=
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|==
name|l1u
operator|)
expr_stmt|;
name|op0lt
operator|=
operator|(
name|h0s
operator|<
name|h1s
operator|||
operator|(
name|h0s
operator|==
name|h1s
operator|&&
name|l0u
operator|<
name|l1u
operator|)
operator|)
expr_stmt|;
name|op1lt
operator|=
operator|(
name|h1s
operator|<
name|h0s
operator|||
operator|(
name|h1s
operator|==
name|h0s
operator|&&
name|l1u
operator|<
name|l0u
operator|)
operator|)
expr_stmt|;
name|op0ltu
operator|=
operator|(
name|h0u
operator|<
name|h1u
operator|||
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|<
name|l1u
operator|)
operator|)
expr_stmt|;
name|op1ltu
operator|=
operator|(
name|h1u
operator|<
name|h0u
operator|||
operator|(
name|h1u
operator|==
name|h0u
operator|&&
name|l1u
operator|<
name|l0u
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Otherwise, there are some code-specific tests we can make.  */
else|else
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
name|nonzero_address_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
name|nonzero_address_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|GEU
case|:
comment|/* Unsigned values are never negative.  */
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|LEU
case|:
comment|/* Unsigned values are never greater than the largest 	     unsigned value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|LT
case|:
comment|/* Optimize abs(x)< 0.0.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tem
operator|=
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|?
name|XEXP
argument_list|(
name|trueop0
argument_list|,
literal|0
argument_list|)
else|:
name|trueop0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ABS
condition|)
return|return
name|const0_rtx
return|;
block|}
break|break;
case|case
name|GE
case|:
comment|/* Optimize abs(x)>= 0.0.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tem
operator|=
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|?
name|XEXP
argument_list|(
name|trueop0
argument_list|,
literal|0
argument_list|)
else|:
name|trueop0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ABS
condition|)
return|return
name|const_true_rtx
return|;
block|}
break|break;
case|case
name|UNGE
case|:
comment|/* Optimize ! (abs(x)< 0.0).  */
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tem
operator|=
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|?
name|XEXP
argument_list|(
name|trueop0
argument_list|,
literal|0
argument_list|)
else|:
name|trueop0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ABS
condition|)
return|return
name|const_true_rtx
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
comment|/* If we reach here, EQUAL, OP0LT, OP0LTU, OP1LT, and OP1LTU are set      as appropriate.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
return|return
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
return|return
operator|!
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
return|return
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GT
case|:
case|case
name|UNGT
case|:
return|return
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LTU
case|:
return|return
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GTU
case|:
return|return
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
return|return
name|equal
operator|||
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GE
case|:
case|case
name|UNGE
case|:
return|return
name|equal
operator|||
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LEU
case|:
return|return
name|equal
operator|||
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GEU
case|:
return|return
name|equal
operator|||
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|ORDERED
case|:
return|return
name|const_true_rtx
return|;
case|case
name|UNORDERED
case|:
return|return
name|const0_rtx
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify CODE, an operation with result mode MODE and three operands,    OP0, OP1, and OP2.  OP0_MODE was the mode of OP0 before it became    a constant.  Return 0 if no simplifications is possible.  */
end_comment

begin_function
name|rtx
name|simplify_ternary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|op0_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* VOIDmode means "infinite" precision.  */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<=
name|width
operator|)
operator|&&
name|width
operator|<=
operator|(
name|unsigned
operator|)
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Extracting a bit-field from a constant */
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|val
operator|>>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op0_mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
expr_stmt|;
else|else
name|val
operator|>>=
name|INTVAL
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|INTVAL
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* First zero-extend.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If desired, propagate sign bit.  */
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|~
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Clear the bits that don't belong in our mode, 	     unless they and our sign bit are all one. 	     So we get either a reasonable negative value or a reasonable 	     unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|op0
operator|!=
name|const0_rtx
condition|?
name|op1
else|:
name|op2
return|;
comment|/* Convert c ? a : a into "a".  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* Convert a != b ? a : b into "a".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NE
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|op1
return|;
comment|/* Convert a == b ? a : b into "b".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|EQ
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|op2
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|cmp_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|op0_mode
expr_stmt|;
name|temp
operator|=
name|simplify_relational_operation
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if any simplifications were possible.  */
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
return|return
name|op2
return|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|const_true_rtx
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|temp
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for happy constants in op1 and op2.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|t
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|f
init|=
name|INTVAL
argument_list|(
name|op2
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|STORE_FLAG_VALUE
operator|&&
name|f
operator|==
literal|0
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|0
operator|&&
name|f
operator|==
name|STORE_FLAG_VALUE
condition|)
block|{
name|enum
name|rtx_code
name|tmp
decl_stmt|;
name|tmp
operator|=
name|reversed_comparison_code
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|UNKNOWN
condition|)
break|break;
name|code
operator|=
name|tmp
expr_stmt|;
block|}
else|else
break|break;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|VEC_MERGE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode
operator|||
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op2
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|n_elts
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|&
name|mask
operator|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
name|op0
return|;
name|op0
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|?
name|CONST_VECTOR_ELT
argument_list|(
name|op0
argument_list|,
name|i
argument_list|)
else|:
name|CONST_VECTOR_ELT
argument_list|(
name|op1
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Evaluate a SUBREG of a CONST_INT or CONST_DOUBLE or CONST_VECTOR,    returning another CONST_INT or CONST_DOUBLE or CONST_VECTOR.     Works by unpacking OP into a collection of 8-bit values    represented as a little-endian array of 'unsigned char', selecting by BYTE,    and then repacking them again for OUTERMODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_immed_subreg
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|,
name|unsigned
name|int
name|byte
parameter_list|)
block|{
comment|/* We support up to 512-bit values (for V8DFmode).  */
enum|enum
block|{
name|max_bitsize
init|=
literal|512
block|,
name|value_bit
init|=
literal|8
block|,
name|value_mask
init|=
operator|(
literal|1
operator|<<
name|value_bit
operator|)
operator|-
literal|1
block|}
enum|;
name|unsigned
name|char
name|value
index|[
name|max_bitsize
operator|/
name|value_bit
index|]
decl_stmt|;
name|int
name|value_start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|elem
decl_stmt|;
name|int
name|num_elem
decl_stmt|;
name|rtx
modifier|*
name|elems
decl_stmt|;
name|int
name|elem_bitsize
decl_stmt|;
name|rtx
name|result_s
decl_stmt|;
name|rtvec
name|result_v
init|=
name|NULL
decl_stmt|;
name|enum
name|mode_class
name|outer_class
decl_stmt|;
name|enum
name|machine_mode
name|outer_submode
decl_stmt|;
comment|/* Some ports misuse CCmode.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|outermode
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|op
return|;
comment|/* Unpack the value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|num_elem
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|elems
operator|=
operator|&
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elem_bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|innermode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num_elem
operator|=
literal|1
expr_stmt|;
name|elems
operator|=
operator|&
name|op
expr_stmt|;
name|elem_bitsize
operator|=
name|max_bitsize
expr_stmt|;
block|}
if|if
condition|(
name|BITS_PER_UNIT
operator|%
name|value_bit
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Too complicated; reducing value_bit may help.  */
if|if
condition|(
name|elem_bitsize
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* I don't know how to handle endianness of sub-units.  */
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|num_elem
condition|;
name|elem
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|vp
decl_stmt|;
name|rtx
name|el
init|=
name|elems
index|[
name|elem
index|]
decl_stmt|;
comment|/* Vectors are kept in target memory order.  (This is probably 	 a mistake.)  */
block|{
name|unsigned
name|byte
init|=
operator|(
name|elem
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|unsigned
name|ibyte
init|=
operator|(
operator|(
operator|(
name|num_elem
operator|-
literal|1
operator|-
name|elem
operator|)
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|unsigned
name|word_byte
init|=
name|WORDS_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|subword_byte
init|=
name|BYTES_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|bytele
init|=
operator|(
name|subword_byte
operator|%
name|UNITS_PER_WORD
operator|+
operator|(
name|word_byte
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|vp
operator|=
name|value
operator|+
operator|(
name|bytele
operator|*
name|BITS_PER_UNIT
operator|)
operator|/
name|value_bit
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|el
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
name|INTVAL
argument_list|(
name|el
argument_list|)
operator|>>
name|i
expr_stmt|;
comment|/* CONST_INTs are always logically sign-extended.  */
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
name|INTVAL
argument_list|(
name|el
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|el
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* If this triggers, someone should have generated a 		 CONST_INT instead.  */
if|if
condition|(
name|elem_bitsize
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|el
argument_list|)
operator|>>
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
name|i
operator|<
name|elem_bitsize
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|el
argument_list|)
operator|>>
operator|(
name|i
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
name|i
operator|+=
name|value_bit
expr_stmt|;
block|}
comment|/* It shouldn't matter what's done here, so fill it with 		 zero.  */
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|el
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|long
name|tmp
index|[
name|max_bitsize
operator|/
literal|32
index|]
decl_stmt|;
name|int
name|bitsize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|el
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitsize
operator|>
name|elem_bitsize
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bitsize
operator|%
name|value_bit
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|real_to_target
argument_list|(
name|tmp
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|el
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|el
argument_list|)
argument_list|)
expr_stmt|;
comment|/* real_to_target produces its result in words affected by 		 FLOAT_WORDS_BIG_ENDIAN.  However, we ignore this, 		 and use WORDS_BIG_ENDIAN instead; see the documentation 	         of SUBREG in rtl.texi.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
block|{
name|int
name|ibase
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|ibase
operator|=
name|bitsize
operator|-
literal|1
operator|-
name|i
expr_stmt|;
else|else
name|ibase
operator|=
name|i
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|tmp
index|[
name|ibase
operator|/
literal|32
index|]
operator|>>
name|i
operator|%
literal|32
expr_stmt|;
block|}
comment|/* It shouldn't matter what's done here, so fill it with 		 zero.  */
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now, pick the right byte to start with.  */
comment|/* Renumber BYTE so that the least-significant byte is byte 0.  A special      case is paradoxical SUBREGs, which shouldn't be adjusted since they      will already have offset 0.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|unsigned
name|ibyte
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|-
name|byte
operator|)
decl_stmt|;
name|unsigned
name|word_byte
init|=
name|WORDS_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|subword_byte
init|=
name|BYTES_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|byte
operator|=
operator|(
name|subword_byte
operator|%
name|UNITS_PER_WORD
operator|+
operator|(
name|word_byte
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
comment|/* BYTE should still be inside OP.  (Note that BYTE is unsigned,      so if it's become negative it will instead be very large.)  */
if|if
condition|(
name|byte
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Convert from bytes to chunks of size value_bit.  */
name|value_start
operator|=
name|byte
operator|*
operator|(
name|BITS_PER_UNIT
operator|/
name|value_bit
operator|)
expr_stmt|;
comment|/* Re-pack the value.  */
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|num_elem
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|outermode
argument_list|)
expr_stmt|;
name|result_v
operator|=
name|rtvec_alloc
argument_list|(
name|num_elem
argument_list|)
expr_stmt|;
name|elems
operator|=
operator|&
name|RTVEC_ELT
argument_list|(
name|result_v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outer_submode
operator|=
name|GET_MODE_INNER
argument_list|(
name|outermode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num_elem
operator|=
literal|1
expr_stmt|;
name|elems
operator|=
operator|&
name|result_s
expr_stmt|;
name|outer_submode
operator|=
name|outermode
expr_stmt|;
block|}
name|outer_class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|outer_submode
argument_list|)
expr_stmt|;
name|elem_bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|outer_submode
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem_bitsize
operator|%
name|value_bit
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|elem_bitsize
operator|+
name|value_start
operator|*
name|value_bit
operator|>
name|max_bitsize
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|num_elem
condition|;
name|elem
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|vp
decl_stmt|;
comment|/* Vectors are stored in target memory order.  (This is probably 	 a mistake.)  */
block|{
name|unsigned
name|byte
init|=
operator|(
name|elem
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|unsigned
name|ibyte
init|=
operator|(
operator|(
operator|(
name|num_elem
operator|-
literal|1
operator|-
name|elem
operator|)
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|unsigned
name|word_byte
init|=
name|WORDS_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|subword_byte
init|=
name|BYTES_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|bytele
init|=
operator|(
name|subword_byte
operator|%
name|UNITS_PER_WORD
operator|+
operator|(
name|word_byte
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|vp
operator|=
name|value
operator|+
name|value_start
operator|+
operator|(
name|bytele
operator|*
name|BITS_PER_UNIT
operator|)
operator|/
name|value_bit
expr_stmt|;
block|}
switch|switch
condition|(
name|outer_class
condition|)
block|{
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|hi
init|=
literal|0
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
name|lo
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|vp
operator|++
operator|&
name|value_mask
argument_list|)
operator|<<
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
name|hi
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|vp
operator|++
operator|&
name|value_mask
argument_list|)
operator|<<
operator|(
name|i
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
comment|/* immed_double_const doesn't call trunc_int_for_mode.  I don't 	       know why.  */
if|if
condition|(
name|elem_bitsize
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|elems
index|[
name|elem
index|]
operator|=
name|gen_int_mode
argument_list|(
name|lo
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
else|else
name|elems
index|[
name|elem
index|]
operator|=
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MODE_FLOAT
case|:
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|tmp
index|[
name|max_bitsize
operator|/
literal|32
index|]
decl_stmt|;
comment|/* real_from_target wants its input in words affected by 	       FLOAT_WORDS_BIG_ENDIAN.  However, we ignore this, 	       and use WORDS_BIG_ENDIAN instead; see the documentation 	       of SUBREG in rtl.texi.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_bitsize
operator|/
literal|32
condition|;
name|i
operator|++
control|)
name|tmp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
block|{
name|int
name|ibase
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|ibase
operator|=
name|elem_bitsize
operator|-
literal|1
operator|-
name|i
expr_stmt|;
else|else
name|ibase
operator|=
name|i
expr_stmt|;
name|tmp
index|[
name|ibase
operator|/
literal|32
index|]
operator||=
operator|(
operator|*
name|vp
operator|++
operator|&
name|value_mask
operator|)
operator|<<
name|i
operator|%
literal|32
expr_stmt|;
block|}
name|real_from_target
argument_list|(
operator|&
name|r
argument_list|,
name|tmp
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
name|elems
index|[
name|elem
index|]
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|outermode
argument_list|)
condition|)
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|outermode
argument_list|,
name|result_v
argument_list|)
return|;
else|else
return|return
name|result_s
return|;
block|}
end_function

begin_comment
comment|/* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)    Return 0 if no simplifications are possible.  */
end_comment

begin_function
name|rtx
name|simplify_subreg
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|,
name|unsigned
name|int
name|byte
parameter_list|)
block|{
comment|/* Little bit of sanity checking.  */
if|if
condition|(
name|innermode
operator|==
name|VOIDmode
operator|||
name|outermode
operator|==
name|VOIDmode
operator|||
name|innermode
operator|==
name|BLKmode
operator|||
name|outermode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|innermode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|byte
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|||
name|byte
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|outermode
operator|==
name|innermode
operator|&&
operator|!
name|byte
condition|)
return|return
name|op
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
return|return
name|simplify_immed_subreg
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
return|;
comment|/* Changing mode twice with SUBREG => just change it once,      or not at all if changing back op starting mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|enum
name|machine_mode
name|innermostmode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|final_offset
init|=
name|byte
operator|+
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|outermode
operator|==
name|innermostmode
operator|&&
name|byte
operator|==
literal|0
operator|&&
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
return|;
comment|/* The SUBREG_BYTE represents offset, as if the value were stored 	 in memory.  Irritating exception is paradoxical subreg, where 	 we define SUBREG_BYTE to be 0.  On big endian machines, this 	 value should be negative.  For a moment, undo this exception.  */
if|if
condition|(
name|byte
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
comment|/* See whether resulting subreg will be paradoxical.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
comment|/* In nonparadoxical subregs we can't handle negative offsets.  */
if|if
condition|(
name|final_offset
operator|<
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Bail out in case resulting subreg would be incorrect.  */
if|if
condition|(
name|final_offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|||
operator|(
name|unsigned
operator|)
name|final_offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
comment|/* In paradoxical subreg, see if we are still looking on lower part. 	     If so, our SUBREG_BYTE will be 0.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|final_offset
condition|)
name|final_offset
operator|=
literal|0
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
block|}
comment|/* Recurse for further possible simplifications.  */
name|new
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
name|final_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|final_offset
argument_list|)
return|;
block|}
comment|/* SUBREG of a hard register => just change the register number      and/or mode.  If the hard register is not valid in that mode,      suppress this simplification.  If the hard register is the stack,      frame, or argument pointer, leave this as a SUBREG.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|rtx_equal_function_value_matters
operator|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
operator|(
name|REG_CANNOT_CHANGE_MODE_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|,
name|innermode
argument_list|,
name|outermode
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|innermode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|innermode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|)
endif|#
directive|endif
operator|&&
operator|(
operator|(
name|reload_completed
operator|&&
operator|!
name|frame_pointer_needed
operator|)
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|subreg_offset_representable_p
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|,
name|outermode
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|byte
argument_list|)
decl_stmt|;
name|int
name|final_regno
init|=
name|subreg_hard_regno
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? We do allow it if the current REG is not valid for 	 its mode.  This is a kludge to work around how float/complex 	 arguments are passed on 32-bit SPARC and should be fixed.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|final_regno
argument_list|,
name|outermode
argument_list|)
operator|||
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|,
name|innermode
argument_list|)
condition|)
block|{
name|rtx
name|x
init|=
name|gen_rtx_REG_offset
argument_list|(
name|op
argument_list|,
name|outermode
argument_list|,
name|final_regno
argument_list|,
name|byte
argument_list|)
decl_stmt|;
comment|/* Propagate original regno.  We don't have any way to specify 	     the offset inside original regno, so do so only for lowpart. 	     The information is used only by alias analysis that can not 	     grog partial register anyway.  */
if|if
condition|(
name|subreg_lowpart_offset
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
operator|==
name|byte
condition|)
name|ORIGINAL_REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
comment|/* If we have a SUBREG of a register that we are replacing and we are      replacing it with a MEM, make a new MEM and try replacing the      SUBREG with it.  Don't do this if the MEM has a mode-dependent address      or if we would be widening it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Allow splitting of volatile memory references in case we don't          have instruction to move the whole thing.  */
operator|&&
operator|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|innermode
argument_list|)
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|adjust_address_nv
argument_list|(
name|op
argument_list|,
name|outermode
argument_list|,
name|byte
argument_list|)
return|;
comment|/* Handle complex values represented as CONCAT      of real and imaginary part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|int
name|is_realpart
init|=
name|byte
operator|<
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE_UNIT_SIZE
argument_list|(
name|innermode
argument_list|)
decl_stmt|;
name|rtx
name|part
init|=
name|is_realpart
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|final_offset
decl_stmt|;
name|rtx
name|res
decl_stmt|;
name|final_offset
operator|=
name|byte
operator|%
operator|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|innermode
argument_list|)
operator|)
expr_stmt|;
name|res
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|part
argument_list|,
name|GET_MODE
argument_list|(
name|part
argument_list|)
argument_list|,
name|final_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
comment|/* We can at least simplify it by referring directly to the relevant part.  */
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|part
argument_list|,
name|final_offset
argument_list|)
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Make a SUBREG operation or equivalent if it folds.  */
end_comment

begin_function
name|rtx
name|simplify_gen_subreg
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|,
name|unsigned
name|int
name|byte
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|;
comment|/* Little bit of sanity checking.  */
if|if
condition|(
name|innermode
operator|==
name|VOIDmode
operator|||
name|outermode
operator|==
name|VOIDmode
operator|||
name|innermode
operator|==
name|BLKmode
operator|||
name|outermode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|innermode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|byte
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|||
name|byte
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|QUEUED
condition|)
return|return
name|NULL_RTX
return|;
name|new
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|byte
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simplify X, an rtx expression.     Return the simplified expression or NULL if no simplifications    were possible.     This is the preferred entry point into the simplification routines;    however, we still allow passes to call the more specific routines.     Right now GCC has three (yes, three) major bodies of RTL simplification    code that need to be unified.  	1. fold_rtx in cse.c.  This code uses various CSE specific 	   information to aid in RTL simplification.  	2. simplify_rtx in combine.c.  Similar to fold_rtx, except that 	   it uses combine specific information to aid in RTL 	   simplification.  	3. The routines in this file.      Long term we want to only have one body of simplification code; to    get to that state I recommend the following steps:  	1. Pour over fold_rtx& simplify_rtx and move any simplifications 	   which are not pass dependent state into these routines.  	2. As code is moved by #1, change fold_rtx& simplify_rtx to 	   use this routine whenever possible.  	3. Allow for pass dependent state to be provided to these 	   routines and add simplifications based on the pass dependent 	   state.  Remove code from cse.c& combine.c that becomes 	   redundant/dead.      It will take time, but ultimately the compiler will be easier to     maintain and improve.  It's totally silly that when we add a     simplification that it needs to be added to 4 places (3 for RTL     simplification and 1 for tree simplification.  */
end_comment

begin_function
name|rtx
name|simplify_rtx
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'c'
case|:
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Fall through....  */
case|case
literal|'2'
case|:
return|return
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
literal|'3'
case|:
case|case
literal|'b'
case|:
return|return
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
literal|'<'
case|:
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|temp
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
operator|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|temp
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|temp
return|;
case|case
literal|'x'
case|:
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
return|return
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|CONSTANT_P_RTX
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|const1_rtx
return|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|code
operator|==
name|LO_SUM
condition|)
block|{
comment|/* Convert (lo_sum (high FOO) FOO) to FOO.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

