begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL simplification functions for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Simplification and canonicalization of RTL.  */
end_comment

begin_comment
comment|/* Much code operates on (low, high) pairs; the low value is an    unsigned wide int, the high value a signed wide int.  We    occasionally need to sign extend from low to high as if low were a    signed wide int.  */
end_comment

begin_define
define|#
directive|define
name|HWI_SIGN_EXTEND
parameter_list|(
name|low
parameter_list|)
define|\
value|((((HOST_WIDE_INT) low)< 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))
end_define

begin_function_decl
specifier|static
name|rtx
name|neg_const_int
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|plus_minus_operand_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|simplify_plus_minus_op_data_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_plus_minus
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_immed_subreg
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_associative_operation
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_relational_operation_1
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_unary_operation_1
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_binary_operation_1
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Negate a CONST_INT rtx, truncating (because a conversion from a    maximally negative number can overflow).  */
end_comment

begin_function
specifier|static
name|rtx
name|neg_const_int
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|i
parameter_list|)
block|{
return|return
name|gen_int_mode
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|i
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Test whether expression, X, is an immediate constant that represents    the most significant bit of machine mode MODE.  */
end_comment

begin_function
name|bool
name|mode_signbit_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
name|false
return|;
name|width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|val
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|<=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|width
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|val
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a binary operation by properly ordering the operands and    seeing if the expression folds.  */
end_comment

begin_function
name|rtx
name|simplify_gen_binary
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If this simplifies, do it.  */
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* Put complex operands first and constants second if commutative.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_ARITH
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a MEM referencing the constant pool, return the real value.    Otherwise return X.  */
end_comment

begin_function
name|rtx
name|avoid_constant_pool_reference
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|c
decl_stmt|,
name|tmp
decl_stmt|,
name|addr
decl_stmt|;
name|enum
name|machine_mode
name|cmode
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
break|break;
case|case
name|FLOAT_EXTEND
case|:
comment|/* Handle float extensions of constant pool references.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|tmp
operator|&&
name|GET_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
return|return
name|x
return|;
default|default:
return|return
name|x
return|;
block|}
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call target hook to avoid the effects of -fpic etc....  */
name|addr
operator|=
name|targetm
operator|.
name|delegitimize_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Split the address into a base and integer offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is a constant pool reference, we can turn it into its      constant and hope that simplifications happen.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|c
operator|=
name|get_pool_constant
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|cmode
operator|=
name|get_pool_mode
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If we're accessing the constant in a different mode than it was          originally stored, attempt to fix that up via subreg simplifications.          If that fails we have no choice but to return the original memory.  */
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|cmode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|c
argument_list|,
name|cmode
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|&&
name|CONSTANT_P
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|tem
return|;
block|}
else|else
return|return
name|c
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is a MEM referencing the constant pool.  */
end_comment

begin_function
name|bool
name|constant_pool_reference_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|avoid_constant_pool_reference
argument_list|(
name|x
argument_list|)
operator|!=
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a unary operation by first seeing if it folds and otherwise making    the specified operation.  */
end_comment

begin_function
name|rtx
name|simplify_gen_unary
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|op_mode
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If this simplifies, use it.  */
if|if
condition|(
operator|(
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|op_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise for ternary operations.  */
end_comment

begin_function
name|rtx
name|simplify_gen_ternary
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|op0_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If this simplifies, use it.  */
if|if
condition|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
return|return
name|gen_rtx_fmt_eee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, for relational operations.    CMP_MODE specifies mode comparison is done in.  */
end_comment

begin_function
name|rtx
name|simplify_gen_relational
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|cmp_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace all occurrences of OLD_RTX in X with NEW_RTX and try to simplify the    resulting RTX.  Return a new RTX which is as simplified as possible.  */
end_comment

begin_function
name|rtx
name|simplify_replace_rtx
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|old_rtx
parameter_list|,
name|rtx
name|new_rtx
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
comment|/* If X is OLD_RTX, return NEW_RTX.  Otherwise, if this is an expression, try      to build a new expression substituting recursively.  If we can't do      anything, return our input.  */
if|if
condition|(
name|x
operator|==
name|old_rtx
condition|)
return|return
name|new_rtx
return|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|RTX_UNARY
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|op0
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op_mode
argument_list|)
return|;
case|case
name|RTX_BIN_ARITH
case|:
case|case
name|RTX_COMM_ARITH
case|:
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|RTX_COMPARE
case|:
case|case
name|RTX_COMM_COMPARE
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|op0
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|op1
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|RTX_TERNARY
case|:
case|case
name|RTX_BITFIELD_OPS
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|op0
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
name|op2
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_ternary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
case|case
name|RTX_EXTRA
case|:
comment|/* The only case we try to handle is a SUBREG.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
name|op0
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op0
condition|?
name|op0
else|:
name|x
return|;
block|}
break|break;
case|case
name|RTX_OBJ
case|:
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|op0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LO_SUM
condition|)
block|{
name|op0
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old_rtx
argument_list|,
name|new_rtx
argument_list|)
expr_stmt|;
comment|/* (lo_sum (high x) x) -> x  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|HIGH
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|old_rtx
argument_list|)
condition|)
return|return
name|new_rtx
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to simplify a unary operation CODE whose output mode is to be    MODE with input operand OP whose mode was originally OP_MODE.    Return zero if no simplification can be made.  */
end_comment

begin_function
name|rtx
name|simplify_unary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|op_mode
parameter_list|)
block|{
name|rtx
name|trueop
decl_stmt|,
name|tem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trueop
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|tem
operator|=
name|simplify_const_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|trueop
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
return|return
name|simplify_unary_operation_1
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform some simplifications we can do even if the operands    aren't constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_unary_operation_1
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op
parameter_list|)
block|{
name|enum
name|rtx_code
name|reversed
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
comment|/* (not (not X)) == X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (not (eq X Y)) == (ne X Y), etc. if BImode or the result of the 	 comparison is all ones.   */
if|if
condition|(
name|COMPARISON_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|mode
operator|==
name|BImode
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|reversed
operator|=
name|reversed_comparison_code
argument_list|(
name|op
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|UNKNOWN
operator|)
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|reversed
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (not (plus X -1)) can become (neg X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Similarly, (not (neg X)) is (plus X -1).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
comment|/* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|XOR
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
comment|/* (not (plus X C)) for signbit C is (xor X D) with D = ~C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode_signbit_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
comment|/* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for 	 operands other than 1, but that is not valid.  We could do a 	 similar simplification for (not (lshiftrt C X)) where C is 	 just the sign bit, but this doesn't seem common enough to 	 bother with.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|const1_rtx
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|ROTATE
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (not (ashiftrt foo C)) where C is the number of bits in FOO 	 minus 1 is (ge foo (const_int 0)) if STORE_FLAG_VALUE is -1, 	 so we can perform the above simplification.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|GE
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|gen_rtx_ROTATE
argument_list|(
name|inner_mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|inner_mode
argument_list|,
name|const1_rtx
argument_list|,
name|inner_mode
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rtl_hooks
operator|.
name|gen_lowpart_no_emit
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
comment|/* Apply De Morgan's laws to reduce number of patterns for machines 	 with negating logical insns (and-not, nand, etc.).  If result has 	 only one NOT, put it first, since that is how the patterns are 	 coded.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
condition|)
block|{
name|rtx
name|in1
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|in2
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|in1
argument_list|)
expr_stmt|;
name|in1
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|op_mode
argument_list|,
name|in1
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|in2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
name|in2
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|op_mode
argument_list|,
name|in2
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in2
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|in1
argument_list|)
operator|!=
name|NOT
condition|)
block|{
name|rtx
name|tem
init|=
name|in2
decl_stmt|;
name|in2
operator|=
name|in1
expr_stmt|;
name|in1
operator|=
name|tem
expr_stmt|;
block|}
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
condition|?
name|AND
else|:
name|IOR
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
return|;
block|}
break|break;
case|case
name|NEG
case|:
comment|/* (neg (neg X)) == X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (neg (plus X 1)) can become (not X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Similarly, (neg (not X)) is (plus X 1).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
comment|/* (neg (minus X Y)) can become (minus Y X).  This transformation 	 isn't safe for modes with signed zeros, since if X and Y are 	 both +0, (minus Y X) is the same as (minus X Y).  If the 	 rounding mode is towards +infinity (or -infinity) then the two 	 expressions will be rounded differently.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* (neg (plus A C)) is simplified to (minus -C A).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* (neg (plus A B)) is canonicalized to (minus (neg A) B).  */
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (neg (mult A B)) becomes (mult (neg A) B). 	 This works even for floating-point values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* NEG commutes with ASHIFT since it is multiplication.  Only do 	 this if we can then eliminate the NEG (e.g., if the operand 	 is a constant).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (neg (ashiftrt X C)) can be replaced by (lshiftrt X C) when 	 C is equal to the width of MODE minus 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (neg (lshiftrt X C)) can be replaced by (ashiftrt X C) when 	 C is equal to the width of MODE minus 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|XOR
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
comment|/* (neg (lt x 0)) is (ashiftrt X C) if STORE_FLAG_VALUE is 1.  */
comment|/* (neg (lt x 0)) is (lshiftrt X C) if STORE_FLAG_VALUE is -1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LT
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|inner
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|isize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|)
block|{
name|temp
operator|=
name|simplify_gen_binary
argument_list|(
name|ASHIFTRT
argument_list|,
name|inner
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|isize
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|inner
condition|)
return|return
name|temp
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|isize
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|SIGN_EXTEND
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|inner
argument_list|)
return|;
return|return
name|simplify_gen_unary
argument_list|(
name|TRUNCATE
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|inner
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
condition|)
block|{
name|temp
operator|=
name|simplify_gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|inner
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|isize
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|inner
condition|)
return|return
name|temp
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|isize
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|inner
argument_list|)
return|;
return|return
name|simplify_gen_unary
argument_list|(
name|TRUNCATE
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|inner
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|TRUNCATE
case|:
comment|/* We can't handle truncation to a partial integer mode here          because we don't know the real bitsize of the partial          integer mode.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
break|break;
comment|/* (truncate:SI ({sign,zero}_extend:DI foo:SI)) == foo:SI.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (truncate:SI (OP:DI ({sign,zero}_extend:DI foo:SI))) is 	 (OP:SI foo:SI) if OP is NEG or ABS.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ABS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* (truncate:A (subreg:B (truncate:C X) 0)) is 	 (truncate:A X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|TRUNCATE
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If we know that the value is already truncated, we can          replace the TRUNCATE with a SUBREG.  Note that this is also          valid if TRULY_NOOP_TRUNCATION is false for the corresponding          modes we just have to apply a different definition for          truncation.  But don't do this for an (LSHIFTRT (MULT ...))           since this will cause problems with the umulXi3_highpart          patterns.  */
if|if
condition|(
operator|(
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
condition|?
operator|(
name|num_sign_bit_copies
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
else|:
name|truncated_to_mode
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
condition|)
return|return
name|rtl_hooks
operator|.
name|gen_lowpart_no_emit
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
comment|/* A truncate of a comparison can be replaced with a subreg if          STORE_FLAG_VALUE permits.  This is like the previous test,          but it works even if the comparison is done in a mode larger          than HOST_BITS_PER_WIDE_INT.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|COMPARISON_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|STORE_FLAG_VALUE
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|rtl_hooks
operator|.
name|gen_lowpart_no_emit
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
break|break;
comment|/* (float_truncate:SF (float_extend:DF foo:SF)) = foo:SF.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FLOAT_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (float_truncate:SF (float_truncate:DF foo:XF))          = (float_truncate:SF foo:XF). 	 This may eliminate double rounding, so it is unsafe.           (float_truncate:SF (float_extend:XF foo:DF))          = (float_truncate:SF foo:DF).           (float_truncate:DF (float_extend:XF foo:SF))          = (float_extend:SF foo:DF).  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FLOAT_TRUNCATE
operator|&&
name|flag_unsafe_math_optimizations
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|?
name|FLOAT_TRUNCATE
else|:
name|FLOAT_EXTEND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/*  (float_truncate (float x)) is (float x)  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FLOAT
operator|&&
operator|(
name|flag_unsafe_math_optimizations
operator|||
operator|(
operator|(
name|unsigned
operator|)
name|significand_size
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|FLOAT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (float_truncate:SF (OP:DF (float_extend:DF foo:sf))) is 	 (OP:SF foo:SF) if OP is NEG or ABS.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ABS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FLOAT_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* (float_truncate:SF (subreg:DF (float_truncate:SF X) 0)) 	 is (float_truncate:SF x).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|FLOAT_TRUNCATE
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
return|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
break|break;
comment|/*  (float_extend (float_extend x)) is (float_extend x)  	  (float_extend (float x)) is (float x) assuming that double 	  rounding can't happen.           */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FLOAT_EXTEND
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FLOAT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|significand_size
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|ABS
case|:
comment|/* (abs (neg<foo>)) -> (abs<foo>) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|ABS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If the mode of the operand is VOIDmode (i.e. if it is ASM_OPERANDS),          do nothing.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
break|break;
comment|/* If operand is something known to be positive, ignore the ABS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FFS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ABS
operator|||
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|op
return|;
comment|/* If operand is known to be only -1 or 0, convert ABS to NEG.  */
if|if
condition|(
name|num_sign_bit_copies
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
break|break;
case|case
name|FFS
case|:
comment|/* (ffs (*_extend<X>)) = (ffs<X>) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|FFS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|POPCOUNT
case|:
case|case
name|PARITY
case|:
comment|/* (pop* (zero_extend<X>)) = (pop*<X>) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|FLOAT
case|:
comment|/* (float (sign_extend<X>)) = (float<X>).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|FLOAT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* (sign_extend (truncate (minus (label_ref L1) (label_ref L2)))) 	 becomes just the MINUS if its mode is MODE.  This allows 	 folding switch statements on machines using casesi (such as 	 the VAX).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Check for a sign extension of a subreg of a promoted 	 variable, where the promotion is sign-extended, and the 	 target mode is the same as the variable's promotion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|)
operator|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
endif|#
directive|endif
break|break;
case|case
name|ZERO_EXTEND
case|:
comment|/* Check for a zero extension of a subreg of a promoted 	 variable, where the promotion is zero-extended, and the 	 target mode is the same as the variable's promotion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>
literal|0
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|)
operator|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to compute the value of a unary operation CODE whose output mode is to    be MODE with input operand OP whose mode was originally OP_MODE.    Return zero if the value cannot be computed.  */
end_comment

begin_function
name|rtx
name|simplify_const_unary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|op_mode
parameter_list|)
block|{
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VEC_DUPLICATE
condition|)
block|{
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|gcc_assert
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|op
expr_stmt|;
else|else
block|{
name|enum
name|machine_mode
name|inmode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|in_elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|inmode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|in_n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|/
name|in_elt_size
operator|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|in_n_elts
operator|<
name|n_elts
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|n_elts
operator|%
name|in_n_elts
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|i
operator|%
name|in_n_elts
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|opmode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|op_elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|opmode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|op_n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|opmode
argument_list|)
operator|/
name|op_elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|op_n_elts
operator|==
name|n_elts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|opmode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
comment|/* The order of these tests is critical so that, for example, we don't      check the wrong mode (input vs. output) for a conversion operation,      such as FIX.  At some point, this should be simplified.  */
if|if
condition|(
name|code
operator|==
name|FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|UNSIGNED_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We don't know how to interpret negative-looking numbers in 	     this case, so don't try to fold those.  */
if|if
condition|(
name|hv
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
empty_stmt|;
else|else
name|hv
operator|=
literal|0
operator|,
name|lv
operator|&=
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_UNSIGNED_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|arg0
init|=
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|val
operator|=
operator|~
name|arg0
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|val
operator|=
operator|-
name|arg0
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|val
operator|=
operator|(
name|arg0
operator|>=
literal|0
condition|?
name|arg0
else|:
operator|-
name|arg0
operator|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
comment|/* Don't use ffs here.  Instead, get low order bit and then its 	     number.  If arg0 is zero, this will return 0, as desired.  */
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
name|exact_log2
argument_list|(
name|arg0
operator|&
operator|(
operator|-
name|arg0
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|CLZ
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|&&
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
condition|)
empty_stmt|;
else|else
name|val
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|arg0
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CTZ
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
condition|)
block|{
comment|/* Even if the value at zero is undefined, we have to come 		 up with some replacement.  Seems good enough.  */
if|if
condition|(
operator|!
name|CTZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
condition|)
name|val
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|exact_log2
argument_list|(
name|arg0
operator|&
operator|-
name|arg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|POPCOUNT
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg0
condition|)
name|val
operator|++
operator|,
name|arg0
operator|&=
name|arg0
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PARITY
case|:
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg0
condition|)
name|val
operator|++
operator|,
name|arg0
operator|&=
name|arg0
operator|-
literal|1
expr_stmt|;
name|val
operator|&=
literal|1
expr_stmt|;
break|break;
case|case
name|BSWAP
case|:
return|return
literal|0
return|;
case|case
name|TRUNCATE
case|:
name|val
operator|=
name|arg0
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
comment|/* When zero-extending a CONST_INT, we need to know its              original mode.  */
name|gcc_assert
argument_list|(
name|op_mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
name|gcc_assert
argument_list|(
name|width
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
name|gcc_assert
argument_list|(
name|width
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SQRT
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|SS_TRUNCATE
case|:
case|case
name|US_TRUNCATE
case|:
case|case
name|SS_NEG
case|:
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|gen_int_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* We can do some operations on integer CONST_DOUBLEs.  Also allow      for a DImode operation on a CONST_INT.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|lv
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|hv
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|,
name|h1
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|lv
operator|=
operator|~
name|l1
expr_stmt|;
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|FFS
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|h1
operator|==
literal|0
condition|)
name|lv
operator|=
literal|0
expr_stmt|;
else|else
name|lv
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|h1
operator|&
operator|-
name|h1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|lv
operator|=
name|exact_log2
argument_list|(
name|l1
operator|&
operator|-
name|l1
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|CLZ
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|h1
argument_list|)
operator|-
literal|1
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|l1
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|lv
argument_list|)
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTZ
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|exact_log2
argument_list|(
name|l1
operator|&
operator|-
name|l1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h1
operator|!=
literal|0
condition|)
name|lv
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|h1
operator|&
operator|-
name|h1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CTZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|lv
argument_list|)
condition|)
name|lv
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|POPCOUNT
case|:
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l1
condition|)
name|lv
operator|++
operator|,
name|l1
operator|&=
name|l1
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|h1
condition|)
name|lv
operator|++
operator|,
name|h1
operator|&=
name|h1
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PARITY
case|:
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l1
condition|)
name|lv
operator|++
operator|,
name|l1
operator|&=
name|l1
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|h1
condition|)
name|lv
operator|++
operator|,
name|h1
operator|&=
name|h1
operator|-
literal|1
expr_stmt|;
name|lv
operator|&=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
comment|/* This is just a change-of-mode, so do nothing.  */
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|gcc_assert
argument_list|(
name|op_mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
else|else
block|{
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|lv
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|lv
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
name|hv
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|lv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SQRT
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|,
name|t
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SQRT
case|:
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|real_isnan
argument_list|(
operator|&
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
name|real_sqrt
argument_list|(
operator|&
name|t
argument_list|,
name|mode
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|d
operator|=
name|REAL_VALUE_ABS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|d
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
comment|/* All this does is change the mode.  */
break|break;
case|case
name|FIX
case|:
name|real_arithmetic
argument_list|(
operator|&
name|d
argument_list|,
name|FIX_TRUNC_EXPR
argument_list|,
operator|&
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
block|{
name|long
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|real_to_target
argument_list|(
name|tmp
argument_list|,
operator|&
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tmp
index|[
name|i
index|]
operator|=
operator|~
name|tmp
index|[
name|i
index|]
expr_stmt|;
name|real_from_target
argument_list|(
operator|&
name|d
argument_list|,
name|tmp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|<=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
comment|/* Although the overflow semantics of RTL's FIX and UNSIGNED_FIX 	 operators are intentionally left unspecified (to ease implementation 	 by target backends), for consistency, this routine implements the 	 same semantics for constant folding as used by the middle-end.  */
comment|/* This was formerly used only for non-IEEE float. 	 eggert@twinsun.com says it is safe for IEEE also.  */
name|HOST_WIDE_INT
name|xh
decl_stmt|,
name|xl
decl_stmt|,
name|th
decl_stmt|,
name|tl
decl_stmt|;
name|REAL_VALUE_TYPE
name|x
decl_stmt|,
name|t
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|x
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIX
case|:
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Test against the signed upper bound.  */
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|th
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|real_from_integer
argument_list|(
operator|&
name|t
argument_list|,
name|VOIDmode
argument_list|,
name|tl
argument_list|,
name|th
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|t
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|xh
operator|=
name|th
expr_stmt|;
name|xl
operator|=
name|tl
expr_stmt|;
break|break;
block|}
comment|/* Test against the signed lower bound.  */
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
name|tl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|th
operator|=
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|real_from_integer
argument_list|(
operator|&
name|t
argument_list|,
name|VOIDmode
argument_list|,
name|tl
argument_list|,
name|th
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|xh
operator|=
name|th
expr_stmt|;
name|xl
operator|=
name|tl
expr_stmt|;
break|break;
block|}
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|xh
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|||
name|REAL_VALUE_NEGATIVE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Test against the unsigned upper bound.  */
if|if
condition|(
name|width
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|th
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|th
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|real_from_integer
argument_list|(
operator|&
name|t
argument_list|,
name|VOIDmode
argument_list|,
name|tl
argument_list|,
name|th
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|t
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|xh
operator|=
name|th
expr_stmt|;
name|xl
operator|=
name|tl
expr_stmt|;
break|break;
block|}
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|xh
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|xl
argument_list|,
name|xh
argument_list|,
name|mode
argument_list|)
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of simplify_binary_operation to simplify a commutative,    associative binary operation CODE with result mode MODE, operating    on OP0 and OP1.  CODE is currently one of PLUS, MULT, AND, IOR, XOR,    SMIN, SMAX, UMIN or UMAX.  Return zero if no simplification or    canonicalization is possible.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_associative_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Linearize the operator to the left.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|code
condition|)
block|{
comment|/* "(a op b) op (c op d)" becomes "((a op b) op c) op d)".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|code
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* "a op (b op c)" becomes "(b op c) op a".  */
if|if
condition|(
operator|!
name|swap_commutative_operands_p
argument_list|(
name|op1
argument_list|,
name|op0
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|code
condition|)
block|{
comment|/* Canonicalize "(x op c) op y" as "(x op y) op c".  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Attempt to simplify "(a op b) op c" as "a op (b op c)".  */
name|tem
operator|=
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
condition|?
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
comment|/* Attempt to simplify "(a op b) op c" as "(a op c) op b".  */
name|tem
operator|=
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
condition|?
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simplify a binary operation CODE with result mode MODE, operating on OP0    and OP1.  Return 0 if no simplification is possible.     Don't use this for relational operations such as EQ or LT.    Use simplify_relational_operation instead.  */
end_comment

begin_function
name|rtx
name|simplify_binary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|trueop0
decl_stmt|,
name|trueop1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Relational operations don't work here.  We must know the mode      of the operands in order to do the comparison correctly.      Assuming a full word can give incorrect results.      Consider comparing 128 with -128 in QImode.  */
name|gcc_assert
argument_list|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMPARE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMM_COMPARE
argument_list|)
expr_stmt|;
comment|/* Make sure the constant is second.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_ARITH
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
name|trueop0
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|trueop1
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|simplify_const_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|trueop0
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
return|return
name|simplify_binary_operation_1
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|trueop0
argument_list|,
name|trueop1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of simplify_binary_operation.  Simplify a binary operation    CODE with result mode MODE, operating on OP0 and OP1.  If OP0 and/or    OP1 are constant pool references, TRUEOP0 and TRUEOP1 represent the    actual constants.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_binary_operation_1
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|trueop0
parameter_list|,
name|rtx
name|trueop1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|,
name|reversed
decl_stmt|,
name|opleft
decl_stmt|,
name|opright
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Even if we can't compute a constant result,      there are some cases worth simplifying.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* Maybe simplify x + 0 to x.  The two expressions are equivalent 	 when x is NaN, infinite, or finite and nonzero.  They aren't 	 when x is -0 and the rounding mode is not towards -infinity, 	 since (-0) + 0 is then 0.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* ((-a) + b) -> (b - a) and similarly for (a + (-b)).  These 	 transformations are safe even for IEEE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (~a) + 1 -> -a */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|trueop1
operator|==
name|const1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Handle both-operands-constant cases.  We can only add 	 CONST_INTs to constants since the sum of relocatable symbols 	 can't be handled by most assemblers.  Don't add CONST_INT 	 to CONST_INT since overflow won't be computed properly if wider 	 than HOST_BITS_PER_WIDE_INT.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|INTVAL
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
comment|/* See if this is something like X * C - X or vice versa or 	 if the multiplication is written as a shift.  If so, we can 	 distribute and make a new multiply, shift, or maybe just 	 have X (if C is 2 in the example above).  But don't make 	 something more expensive than we had before.  */
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0h
init|=
literal|0
decl_stmt|,
name|coeff1h
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|coeff0l
init|=
literal|1
decl_stmt|,
name|coeff1l
init|=
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|coeff0l
operator|=
operator|-
literal|1
expr_stmt|;
name|coeff0h
operator|=
operator|-
literal|1
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0l
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|coeff0h
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0l
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|coeff0h
operator|=
literal|0
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|coeff1l
operator|=
operator|-
literal|1
expr_stmt|;
name|coeff1h
operator|=
operator|-
literal|1
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff1l
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|coeff1h
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff1l
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|coeff1h
operator|=
literal|0
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|rtx
name|orig
init|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|rtx
name|coeff
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|add_double
argument_list|(
name|coeff0l
argument_list|,
name|coeff0h
argument_list|,
name|coeff1l
argument_list|,
name|coeff1h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|immed_double_const
argument_list|(
name|l
argument_list|,
name|h
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
return|return
name|rtx_cost
argument_list|(
name|tem
argument_list|,
name|SET
argument_list|)
operator|<=
name|rtx_cost
argument_list|(
name|orig
argument_list|,
name|SET
argument_list|)
condition|?
name|tem
else|:
literal|0
return|;
block|}
block|}
comment|/* (plus (xor X C1) C2) is (xor X (C1^C2)) if C2 is signbit.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|XOR
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|mode_signbit_p
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Canonicalize (plus (mult (neg B) C) A) to (minus A (mult B C)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|rtx
name|in1
decl_stmt|,
name|in2
decl_stmt|;
name|in1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in2
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
argument_list|)
return|;
block|}
comment|/* (plus (comparison A B) C) can become (neg (rev-comp A B)) if 	 C is 1 and STORE_FLAG_VALUE is -1 or if C is -1 and STORE_FLAG_VALUE 	 is 1.  */
if|if
condition|(
name|COMPARISON_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|trueop1
operator|==
name|const1_rtx
operator|)
operator|||
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|trueop1
operator|==
name|constm1_rtx
operator|)
operator|)
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|reversed
argument_list|,
name|mode
argument_list|)
return|;
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	 simplify this by the associative law. 	 Don't use the associative law for floating point. 	 The inaccuracy makes it nonassociative, 	 and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|plus_minus_operand_p
argument_list|(
name|op0
argument_list|)
operator|||
name|plus_minus_operand_p
argument_list|(
name|op1
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* Reassociate floating point addition only when the user 	 specifies unsafe math optimizations.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
break|break;
case|case
name|COMPARE
case|:
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Convert (compare FOO (const_int 0)) to FOO unless we aren't 	 using cc0, in which case we want to leave it as a COMPARE 	 so we can distinguish it from a register-register-copy.  	 In IEEE floating point, x-0 is not the same as x.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
endif|#
directive|endif
comment|/* Convert (compare (gt (flags) 0) (lt (flags) 0)) to (flags).  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GTU
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LTU
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|rtx
name|xop00
init|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop10
init|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|xop10
argument_list|)
operator|==
name|CC0
condition|)
else|#
directive|else
if|if
condition|(
name|REG_P
argument_list|(
name|xop00
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|xop10
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|xop00
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|xop10
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|xop00
argument_list|)
operator|==
name|REGNO
argument_list|(
name|xop10
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|xop00
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|xop10
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
endif|#
directive|endif
return|return
name|xop00
return|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* We can't assume x-x is 0 even with non-IEEE floating point, 	 but since it is zero except in very strange circumstances, we 	 will treat it as zero with -funsafe-math-optimizations.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Change subtraction from zero into negation.  (0 - x) is the 	 same as -x when x is NaN, infinite, or finite and nonzero. 	 But if the mode has signed zeros, and does not round towards 	 -infinity, then 0 - 0 is 0, not -0.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
return|;
comment|/* (-1 - a) is ~a.  */
if|if
condition|(
name|trueop0
operator|==
name|constm1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Subtracting 0 has no effect unless the mode has signed zeros 	 and supports rounding towards -infinity.  In such a case, 	 0 - 0 is -0.  */
if|if
condition|(
operator|!
operator|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* See if this is something like X * C - X or vice versa or 	 if the multiplication is written as a shift.  If so, we can 	 distribute and make a new multiply, shift, or maybe just 	 have X (if C is 2 in the example above).  But don't make 	 something more expensive than we had before.  */
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0h
init|=
literal|0
decl_stmt|,
name|negcoeff1h
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|coeff0l
init|=
literal|1
decl_stmt|,
name|negcoeff1l
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|coeff0l
operator|=
operator|-
literal|1
expr_stmt|;
name|coeff0h
operator|=
operator|-
literal|1
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0l
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|coeff0h
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0l
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|coeff0h
operator|=
literal|0
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|negcoeff1l
operator|=
literal|1
expr_stmt|;
name|negcoeff1h
operator|=
literal|0
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|negcoeff1l
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|negcoeff1h
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|negcoeff1l
operator|=
operator|-
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|negcoeff1h
operator|=
operator|-
literal|1
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|rtx
name|orig
init|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|rtx
name|coeff
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|add_double
argument_list|(
name|coeff0l
argument_list|,
name|coeff0h
argument_list|,
name|negcoeff1l
argument_list|,
name|negcoeff1h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|immed_double_const
argument_list|(
name|l
argument_list|,
name|h
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
return|return
name|rtx_cost
argument_list|(
name|tem
argument_list|,
name|SET
argument_list|)
operator|<=
name|rtx_cost
argument_list|(
name|orig
argument_list|,
name|SET
argument_list|)
condition|?
name|tem
else|:
literal|0
return|;
block|}
block|}
comment|/* (a - (-b)) -> (a + b).  True even for IEEE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (-x - c) may be simplified as (-c - x).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Don't let a relocatable value get a negative coeff.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
comment|/* (x - (x& y)) -> (x& ~y) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|AND
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
comment|/* If STORE_FLAG_VALUE is 1, (minus 1 (comparison foo bar)) can be done 	 by reversing the comparison code if valid.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|trueop0
operator|==
name|const1_rtx
operator|&&
name|COMPARISON_P
argument_list|(
name|op1
argument_list|)
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
comment|/* Canonicalize (minus A (mult (neg B) C)) to (plus (mult B C) A).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|rtx
name|in1
decl_stmt|,
name|in2
decl_stmt|;
name|in1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in2
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
argument_list|,
name|op0
argument_list|)
return|;
block|}
comment|/* Canonicalize (minus (neg A) (mult B C)) to 	 (minus (mult (neg B) C) A).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|rtx
name|in1
decl_stmt|,
name|in2
decl_stmt|;
name|in1
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|in2
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	 simplify this by the associative law.  This will, for example,          canonicalize (minus A (plus B C)) to (minus (minus A B) C). 	 Don't use the associative law for floating point. 	 The inaccuracy makes it nonassociative, 	 and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|plus_minus_operand_p
argument_list|(
name|op0
argument_list|)
operator|||
name|plus_minus_operand_p
argument_list|(
name|op1
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|trueop1
operator|==
name|constm1_rtx
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Maybe simplify x * 0 to 0.  The reduction is not valid if 	 x is NaN, since x * 0 is then also NaN.  Nor is it valid 	 when the mode has signed zeros, since multiplying a negative 	 number by 0 will give -0, not 0.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for 	 signalling NaNs.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Convert multiply by constant power of two into shift unless 	 we are still generating RTL.  This test is a kludge.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|val
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
comment|/* If the mode is larger than the host word size, and the 	     uppermost bit is set, then this isn't a power of two due 	     to implicit sign extension.  */
operator|&&
operator|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|val
operator|!=
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
comment|/* Likewise for multipliers wider than a word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop1
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|val
operator|=
name|exact_log2
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val
operator|+
name|HOST_BITS_PER_WIDE_INT
argument_list|)
argument_list|)
return|;
comment|/* x*2 is x+x and x*(-1) is -x */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst2
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconstm1
argument_list|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Optimize -x * -x as x * x.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Likewise, optimize abs(x) * abs(x) as x * x.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ABS
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ABS
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Reassociate multiplication, but for floating point MULTs 	 only when the user specifies unsafe math optimizations.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* A | (~A) -> -1 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|constm1_rtx
return|;
comment|/* (ior A C) is C if all bits of A that might be nonzero are on in C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|op1
return|;
comment|/* Convert (A& B) | A to A.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* Convert (ior (ashift A CX) (lshiftrt A CY)) where CX+CY equals the          mode size to (rotate A CX).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|opleft
operator|=
name|op1
expr_stmt|;
name|opright
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|opright
operator|=
name|op1
expr_stmt|;
name|opleft
operator|=
name|op0
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|opleft
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|opright
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|opleft
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|opleft
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|opleft
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_ROTATE
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|opleft
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Same, but for ashift that has been "simplified" to a wider mode         by simplify_shift_const.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|opleft
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|opleft
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|opright
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|opleft
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|SUBREG_BYTE
argument_list|(
name|opleft
argument_list|)
operator|==
name|SUBREG_BYTE
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|opleft
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|opleft
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|opleft
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|opleft
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|opleft
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_ROTATE
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|opright
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|opleft
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* If we have (ior (and (X C1) C2)), simplify this by making 	 C1 as small as possible if C1 actually changes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
comment|/* If OP0 is (ashiftrt (plus ...) C), it might actually be          a (sign_extend (plus ...)).  Then check if OP1 is a CONST_INT and 	 the PLUS does not affect any of the bits in OP1: then we can do 	 the IOR as a PLUS and we can associate.  This is valid if OP1          can be safely shifted left C bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|mask
init|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|<<
name|count
decl_stmt|;
if|if
condition|(
name|mask
operator|>>
name|count
operator|==
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&&
operator|(
name|mask
operator|&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Canonicalize XOR of the most significant bit to PLUS.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|mode_signbit_p
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* (xor (plus X C1) C2) is (xor X (C1^C2)) if C1 is signbit.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|mode_signbit_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If we are XORing two things that have no bits in common, 	 convert them into an IOR.  This helps to detect rotation encoded 	 using those methods and possibly other simplifications.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&
name|nonzero_bits
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|simplify_gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
return|;
comment|/* Convert (XOR (NOT x) (NOT y)) to (XOR x y). 	 Also convert (XOR (NOT x) y) to (NOT (XOR x y)), similarly for 	 (NOT y).  */
block|{
name|int
name|num_negated
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
condition|)
name|num_negated
operator|++
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
condition|)
name|num_negated
operator|++
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_negated
operator|==
literal|2
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|num_negated
operator|==
literal|1
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Convert (xor (and A B) B) to (and (not A) B).  The latter may 	 correspond to a machine insn or result in further simplifications 	 if B is a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
comment|/* (xor (comparison foo bar) (const_int 1)) can become the reversed 	 comparison if STORE_FLAG_VALUE is 1.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|trueop1
operator|==
name|const1_rtx
operator|&&
name|COMPARISON_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
comment|/* (lshiftrt foo C) where C is the number of bits in FOO minus 1 	 is (lt foo (const_int 0)), so we can perform the above 	 simplification if STORE_FLAG_VALUE is 1.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|trueop1
operator|==
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|gen_rtx_GE
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* (xor (comparison foo bar) (const_int sign-bit)) 	 when STORE_FLAG_VALUE is the sign bit.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|&&
name|trueop1
operator|==
name|const_true_rtx
operator|&&
name|COMPARISON_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
break|break;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|trueop1
return|;
comment|/* If we are turning off bits already known off in OP0, we need 	 not do an AND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|trueop0
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|op0
return|;
comment|/* A& (~A) -> 0 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Transform (and (extend X) C) into (zero_extend (and X C)) if 	 there are no nonzero bits of C outside of X's mode.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|enum
name|machine_mode
name|imode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|imode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|,
name|imode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|imode
argument_list|)
return|;
block|}
comment|/* Convert (A ^ B)& A to A& (~B) since the latter is often a single 	 insn (and may simplify more).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Similarly for (~(A ^ B))& A.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Convert (A | B)& A to A.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|IOR
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* For constants M and N, if M == (1LL<< cst) - 1&& (N& M) == M, 	 ((A& N) + B)& M -> (A + B)& M 	 Similarly if (N& M) == 0, 	 ((A | N) + B)& M -> (A + B)& M 	 and for - instead of + and/or ^ instead of |.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|~
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|&
operator|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|)
condition|)
block|{
name|rtx
name|pmop
index|[
literal|2
index|]
decl_stmt|;
name|int
name|which
decl_stmt|;
name|pmop
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pmop
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|which
operator|=
literal|0
init|;
name|which
operator|<
literal|2
condition|;
name|which
operator|++
control|)
block|{
name|tem
operator|=
name|pmop
index|[
name|which
index|]
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|)
operator|==
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
condition|)
name|pmop
index|[
name|which
index|]
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
case|case
name|XOR
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pmop
index|[
name|which
index|]
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|pmop
index|[
literal|0
index|]
operator|!=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|||
name|pmop
index|[
literal|1
index|]
operator|!=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|simplify_gen_binary
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|pmop
index|[
literal|0
index|]
argument_list|,
name|pmop
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|op1
argument_list|)
return|;
block|}
block|}
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|UDIV
case|:
comment|/* 0/x is 0 (or x&0 if x has side-effects).  */
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|trueop0
argument_list|)
return|;
return|return
name|trueop0
return|;
block|}
comment|/* x/1 is x.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|rtl_hooks
operator|.
name|gen_lowpart_no_emit
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
comment|/* Convert divide by power of two into shift.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|val
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|DIV
case|:
comment|/* Handle floating point and integers separately.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* Maybe change 0.0 / x to 0.0.  This transformation isn't 	     safe for modes with NaNs, since 0.0 / 0.0 will then be 	     NaN rather than 0.0.  Nor is it safe for modes with signed 	     zeros, since dividing 0 by a negative number gives -0.0  */
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* x/1.0 is x.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|trueop1
operator|!=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
comment|/* x/-1.0 is -x.  */
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconstm1
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Change FP division by a constant into multiplication. 		 Only do this with -funsafe-math-optimizations.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|!
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst0
argument_list|)
condition|)
block|{
name|REAL_ARITHMETIC
argument_list|(
name|d
argument_list|,
name|RDIV_EXPR
argument_list|,
name|dconst1
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|tem
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* 0/x is 0 (or x&0 if x has side-effects).  */
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|trueop0
argument_list|)
return|;
return|return
name|trueop0
return|;
block|}
comment|/* x/1 is x.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|rtl_hooks
operator|.
name|gen_lowpart_no_emit
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
comment|/* x/-1 is -x.  */
if|if
condition|(
name|trueop1
operator|==
name|constm1_rtx
condition|)
block|{
name|rtx
name|x
init|=
name|rtl_hooks
operator|.
name|gen_lowpart_no_emit
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
decl_stmt|;
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|UMOD
case|:
comment|/* 0%x is 0 (or x&0 if x has side-effects).  */
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|trueop0
argument_list|)
return|;
return|return
name|trueop0
return|;
block|}
comment|/* x%1 is 0 (of x&0 if x has side-effects).  */
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
comment|/* Implement modulus by power of two as AND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MOD
case|:
comment|/* 0%x is 0 (or x&0 if x has side-effects).  */
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|trueop0
argument_list|)
return|;
return|return
name|trueop0
return|;
block|}
comment|/* x%1 and x%-1 is 0 (or x&0 if x has side-effects).  */
if|if
condition|(
name|trueop1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
operator|||
name|trueop1
operator|==
name|constm1_rtx
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
break|break;
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Rotating ~0 always results in ~0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|ASHIFT
case|:
case|case
name|SS_ASHIFT
case|:
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|LSHIFTRT
case|:
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|trueop0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Optimize (lshiftrt (clz X) C) as (eq X 0).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CLZ
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|width
condition|)
block|{
name|enum
name|machine_mode
name|imode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|zero_val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|imode
argument_list|,
name|zero_val
argument_list|)
operator|&&
name|zero_val
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|imode
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
name|exact_log2
argument_list|(
name|zero_val
argument_list|)
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|EQ
argument_list|,
name|mode
argument_list|,
name|imode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
name|trueop1
operator|==
name|constm1_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
name|tem
operator|=
name|simplify_associative_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|SS_PLUS
case|:
case|case
name|US_PLUS
case|:
case|case
name|SS_MINUS
case|:
case|case
name|US_MINUS
case|:
comment|/* ??? There are simplifications that can be done.  */
return|return
literal|0
return|;
case|case
name|VEC_SELECT
case|:
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|==
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|XVECLEN
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
return|return
name|CONST_VECTOR_ELT
argument_list|(
name|trueop0
argument_list|,
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|XVECLEN
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|int
operator|)
name|n_elts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|trueop0
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|XVECLEN
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|VEC_CONCAT
condition|)
block|{
name|rtx
name|vec
init|=
name|trueop0
decl_stmt|;
name|int
name|offset
init|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|trueop1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Try to find the element in the VEC_CONCAT.  */
while|while
condition|(
name|GET_MODE
argument_list|(
name|vec
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|vec
argument_list|)
operator|==
name|VEC_CONCAT
condition|)
block|{
name|HOST_WIDE_INT
name|vec_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|vec_size
condition|)
name|vec
operator|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|offset
operator|-=
name|vec_size
expr_stmt|;
name|vec
operator|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vec
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|vec
argument_list|)
operator|==
name|mode
condition|)
return|return
name|vec
return|;
block|}
return|return
literal|0
return|;
case|case
name|VEC_CONCAT
case|:
block|{
name|enum
name|machine_mode
name|op0_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
else|:
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|op1_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|trueop1
argument_list|)
else|:
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|op0_mode
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|op1_mode
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|op0_mode
argument_list|)
condition|)
name|gcc_assert
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_INNER
argument_list|(
name|op0_mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|op0_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|op1_mode
argument_list|)
condition|)
name|gcc_assert
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_INNER
argument_list|(
name|op1_mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|op1_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_VECTOR
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_VECTOR
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|in_n_elts
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|op0_mode
argument_list|)
condition|)
name|in_n_elts
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|op0_mode
argument_list|)
operator|/
name|elt_size
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|in_n_elts
condition|)
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|op0_mode
argument_list|)
condition|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|trueop0
expr_stmt|;
else|else
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|trueop0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|op1_mode
argument_list|)
condition|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|trueop1
expr_stmt|;
else|else
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|trueop1
argument_list|,
name|i
operator|-
name|in_n_elts
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|rtx
name|simplify_const_binary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|HOST_WIDE_INT
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg0s
decl_stmt|,
name|arg1s
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|code
operator|!=
name|VEC_CONCAT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|unsigned
name|n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|op0mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|unsigned
name|op0_n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|op0mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|op1mode
init|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|op1_n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|op1mode
argument_list|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|op0_n_elts
operator|==
name|n_elts
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|op1_n_elts
operator|==
name|n_elts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|CONST_VECTOR_ELT
argument_list|(
name|op0
argument_list|,
name|i
argument_list|)
argument_list|,
name|CONST_VECTOR_ELT
argument_list|(
name|op1
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|code
operator|==
name|VEC_CONCAT
operator|&&
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|unsigned
name|n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|n_elts
operator|>=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_elts
operator|==
literal|2
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|CONST_VECTOR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_VECTOR
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
operator|=
name|op0
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|op0_n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|op1_n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_VECTOR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_VECTOR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|op0_n_elts
operator|+
name|op1_n_elts
operator|==
name|n_elts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op0_n_elts
condition|;
operator|++
name|i
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op1_n_elts
condition|;
operator|++
name|i
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|op0_n_elts
operator|+
name|i
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
condition|)
block|{
name|long
name|tmp0
index|[
literal|4
index|]
decl_stmt|;
name|long
name|tmp1
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|real_to_target
argument_list|(
name|tmp0
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|tmp1
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AND
case|:
name|tmp0
index|[
name|i
index|]
operator|&=
name|tmp1
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|tmp0
index|[
name|i
index|]
operator||=
name|tmp1
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|tmp0
index|[
name|i
index|]
operator|^=
name|tmp1
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|real_from_target
argument_list|(
operator|&
name|r
argument_list|,
name|tmp0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
else|else
block|{
name|REAL_VALUE_TYPE
name|f0
decl_stmt|,
name|f1
decl_stmt|,
name|value
decl_stmt|,
name|result
decl_stmt|;
name|bool
name|inexact
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|f0
argument_list|,
name|mode
argument_list|,
operator|&
name|f0
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|f1
argument_list|,
name|mode
argument_list|,
operator|&
name|f1
argument_list|)
expr_stmt|;
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|REAL_VALUE_ISNAN
argument_list|(
name|f0
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|f1
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|DIV
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f1
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|(
name|flag_trapping_math
operator|||
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|&&
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_trapping_math
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|f0
argument_list|)
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|f1
argument_list|)
condition|)
block|{
name|int
name|s0
init|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|f0
argument_list|)
decl_stmt|;
name|int
name|s1
init|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|f1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* Inf + -Inf = NaN plus exception.  */
if|if
condition|(
name|s0
operator|!=
name|s1
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|MINUS
case|:
comment|/* Inf - Inf = NaN plus exception.  */
if|if
condition|(
name|s0
operator|==
name|s1
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|DIV
case|:
comment|/* Inf / Inf = NaN plus exception.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|MULT
operator|&&
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|&&
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_trapping_math
operator|&&
operator|(
operator|(
name|REAL_VALUE_ISINF
argument_list|(
name|f0
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f1
argument_list|,
name|dconst0
argument_list|)
operator|)
operator|||
operator|(
name|REAL_VALUE_ISINF
argument_list|(
name|f1
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f0
argument_list|,
name|dconst0
argument_list|)
operator|)
operator|)
condition|)
comment|/* Inf * 0 = NaN plus exception.  */
return|return
literal|0
return|;
name|inexact
operator|=
name|real_arithmetic
argument_list|(
operator|&
name|value
argument_list|,
name|rtx_to_tree_code
argument_list|(
name|code
argument_list|)
argument_list|,
operator|&
name|f0
argument_list|,
operator|&
name|f1
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|result
argument_list|,
name|mode
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Don't constant fold this floating point operation if 	     the result has overflowed and flag_trapping_math.  */
if|if
condition|(
name|flag_trapping_math
operator|&&
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_ISINF
argument_list|(
name|f0
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_ISINF
argument_list|(
name|f1
argument_list|)
condition|)
comment|/* Overflow plus exception.  */
return|return
literal|0
return|;
comment|/* Don't constant fold this floating point operation if the 	     result may dependent upon the run-time rounding mode and 	     flag_rounding_math is set, or if GCC's software emulation 	     is unable to accurately represent the result.  */
if|if
condition|(
operator|(
name|flag_rounding_math
operator|||
operator|(
name|REAL_MODE_FORMAT_COMPOSITE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
operator|)
operator|)
operator|&&
operator|(
name|inexact
operator|||
operator|!
name|real_identical
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|value
argument_list|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|result
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
comment|/* We can fold some multi-word operations.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|lv
decl_stmt|,
name|lt
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|hv
decl_stmt|,
name|ht
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op0
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|,
name|h1
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l2
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|,
name|h2
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
expr_stmt|;
else|else
name|l2
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|,
name|h2
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MINUS
case|:
comment|/* A - B == A + (-B).  */
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
name|l2
operator|=
name|lv
operator|,
name|h2
operator|=
name|hv
expr_stmt|;
comment|/* Fall through....  */
case|case
name|PLUS
case|:
name|add_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|mul_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|div_and_round_double
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
literal|0
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
operator|&
name|lt
argument_list|,
operator|&
name|ht
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|div_and_round_double
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
literal|0
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lt
argument_list|,
operator|&
name|ht
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|div_and_round_double
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
literal|1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
operator|&
name|lt
argument_list|,
operator|&
name|ht
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|div_and_round_double
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
literal|1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lt
argument_list|,
operator|&
name|ht
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|AND
case|:
name|lv
operator|=
name|l1
operator|&
name|l2
operator|,
name|hv
operator|=
name|h1
operator|&
name|h2
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|lv
operator|=
name|l1
operator||
name|l2
operator|,
name|hv
operator|=
name|h1
operator||
name|h2
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|lv
operator|=
name|l1
operator|^
name|l2
operator|,
name|hv
operator|=
name|h1
operator|^
name|h2
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|h1
operator|<
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|h1
operator|>
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|l2
operator|&=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|,
name|h2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h2
operator|!=
literal|0
operator|||
name|l2
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
condition|)
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
name|code
operator|==
name|ASHIFTRT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ROTATE
condition|)
name|lrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
comment|/* code == ROTATERT */
name|rrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|!=
literal|0
condition|)
block|{
comment|/* Get the integer argument values in two forms:          zero-extended in ARG0, ARG1 and sign-extended in ARG0S, ARG1S.  */
name|arg0
operator|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|arg0
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg1
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg0s
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|arg0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|arg1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
else|else
block|{
name|arg0s
operator|=
name|arg0
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
block|}
comment|/* Compute the value of the arithmetic.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|val
operator|=
name|arg0s
operator|+
name|arg1s
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|val
operator|=
name|arg0s
operator|-
name|arg1s
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|val
operator|=
name|arg0s
operator|*
name|arg1s
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|/
name|arg1s
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|%
name|arg1s
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|/
name|arg1
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
operator|||
operator|(
name|arg0s
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
name|arg1s
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|%
name|arg1
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|val
operator|=
name|arg0
operator|&
name|arg1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|val
operator|=
name|arg0
operator||
name|arg1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|val
operator|=
name|arg0
operator|^
name|arg1
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
comment|/* Truncate the shift if SHIFT_COUNT_TRUNCATED, otherwise make sure 	     the value is in range.  We can't return any old value for 	     out-of-range arguments because either the middle-end (via 	     shift_truncation_mask) or the back-end might be relying on 	     target-specific knowledge.  Nor can we rely on 	     shift_truncation_mask, since the shift might not be part of an 	     ashlM3, lshrM3 or ashrM3 instruction.  */
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
operator|%
name|width
expr_stmt|;
elseif|else
if|if
condition|(
name|arg1
operator|<
literal|0
operator|||
name|arg1
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|code
operator|==
name|ASHIFT
condition|?
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
else|:
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
operator|)
expr_stmt|;
comment|/* Sign-extend the result for arithmetic right shifts.  */
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
operator|&&
name|arg0s
operator|<
literal|0
operator|&&
name|arg1
operator|>
literal|0
condition|)
name|val
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|width
operator|-
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
comment|/* Do nothing here.  */
return|return
literal|0
return|;
case|case
name|SMIN
case|:
name|val
operator|=
name|arg0s
operator|<=
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|<=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|val
operator|=
name|arg0s
operator|>
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|SS_PLUS
case|:
case|case
name|US_PLUS
case|:
case|case
name|SS_MINUS
case|:
case|case
name|US_MINUS
case|:
case|case
name|SS_ASHIFT
case|:
comment|/* ??? There are simplifications that can be done.  */
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|gen_int_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a PLUS or MINUS, at least one of whose operands may be another    PLUS or MINUS.     Rather than test for specific case, we do this by a brute-force method    and do all possible simplifications until no more changes occur.  Then    we rebuild the operation.  */
end_comment

begin_struct
struct|struct
name|simplify_plus_minus_op_data
block|{
name|rtx
name|op
decl_stmt|;
name|short
name|neg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|simplify_plus_minus_op_data_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|simplify_plus_minus_op_data
modifier|*
name|d1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|simplify_plus_minus_op_data
modifier|*
name|d2
init|=
name|p2
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|commutative_operand_precedence
argument_list|(
name|d2
operator|->
name|op
argument_list|)
operator|-
name|commutative_operand_precedence
argument_list|(
name|d1
operator|->
name|op
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* Group together equal REGs to do more simplification.  */
if|if
condition|(
name|REG_P
argument_list|(
name|d1
operator|->
name|op
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|d2
operator|->
name|op
argument_list|)
condition|)
return|return
name|REGNO
argument_list|(
name|d1
operator|->
name|op
argument_list|)
operator|-
name|REGNO
argument_list|(
name|d2
operator|->
name|op
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|simplify_plus_minus
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|struct
name|simplify_plus_minus_op_data
name|ops
index|[
literal|8
index|]
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|n_ops
init|=
literal|2
decl_stmt|,
name|input_ops
init|=
literal|2
decl_stmt|;
name|int
name|changed
decl_stmt|,
name|n_constants
init|=
literal|0
decl_stmt|,
name|canonicalized
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
name|ops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ops
argument_list|)
expr_stmt|;
comment|/* Set up the two operands and then expand them until nothing has been      changed.  If we run out of room in our array, give up; this should      almost never happen.  */
name|ops
index|[
literal|0
index|]
operator|.
name|op
operator|=
name|op0
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|.
name|op
operator|=
name|op1
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|.
name|neg
operator|=
operator|(
name|code
operator|==
name|MINUS
operator|)
expr_stmt|;
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|this_op
init|=
name|ops
index|[
name|i
index|]
operator|.
name|op
decl_stmt|;
name|int
name|this_neg
init|=
name|ops
index|[
name|i
index|]
operator|.
name|neg
decl_stmt|;
name|enum
name|rtx_code
name|this_code
init|=
name|GET_CODE
argument_list|(
name|this_op
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|this_code
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|n_ops
operator|==
literal|7
condition|)
return|return
name|NULL_RTX
return|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|neg
operator|=
operator|(
name|this_code
operator|==
name|MINUS
operator|)
operator|^
name|this_neg
expr_stmt|;
name|n_ops
operator|++
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input_ops
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|canonicalized
operator||=
name|this_neg
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
operator|!
name|this_neg
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|canonicalized
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CONST
case|:
if|if
condition|(
name|n_ops
operator|<
literal|7
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
index|]
operator|.
name|neg
operator|=
name|this_neg
expr_stmt|;
name|n_ops
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|canonicalized
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NOT
case|:
comment|/* ~a -> (-a - 1) */
if|if
condition|(
name|n_ops
operator|!=
literal|7
condition|)
block|{
name|ops
index|[
name|n_ops
index|]
operator|.
name|op
operator|=
name|constm1_rtx
expr_stmt|;
name|ops
index|[
name|n_ops
operator|++
index|]
operator|.
name|neg
operator|=
name|this_neg
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|XEXP
argument_list|(
name|this_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
operator|!
name|this_neg
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|canonicalized
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
name|n_constants
operator|++
expr_stmt|;
if|if
condition|(
name|this_neg
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|this_op
argument_list|)
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|canonicalized
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
if|if
condition|(
name|n_constants
operator|>
literal|1
condition|)
name|canonicalized
operator|=
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|n_ops
operator|>=
literal|2
argument_list|)
expr_stmt|;
comment|/* If we only have two operands, we can avoid the loops.  */
if|if
condition|(
name|n_ops
operator|==
literal|2
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|ops
index|[
literal|0
index|]
operator|.
name|neg
operator|||
name|ops
index|[
literal|1
index|]
operator|.
name|neg
condition|?
name|MINUS
else|:
name|PLUS
decl_stmt|;
name|rtx
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
comment|/* Get the two operands.  Be careful with the order, especially for 	 the cases where code == MINUS.  */
if|if
condition|(
name|ops
index|[
literal|0
index|]
operator|.
name|neg
operator|&&
name|ops
index|[
literal|1
index|]
operator|.
name|neg
condition|)
block|{
name|lhs
operator|=
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|ops
index|[
literal|0
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|ops
index|[
literal|1
index|]
operator|.
name|op
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ops
index|[
literal|0
index|]
operator|.
name|neg
condition|)
block|{
name|lhs
operator|=
name|ops
index|[
literal|1
index|]
operator|.
name|op
expr_stmt|;
name|rhs
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
block|}
else|else
block|{
name|lhs
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
name|rhs
operator|=
name|ops
index|[
literal|1
index|]
operator|.
name|op
expr_stmt|;
block|}
return|return
name|simplify_const_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Now simplify each pair of operands until nothing changes.  */
do|do
block|{
comment|/* Insertion sort is good enough for an eight-element array.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|simplify_plus_minus_op_data
name|save
decl_stmt|;
name|j
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|simplify_plus_minus_op_data_cmp
argument_list|(
operator|&
name|ops
index|[
name|j
index|]
argument_list|,
operator|&
name|ops
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|canonicalized
operator|=
literal|1
expr_stmt|;
name|save
operator|=
name|ops
index|[
name|i
index|]
expr_stmt|;
do|do
name|ops
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|ops
index|[
name|j
index|]
expr_stmt|;
do|while
condition|(
name|j
operator|--
operator|&&
name|simplify_plus_minus_op_data_cmp
argument_list|(
operator|&
name|ops
index|[
name|j
index|]
argument_list|,
operator|&
name|save
argument_list|)
operator|>
literal|0
condition|)
do|;
name|ops
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|save
expr_stmt|;
block|}
comment|/* This is only useful the first time through.  */
if|if
condition|(
operator|!
name|canonicalized
condition|)
return|return
name|NULL_RTX
return|;
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_ops
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|rtx
name|lhs
init|=
name|ops
index|[
name|j
index|]
operator|.
name|op
decl_stmt|,
name|rhs
init|=
name|ops
index|[
name|i
index|]
operator|.
name|op
decl_stmt|;
name|int
name|lneg
init|=
name|ops
index|[
name|j
index|]
operator|.
name|neg
decl_stmt|,
name|rneg
init|=
name|ops
index|[
name|i
index|]
operator|.
name|neg
decl_stmt|;
if|if
condition|(
name|lhs
operator|!=
literal|0
operator|&&
name|rhs
operator|!=
literal|0
condition|)
block|{
name|enum
name|rtx_code
name|ncode
init|=
name|PLUS
decl_stmt|;
if|if
condition|(
name|lneg
operator|!=
name|rneg
condition|)
block|{
name|ncode
operator|=
name|MINUS
expr_stmt|;
if|if
condition|(
name|lneg
condition|)
name|tem
operator|=
name|lhs
operator|,
name|lhs
operator|=
name|rhs
operator|,
name|rhs
operator|=
name|tem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
name|tem
operator|=
name|lhs
operator|,
name|lhs
operator|=
name|rhs
operator|,
name|rhs
operator|=
name|tem
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|tem_lhs
decl_stmt|,
name|tem_rhs
decl_stmt|;
name|tem_lhs
operator|=
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|CONST
condition|?
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
else|:
name|lhs
expr_stmt|;
name|tem_rhs
operator|=
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST
condition|?
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
else|:
name|rhs
expr_stmt|;
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|ncode
argument_list|,
name|mode
argument_list|,
name|tem_lhs
argument_list|,
name|tem_rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|gen_rtx_CONST
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|ncode
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* Reject "simplifications" that just wrap the two 		   arguments in a CONST.  Failure to do so can result 		   in infinite recursion with simplify_binary_operation 		   when it calls us to simplify CONST operations.  */
if|if
condition|(
name|tem
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ncode
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|lhs
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|rhs
operator|)
condition|)
block|{
name|lneg
operator|&=
name|rneg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NEG
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|,
name|lneg
operator|=
operator|!
name|lneg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|lneg
condition|)
name|tem
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
operator|,
name|lneg
operator|=
literal|0
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|tem
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
name|lneg
expr_stmt|;
name|ops
index|[
name|j
index|]
operator|.
name|op
operator|=
name|NULL_RTX
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Pack all the operands to the lower-numbered entries.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_ops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|j
index|]
operator|.
name|op
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|=
name|ops
index|[
name|j
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|n_ops
operator|=
name|i
expr_stmt|;
block|}
do|while
condition|(
name|changed
condition|)
do|;
comment|/* Create (minus -C X) instead of (neg (const (plus X C))).  */
if|if
condition|(
name|n_ops
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
literal|1
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONSTANT_P
argument_list|(
name|ops
index|[
literal|0
index|]
operator|.
name|op
argument_list|)
operator|&&
name|ops
index|[
literal|0
index|]
operator|.
name|neg
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|ops
index|[
literal|1
index|]
operator|.
name|op
argument_list|,
name|ops
index|[
literal|0
index|]
operator|.
name|op
argument_list|)
return|;
comment|/* We suppressed creation of trivial CONST expressions in the      combination loop to avoid recursion.  Create one manually now.      The combination loop should have ensured that there is exactly      one CONST_INT, and the sort will have ensured that it is last      in the array and that any other constant will be next-to-last.  */
if|if
condition|(
name|n_ops
operator|>
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONSTANT_P
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
argument_list|)
condition|)
block|{
name|rtx
name|value
init|=
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|.
name|neg
operator|^
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|neg
condition|)
name|value
operator|=
name|neg_const_int
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
operator|=
name|plus_constant
argument_list|(
name|ops
index|[
name|n_ops
operator|-
literal|2
index|]
operator|.
name|op
argument_list|,
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|n_ops
operator|--
expr_stmt|;
block|}
comment|/* Put a non-negated operand first, if possible.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|&&
name|ops
index|[
name|i
index|]
operator|.
name|neg
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|n_ops
condition|)
name|ops
index|[
literal|0
index|]
operator|.
name|op
operator|=
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|ops
index|[
literal|0
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|ops
index|[
name|i
index|]
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|op
operator|=
name|tem
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|.
name|neg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now make the result by performing the requested operations.  */
name|result
operator|=
name|ops
index|[
literal|0
index|]
operator|.
name|op
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|ops
index|[
name|i
index|]
operator|.
name|neg
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|mode
argument_list|,
name|result
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Check whether an operand is suitable for calling simplify_plus_minus.  */
end_comment

begin_function
specifier|static
name|bool
name|plus_minus_operand_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like simplify_binary_operation except used for relational operators.    MODE is the mode of the result. If MODE is VOIDmode, both operands must    not also be VOIDmode.     CMP_MODE specifies in which mode the comparison is done in, so it is    the mode of the operands.  If CMP_MODE is VOIDmode, it is taken from    the operands or, if both are VOIDmode, the operands are compared in    "infinite precision".  */
end_comment

begin_function
name|rtx
name|simplify_relational_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|cmp_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|,
name|trueop0
decl_stmt|,
name|trueop1
decl_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|simplify_const_relational_operation
argument_list|(
name|code
argument_list|,
name|cmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|tem
operator|==
name|const0_rtx
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
block|{
name|REAL_VALUE_TYPE
name|val
decl_stmt|;
name|val
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
return|;
block|}
else|#
directive|else
return|return
name|NULL_RTX
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|tem
operator|==
name|const0_rtx
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
ifdef|#
directive|ifdef
name|VECTOR_STORE_FLAG_VALUE
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
name|rtvec
name|v
decl_stmt|;
name|rtx
name|val
init|=
name|VECTOR_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|val
operator|==
name|const1_rtx
condition|)
return|return
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
return|;
name|units
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|v
operator|=
name|rtvec_alloc
argument_list|(
name|units
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|val
expr_stmt|;
return|return
name|gen_rtx_raw_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
else|#
directive|else
return|return
name|NULL_RTX
return|;
endif|#
directive|endif
block|}
return|return
name|tem
return|;
block|}
comment|/* For the following tests, ensure const0_rtx is op1.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|||
operator|(
name|op0
operator|==
name|const0_rtx
operator|&&
name|op1
operator|!=
name|const0_rtx
operator|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
operator|,
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* If op0 is a compare, extract the comparison arguments from it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|cmp_mode
argument_list|)
operator|==
name|MODE_CC
operator|||
name|CC0_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|trueop0
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|trueop1
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|simplify_relational_operation_1
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|trueop0
argument_list|,
name|trueop1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This part of simplify_relational_operation is only used when CMP_MODE    is not in class MODE_CC (i.e. it is a real comparison).     MODE is the mode of the result, while CMP_MODE specifies in which    mode the comparison is done in, so it is the mode of the operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_relational_operation_1
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|cmp_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|rtx_code
name|op0code
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|COMPARISON_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
comment|/* If op0 is a comparison, extract the comparison arguments 	     from it.  */
if|if
condition|(
name|code
operator|==
name|NE
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|simplify_rtx
argument_list|(
name|op0
argument_list|)
return|;
else|else
return|return
name|simplify_gen_relational
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
block|{
name|enum
name|rtx_code
name|new_code
init|=
name|reversed_comparison_code
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_code
operator|!=
name|UNKNOWN
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|new_code
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/* (eq/ne (plus x cst1) cst2) simplifies to (eq/ne x (cst2 - cst1))  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
operator|(
name|op0code
operator|==
name|PLUS
operator|||
name|op0code
operator|==
name|MINUS
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|INTEGRAL_MODE_P
argument_list|(
name|cmp_mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|c
init|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|c
operator|=
name|simplify_gen_binary
argument_list|(
name|op0code
operator|==
name|PLUS
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|cmp_mode
argument_list|,
name|op1
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|x
argument_list|,
name|c
argument_list|)
return|;
block|}
comment|/* (ne:SI (zero_extract:SI FOO (const_int 1) BAR) (const_int 0))) is      the same as (zero_extract:SI FOO (const_int 1) BAR).  */
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|cmp_mode
operator|!=
name|VOIDmode
comment|/* ??? Work-around BImode bugs in the ia64 backend.  */
operator|&&
name|mode
operator|!=
name|BImode
operator|&&
name|cmp_mode
operator|!=
name|BImode
operator|&&
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|cmp_mode
argument_list|)
operator|==
literal|1
operator|&&
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|cmp_mode
argument_list|)
condition|?
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|cmp_mode
argument_list|)
else|:
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|cmp_mode
argument_list|)
return|;
comment|/* (eq/ne (xor x y) 0) simplifies to (eq/ne x y).  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|op0code
operator|==
name|XOR
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (eq/ne (xor x y) x) simplifies to (eq/ne y 0).  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
name|op0code
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* Likewise (eq/ne (xor x y) y) simplifies to (eq/ne x 0).  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
name|op0code
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* (eq/ne (xor x C1) C2) simplifies to (eq/ne x (C1^C2)).  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
name|op0code
operator|==
name|XOR
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplify_gen_binary
argument_list|(
name|XOR
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Check if the given comparison (done in the given MODE) is actually a    tautology or a contradiction.    If no simplification is possible, this function returns zero.    Otherwise, it returns either const_true_rtx or const0_rtx.  */
end_comment

begin_function
name|rtx
name|simplify_const_relational_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|int
name|equal
decl_stmt|,
name|op0lt
decl_stmt|,
name|op0ltu
decl_stmt|,
name|op1lt
decl_stmt|,
name|op1ltu
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|trueop0
decl_stmt|;
name|rtx
name|trueop1
decl_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|VOIDmode
operator|||
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
comment|/* If op0 is a compare, extract the comparison arguments from it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
block|{
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* We can't simplify MODE_CC values since we don't know what the      actual comparison is.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|||
name|CC0_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Make sure the constant is second.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|trueop0
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|trueop1
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* For integer comparisons of A and B maybe we can simplify A - B and can      then simplify a comparison of that with zero.  If A and B are both either      a register or a CONST_INT, this can't help; testing for these cases will      prevent infinite recursion here and speed things up.       We can only do this for EQ and NE comparisons as otherwise we may      lose or introduce overflow which we cannot disregard as undefined as      we do not know the signedness of the operation on either the left or      the right hand side of the comparison.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|trueop1
operator|!=
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
operator|!
operator|(
operator|(
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|op1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
comment|/* We cannot do this if tem is a nonzero address.  */
operator|&&
operator|!
name|nonzero_address_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|simplify_const_relational_operation
argument_list|(
name|signed_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|const0_rtx
argument_list|)
return|;
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|code
operator|==
name|ORDERED
condition|)
return|return
name|const_true_rtx
return|;
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|code
operator|==
name|UNORDERED
condition|)
return|return
name|const0_rtx
return|;
comment|/* For modes without NaNs, if the two operands are equal, we know the      result except if they have side-effects.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|trueop0
argument_list|,
name|trueop1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|trueop0
argument_list|)
condition|)
name|equal
operator|=
literal|1
operator|,
name|op0lt
operator|=
literal|0
operator|,
name|op0ltu
operator|=
literal|0
operator|,
name|op1lt
operator|=
literal|0
operator|,
name|op1ltu
operator|=
literal|0
expr_stmt|;
comment|/* If the operands are floating-point constants, see if we can fold      the result.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|trueop0
argument_list|)
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|d0
decl_stmt|,
name|d1
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d0
argument_list|,
name|trueop0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d1
argument_list|,
name|trueop1
argument_list|)
expr_stmt|;
comment|/* Comparisons are unordered iff at least one of the values is NaN.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d0
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNEQ
case|:
case|case
name|UNLT
case|:
case|case
name|UNGT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGE
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
return|return
name|const_true_rtx
return|;
case|case
name|EQ
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTGT
case|:
case|case
name|ORDERED
case|:
return|return
name|const0_rtx
return|;
default|default:
return|return
literal|0
return|;
block|}
name|equal
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|op0lt
operator|=
name|op0ltu
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|op1lt
operator|=
name|op1ltu
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, see if the operands are both integers.  */
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|l0s
decl_stmt|,
name|h0s
decl_stmt|,
name|l1s
decl_stmt|,
name|h1s
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l0u
decl_stmt|,
name|h0u
decl_stmt|,
name|l1u
decl_stmt|,
name|h1u
decl_stmt|;
comment|/* Get the two words comprising each integer constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l0u
operator|=
name|l0s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l0u
operator|=
name|l0s
operator|=
name|INTVAL
argument_list|(
name|trueop0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l0s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|trueop1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l1u
operator|=
name|l1s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l1u
operator|=
name|l1s
operator|=
name|INTVAL
argument_list|(
name|trueop1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1s
argument_list|)
expr_stmt|;
block|}
comment|/* If WIDTH is nonzero and smaller than HOST_BITS_PER_WIDE_INT, 	 we have to sign or zero-extend the values.  */
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|l0u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|l1u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
if|if
condition|(
name|l1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|h0u
operator|=
name|h1u
operator|=
literal|0
operator|,
name|h0s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l0s
argument_list|)
operator|,
name|h1s
operator|=
name|HWI_SIGN_EXTEND
argument_list|(
name|l1s
argument_list|)
expr_stmt|;
name|equal
operator|=
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|==
name|l1u
operator|)
expr_stmt|;
name|op0lt
operator|=
operator|(
name|h0s
operator|<
name|h1s
operator|||
operator|(
name|h0s
operator|==
name|h1s
operator|&&
name|l0u
operator|<
name|l1u
operator|)
operator|)
expr_stmt|;
name|op1lt
operator|=
operator|(
name|h1s
operator|<
name|h0s
operator|||
operator|(
name|h1s
operator|==
name|h0s
operator|&&
name|l1u
operator|<
name|l0u
operator|)
operator|)
expr_stmt|;
name|op0ltu
operator|=
operator|(
name|h0u
operator|<
name|h1u
operator|||
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|<
name|l1u
operator|)
operator|)
expr_stmt|;
name|op1ltu
operator|=
operator|(
name|h1u
operator|<
name|h0u
operator|||
operator|(
name|h1u
operator|==
name|h0u
operator|&&
name|l1u
operator|<
name|l0u
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Otherwise, there are some code-specific tests we can make.  */
else|else
block|{
comment|/* Optimize comparisons with upper and lower bounds.  */
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|rtx
name|mmin
decl_stmt|,
name|mmax
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
condition|)
name|sign
operator|=
literal|0
expr_stmt|;
else|else
name|sign
operator|=
literal|1
expr_stmt|;
name|get_mode_bounds
argument_list|(
name|mode
argument_list|,
name|sign
argument_list|,
name|mode
argument_list|,
operator|&
name|mmin
argument_list|,
operator|&
name|mmax
argument_list|)
expr_stmt|;
name|tem
operator|=
name|NULL_RTX
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GEU
case|:
case|case
name|GE
case|:
comment|/* x>= min is always true.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop1
argument_list|,
name|mmin
argument_list|)
condition|)
name|tem
operator|=
name|const_true_rtx
expr_stmt|;
else|else
break|break;
case|case
name|LEU
case|:
case|case
name|LE
case|:
comment|/* x<= max is always true.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop1
argument_list|,
name|mmax
argument_list|)
condition|)
name|tem
operator|=
name|const_true_rtx
expr_stmt|;
break|break;
case|case
name|GTU
case|:
case|case
name|GT
case|:
comment|/* x> max is always false.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop1
argument_list|,
name|mmax
argument_list|)
condition|)
name|tem
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|LTU
case|:
case|case
name|LT
case|:
comment|/* x< min is always false.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|trueop1
argument_list|,
name|mmin
argument_list|)
condition|)
name|tem
operator|=
name|const0_rtx
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|tem
operator|==
name|const0_rtx
operator|||
name|tem
operator|==
name|const_true_rtx
condition|)
return|return
name|tem
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
name|nonzero_address_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|trueop1
operator|==
name|const0_rtx
operator|&&
name|nonzero_address_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|LT
case|:
comment|/* Optimize abs(x)< 0.0.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
operator|!
name|flag_wrapv
operator|&&
operator|!
name|flag_trapv
operator|&&
name|flag_strict_overflow
operator|)
operator|)
condition|)
block|{
name|tem
operator|=
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|?
name|XEXP
argument_list|(
name|trueop0
argument_list|,
literal|0
argument_list|)
else|:
name|trueop0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ABS
condition|)
block|{
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|issue_strict_overflow_warning
argument_list|(
name|WARN_STRICT_OVERFLOW_CONDITIONAL
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wstrict_overflow
argument_list|,
operator|(
literal|"assuming signed overflow does not occur when "
literal|"assuming abs (x)< 0 is false"
operator|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
break|break;
case|case
name|GE
case|:
comment|/* Optimize abs(x)>= 0.0.  */
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
operator|!
name|flag_wrapv
operator|&&
operator|!
name|flag_trapv
operator|&&
name|flag_strict_overflow
operator|)
operator|)
condition|)
block|{
name|tem
operator|=
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|?
name|XEXP
argument_list|(
name|trueop0
argument_list|,
literal|0
argument_list|)
else|:
name|trueop0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ABS
condition|)
block|{
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|issue_strict_overflow_warning
argument_list|(
name|WARN_STRICT_OVERFLOW_CONDITIONAL
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wstrict_overflow
argument_list|,
operator|(
literal|"assuming signed overflow does not occur when "
literal|"assuming abs (x)>= 0 is true"
operator|)
argument_list|)
expr_stmt|;
return|return
name|const_true_rtx
return|;
block|}
block|}
break|break;
case|case
name|UNGE
case|:
comment|/* Optimize ! (abs(x)< 0.0).  */
if|if
condition|(
name|trueop1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tem
operator|=
name|GET_CODE
argument_list|(
name|trueop0
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|?
name|XEXP
argument_list|(
name|trueop0
argument_list|,
literal|0
argument_list|)
else|:
name|trueop0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ABS
condition|)
return|return
name|const_true_rtx
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
comment|/* If we reach here, EQUAL, OP0LT, OP0LTU, OP1LT, and OP1LTU are set      as appropriate.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
return|return
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
return|return
operator|!
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
return|return
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GT
case|:
case|case
name|UNGT
case|:
return|return
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LTU
case|:
return|return
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GTU
case|:
return|return
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
return|return
name|equal
operator|||
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GE
case|:
case|case
name|UNGE
case|:
return|return
name|equal
operator|||
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LEU
case|:
return|return
name|equal
operator|||
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GEU
case|:
return|return
name|equal
operator|||
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|ORDERED
case|:
return|return
name|const_true_rtx
return|;
case|case
name|UNORDERED
case|:
return|return
name|const0_rtx
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify CODE, an operation with result mode MODE and three operands,    OP0, OP1, and OP2.  OP0_MODE was the mode of OP0 before it became    a constant.  Return 0 if no simplifications is possible.  */
end_comment

begin_function
name|rtx
name|simplify_ternary_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|op0_mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* VOIDmode means "infinite" precision.  */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<=
name|width
operator|)
operator|&&
name|width
operator|<=
operator|(
name|unsigned
operator|)
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Extracting a bit-field from a constant */
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|val
operator|>>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op0_mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
expr_stmt|;
else|else
name|val
operator|>>=
name|INTVAL
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|INTVAL
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* First zero-extend.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If desired, propagate sign bit.  */
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|~
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Clear the bits that don't belong in our mode, 	     unless they and our sign bit are all one. 	     So we get either a reasonable negative value or a reasonable 	     unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|gen_int_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
return|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|op0
operator|!=
name|const0_rtx
condition|?
name|op1
else|:
name|op2
return|;
comment|/* Convert c ? a : a into "a".  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* Convert a != b ? a : b into "a".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NE
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|op1
return|;
comment|/* Convert a == b ? a : b into "b".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|EQ
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|op2
return|;
if|if
condition|(
name|COMPARISON_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|cmp_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Look for happy constants in op1 and op2.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|t
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|f
init|=
name|INTVAL
argument_list|(
name|op2
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|STORE_FLAG_VALUE
operator|&&
name|f
operator|==
literal|0
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|0
operator|&&
name|f
operator|==
name|STORE_FLAG_VALUE
condition|)
block|{
name|enum
name|rtx_code
name|tmp
decl_stmt|;
name|tmp
operator|=
name|reversed_comparison_code
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|UNKNOWN
condition|)
break|break;
name|code
operator|=
name|tmp
expr_stmt|;
block|}
else|else
break|break;
return|return
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|op0_mode
expr_stmt|;
name|temp
operator|=
name|simplify_relational_operation
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if any simplifications were possible.  */
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|temp
operator|==
name|const0_rtx
condition|?
name|op2
else|:
name|op1
return|;
elseif|else
if|if
condition|(
name|temp
condition|)
return|return
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|VEC_MERGE
case|:
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|op2
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|n_elts
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|&
name|mask
operator|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
name|op0
return|;
name|op0
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|?
name|CONST_VECTOR_ELT
argument_list|(
name|op0
argument_list|,
name|i
argument_list|)
else|:
name|CONST_VECTOR_ELT
argument_list|(
name|op1
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Evaluate a SUBREG of a CONST_INT or CONST_DOUBLE or CONST_VECTOR,    returning another CONST_INT or CONST_DOUBLE or CONST_VECTOR.     Works by unpacking OP into a collection of 8-bit values    represented as a little-endian array of 'unsigned char', selecting by BYTE,    and then repacking them again for OUTERMODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_immed_subreg
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|,
name|unsigned
name|int
name|byte
parameter_list|)
block|{
comment|/* We support up to 512-bit values (for V8DFmode).  */
enum|enum
block|{
name|max_bitsize
init|=
literal|512
block|,
name|value_bit
init|=
literal|8
block|,
name|value_mask
init|=
operator|(
literal|1
operator|<<
name|value_bit
operator|)
operator|-
literal|1
block|}
enum|;
name|unsigned
name|char
name|value
index|[
name|max_bitsize
operator|/
name|value_bit
index|]
decl_stmt|;
name|int
name|value_start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|elem
decl_stmt|;
name|int
name|num_elem
decl_stmt|;
name|rtx
modifier|*
name|elems
decl_stmt|;
name|int
name|elem_bitsize
decl_stmt|;
name|rtx
name|result_s
decl_stmt|;
name|rtvec
name|result_v
init|=
name|NULL
decl_stmt|;
name|enum
name|mode_class
name|outer_class
decl_stmt|;
name|enum
name|machine_mode
name|outer_submode
decl_stmt|;
comment|/* Some ports misuse CCmode.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|outermode
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|op
return|;
comment|/* We have no way to represent a complex constant at the rtl level.  */
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|outermode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Unpack the value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|num_elem
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|elems
operator|=
operator|&
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elem_bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|innermode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num_elem
operator|=
literal|1
expr_stmt|;
name|elems
operator|=
operator|&
name|op
expr_stmt|;
name|elem_bitsize
operator|=
name|max_bitsize
expr_stmt|;
block|}
comment|/* If this asserts, it is too complicated; reducing value_bit may help.  */
name|gcc_assert
argument_list|(
name|BITS_PER_UNIT
operator|%
name|value_bit
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* I don't know how to handle endianness of sub-units.  */
name|gcc_assert
argument_list|(
name|elem_bitsize
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|num_elem
condition|;
name|elem
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|vp
decl_stmt|;
name|rtx
name|el
init|=
name|elems
index|[
name|elem
index|]
decl_stmt|;
comment|/* Vectors are kept in target memory order.  (This is probably 	 a mistake.)  */
block|{
name|unsigned
name|byte
init|=
operator|(
name|elem
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|unsigned
name|ibyte
init|=
operator|(
operator|(
operator|(
name|num_elem
operator|-
literal|1
operator|-
name|elem
operator|)
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|unsigned
name|word_byte
init|=
name|WORDS_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|subword_byte
init|=
name|BYTES_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|bytele
init|=
operator|(
name|subword_byte
operator|%
name|UNITS_PER_WORD
operator|+
operator|(
name|word_byte
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|vp
operator|=
name|value
operator|+
operator|(
name|bytele
operator|*
name|BITS_PER_UNIT
operator|)
operator|/
name|value_bit
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|el
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
name|INTVAL
argument_list|(
name|el
argument_list|)
operator|>>
name|i
expr_stmt|;
comment|/* CONST_INTs are always logically sign-extended.  */
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
name|INTVAL
argument_list|(
name|el
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|el
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* If this triggers, someone should have generated a 		 CONST_INT instead.  */
name|gcc_assert
argument_list|(
name|elem_bitsize
operator|>
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|el
argument_list|)
operator|>>
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
name|i
operator|<
name|elem_bitsize
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|el
argument_list|)
operator|>>
operator|(
name|i
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
name|i
operator|+=
name|value_bit
expr_stmt|;
block|}
comment|/* It shouldn't matter what's done here, so fill it with 		 zero.  */
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|long
name|tmp
index|[
name|max_bitsize
operator|/
literal|32
index|]
decl_stmt|;
name|int
name|bitsize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|el
argument_list|)
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|el
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bitsize
operator|<=
name|elem_bitsize
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bitsize
operator|%
name|value_bit
operator|==
literal|0
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|tmp
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|el
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|el
argument_list|)
argument_list|)
expr_stmt|;
comment|/* real_to_target produces its result in words affected by 		 FLOAT_WORDS_BIG_ENDIAN.  However, we ignore this, 		 and use WORDS_BIG_ENDIAN instead; see the documentation 	         of SUBREG in rtl.texi.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
block|{
name|int
name|ibase
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|ibase
operator|=
name|bitsize
operator|-
literal|1
operator|-
name|i
expr_stmt|;
else|else
name|ibase
operator|=
name|i
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|tmp
index|[
name|ibase
operator|/
literal|32
index|]
operator|>>
name|i
operator|%
literal|32
expr_stmt|;
block|}
comment|/* It shouldn't matter what's done here, so fill it with 		 zero.  */
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
operator|*
name|vp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now, pick the right byte to start with.  */
comment|/* Renumber BYTE so that the least-significant byte is byte 0.  A special      case is paradoxical SUBREGs, which shouldn't be adjusted since they      will already have offset 0.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|unsigned
name|ibyte
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|-
name|byte
operator|)
decl_stmt|;
name|unsigned
name|word_byte
init|=
name|WORDS_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|subword_byte
init|=
name|BYTES_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|byte
operator|=
operator|(
name|subword_byte
operator|%
name|UNITS_PER_WORD
operator|+
operator|(
name|word_byte
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
comment|/* BYTE should still be inside OP.  (Note that BYTE is unsigned,      so if it's become negative it will instead be very large.)  */
name|gcc_assert
argument_list|(
name|byte
operator|<
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert from bytes to chunks of size value_bit.  */
name|value_start
operator|=
name|byte
operator|*
operator|(
name|BITS_PER_UNIT
operator|/
name|value_bit
operator|)
expr_stmt|;
comment|/* Re-pack the value.  */
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|num_elem
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|outermode
argument_list|)
expr_stmt|;
name|result_v
operator|=
name|rtvec_alloc
argument_list|(
name|num_elem
argument_list|)
expr_stmt|;
name|elems
operator|=
operator|&
name|RTVEC_ELT
argument_list|(
name|result_v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outer_submode
operator|=
name|GET_MODE_INNER
argument_list|(
name|outermode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num_elem
operator|=
literal|1
expr_stmt|;
name|elems
operator|=
operator|&
name|result_s
expr_stmt|;
name|outer_submode
operator|=
name|outermode
expr_stmt|;
block|}
name|outer_class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|outer_submode
argument_list|)
expr_stmt|;
name|elem_bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|outer_submode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|elem_bitsize
operator|%
name|value_bit
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|elem_bitsize
operator|+
name|value_start
operator|*
name|value_bit
operator|<=
name|max_bitsize
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|num_elem
condition|;
name|elem
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|vp
decl_stmt|;
comment|/* Vectors are stored in target memory order.  (This is probably 	 a mistake.)  */
block|{
name|unsigned
name|byte
init|=
operator|(
name|elem
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|unsigned
name|ibyte
init|=
operator|(
operator|(
operator|(
name|num_elem
operator|-
literal|1
operator|-
name|elem
operator|)
operator|*
name|elem_bitsize
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|unsigned
name|word_byte
init|=
name|WORDS_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|subword_byte
init|=
name|BYTES_BIG_ENDIAN
condition|?
name|ibyte
else|:
name|byte
decl_stmt|;
name|unsigned
name|bytele
init|=
operator|(
name|subword_byte
operator|%
name|UNITS_PER_WORD
operator|+
operator|(
name|word_byte
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|vp
operator|=
name|value
operator|+
name|value_start
operator|+
operator|(
name|bytele
operator|*
name|BITS_PER_UNIT
operator|)
operator|/
name|value_bit
expr_stmt|;
block|}
switch|switch
condition|(
name|outer_class
condition|)
block|{
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|hi
init|=
literal|0
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
name|lo
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|vp
operator|++
operator|&
name|value_mask
argument_list|)
operator|<<
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
name|hi
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|vp
operator|++
operator|&
name|value_mask
argument_list|)
operator|<<
operator|(
name|i
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
comment|/* immed_double_const doesn't call trunc_int_for_mode.  I don't 	       know why.  */
if|if
condition|(
name|elem_bitsize
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|elems
index|[
name|elem
index|]
operator|=
name|gen_int_mode
argument_list|(
name|lo
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elem_bitsize
operator|<=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
name|elems
index|[
name|elem
index|]
operator|=
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
block|}
break|break;
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_DECIMAL_FLOAT
case|:
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|tmp
index|[
name|max_bitsize
operator|/
literal|32
index|]
decl_stmt|;
comment|/* real_from_target wants its input in words affected by 	       FLOAT_WORDS_BIG_ENDIAN.  However, we ignore this, 	       and use WORDS_BIG_ENDIAN instead; see the documentation 	       of SUBREG in rtl.texi.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_bitsize
operator|/
literal|32
condition|;
name|i
operator|++
control|)
name|tmp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elem_bitsize
condition|;
name|i
operator|+=
name|value_bit
control|)
block|{
name|int
name|ibase
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|ibase
operator|=
name|elem_bitsize
operator|-
literal|1
operator|-
name|i
expr_stmt|;
else|else
name|ibase
operator|=
name|i
expr_stmt|;
name|tmp
index|[
name|ibase
operator|/
literal|32
index|]
operator||=
operator|(
operator|*
name|vp
operator|++
operator|&
name|value_mask
operator|)
operator|<<
name|i
operator|%
literal|32
expr_stmt|;
block|}
name|real_from_target
argument_list|(
operator|&
name|r
argument_list|,
name|tmp
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
name|elems
index|[
name|elem
index|]
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|outer_submode
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|outermode
argument_list|)
condition|)
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|outermode
argument_list|,
name|result_v
argument_list|)
return|;
else|else
return|return
name|result_s
return|;
block|}
end_function

begin_comment
comment|/* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)    Return 0 if no simplifications are possible.  */
end_comment

begin_function
name|rtx
name|simplify_subreg
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|,
name|unsigned
name|int
name|byte
parameter_list|)
block|{
comment|/* Little bit of sanity checking.  */
name|gcc_assert
argument_list|(
name|innermode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|outermode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|innermode
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|outermode
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|innermode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|byte
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|byte
operator|<
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outermode
operator|==
name|innermode
operator|&&
operator|!
name|byte
condition|)
return|return
name|op
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
return|return
name|simplify_immed_subreg
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
return|;
comment|/* Changing mode twice with SUBREG => just change it once,      or not at all if changing back op starting mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|enum
name|machine_mode
name|innermostmode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|final_offset
init|=
name|byte
operator|+
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|newx
decl_stmt|;
if|if
condition|(
name|outermode
operator|==
name|innermostmode
operator|&&
name|byte
operator|==
literal|0
operator|&&
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
return|;
comment|/* The SUBREG_BYTE represents offset, as if the value were stored 	 in memory.  Irritating exception is paradoxical subreg, where 	 we define SUBREG_BYTE to be 0.  On big endian machines, this 	 value should be negative.  For a moment, undo this exception.  */
if|if
condition|(
name|byte
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
comment|/* See whether resulting subreg will be paradoxical.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
comment|/* In nonparadoxical subregs we can't handle negative offsets.  */
if|if
condition|(
name|final_offset
operator|<
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Bail out in case resulting subreg would be incorrect.  */
if|if
condition|(
name|final_offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|||
operator|(
name|unsigned
operator|)
name|final_offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
comment|/* In paradoxical subreg, see if we are still looking on lower part. 	     If so, our SUBREG_BYTE will be 0.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|final_offset
condition|)
name|final_offset
operator|=
literal|0
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
block|}
comment|/* Recurse for further possible simplifications.  */
name|newx
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|innermostmode
argument_list|,
name|final_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|newx
condition|)
return|return
name|newx
return|;
if|if
condition|(
name|validate_subreg
argument_list|(
name|outermode
argument_list|,
name|innermostmode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|final_offset
argument_list|)
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|final_offset
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Merge implicit and explicit truncations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|&&
name|subreg_lowpart_offset
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
operator|==
name|byte
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|TRUNCATE
argument_list|,
name|outermode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* SUBREG of a hard register => just change the register number      and/or mode.  If the hard register is not valid in that mode,      suppress this simplification.  If the hard register is the stack,      frame, or argument pointer, leave this as a SUBREG.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
operator|(
name|REG_CANNOT_CHANGE_MODE_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|,
name|innermode
argument_list|,
name|outermode
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|innermode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|innermode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|)
endif|#
directive|endif
operator|&&
operator|(
operator|(
name|reload_completed
operator|&&
operator|!
name|frame_pointer_needed
operator|)
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|subreg_offset_representable_p
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|,
name|outermode
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|final_regno
init|=
name|regno
operator|+
name|subreg_regno_offset
argument_list|(
name|regno
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|,
name|outermode
argument_list|)
decl_stmt|;
comment|/* ??? We do allow it if the current REG is not valid for 	 its mode.  This is a kludge to work around how float/complex 	 arguments are passed on 32-bit SPARC and should be fixed.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|final_regno
argument_list|,
name|outermode
argument_list|)
operator|||
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|innermode
argument_list|)
condition|)
block|{
name|rtx
name|x
decl_stmt|;
name|int
name|final_offset
init|=
name|byte
decl_stmt|;
comment|/* Adjust offset for paradoxical subregs.  */
if|if
condition|(
name|byte
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|final_offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
name|x
operator|=
name|gen_rtx_REG_offset
argument_list|(
name|op
argument_list|,
name|outermode
argument_list|,
name|final_regno
argument_list|,
name|final_offset
argument_list|)
expr_stmt|;
comment|/* Propagate original regno.  We don't have any way to specify 	     the offset inside original regno, so do so only for lowpart. 	     The information is used only by alias analysis that can not 	     grog partial register anyway.  */
if|if
condition|(
name|subreg_lowpart_offset
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
operator|==
name|byte
condition|)
name|ORIGINAL_REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
comment|/* If we have a SUBREG of a register that we are replacing and we are      replacing it with a MEM, make a new MEM and try replacing the      SUBREG with it.  Don't do this if the MEM has a mode-dependent address      or if we would be widening it.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Allow splitting of volatile memory references in case we don't          have instruction to move the whole thing.  */
operator|&&
operator|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|innermode
argument_list|)
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|adjust_address_nv
argument_list|(
name|op
argument_list|,
name|outermode
argument_list|,
name|byte
argument_list|)
return|;
comment|/* Handle complex values represented as CONCAT      of real and imaginary part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|unsigned
name|int
name|inner_size
decl_stmt|,
name|final_offset
decl_stmt|;
name|rtx
name|part
decl_stmt|,
name|res
decl_stmt|;
name|inner_size
operator|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|innermode
argument_list|)
expr_stmt|;
name|part
operator|=
name|byte
operator|<
name|inner_size
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final_offset
operator|=
name|byte
operator|%
name|inner_size
expr_stmt|;
if|if
condition|(
name|final_offset
operator|+
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|>
name|inner_size
condition|)
return|return
name|NULL_RTX
return|;
name|res
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|part
argument_list|,
name|GET_MODE
argument_list|(
name|part
argument_list|)
argument_list|,
name|final_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
if|if
condition|(
name|validate_subreg
argument_list|(
name|outermode
argument_list|,
name|GET_MODE
argument_list|(
name|part
argument_list|)
argument_list|,
name|part
argument_list|,
name|final_offset
argument_list|)
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|part
argument_list|,
name|final_offset
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Optimize SUBREG truncations of zero and sign extended values.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|bitpos
init|=
name|subreg_lsb_1
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
decl_stmt|;
comment|/* If we're requesting the lowpart of a zero or sign extension, 	 there are three possibilities.  If the outermode is the same 	 as the origmode, we can omit both the extension and the subreg. 	 If the outermode is not larger than the origmode, we can apply 	 the truncation without the extension.  Finally, if the outermode 	 is larger than the origmode, but both are integer modes, we 	 can just extend to the appropriate mode.  */
if|if
condition|(
name|bitpos
operator|==
literal|0
condition|)
block|{
name|enum
name|machine_mode
name|origmode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outermode
operator|==
name|origmode
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|origmode
argument_list|)
condition|)
return|return
name|simplify_gen_subreg
argument_list|(
name|outermode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|origmode
argument_list|,
name|subreg_lowpart_offset
argument_list|(
name|outermode
argument_list|,
name|origmode
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|outermode
argument_list|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|outermode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|origmode
argument_list|)
return|;
block|}
comment|/* A SUBREG resulting from a zero extension may fold to zero if 	 it extracts higher bits that the ZERO_EXTEND's source bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
name|bitpos
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|outermode
argument_list|)
return|;
block|}
comment|/* Simplify (subreg:QI (lshiftrt:SI (sign_extend:SI (x:QI)) C), 0) into      to (ashiftrt:QI (x:QI) C), where C is a suitable small constant and      the outer subreg is effectively a truncation to the original mode.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|outermode
argument_list|)
comment|/* Ensure that OUTERMODE is at least twice as wide as the INNERMODE 	 to avoid the possibility that an outer LSHIFTRT shifts by more 	 than the sign extension's sign_bit_copies and introduces zeros 	 into the high bits of the result.  */
operator|&&
operator|(
literal|2
operator|*
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|innermode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|outermode
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|&&
name|subreg_lsb_1
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
operator|==
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFTRT
argument_list|,
name|outermode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Likewise (subreg:QI (lshiftrt:SI (zero_extend:SI (x:QI)) C), 0) into      to (lshiftrt:QI (x:QI) C), where C is a suitable small constant and      the outer subreg is effectively a truncation to the original mode.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|outermode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|innermode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|outermode
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|&&
name|subreg_lsb_1
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
operator|==
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|outermode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Likewise (subreg:QI (ashift:SI (zero_extend:SI (x:QI)) C), 0) into      to (ashift:QI (x:QI) C), where C is a suitable small constant and      the outer subreg is effectively a truncation to the original mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|outermode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|innermode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|outermode
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|outermode
argument_list|)
operator|&&
name|subreg_lsb_1
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
operator|==
literal|0
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|outermode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Make a SUBREG operation or equivalent if it folds.  */
end_comment

begin_function
name|rtx
name|simplify_gen_subreg
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|,
name|unsigned
name|int
name|byte
parameter_list|)
block|{
name|rtx
name|newx
decl_stmt|;
name|newx
operator|=
name|simplify_subreg
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|innermode
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|newx
condition|)
return|return
name|newx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|validate_subreg
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|,
name|op
argument_list|,
name|byte
argument_list|)
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|outermode
argument_list|,
name|op
argument_list|,
name|byte
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Simplify X, an rtx expression.     Return the simplified expression or NULL if no simplifications    were possible.     This is the preferred entry point into the simplification routines;    however, we still allow passes to call the more specific routines.     Right now GCC has three (yes, three) major bodies of RTL simplification    code that need to be unified.  	1. fold_rtx in cse.c.  This code uses various CSE specific 	   information to aid in RTL simplification.  	2. simplify_rtx in combine.c.  Similar to fold_rtx, except that 	   it uses combine specific information to aid in RTL 	   simplification.  	3. The routines in this file.      Long term we want to only have one body of simplification code; to    get to that state I recommend the following steps:  	1. Pour over fold_rtx& simplify_rtx and move any simplifications 	   which are not pass dependent state into these routines.  	2. As code is moved by #1, change fold_rtx& simplify_rtx to 	   use this routine whenever possible.  	3. Allow for pass dependent state to be provided to these 	   routines and add simplifications based on the pass dependent 	   state.  Remove code from cse.c& combine.c that becomes 	   redundant/dead.      It will take time, but ultimately the compiler will be easier to     maintain and improve.  It's totally silly that when we add a     simplification that it needs to be added to 4 places (3 for RTL     simplification and 1 for tree simplification.  */
end_comment

begin_function
name|rtx
name|simplify_rtx
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|RTX_UNARY
case|:
return|return
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|RTX_COMM_ARITH
case|:
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Fall through....  */
case|case
name|RTX_BIN_ARITH
case|:
return|return
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|RTX_TERNARY
case|:
case|case
name|RTX_BITFIELD_OPS
case|:
return|return
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|RTX_COMPARE
case|:
case|case
name|RTX_COMM_COMPARE
case|:
return|return
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|RTX_EXTRA
case|:
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
return|return
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|RTX_OBJ
case|:
if|if
condition|(
name|code
operator|==
name|LO_SUM
condition|)
block|{
comment|/* Convert (lo_sum (high FOO) FOO) to FOO.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

