begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compute register class preferences for pseudo-registers.    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996    1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains two passes of the compiler: reg_scan and reg_class.    It also defines some tables of information about the hardware registers    and a function init_reg_sets to initialize the tables.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_function_decl
specifier|static
name|void
name|init_reg_sets_1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_reg_autoinc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If we have auto-increment or auto-decrement and we can have secondary    reloads, we are not allowed to use classes requiring secondary    reloads for pseudos auto-incremented since reload can't handle it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|)
operator|||
name|defined
argument_list|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|)
end_if

begin_define
define|#
directive|define
name|FORBIDDEN_INC_DEC_CLASSES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Register tables used by many passes.  */
end_comment

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use (stack pointer, pc, frame pointer, etc.).    These are the registers that cannot be used to allocate    a pseudo reg for general use.  */
end_comment

begin_decl_stmt
name|char
name|fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|initial_fixed_regs
index|[]
init|=
name|FIXED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use or are clobbered by function calls.    These are the registers that cannot be used to allocate    a pseudo reg whose life crosses calls unless we are able    to save/restore them across the calls.  */
end_comment

begin_decl_stmt
name|char
name|call_used_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_used_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* HARD_REG_SET of registers we want to avoid caller saving.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|losing_caller_save_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|initial_call_used_regs
index|[]
init|=
name|CALL_USED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is much like call_used_regs, except it doesn't have to    be a superset of FIXED_REGISTERS. This vector indicates    what is really call clobbered, and is used when defining    regs_invalidated_by_call.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CALL_REALLY_USED_REGISTERS
end_ifdef

begin_decl_stmt
name|char
name|call_really_used_regs
index|[]
init|=
name|CALL_REALLY_USED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CALL_REALLY_USED_REGISTERS
end_ifdef

begin_define
define|#
directive|define
name|CALL_REALLY_USED_REGNO_P
parameter_list|(
name|X
parameter_list|)
value|call_really_used_regs[X]
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CALL_REALLY_USED_REGNO_P
parameter_list|(
name|X
parameter_list|)
value|call_used_regs[X]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers that are    fixed use or call used registers that cannot hold quantities across    calls even if we are willing to save and restore them.  call fixed    registers are a subset of call used registers.  */
end_comment

begin_decl_stmt
name|char
name|call_fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of non-fixed registers.  */
end_comment

begin_decl_stmt
name|int
name|n_non_fixed_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are being used for global register decls.    These must be exempt from ordinary flow analysis    and are also considered fixed.  */
end_comment

begin_decl_stmt
name|char
name|global_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains 1 for registers that are set or clobbered by calls.  */
end_comment

begin_comment
comment|/* ??? Ideally, this would be just call_used_regs plus global_regs, but    for someone's bright idea to have call_used_regs strictly include    fixed_regs.  Which leaves us guessing as to the set of fixed_regs    that are actually preserved.  We know for sure that those associated    with the local stack frame are safe, but scant others.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|regs_invalidated_by_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of register numbers in the order in which to try to use them.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
end_ifdef

begin_decl_stmt
name|int
name|reg_alloc_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The inverse of reg_alloc_order.  */
end_comment

begin_decl_stmt
name|int
name|inv_reg_alloc_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For each reg class, a HARD_REG_SET saying which registers are in it.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|reg_class_contents
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same information, but as an array of unsigned ints.  We copy from    these unsigned ints to the table above.  We do this so the tm.h files    do not have to be aware of the wordsize for machines with<= 64 regs.    Note that we hard-code 32 here, not HOST_BITS_PER_INT.  */
end_comment

begin_define
define|#
directive|define
name|N_REG_INTS
define|\
value|((FIRST_PSEUDO_REGISTER + (32 - 1)) / 32)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int_reg_class_contents
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_INTS
index|]
init|=
name|REG_CLASS_CONTENTS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, number of regs it contains.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|reg_class_size
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the containing classes.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_superclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the classes contained in it.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each pair of reg classes,    a largest reg class contained in their union.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subunion
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each pair of reg classes,    the smallest reg class containing their union.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_superunion
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array containing all of the register names.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|reg_names
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each hard register, the widest mode object that it can contain.    This will be a MODE_INT mode if the register can hold integers.  Otherwise    it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the    register.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|reg_raw_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if class does contain register of given mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|contains_reg_of_mode
index|[
name|N_REG_CLASSES
index|]
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum cost of moving from a register in one class to a register in    another class.  Based on REGISTER_MOVE_COST.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move_cost
index|[
name|MAX_MACHINE_MODE
index|]
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but here we don't have to move if the first index is a subset    of the second so in that case the cost is zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|may_move_in_cost
index|[
name|MAX_MACHINE_MODE
index|]
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but here we don't have to move if the first index is a superset    of the second so in that case the cost is zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|may_move_out_cost
index|[
name|MAX_MACHINE_MODE
index|]
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
end_ifdef

begin_comment
comment|/* These are the classes that regs which are auto-incremented or decremented    cannot be put in.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forbidden_inc_dec_class
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, is nonzero if (REG n) is used in an auto-inc or auto-dec    context.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|in_inc_dec
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FORBIDDEN_INC_DEC_CLASSES */
end_comment

begin_comment
comment|/* Sample MEM values for use by memory_move_secondary_cost.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|top_of_stack
index|[
name|MAX_MACHINE_MODE
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Linked list of reg_info structures allocated for reg_n_info array.    Grouping all of the allocated structures together in one lump    means only one call to bzero to clear them, rather than n smaller    calls.  */
end_comment

begin_struct
struct|struct
name|reg_info_data
block|{
name|struct
name|reg_info_data
modifier|*
name|next
decl_stmt|;
comment|/* next set of reg_info structures */
name|size_t
name|min_index
decl_stmt|;
comment|/* minimum index # */
name|size_t
name|max_index
decl_stmt|;
comment|/* maximum index # */
name|char
name|used_p
decl_stmt|;
comment|/* nonzero if this has been used previously */
name|reg_info
name|data
index|[
literal|1
index|]
decl_stmt|;
comment|/* beginning of the reg_info data */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|reg_info_data
modifier|*
name|reg_info_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* No more global register variables may be declared; true once    regclass has been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_global_reg_vars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function called only once to initialize the above data on reg usage.    Once this is done, various switches may override.  */
end_comment

begin_function
name|void
name|init_reg_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* First copy the register information from the initial int form into      the regsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Note that we hard-code 32 here, not HOST_BITS_PER_INT.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|int_reg_class_contents
index|[
name|i
index|]
index|[
name|j
operator|/
literal|32
index|]
operator|&
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|j
operator|%
literal|32
operator|)
operator|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|fixed_regs
argument_list|,
name|initial_fixed_regs
argument_list|,
sizeof|sizeof
name|fixed_regs
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|call_used_regs
argument_list|,
name|initial_call_used_regs
argument_list|,
sizeof|sizeof
name|call_used_regs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|global_regs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|global_regs
argument_list|)
expr_stmt|;
comment|/* Do any additional initialization regsets may need.  */
name|INIT_ONCE_REG_SET
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|inv_reg_alloc_order
index|[
name|reg_alloc_order
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* After switches have been processed, which perhaps alter    `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */
end_comment

begin_function
specifier|static
name|void
name|init_reg_sets_1
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
comment|/* enum machine_mode */
name|m
decl_stmt|;
name|char
name|allocatable_regs_of_mode
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
comment|/* This macro allows the fixed or call-used registers      and the register classes to depend on target flags.  */
ifdef|#
directive|ifdef
name|CONDITIONAL_REGISTER_USAGE
name|CONDITIONAL_REGISTER_USAGE
expr_stmt|;
endif|#
directive|endif
comment|/* Compute number of hard regs in each class.  */
name|memset
argument_list|(
name|reg_class_size
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reg_class_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|reg_class_size
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* Initialize the table of subunions.      reg_class_subunion[I][J] gets the largest-numbered reg-class      that is contained in the union of classes I and J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|HARD_REG_SET
name|c
decl_stmt|;
name|int
name|k
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|N_REG_CLASSES
condition|;
name|k
operator|++
control|)
block|{
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|c
argument_list|,
name|subclass1
argument_list|)
expr_stmt|;
continue|continue;
name|subclass1
label|:
comment|/* Keep the largest subclass.  */
comment|/* SPEE 900308 */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|i
index|]
index|[
name|j
index|]
index|]
argument_list|,
name|subclass2
argument_list|)
expr_stmt|;
name|reg_class_subunion
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|k
expr_stmt|;
name|subclass2
label|:
empty_stmt|;
block|}
block|}
block|}
comment|/* Initialize the table of superunions.      reg_class_superunion[I][J] gets the smallest-numbered reg-class      containing the union of classes I and J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|HARD_REG_SET
name|c
decl_stmt|;
name|int
name|k
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|N_REG_CLASSES
condition|;
name|k
operator|++
control|)
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|superclass
argument_list|)
expr_stmt|;
name|superclass
label|:
name|reg_class_superunion
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|k
expr_stmt|;
block|}
block|}
comment|/* Initialize the tables of subclasses and superclasses of each reg class.      First clear the whole table, then add the elements as they are found.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|reg_class_superclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
name|reg_class_subclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
continue|continue;
name|subclass
label|:
comment|/* Reg class I is a subclass of J. 	     Add J to the table of superclasses of I.  */
name|p
operator|=
operator|&
name|reg_class_superclasses
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|j
expr_stmt|;
comment|/* Add I to the table of superclasses of J.  */
name|p
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|i
expr_stmt|;
block|}
block|}
comment|/* Initialize "constant" tables.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|fixed_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_invalidated_by_call
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|call_fixed_regs
argument_list|,
name|fixed_regs
argument_list|,
sizeof|sizeof
name|call_fixed_regs
argument_list|)
expr_stmt|;
name|n_non_fixed_regs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|n_non_fixed_regs
operator|++
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|losing_caller_save_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* There are a couple of fixed registers that we know are safe to 	 exclude from being clobbered by calls:  	 The frame pointer is always preserved across calls.  The arg pointer 	 is if it is fixed.  The stack pointer usually is, unless 	 RETURN_POPS_ARGS, in which case an explicit CLOBBER will be present. 	 If we are generating PIC code, the PIC offset table register is 	 preserved across calls, though the target can override that.  */
if|if
condition|(
name|i
operator|==
name|STACK_POINTER_REGNUM
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|FRAME_POINTER_REGNUM
condition|)
empty_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
elseif|else
if|if
condition|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
empty_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
elseif|else
if|if
condition|(
name|i
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|i
index|]
condition|)
empty_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
elseif|else
if|if
condition|(
name|i
operator|==
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|fixed_regs
index|[
name|i
index|]
condition|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|CALL_REALLY_USED_REGNO_P
argument_list|(
name|i
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|contains_reg_of_mode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|contains_reg_of_mode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|allocatable_regs_of_mode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|allocatable_regs_of_mode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|(
name|unsigned
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|m
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|CLASS_MAX_NREGS
argument_list|(
name|i
argument_list|,
name|m
argument_list|)
operator|<=
name|reg_class_size
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|j
index|]
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|contains_reg_of_mode
index|[
name|i
index|]
index|[
name|m
index|]
operator|=
literal|1
expr_stmt|;
name|allocatable_regs_of_mode
index|[
name|m
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Initialize the move cost table.  Find every subset of each class      and take the maximum cost of moving any subset to any other.  */
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|(
name|unsigned
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|allocatable_regs_of_mode
index|[
name|m
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|contains_reg_of_mode
index|[
name|i
index|]
index|[
name|m
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|int
name|cost
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|contains_reg_of_mode
index|[
name|j
index|]
index|[
name|m
index|]
condition|)
block|{
name|move_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|65536
expr_stmt|;
name|may_move_in_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|65536
expr_stmt|;
name|may_move_out_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|65536
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|m
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|p2
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p2
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p2
operator|++
control|)
if|if
condition|(
operator|*
name|p2
operator|!=
name|i
operator|&&
name|contains_reg_of_mode
index|[
operator|*
name|p2
index|]
index|[
name|m
index|]
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|move_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
operator|*
name|p2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
operator|&
name|reg_class_subclasses
index|[
name|i
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p1
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p1
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|!=
name|j
operator|&&
name|contains_reg_of_mode
index|[
operator|*
name|p1
index|]
index|[
name|m
index|]
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|move_cost
index|[
name|m
index|]
index|[
operator|*
name|p1
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|move_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cost
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
condition|)
name|may_move_in_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|may_move_in_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cost
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
condition|)
name|may_move_out_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|may_move_out_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cost
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|move_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|65536
expr_stmt|;
name|may_move_in_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|65536
expr_stmt|;
name|may_move_out_cost
index|[
name|m
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|65536
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the table of register modes.    These values are used to record death information for individual registers    (as opposed to a multi-register mode).  */
end_comment

begin_function
name|void
name|init_reg_modes_once
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|reg_raw_mode
index|[
name|i
index|]
operator|=
name|choose_hard_reg_mode
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If we couldn't find a valid mode, just use the previous mode.          ??? One situation in which we need to do this is on the mips where 	 HARD_REGNO_NREGS (fpreg, [SD]Fmode) returns 2.  Ideally we'd like 	 to use DF mode for the even registers and VOIDmode for the odd 	 (for the cpu models where the odd ones are inaccessible).  */
if|if
condition|(
name|reg_raw_mode
index|[
name|i
index|]
operator|==
name|VOIDmode
condition|)
name|reg_raw_mode
index|[
name|i
index|]
operator|=
name|i
operator|==
literal|0
condition|?
name|word_mode
else|:
name|reg_raw_mode
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish initializing the register sets and    initialize the register modes.  */
end_comment

begin_function
name|void
name|init_regs
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This finishes what was started by init_reg_sets, but couldn't be done      until after register usage was specified.  */
name|init_reg_sets_1
argument_list|()
expr_stmt|;
name|init_reg_autoinc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize some fake stack-frame MEM references for use in    memory_move_secondary_cost.  */
end_comment

begin_function
name|void
name|init_fake_stack_mems
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MACHINE_MODE
condition|;
name|i
operator|++
control|)
name|top_of_stack
index|[
name|i
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|i
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
end_ifdef

begin_comment
comment|/* Compute extra cost of moving registers to/from memory due to reloads.    Only needed if secondary reloads are required for memory moves.  */
end_comment

begin_function
name|int
name|memory_move_secondary_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|int
name|in
parameter_list|)
block|{
name|enum
name|reg_class
name|altclass
decl_stmt|;
name|int
name|partial_cost
init|=
literal|0
decl_stmt|;
comment|/* We need a memory reference to feed to SECONDARY... macros.  */
comment|/* mem may be unused even if the SECONDARY_ macros are defined.  */
name|rtx
name|mem
name|ATTRIBUTE_UNUSED
init|=
name|top_of_stack
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|in
condition|)
block|{
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
name|altclass
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|#
directive|else
name|altclass
operator|=
name|NO_REGS
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
name|altclass
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|#
directive|else
name|altclass
operator|=
name|NO_REGS
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|altclass
operator|==
name|NO_REGS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|in
condition|)
name|partial_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|altclass
argument_list|,
name|class
argument_list|)
expr_stmt|;
else|else
name|partial_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class
argument_list|,
name|altclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|altclass
condition|)
comment|/* This isn't simply a copy-to-temporary situation.  Can't guess        what it is, so MEMORY_MOVE_COST really ought not to be calling        here in that case.         I'm tempted to put in an abort here, but returning this will        probably only give poor estimates, which is what we would've        had before this code anyways.  */
return|return
name|partial_cost
return|;
comment|/* Check if the secondary reload register will also need a      secondary reload.  */
return|return
name|memory_move_secondary_cost
argument_list|(
name|mode
argument_list|,
name|altclass
argument_list|,
name|in
argument_list|)
operator|+
name|partial_cost
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a machine mode that is legitimate for hard reg REGNO and large    enough to save nregs.  If we can't find one, return VOIDmode.    If CALL_SAVED is true, only consider modes that are call saved.  */
end_comment

begin_function
name|enum
name|machine_mode
name|choose_hard_reg_mode
parameter_list|(
name|unsigned
name|int
name|regno
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|bool
name|call_saved
parameter_list|)
block|{
name|unsigned
name|int
comment|/* enum machine_mode */
name|m
decl_stmt|;
name|enum
name|machine_mode
name|found_mode
init|=
name|VOIDmode
decl_stmt|,
name|mode
decl_stmt|;
comment|/* We first look for the largest integer mode that can be validly      held in REGNO.  If none, we look for the largest floating-point mode.      If we still didn't find a valid mode, try CCmode.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|call_saved
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|found_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|found_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|found_mode
return|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|call_saved
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|found_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|found_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|found_mode
return|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|call_saved
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|found_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|found_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|found_mode
return|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|call_saved
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|found_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|found_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|found_mode
return|;
comment|/* Iterate over all of the CCmodes.  */
for|for
control|(
name|m
operator|=
operator|(
name|unsigned
name|int
operator|)
name|CCmode
init|;
name|m
operator|<
operator|(
name|unsigned
name|int
operator|)
name|NUM_MACHINE_MODES
condition|;
operator|++
name|m
control|)
block|{
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
name|m
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|call_saved
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
return|return
name|mode
return|;
block|}
comment|/* We can't find a mode valid for this register.  */
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Specify the usage characteristics of the register named NAME.    It should be a fixed register if FIXED and a    call-used register if CALL_USED.  */
end_comment

begin_function
name|void
name|fix_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|fixed
parameter_list|,
name|int
name|call_used
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Decode the name and update the primary form of      the register info.  */
if|if
condition|(
operator|(
name|i
operator|=
name|decode_reg_name
argument_list|(
name|name
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
name|STACK_POINTER_REGNUM
ifdef|#
directive|ifdef
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
else|#
directive|else
operator|||
name|i
operator|==
name|FRAME_POINTER_REGNUM
endif|#
directive|endif
operator|)
operator|&&
operator|(
name|fixed
operator|==
literal|0
operator|||
name|call_used
operator|==
literal|0
operator|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|what_option
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|"call-saved"
block|,
literal|"call-used"
block|}
block|,
block|{
literal|"no-such-option"
block|,
literal|"fixed"
block|}
block|}
decl_stmt|;
name|error
argument_list|(
literal|"can't use '%s' as a %s register"
argument_list|,
name|name
argument_list|,
name|what_option
index|[
name|fixed
index|]
index|[
name|call_used
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixed_regs
index|[
name|i
index|]
operator|=
name|fixed
expr_stmt|;
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_used
expr_stmt|;
ifdef|#
directive|ifdef
name|CALL_REALLY_USED_REGISTERS
if|if
condition|(
name|fixed
operator|==
literal|0
condition|)
name|call_really_used_regs
index|[
name|i
index|]
operator|=
name|call_used
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark register number I as global.  */
end_comment

begin_function
name|void
name|globalize_reg
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|no_global_reg_vars
condition|)
name|error
argument_list|(
literal|"global register variable follows a function definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"register used for two global register variables"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|warning
argument_list|(
literal|"call-clobbered register used for global register variable"
argument_list|)
expr_stmt|;
name|global_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If we're globalizing the frame pointer, we need to set the      appropriate regs_invalidated_by_call bit, even if it's already      set in fixed_regs.  */
if|if
condition|(
name|i
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If already fixed, nothing else to do.  */
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
return|return;
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|n_non_fixed_regs
operator|--
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Now the data and code for the `regclass' pass, which happens    just before local-alloc.  */
end_comment

begin_comment
comment|/* The `costs' struct records the cost of using a hard register of each class    and of using memory for each pseudo.  We use this data to set up    register class preferences.  */
end_comment

begin_struct
struct|struct
name|costs
block|{
name|int
name|cost
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|mem_cost
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure used to record preferences of given pseudo.  */
end_comment

begin_struct
struct|struct
name|reg_pref
block|{
comment|/* (enum reg_class) prefclass is the preferred class.  */
name|char
name|prefclass
decl_stmt|;
comment|/* altclass is a register class that we should use for allocating      pseudo if no register in the preferred class is available.      If no register in this class is available, memory is preferred.       It might appear to be more general to have a bitmask of classes here,      but since it is recommended that there be a class corresponding to the      union of most major pair of classes, that generality is not required.  */
name|char
name|altclass
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record the cost of each class for each pseudo.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|costs
modifier|*
name|costs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialized once, and used to initialize cost values for each insn.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|costs
name|init_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record preferences of each pseudo.    This is available after `regclass' is run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reg_pref
modifier|*
name|reg_pref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocated buffers for reg_pref.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reg_pref
modifier|*
name|reg_pref_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Frequency of executions of current insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frequency
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|scan_one_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_operand_costs
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|costs
modifier|*
parameter_list|,
name|struct
name|reg_pref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_regclass
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_reg_classes
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|costs
modifier|*
parameter_list|,
name|struct
name|reg_pref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copy_cost
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|reg_class
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_address_regs
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|reg_class
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
end_ifdef

begin_function_decl
specifier|static
name|int
name|auto_inc_dec_reg_p
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|reg_scan_mark_refs
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the reg_class in which pseudo reg number REGNO is best allocated.    This function is sometimes called before the info has been computed.    When that happens, just return GENERAL_REGS, which is innocuous.  */
end_comment

begin_function
name|enum
name|reg_class
name|reg_preferred_class
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|reg_pref
operator|==
literal|0
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
operator|(
expr|enum
name|reg_class
operator|)
name|reg_pref
index|[
name|regno
index|]
operator|.
name|prefclass
return|;
block|}
end_function

begin_function
name|enum
name|reg_class
name|reg_alternate_class
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|reg_pref
operator|==
literal|0
condition|)
return|return
name|ALL_REGS
return|;
return|return
operator|(
expr|enum
name|reg_class
operator|)
name|reg_pref
index|[
name|regno
index|]
operator|.
name|altclass
return|;
block|}
end_function

begin_comment
comment|/* Initialize some global data for this pass.  */
end_comment

begin_function
name|void
name|regclass_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|init_cost
operator|.
name|mem_cost
operator|=
literal|10000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|init_cost
operator|.
name|cost
index|[
name|i
index|]
operator|=
literal|10000
expr_stmt|;
comment|/* This prevents dump_flow_info from losing if called      before regclass is run.  */
name|reg_pref
operator|=
name|NULL
expr_stmt|;
comment|/* No more global register variables may be declared.  */
name|no_global_reg_vars
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump register costs.  */
end_comment

begin_function
specifier|static
name|void
name|dump_regclass
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|int
comment|/* enum reg_class */
name|class
decl_stmt|;
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  Register %i costs:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
operator|(
name|int
operator|)
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|contains_reg_of_mode
index|[
operator|(
expr|enum
name|reg_class
condition|)
name|class
expr|]
index|[
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
index|]
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
operator|&&
operator|(
operator|!
name|in_inc_dec
index|[
name|i
index|]
operator|||
operator|!
name|forbidden_inc_dec_class
index|[
operator|(
expr|enum
name|reg_class
operator|)
name|class
expr|]
block|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
name|invalid_mode_change_p
argument_list|(
name|i
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|class
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
endif|#
directive|endif
block|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %s:%i"
argument_list|,
name|reg_class_names
index|[
name|class
index|]
argument_list|,
name|costs
index|[
name|i
index|]
operator|.
name|cost
index|[
operator|(
expr|enum
name|reg_class
argument_list|)
name|class
expr|]
block|)
function|;
end_function

begin_expr_stmt
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" MEM:%i\n"
argument_list|,
name|costs
index|[
name|i
index|]
operator|.
name|mem_cost
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
unit|}     } }
end_escape

begin_comment
comment|/* Calculate the costs of insn operands.  */
end_comment

begin_function
unit|static
name|void
name|record_operand_costs
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|costs
modifier|*
name|op_costs
parameter_list|,
name|struct
name|reg_pref
modifier|*
name|reg_pref
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|modes
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|constraints
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
expr_stmt|;
name|modes
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* If we get here, we are set up to record the costs of all the      operands for this insn.  Start by initializing the costs.      Then handle any address registers.  Finally record the desired      classes for any pseudos, doing it twice if some pair of      operands are commutative.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|op_costs
index|[
name|i
index|]
operator|=
name|init_cost
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|modes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|frequency
operator|*
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'p'
operator|||
name|EXTRA_ADDRESS_CONSTRAINT
argument_list|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|constraints
index|[
name|i
index|]
argument_list|)
condition|)
name|record_address_regs
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|modes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|frequency
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for commutative in a separate loop so everything will      have been initialized.  We must do this even if one operand      is a constant--see addsi3 in m68k.md.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
specifier|const
name|char
modifier|*
name|xconstraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Handle commutative operands by swapping the constraints. 	   We assume the modes are the same.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|j
operator|++
control|)
name|xconstraints
index|[
name|j
index|]
operator|=
name|constraints
index|[
name|j
index|]
expr_stmt|;
name|xconstraints
index|[
name|i
index|]
operator|=
name|constraints
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|xconstraints
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
name|record_reg_classes
argument_list|(
name|recog_data
operator|.
name|n_alternatives
argument_list|,
name|recog_data
operator|.
name|n_operands
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|,
name|modes
argument_list|,
name|xconstraints
argument_list|,
name|insn
argument_list|,
name|op_costs
argument_list|,
name|reg_pref
argument_list|)
expr_stmt|;
block|}
name|record_reg_classes
argument_list|(
name|recog_data
operator|.
name|n_alternatives
argument_list|,
name|recog_data
operator|.
name|n_operands
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|,
name|modes
argument_list|,
name|constraints
argument_list|,
name|insn
argument_list|,
name|op_costs
argument_list|,
name|reg_pref
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of regclass, processes one insn INSN.  Scan it and record each    time it would save code to put a certain register in a certain class.    PASS, when nonzero, inhibits some optimizations which need only be done    once.    Return the last insn processed, so that the scan can be continued from    there.  */
end_comment

begin_function
specifier|static
name|rtx
name|scan_one_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|pat_code
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|note
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|costs
name|op_costs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
name|insn
return|;
name|pat_code
operator|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat_code
operator|==
name|USE
operator|||
name|pat_code
operator|==
name|CLOBBER
operator|||
name|pat_code
operator|==
name|ASM_INPUT
operator|||
name|pat_code
operator|==
name|ADDR_VEC
operator|||
name|pat_code
operator|==
name|ADDR_DIFF_VEC
condition|)
return|return
name|insn
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If this insn loads a parameter from its stack slot, then      it represents a savings, rather than a cost, if the      parameter is stored in memory.  Record this fact.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|costs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|mem_cost
operator|-=
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|GENERAL_REGS
argument_list|,
literal|1
argument_list|)
operator|*
name|frequency
operator|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|frequency
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
comment|/* Improve handling of two-address insns such as      (set X (ashift CONST Y)) where CONST must be made to      match X. Change it into two insns: (set X CONST)      (set X (ashift X Y)).  If we left this for reloading, it      would probably get three insns because X and Y might go      in the same place. This prevents X and Y from receiving      the same hard reg.       We can only do this if the modes of operands 0 and 1      (which might not be the same) are tieable and we only need      do this during our first pass.  */
if|if
condition|(
name|pass
operator|==
literal|0
operator|&&
name|optimize
operator|&&
name|recog_data
operator|.
name|n_operands
operator|>=
literal|3
operator|&&
name|recog_data
operator|.
name|constraints
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|recog_data
operator|.
name|constraints
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
literal|2
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|previnsn
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|gen_lowpart
argument_list|(
name|recog_data
operator|.
name|operand_mode
index|[
literal|1
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|newinsn
init|=
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|dest
argument_list|,
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If this insn was the start of a basic block, 	 include the new insn in that block. 	 We need not check for code_label here; 	 while a basic block can start with a code_label, 	 INSN could not be at the beginning of that block.  */
if|if
condition|(
name|previnsn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|previnsn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|basic_block
name|b
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|b
argument_list|)
condition|)
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|newinsn
expr_stmt|;
block|}
comment|/* This makes one more setting of new insns's dest.  */
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_FREQ
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|+=
name|frequency
expr_stmt|;
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
literal|1
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_FREQ
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|+=
name|frequency
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_dups
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_FREQ
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|+=
name|frequency
expr_stmt|;
block|}
return|return
name|PREV_INSN
argument_list|(
name|newinsn
argument_list|)
return|;
block|}
name|record_operand_costs
argument_list|(
name|insn
argument_list|,
name|op_costs
argument_list|,
name|reg_pref
argument_list|)
expr_stmt|;
comment|/* Now add the cost for each operand to the total costs for      its register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|struct
name|costs
modifier|*
name|p
init|=
operator|&
name|costs
index|[
name|regno
index|]
decl_stmt|,
modifier|*
name|q
init|=
operator|&
name|op_costs
index|[
name|i
index|]
decl_stmt|;
name|p
operator|->
name|mem_cost
operator|+=
name|q
operator|->
name|mem_cost
operator|*
name|frequency
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
name|p
operator|->
name|cost
index|[
name|j
index|]
operator|+=
name|q
operator|->
name|cost
index|[
name|j
index|]
operator|*
name|frequency
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Initialize information about which register classes can be used for    pseudos that are auto-incremented or auto-decremented.  */
end_comment

begin_function
specifier|static
name|void
name|init_reg_autoinc
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|r
init|=
name|gen_rtx_raw_REG
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|m
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|REGNO
argument_list|(
name|r
argument_list|)
operator|=
name|j
expr_stmt|;
for|for
control|(
name|m
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|m
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|m
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|m
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* If a register is not directly suitable for an 		     auto-increment or decrement addressing mode and 		     requires secondary reloads, disallow its class from 		     being used in such addresses.  */
if|if
condition|(
operator|(
literal|0
ifdef|#
directive|ifdef
name|SECONDARY_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_RELOAD_CLASS
argument_list|(
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
else|#
directive|else
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
endif|#
directive|endif
operator|)
operator|&&
operator|!
name|auto_inc_dec_reg_p
argument_list|(
name|r
argument_list|,
name|m
argument_list|)
condition|)
name|forbidden_inc_dec_class
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* FORBIDDEN_INC_DEC_CLASSES */
block|}
end_function

begin_comment
comment|/* This is a pass of the compiler that scans all instructions    and calculates the preferred class for each pseudo-register.    This information can be accessed later by calling `reg_preferred_class'.    This pass comes just before local register allocation.  */
end_comment

begin_function
name|void
name|regclass
parameter_list|(
name|rtx
name|f
parameter_list|,
name|int
name|nregs
parameter_list|,
name|FILE
modifier|*
name|dump
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|costs
operator|=
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|costs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|in_inc_dec
operator|=
name|xmalloc
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FORBIDDEN_INC_DEC_CLASSES */
comment|/* Normally we scan the insns once and determine the best class to use for      each register.  However, if -fexpensive_optimizations are on, we do so      twice, the second time using the tentative best classes to guide the      selection.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
name|flag_expensive_optimizations
condition|;
name|pass
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n\nPass %i\n\n"
argument_list|,
name|pass
argument_list|)
expr_stmt|;
comment|/* Zero out our accumulation of the cost of each class for each reg.  */
name|memset
argument_list|(
name|costs
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|costs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|memset
argument_list|(
name|in_inc_dec
argument_list|,
literal|0
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Scan the instructions and record each time it would 	 save code to put a certain register in a certain class.  */
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
name|frequency
operator|=
name|REG_FREQ_MAX
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|insn
operator|=
name|scan_one_insn
argument_list|(
name|insn
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
else|else
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Show that an insn inside a loop is likely to be executed three 	       times more than insns outside a loop.  This is much more 	       aggressive than the assumptions made elsewhere and is being 	       tried as an experiment.  */
name|frequency
operator|=
name|REG_FREQ_FROM_BB
argument_list|(
name|bb
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|insn
operator|=
name|scan_one_insn
argument_list|(
name|insn
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Now for each register look at how desirable each class is 	 and find which class is preferred.  Store that in 	 `prefclass'.  Record in `altclass' the largest register 	 class any of whose registers is better than memory.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|reg_pref
operator|=
name|reg_pref_buffer
expr_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
name|dump_regclass
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|best_cost
init|=
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|-
literal|2
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|enum
name|reg_class
name|best
init|=
name|ALL_REGS
decl_stmt|,
name|alt
init|=
name|NO_REGS
decl_stmt|;
comment|/* This is an enum reg_class, but we call it an int 	     to save lots of casts.  */
name|int
name|class
decl_stmt|;
name|struct
name|costs
modifier|*
name|p
init|=
operator|&
name|costs
index|[
name|i
index|]
decl_stmt|;
comment|/* In non-optimizing compilation REG_N_REFS is not initialized 	     yet.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|class
operator|=
operator|(
name|int
operator|)
name|ALL_REGS
operator|-
literal|1
init|;
name|class
operator|>
literal|0
condition|;
name|class
operator|--
control|)
block|{
comment|/* Ignore classes that are too small for this operand or 		 invalid for an operand that was auto-incremented.  */
if|if
condition|(
operator|!
name|contains_reg_of_mode
index|[
name|class
index|]
index|[
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
index|]
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
operator|||
operator|(
name|in_inc_dec
index|[
name|i
index|]
operator|&&
name|forbidden_inc_dec_class
index|[
name|class
index|]
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|||
name|invalid_mode_change_p
argument_list|(
name|i
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|class
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|p
operator|->
name|cost
index|[
name|class
index|]
expr_stmt|;
name|best
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|==
name|best_cost
condition|)
name|best
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|best
index|]
index|[
name|class
index|]
expr_stmt|;
block|}
comment|/* Record the alternate register class; i.e., a class for which 	     every register in it is better than using memory.  If adding a 	     class would make a smaller class (i.e., no union of just those 	     classes exists), skip that class.  The major unions of classes 	     should be provided as a register class.  Don't do this if we 	     will be doing it again later.  */
if|if
condition|(
operator|(
name|pass
operator|==
literal|1
operator|||
name|dump
operator|)
operator|||
operator|!
name|flag_expensive_optimizations
condition|)
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|<
name|p
operator|->
name|mem_cost
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|alt
index|]
index|[
name|class
index|]
index|]
operator|>
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|alt
index|]
operator|)
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
operator|&&
operator|!
operator|(
name|in_inc_dec
index|[
name|i
index|]
operator|&&
name|forbidden_inc_dec_class
index|[
name|class
index|]
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
name|invalid_mode_change_p
argument_list|(
name|i
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|class
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
name|alt
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|alt
index|]
index|[
name|class
index|]
expr_stmt|;
comment|/* If we don't add any classes, nothing to try.  */
if|if
condition|(
name|alt
operator|==
name|best
condition|)
name|alt
operator|=
name|NO_REGS
expr_stmt|;
if|if
condition|(
name|dump
operator|&&
operator|(
name|reg_pref
index|[
name|i
index|]
operator|.
name|prefclass
operator|!=
operator|(
name|int
operator|)
name|best
operator|||
name|reg_pref
index|[
name|i
index|]
operator|.
name|altclass
operator|!=
operator|(
name|int
operator|)
name|alt
operator|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  Register %i"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|ALL_REGS
operator|||
name|best
operator|==
name|ALL_REGS
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" pref %s\n"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|best
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|alt
operator|==
name|NO_REGS
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" pref %s or none\n"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|best
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" pref %s, else %s\n"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|best
index|]
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|alt
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* We cast to (int) because (char) hits bugs in some compilers.  */
name|reg_pref
index|[
name|i
index|]
operator|.
name|prefclass
operator|=
operator|(
name|int
operator|)
name|best
expr_stmt|;
name|reg_pref
index|[
name|i
index|]
operator|.
name|altclass
operator|=
operator|(
name|int
operator|)
name|alt
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|free
argument_list|(
name|in_inc_dec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|costs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the cost of using memory or registers of various classes for    the operands in INSN.     N_ALTS is the number of alternatives.     N_OPS is the number of operands.     OPS is an array of the operands.     MODES are the modes of the operands, in case any are VOIDmode.     CONSTRAINTS are the constraints to use for the operands.  This array    is modified by this procedure.     This procedure works alternative by alternative.  For each alternative    we assume that we will be able to allocate all pseudos to their ideal    register class and calculate the cost of using that alternative.  Then    we compute for each operand that is a pseudo-register, the cost of    having the pseudo allocated to each register class and using it in that    alternative.  To this cost is added the cost of the alternative.     The cost of each class for this insn is its lowest cost among all the    alternatives.  */
end_comment

begin_function
specifier|static
name|void
name|record_reg_classes
parameter_list|(
name|int
name|n_alts
parameter_list|,
name|int
name|n_ops
parameter_list|,
name|rtx
modifier|*
name|ops
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|modes
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|constraints
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|struct
name|costs
modifier|*
name|op_costs
parameter_list|,
name|struct
name|reg_pref
modifier|*
name|reg_pref
parameter_list|)
block|{
name|int
name|alt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Process each alternative, each time minimizing an operand's cost with      the cost for each operand in that alternative.  */
for|for
control|(
name|alt
operator|=
literal|0
init|;
name|alt
operator|<
name|n_alts
condition|;
name|alt
operator|++
control|)
block|{
name|struct
name|costs
name|this_op_costs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|alt_fail
init|=
literal|0
decl_stmt|;
name|int
name|alt_cost
init|=
literal|0
decl_stmt|;
name|enum
name|reg_class
name|classes
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|allows_mem
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|class
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|op
init|=
name|ops
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|modes
index|[
name|i
index|]
decl_stmt|;
name|int
name|allows_addr
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Initially show we know nothing about the register class.  */
name|classes
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
name|allows_mem
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If this operand has no constraints at all, we can conclude 	     nothing about it since anything is valid.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|memset
argument_list|(
operator|&
name|this_op_costs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|this_op_costs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this alternative is only relevant when this operand 	     matches a previous operand, we do different things depending 	     on whether this operand is a pseudo-reg or not.  We must process 	     any modifiers for the operand before we can make this test.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|||
operator|*
name|p
operator|==
literal|'='
operator|||
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'&'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'0'
operator|+
name|i
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|','
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Copy class and whether memory is allowed from the matching 		 alternative.  Then perform any needed cost computations 		 and/or adjustments.  */
name|j
operator|=
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|classes
index|[
name|i
index|]
operator|=
name|classes
index|[
name|j
index|]
expr_stmt|;
name|allows_mem
index|[
name|i
index|]
operator|=
name|allows_mem
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If this matches the other operand, we have no added 		     cost and we win.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|,
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* If we can put the other operand into a register, add to 		     the cost of this alternative the cost to copy this 		     operand to the register used for the other operand.  */
elseif|else
if|if
condition|(
name|classes
index|[
name|j
index|]
operator|!=
name|NO_REGS
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
operator|,
name|win
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* This op is a pseudo but the one it matches is not.  */
comment|/* If we can't put the other operand into a register, this 		     alternative can't be used.  */
if|if
condition|(
name|classes
index|[
name|j
index|]
operator|==
name|NO_REGS
condition|)
name|alt_fail
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, add to the cost of this alternative the cost 		     to copy the other operand to the register used for this 		     operand.  */
else|else
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The costs of this operand are not the same as the other 		     operand since move costs are not symmetric.  Moreover, 		     if we cannot tie them, this alternative needs to do a 		     copy, which is one instruction.  */
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|this_op_costs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|class
index|]
operator|=
operator|(
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_OUT
condition|?
name|may_move_in_cost
index|[
name|mode
index|]
index|[
name|class
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
else|:
literal|0
operator|)
operator|+
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_IN
condition|?
name|may_move_out_cost
index|[
name|mode
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
name|class
index|]
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* If the alternative actually allows memory, make things 		     a bit cheaper since we won't need an extra insn to 		     load it.  */
name|pp
operator|->
name|mem_cost
operator|=
operator|(
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_IN
condition|?
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_OUT
condition|?
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
else|:
literal|0
operator|)
operator|-
name|allows_mem
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* If we have assigned a class to this register in our 		     first pass, add a cost to this alternative corresponding 		     to what we would add if this register were not in the 		     appropriate class.  */
if|if
condition|(
name|reg_pref
condition|)
name|alt_cost
operator|+=
operator|(
name|may_move_in_cost
index|[
name|mode
index|]
index|[
operator|(
name|unsigned
name|char
operator|)
name|reg_pref
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
operator|.
name|prefclass
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|op
argument_list|)
condition|)
name|alt_cost
operator|+=
literal|2
expr_stmt|;
comment|/* This is in place of ordinary cost computation 		     for this operand, so skip to the end of the 		     alternative (should be just one character).  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|constraints
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Scan all the constraint letters.  See if the operand matches 	     any of the constraints.  Collect the valid register classes 	     and see if this operand accepts memory.  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|','
case|:
break|break;
case|case
literal|'*'
case|:
comment|/* Ignore the next letter for this pass.  */
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|alt_cost
operator|+=
literal|2
expr_stmt|;
case|case
literal|'!'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
break|break;
case|case
literal|'p'
case|:
name|allows_addr
operator|=
literal|1
expr_stmt|;
name|win
operator|=
name|address_operand
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We know this operand is an address, so we want it to be 		     allocated to a register that can be the base of an 		     address, ie BASE_REG_CLASS.  */
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
case|case
literal|'V'
case|:
comment|/* It doesn't seem worth distinguishing between offsettable 		     and non-offsettable addresses here.  */
name|allows_mem
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_CONSTRAINT_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|,
name|p
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|,
name|p
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
name|allows_mem
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
case|case
literal|'r'
case|:
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT_STR
elseif|else
if|if
condition|(
name|EXTRA_CONSTRAINT_STR
argument_list|(
name|op
argument_list|,
name|c
argument_list|,
name|p
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|EXTRA_MEMORY_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
condition|)
block|{
comment|/* Every MEM can be reloaded to fit.  */
name|allows_mem
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
name|win
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|EXTRA_ADDRESS_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
condition|)
block|{
comment|/* Every address can be reloaded to fit.  */
name|allows_addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|address_operand
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* We know this operand is an address, so we want it to 			 be allocated to a register that can be the base of an 			 address, ie BASE_REG_CLASS.  */
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
index|]
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
name|p
operator|+=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
break|break;
block|}
name|constraints
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
comment|/* How we account for this operand now depends on whether it is  a 	     pseudo register or not.  If it is, we first check if any 	     register classes are valid.  If not, we ignore this alternative, 	     since we want to assume that all pseudos get allocated for 	     register preferencing.  If some register class is valid, compute 	     the costs of moving the pseudo into that class.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|NO_REGS
condition|)
block|{
comment|/* We must always fail if the operand is a REG, but 		     we did not find a suitable class.  		     Otherwise we may perform an uninitialized read 		     from this_op_costs after the `continue' statement 		     below.  */
name|alt_fail
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|this_op_costs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|class
index|]
operator|=
operator|(
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_OUT
condition|?
name|may_move_in_cost
index|[
name|mode
index|]
index|[
name|class
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
else|:
literal|0
operator|)
operator|+
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_IN
condition|?
name|may_move_out_cost
index|[
name|mode
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
name|class
index|]
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* If the alternative actually allows memory, make things 		     a bit cheaper since we won't need an extra insn to 		     load it.  */
name|pp
operator|->
name|mem_cost
operator|=
operator|(
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_IN
condition|?
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_OUT
condition|?
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
else|:
literal|0
operator|)
operator|-
name|allows_mem
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* If we have assigned a class to this register in our 		     first pass, add a cost to this alternative corresponding 		     to what we would add if this register were not in the 		     appropriate class.  */
if|if
condition|(
name|reg_pref
condition|)
name|alt_cost
operator|+=
operator|(
name|may_move_in_cost
index|[
name|mode
index|]
index|[
operator|(
name|unsigned
name|char
operator|)
name|reg_pref
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
operator|.
name|prefclass
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, if this alternative wins, either because we 	     have already determined that or if we have a hard register of 	     the proper class, there is no cost for this alternative.  */
elseif|else
if|if
condition|(
name|win
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* If registers are valid, the cost of this alternative includes 	     copying the object to and/or from a register.  */
elseif|else
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|!=
name|NO_REGS
condition|)
block|{
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_OUT
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_IN
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The only other way this alternative can be used is if this is a 	     constant that could be placed into memory.  */
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|allows_addr
operator|||
name|allows_mem
index|[
name|i
index|]
operator|)
condition|)
name|alt_cost
operator|+=
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|alt_fail
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|alt_fail
condition|)
continue|continue;
comment|/* Finally, update the costs with the information we've calculated 	 about this alternative.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|op_costs
index|[
name|i
index|]
decl_stmt|,
modifier|*
name|qq
init|=
operator|&
name|this_op_costs
index|[
name|i
index|]
decl_stmt|;
name|int
name|scale
init|=
literal|1
operator|+
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_INOUT
operator|)
decl_stmt|;
name|pp
operator|->
name|mem_cost
operator|=
name|MIN
argument_list|(
name|pp
operator|->
name|mem_cost
argument_list|,
operator|(
name|qq
operator|->
name|mem_cost
operator|+
name|alt_cost
operator|)
operator|*
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|class
index|]
operator|=
name|MIN
argument_list|(
name|pp
operator|->
name|cost
index|[
name|class
index|]
argument_list|,
operator|(
name|qq
operator|->
name|cost
index|[
name|class
index|]
operator|+
name|alt_cost
operator|)
operator|*
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this insn is a single set copying operand 1 to operand 0      and one operand is a pseudo with the other a hard reg or a pseudo      that prefers a register that is in its own register class then      we may want to adjust the cost of that register class to -1.       Avoid the adjustment if the source does not die to avoid stressing of      register allocator by preferrencing two colliding registers into single      class.       Also avoid the adjustment if a copy between registers of the class      is expensive (ten times the cost of a default copy is considered      arbitrarily expensive).  This avoids losing when the preferred class      is very expensive as the source of a copy instruction.  */
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|ops
index|[
literal|0
index|]
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|&&
name|ops
index|[
literal|1
index|]
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|ops
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|ops
index|[
operator|!
name|i
index|]
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|ops
index|[
operator|!
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|class
decl_stmt|;
name|unsigned
name|int
name|nr
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_pref
operator|!=
literal|0
condition|)
block|{
name|enum
name|reg_class
name|pref
init|=
name|reg_pref
index|[
name|regno
index|]
operator|.
name|prefclass
decl_stmt|;
if|if
condition|(
operator|(
name|reg_class_size
index|[
operator|(
name|unsigned
name|char
operator|)
name|pref
index|]
operator|==
operator|(
name|unsigned
operator|)
name|CLASS_MAX_NREGS
argument_list|(
name|pref
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
name|REGISTER_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|pref
argument_list|,
name|pref
argument_list|)
operator|<
literal|10
operator|*
literal|2
condition|)
name|op_costs
index|[
name|i
index|]
operator|.
name|cost
index|[
operator|(
name|unsigned
name|char
operator|)
name|pref
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|reg_class_size
index|[
name|class
index|]
operator|==
operator|(
name|unsigned
operator|)
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_class_size
index|[
name|class
index|]
operator|==
literal|1
condition|)
name|op_costs
index|[
name|i
index|]
operator|.
name|cost
index|[
name|class
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
operator|(
name|unsigned
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|;
name|nr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
operator|+
name|nr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|nr
operator|==
operator|(
name|unsigned
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|op_costs
index|[
name|i
index|]
operator|.
name|cost
index|[
name|class
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the cost of loading X into (if TO_P is nonzero) or from (if    TO_P is zero) a register of class CLASS in mode MODE.     X must not be a pseudo.  */
end_comment

begin_function
specifier|static
name|int
name|copy_cost
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|int
name|to_p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
name|enum
name|reg_class
name|secondary_class
init|=
name|NO_REGS
decl_stmt|;
endif|#
directive|endif
comment|/* If X is a SCRATCH, there is actually nothing to move since we are      assuming optimal allocation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|0
return|;
comment|/* Get the class we will actually use for a reload.  */
name|class
operator|=
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|x
argument_list|,
name|class
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
comment|/* If we need a secondary reload (we assume here that we are using      the secondary reload as an intermediate, not a scratch register), the      cost is that to load the input into the intermediate register, then      to copy them.  We use a special value of TO_P to avoid recursion.  */
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|to_p
operator|==
literal|1
condition|)
name|secondary_class
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
operator|!
name|to_p
condition|)
name|secondary_class
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|secondary_class
operator|!=
name|NO_REGS
condition|)
return|return
operator|(
name|move_cost
index|[
name|mode
index|]
index|[
operator|(
name|int
operator|)
name|secondary_class
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+
name|copy_cost
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|secondary_class
argument_list|,
literal|2
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_SECONDARY_RELOADS */
comment|/* For memory, use the memory move cost, for (hard) registers, use the      cost to move between the register classes, and use 2 for everything      else (constants).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
name|class
operator|==
name|NO_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class
argument_list|,
name|to_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|move_cost
index|[
name|mode
index|]
index|[
operator|(
name|int
operator|)
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
return|;
else|else
comment|/* If this is a constant, we may eventually want to call rtx_cost here.  */
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the pseudo registers we must reload into hard registers    in a subexpression of a memory address, X.     CLASS is the class that the register needs to be in and is either    BASE_REG_CLASS or INDEX_REG_CLASS.     SCALE is twice the amount to multiply the cost by (it is twice so we    can represent half-cost adjustments).  */
end_comment

begin_function
specifier|static
name|void
name|record_address_regs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|PLUS
case|:
comment|/* When we have an address that is a sum, 	 we must determine whether registers are "base" or "index" regs. 	 If there is a sum of two registers, we must choose one to be 	 the "base".  Luckily, we can use the REG_POINTER to make a good 	 choice most of the time.  We only need to do this on machines 	 that can have two registers in an address and where the base 	 and index register classes are different.  	 ??? This code used to set REGNO_POINTER_FLAG in some cases, but 	 that seems bogus since it should only be set when we are sure 	 the register is being used as a pointer.  */
block|{
name|rtx
name|arg0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|arg1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Look inside subregs.  */
if|if
condition|(
name|code0
operator|==
name|SUBREG
condition|)
name|arg0
operator|=
name|SUBREG_REG
argument_list|(
name|arg0
argument_list|)
operator|,
name|code0
operator|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|SUBREG
condition|)
name|arg1
operator|=
name|SUBREG_REG
argument_list|(
name|arg1
argument_list|)
operator|,
name|code1
operator|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* If this machine only allows one register per address, it must 	   be in the first operand.  */
if|if
condition|(
name|MAX_REGS_PER_ADDRESS
operator|==
literal|1
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If index and base registers are the same on this machine, just 	   record registers in any non-constant operands.  We assume here, 	   as well as in the tests below, that all addresses are in 	   canonical form.  */
elseif|else
if|if
condition|(
name|INDEX_REG_CLASS
operator|==
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|arg1
argument_list|)
condition|)
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/* If the second operand is a constant integer, it doesn't change 	   what class the first operand must be.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|||
name|code1
operator|==
name|CONST_DOUBLE
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If the second operand is a symbolic constant, the first operand 	   must be an index register.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|CONST
operator|||
name|code1
operator|==
name|LABEL_REF
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If both operands are registers but one is already a hard register 	   of index or base class, give the other the class that the hard 	   register is not.  */
ifdef|#
directive|ifdef
name|REG_OK_FOR_BASE_P
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|arg0
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg0
argument_list|)
operator|||
name|REG_OK_FOR_INDEX_P
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg0
argument_list|)
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|arg1
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg1
argument_list|)
operator|||
name|REG_OK_FOR_INDEX_P
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg1
argument_list|)
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If one operand is known to be a pointer, it must be the base 	   with the other operand the index.  Likewise if the other operand 	   is a MULT.  */
elseif|else
if|if
condition|(
operator|(
name|code0
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|arg0
argument_list|)
operator|)
operator|||
name|code1
operator|==
name|MULT
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|arg1
argument_list|)
operator|)
operator|||
name|code0
operator|==
name|MULT
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, count equal chances that each might be a base 	   or index register.  This case should be rare.  */
else|else
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Double the importance of a pseudo register that is incremented 	 or decremented, since it would take two extra insns 	 if it ends up in the wrong place.  */
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
literal|2
operator|*
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
literal|2
operator|*
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
comment|/* Double the importance of a pseudo register that is incremented 	 or decremented, since it would take two extra insns 	 if it ends up in the wrong place.  If the operand is a pseudo, 	 show it is being used in an INC_DEC context.  */
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|in_inc_dec
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|class
argument_list|,
literal|2
operator|*
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|costs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|->
name|mem_cost
operator|+=
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|Pmode
argument_list|,
name|class
argument_list|,
literal|1
argument_list|)
operator|*
name|scale
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|i
index|]
operator|+=
operator|(
name|may_move_in_cost
index|[
name|Pmode
index|]
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|*
name|scale
operator|)
operator|/
literal|2
expr_stmt|;
block|}
break|break;
default|default:
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
end_ifdef

begin_comment
comment|/* Return 1 if REG is valid as an auto-increment memory reference    to an object of MODE.  */
end_comment

begin_function
specifier|static
name|int
name|auto_inc_dec_reg_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_POST_DECREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_PRE_INCREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PRE_INC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|short
modifier|*
name|renumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|regno_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|reg_n_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate enough space to hold NUM_REGS registers for the tables used for    reg_scan and flow_analysis that are indexed by the register number.  If    NEW_P is nonzero, initialize all of the registers, otherwise only    initialize the new registers allocated.  The same table is kept from    function to function, only reallocating it when we need more room.  If    RENUMBER_P is nonzero, allocate the reg_renumber array also.  */
end_comment

begin_function
name|void
name|allocate_reg_info
parameter_list|(
name|size_t
name|num_regs
parameter_list|,
name|int
name|new_p
parameter_list|,
name|int
name|renumber_p
parameter_list|)
block|{
name|size_t
name|size_info
decl_stmt|;
name|size_t
name|size_renumber
decl_stmt|;
name|size_t
name|min
init|=
operator|(
name|new_p
operator|)
condition|?
literal|0
else|:
name|reg_n_max
decl_stmt|;
name|struct
name|reg_info_data
modifier|*
name|reg_data
decl_stmt|;
if|if
condition|(
name|num_regs
operator|>
name|regno_allocated
condition|)
block|{
name|size_t
name|old_allocated
init|=
name|regno_allocated
decl_stmt|;
name|regno_allocated
operator|=
name|num_regs
operator|+
operator|(
name|num_regs
operator|/
literal|20
operator|)
expr_stmt|;
comment|/* Add some slop space.  */
name|size_renumber
operator|=
name|regno_allocated
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_n_info
condition|)
block|{
name|VARRAY_REG_INIT
argument_list|(
name|reg_n_info
argument_list|,
name|regno_allocated
argument_list|,
literal|"reg_n_info"
argument_list|)
expr_stmt|;
name|renumber
operator|=
name|xmalloc
argument_list|(
name|size_renumber
argument_list|)
expr_stmt|;
name|reg_pref_buffer
operator|=
name|xmalloc
argument_list|(
name|regno_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_pref
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VARRAY_GROW
argument_list|(
name|reg_n_info
argument_list|,
name|regno_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_p
condition|)
comment|/* If we're zapping everything, no need to realloc.  */
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|renumber
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_pref
argument_list|)
expr_stmt|;
name|renumber
operator|=
name|xmalloc
argument_list|(
name|size_renumber
argument_list|)
expr_stmt|;
name|reg_pref_buffer
operator|=
name|xmalloc
argument_list|(
name|regno_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_pref
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renumber
operator|=
name|xrealloc
argument_list|(
name|renumber
argument_list|,
name|size_renumber
argument_list|)
expr_stmt|;
name|reg_pref_buffer
operator|=
name|xrealloc
argument_list|(
name|reg_pref_buffer
argument_list|,
name|regno_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_pref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|size_info
operator|=
operator|(
name|regno_allocated
operator|-
name|old_allocated
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|reg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|reg_info_data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|reg_info
argument_list|)
expr_stmt|;
name|reg_data
operator|=
name|xcalloc
argument_list|(
name|size_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_data
operator|->
name|min_index
operator|=
name|old_allocated
expr_stmt|;
name|reg_data
operator|->
name|max_index
operator|=
name|regno_allocated
operator|-
literal|1
expr_stmt|;
name|reg_data
operator|->
name|next
operator|=
name|reg_info_head
expr_stmt|;
name|reg_info_head
operator|=
name|reg_data
expr_stmt|;
block|}
name|reg_n_max
operator|=
name|num_regs
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|num_regs
condition|)
block|{
comment|/* Loop through each of the segments allocated for the actual 	 reg_info pages, and set up the pointers, zero the pages, etc.  */
for|for
control|(
name|reg_data
operator|=
name|reg_info_head
init|;
name|reg_data
operator|&&
name|reg_data
operator|->
name|max_index
operator|>=
name|min
condition|;
name|reg_data
operator|=
name|reg_data
operator|->
name|next
control|)
block|{
name|size_t
name|min_index
init|=
name|reg_data
operator|->
name|min_index
decl_stmt|;
name|size_t
name|max_index
init|=
name|reg_data
operator|->
name|max_index
decl_stmt|;
name|size_t
name|max
init|=
name|MIN
argument_list|(
name|max_index
argument_list|,
name|num_regs
argument_list|)
decl_stmt|;
name|size_t
name|local_min
init|=
name|min
operator|-
name|min_index
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|reg_data
operator|->
name|min_index
operator|>
name|num_regs
condition|)
continue|continue;
if|if
condition|(
name|min
operator|<
name|min_index
condition|)
name|local_min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|reg_data
operator|->
name|used_p
condition|)
comment|/* page just allocated with calloc */
name|reg_data
operator|->
name|used_p
operator|=
literal|1
expr_stmt|;
comment|/* no need to zero */
else|else
name|memset
argument_list|(
operator|&
name|reg_data
operator|->
name|data
index|[
name|local_min
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_info
argument_list|)
operator|*
operator|(
name|max
operator|-
name|min_index
operator|-
name|local_min
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_index
operator|+
name|local_min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|VARRAY_REG
argument_list|(
name|reg_n_info
argument_list|,
name|i
argument_list|)
operator|=
operator|&
name|reg_data
operator|->
name|data
index|[
name|i
operator|-
name|min_index
index|]
expr_stmt|;
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
name|renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_pref_buffer
index|[
name|i
index|]
operator|.
name|prefclass
operator|=
operator|(
name|char
operator|)
name|NO_REGS
expr_stmt|;
name|reg_pref_buffer
index|[
name|i
index|]
operator|.
name|altclass
operator|=
operator|(
name|char
operator|)
name|NO_REGS
expr_stmt|;
block|}
block|}
block|}
comment|/* If {pref,alt}class have already been allocated, update the pointers to      the newly realloced ones.  */
if|if
condition|(
name|reg_pref
condition|)
name|reg_pref
operator|=
name|reg_pref_buffer
expr_stmt|;
if|if
condition|(
name|renumber_p
condition|)
name|reg_renumber
operator|=
name|renumber
expr_stmt|;
comment|/* Tell the regset code about the new number of registers.  */
name|MAX_REGNO_REG_SET
argument_list|(
name|num_regs
argument_list|,
name|new_p
argument_list|,
name|renumber_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free up the space allocated by allocate_reg_info.  */
end_comment

begin_function
name|void
name|free_reg_info
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|reg_n_info
condition|)
block|{
name|struct
name|reg_info_data
modifier|*
name|reg_data
decl_stmt|;
name|struct
name|reg_info_data
modifier|*
name|reg_next
decl_stmt|;
name|VARRAY_FREE
argument_list|(
name|reg_n_info
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_data
operator|=
name|reg_info_head
init|;
name|reg_data
condition|;
name|reg_data
operator|=
name|reg_next
control|)
block|{
name|reg_next
operator|=
name|reg_data
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|reg_pref_buffer
argument_list|)
expr_stmt|;
name|reg_pref_buffer
operator|=
operator|(
expr|struct
name|reg_pref
operator|*
operator|)
literal|0
expr_stmt|;
name|reg_info_head
operator|=
operator|(
expr|struct
name|reg_info_data
operator|*
operator|)
literal|0
expr_stmt|;
name|renumber
operator|=
operator|(
name|short
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|regno_allocated
operator|=
literal|0
expr_stmt|;
name|reg_n_max
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the `regscan' pass of the compiler, run just before cse    and again just before loop.     It finds the first and last use of each pseudo-register    and records them in the vectors regno_first_uid, regno_last_uid    and counts the number of sets in the vector reg_n_sets.     REPEAT is nonzero the second time this is called.  */
end_comment

begin_comment
comment|/* Maximum number of parallel sets and clobbers in any insn in this fn.    Always at least 3, since the combiner could put that many together    and we want this to remain correct for all the remaining passes.    This corresponds to the maximum number of times note_stores will call    a function for any insn.  */
end_comment

begin_decl_stmt
name|int
name|max_parallel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used as a temporary to record the largest number of registers in    PARALLEL in a SET_DEST.  This is added to max_parallel.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_set_parallel
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|reg_scan
parameter_list|(
name|rtx
name|f
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|int
name|repeat
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_REG_SCAN
argument_list|)
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|nregs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|max_parallel
operator|=
literal|3
expr_stmt|;
name|max_set_parallel
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
name|max_parallel
condition|)
name|max_parallel
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_scan_mark_refs
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|max_parallel
operator|+=
name|max_set_parallel
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REG_SCAN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update 'regscan' information by looking at the insns    from FIRST to LAST.  Some new REGs have been created,    and any REG with number greater than OLD_MAX_REGNO is    such a REG.  We only update information for those.  */
end_comment

begin_function
name|void
name|reg_scan_update
parameter_list|(
name|rtx
name|first
parameter_list|,
name|rtx
name|last
parameter_list|,
name|unsigned
name|int
name|old_max_regno
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
name|max_parallel
condition|)
name|max_parallel
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_scan_mark_refs
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|old_max_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|,
name|old_max_regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* X is the expression to scan.  INSN is the insn it appears in.    NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.    We should only record information for REGs with numbers    greater than or equal to MIN_REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|reg_scan_mark_refs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|note_flag
parameter_list|,
name|unsigned
name|int
name|min_regno
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|REG
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|min_regno
condition|)
block|{
name|REGNO_LAST_NOTE_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note_flag
condition|)
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If we are called by reg_scan_update() (indicated by min_regno 	       being set), we also need to update the reference count.  */
if|if
condition|(
name|min_regno
condition|)
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EXPR_LIST
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN_LIST
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|min_regno
condition|)
block|{
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SET
case|:
comment|/* Count a set of the destination if it is a register.  */
for|for
control|(
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTEND
condition|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* For a PARALLEL, record the number of things (less the usual one for a 	 SET) that are set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
condition|)
name|max_set_parallel
operator|=
name|MAX
argument_list|(
name|max_set_parallel
argument_list|,
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|min_regno
condition|)
block|{
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
comment|/* If this is setting a pseudo from another pseudo or the sum of a 	 pseudo and a constant integer and the other pseudo is known to be 	 a pointer, set the destination to be a pointer as well.  	 Likewise if it is setting the destination from an address or from a 	 value equivalent to an address or to the sum of an address and 	 something else.  	 But don't do any of this if the pseudo corresponds to a user 	 variable since it should have already been set as a pointer based 	 on the type.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|min_regno
comment|/* If the destination pseudo is set more than once, then other 	     sets might not be to a pointer value (consider access to a 	     union in two threads of control in the presence of global 	     optimizations).  So only set REG_POINTER on the destination 	     pseudo if this is the only set of that pseudo.  */
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|REG_POINTER
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LO_SUM
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LO_SUM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|||
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
condition|)
name|REG_POINTER
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is setting a register from a register or from a simple 	 conversion of a register, propagate REG_EXPR.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|TRUNCATE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|src
argument_list|)
operator|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_ATTRS
argument_list|(
name|dest
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|src
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|dest
argument_list|)
operator|=
name|REG_ATTRS
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_ATTRS
argument_list|(
name|dest
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
name|set_reg_attrs_from_mem
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* ... fall through ...  */
default|default:
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
operator|&&
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|reg_scan_mark_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if C1 is a subset of C2, i.e., if every register in C1    is also in C2.  */
end_comment

begin_function
name|int
name|reg_class_subset_p
parameter_list|(
name|enum
name|reg_class
name|c1
parameter_list|,
name|enum
name|reg_class
name|c2
parameter_list|)
block|{
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c2
operator|==
name|ALL_REGS
condition|)
name|win
label|:
return|return
literal|1
return|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there is a register that is in both C1 and C2.  */
end_comment

begin_function
name|int
name|reg_classes_intersect_p
parameter_list|(
name|enum
name|reg_class
name|c1
parameter_list|,
name|enum
name|reg_class
name|c2
parameter_list|)
block|{
name|HARD_REG_SET
name|c
decl_stmt|;
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c1
operator|==
name|ALL_REGS
operator|||
name|c2
operator|==
name|ALL_REGS
condition|)
return|return
literal|1
return|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|lose
label|:
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Release any memory allocated by register sets.  */
end_comment

begin_function
name|void
name|regset_release_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap_release_memory
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
end_ifdef

begin_struct
struct|struct
name|subregs_of_mode_node
block|{
name|unsigned
name|int
name|block
decl_stmt|;
name|unsigned
name|char
name|modes
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|htab_t
name|subregs_of_mode
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|hashval_t
name|som_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|struct
name|subregs_of_mode_node
modifier|*
name|a
init|=
name|x
decl_stmt|;
return|return
name|a
operator|->
name|block
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|som_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
specifier|const
name|struct
name|subregs_of_mode_node
modifier|*
name|a
init|=
name|x
decl_stmt|;
specifier|const
name|struct
name|subregs_of_mode_node
modifier|*
name|b
init|=
name|y
decl_stmt|;
return|return
name|a
operator|->
name|block
operator|==
name|b
operator|->
name|block
return|;
block|}
end_function

begin_function
name|void
name|init_subregs_of_mode
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|subregs_of_mode
condition|)
name|htab_empty
argument_list|(
name|subregs_of_mode
argument_list|)
expr_stmt|;
else|else
name|subregs_of_mode
operator|=
name|htab_create
argument_list|(
literal|100
argument_list|,
name|som_hash
argument_list|,
name|som_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|record_subregs_of_mode
parameter_list|(
name|rtx
name|subreg
parameter_list|)
block|{
name|struct
name|subregs_of_mode_node
name|dummy
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|subreg
argument_list|)
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|subreg
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|dummy
operator|.
name|block
operator|=
name|regno
operator|&
operator|-
literal|8
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|subregs_of_mode
argument_list|,
operator|&
name|dummy
argument_list|,
name|dummy
operator|.
name|block
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|node
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|block
operator|=
name|regno
operator|&
operator|-
literal|8
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
block|}
name|node
operator|->
name|modes
index|[
name|mode
index|]
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|&
literal|7
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set bits in *USED which correspond to registers which can't change    their mode from FROM to any mode in which REGNO was encountered.  */
end_comment

begin_function
name|void
name|cannot_change_mode_set_regs
parameter_list|(
name|HARD_REG_SET
modifier|*
name|used
parameter_list|,
name|enum
name|machine_mode
name|from
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|struct
name|subregs_of_mode_node
name|dummy
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|enum
name|machine_mode
name|to
decl_stmt|;
name|unsigned
name|char
name|mask
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|dummy
operator|.
name|block
operator|=
name|regno
operator|&
operator|-
literal|8
expr_stmt|;
name|node
operator|=
name|htab_find_with_hash
argument_list|(
name|subregs_of_mode
argument_list|,
operator|&
name|dummy
argument_list|,
name|dummy
operator|.
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|regno
operator|&
literal|7
operator|)
expr_stmt|;
for|for
control|(
name|to
operator|=
name|VOIDmode
init|;
name|to
operator|<
name|NUM_MACHINE_MODES
condition|;
name|to
operator|++
control|)
if|if
condition|(
name|node
operator|->
name|modes
index|[
name|to
index|]
operator|&
name|mask
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|used
argument_list|,
name|i
argument_list|)
operator|&&
name|REG_CANNOT_CHANGE_MODE_P
argument_list|(
name|i
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|used
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if REGNO has had an invalid mode change in CLASS from FROM    mode.  */
end_comment

begin_function
name|bool
name|invalid_mode_change_p
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|from
parameter_list|)
block|{
name|struct
name|subregs_of_mode_node
name|dummy
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|enum
name|machine_mode
name|to
decl_stmt|;
name|unsigned
name|char
name|mask
decl_stmt|;
name|dummy
operator|.
name|block
operator|=
name|regno
operator|&
operator|-
literal|8
expr_stmt|;
name|node
operator|=
name|htab_find_with_hash
argument_list|(
name|subregs_of_mode
argument_list|,
operator|&
name|dummy
argument_list|,
name|dummy
operator|.
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|regno
operator|&
literal|7
operator|)
expr_stmt|;
for|for
control|(
name|to
operator|=
name|VOIDmode
init|;
name|to
operator|<
name|NUM_MACHINE_MODES
condition|;
name|to
operator|++
control|)
if|if
condition|(
name|node
operator|->
name|modes
index|[
name|to
index|]
operator|&
name|mask
condition|)
if|if
condition|(
name|CANNOT_CHANGE_MODE_CLASS
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CANNOT_CHANGE_MODE_CLASS */
end_comment

begin_include
include|#
directive|include
file|"gt-regclass.h"
end_include

end_unit

