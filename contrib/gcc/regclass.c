begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compute register class preferences for pseudo-registers.    Copyright (C) 1987, 88, 91-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains two passes of the compiler: reg_scan and reg_class.    It also defines some tables of information about the hardware registers    and a function init_reg_sets to initialize the tables.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_MOVE_COST
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|init_reg_sets_1
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_reg_modes
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we have auto-increment or auto-decrement and we can have secondary    reloads, we are not allowed to use classes requiring secondary    reloads for pseudos auto-incremented since reload can't handle it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|)
operator|||
name|defined
argument_list|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|)
end_if

begin_define
define|#
directive|define
name|FORBIDDEN_INC_DEC_CLASSES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Register tables used by many passes.  */
end_comment

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use (stack pointer, pc, frame pointer, etc.).    These are the registers that cannot be used to allocate    a pseudo reg for general use.  */
end_comment

begin_decl_stmt
name|char
name|fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|initial_fixed_regs
index|[]
init|=
name|FIXED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use or are clobbered by function calls.    These are the registers that cannot be used to allocate    a pseudo reg whose life crosses calls unless we are able    to save/restore them across the calls.  */
end_comment

begin_decl_stmt
name|char
name|call_used_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_used_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* HARD_REG_SET of registers we want to avoid caller saving.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|losing_caller_save_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|initial_call_used_regs
index|[]
init|=
name|CALL_USED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers that are    fixed use or call used registers that cannot hold quantities across    calls even if we are willing to save and restore them.  call fixed    registers are a subset of call used registers.  */
end_comment

begin_decl_stmt
name|char
name|call_fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of non-fixed registers.  */
end_comment

begin_decl_stmt
name|int
name|n_non_fixed_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are being used for global register decls.    These must be exempt from ordinary flow analysis    and are also considered fixed.  */
end_comment

begin_decl_stmt
name|char
name|global_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of register numbers in the order in which to try to use them.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
end_ifdef

begin_decl_stmt
name|int
name|reg_alloc_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For each reg class, a HARD_REG_SET saying which registers are in it.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|reg_class_contents
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same information, but as an array of unsigned ints.  We copy from    these unsigned ints to the table above.  We do this so the tm.h files    do not have to be aware of the wordsize for machines with<= 64 regs.  */
end_comment

begin_define
define|#
directive|define
name|N_REG_INTS
define|\
value|((FIRST_PSEUDO_REGISTER + (HOST_BITS_PER_INT - 1)) / HOST_BITS_PER_INT)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int_reg_class_contents
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_INTS
index|]
init|=
name|REG_CLASS_CONTENTS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, number of regs it contains.  */
end_comment

begin_decl_stmt
name|int
name|reg_class_size
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the containing classes.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_superclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the classes contained in it.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each pair of reg classes,    a largest reg class contained in their union.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subunion
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each pair of reg classes,    the smallest reg class containing their union.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_superunion
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array containing all of the register names */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_names
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each hard register, the widest mode object that it can contain.    This will be a MODE_INT mode if the register can hold integers.  Otherwise    it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the    register.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|reg_raw_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum cost of moving from a register in one class to a register in    another class.  Based on REGISTER_MOVE_COST.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move_cost
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but here we don't have to move if the first index is a subset    of the second so in that case the cost is zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|may_move_cost
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
end_ifdef

begin_comment
comment|/* These are the classes that regs which are auto-incremented or decremented    cannot be put in.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forbidden_inc_dec_class
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, is non-zero if (REG n) is used in an auto-inc or auto-dec    context.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|in_inc_dec
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FORBIDDEN_INC_DEC_CLASSES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
end_ifdef

begin_comment
comment|/* Sample MEM values for use by memory_move_secondary_cost.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|top_of_stack
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SECONDARY_RELOADS */
end_comment

begin_comment
comment|/* Linked list of reg_info structures allocated for reg_n_info array.    Grouping all of the allocated structures together in one lump    means only one call to bzero to clear them, rather than n smaller    calls.  */
end_comment

begin_struct
struct|struct
name|reg_info_data
block|{
name|struct
name|reg_info_data
modifier|*
name|next
decl_stmt|;
comment|/* next set of reg_info structures */
name|size_t
name|min_index
decl_stmt|;
comment|/* minimum index # */
name|size_t
name|max_index
decl_stmt|;
comment|/* maximum index # */
name|char
name|used_p
decl_stmt|;
comment|/* non-zero if this has been used previously */
name|reg_info
name|data
index|[
literal|1
index|]
decl_stmt|;
comment|/* beginning of the reg_info data */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|reg_info_data
modifier|*
name|reg_info_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function called only once to initialize the above data on reg usage.    Once this is done, various switches may override.  */
end_comment

begin_function
name|void
name|init_reg_sets
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* First copy the register information from the initial int form into      the regsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|int_reg_class_contents
index|[
name|i
index|]
index|[
name|j
operator|/
name|HOST_BITS_PER_INT
index|]
operator|&
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|j
operator|%
name|HOST_BITS_PER_INT
operator|)
operator|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|initial_fixed_regs
argument_list|,
name|fixed_regs
argument_list|,
sizeof|sizeof
name|fixed_regs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|initial_call_used_regs
argument_list|,
name|call_used_regs
argument_list|,
sizeof|sizeof
name|call_used_regs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|global_regs
argument_list|,
sizeof|sizeof
name|global_regs
argument_list|)
expr_stmt|;
comment|/* Do any additional initialization regsets may need */
name|INIT_ONCE_REG_SET
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After switches have been processed, which perhaps alter    `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */
end_comment

begin_function
specifier|static
name|void
name|init_reg_sets_1
parameter_list|()
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This macro allows the fixed or call-used registers      and the register classes to depend on target flags.  */
ifdef|#
directive|ifdef
name|CONDITIONAL_REGISTER_USAGE
name|CONDITIONAL_REGISTER_USAGE
expr_stmt|;
endif|#
directive|endif
comment|/* Compute number of hard regs in each class.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_class_size
argument_list|,
sizeof|sizeof
name|reg_class_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|reg_class_size
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* Initialize the table of subunions.      reg_class_subunion[I][J] gets the largest-numbered reg-class      that is contained in the union of classes I and J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|c
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|N_REG_CLASSES
condition|;
name|k
operator|++
control|)
block|{
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|c
argument_list|,
name|subclass1
argument_list|)
expr_stmt|;
continue|continue;
name|subclass1
label|:
comment|/* keep the largest subclass */
comment|/* SPEE 900308 */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|i
index|]
index|[
name|j
index|]
index|]
argument_list|,
name|subclass2
argument_list|)
expr_stmt|;
name|reg_class_subunion
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|k
expr_stmt|;
name|subclass2
label|:
empty_stmt|;
block|}
block|}
block|}
comment|/* Initialize the table of superunions.      reg_class_superunion[I][J] gets the smallest-numbered reg-class      containing the union of classes I and J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|c
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|N_REG_CLASSES
condition|;
name|k
operator|++
control|)
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|superclass
argument_list|)
expr_stmt|;
name|superclass
label|:
name|reg_class_superunion
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|k
expr_stmt|;
block|}
block|}
comment|/* Initialize the tables of subclasses and superclasses of each reg class.      First clear the whole table, then add the elements as they are found.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|reg_class_superclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
name|reg_class_subclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
continue|continue;
name|subclass
label|:
comment|/* Reg class I is a subclass of J. 	     Add J to the table of superclasses of I.  */
name|p
operator|=
operator|&
name|reg_class_superclasses
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|j
expr_stmt|;
comment|/* Add I to the table of superclasses of J.  */
name|p
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|i
expr_stmt|;
block|}
block|}
comment|/* Initialize "constant" tables.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|fixed_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fixed_regs
argument_list|,
name|call_fixed_regs
argument_list|,
sizeof|sizeof
name|call_fixed_regs
argument_list|)
expr_stmt|;
name|n_non_fixed_regs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|n_non_fixed_regs
operator|++
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|losing_caller_save_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the move cost table.  Find every subset of each class      and take the maximum cost of moving any subset to any other.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|int
name|cost
init|=
name|i
operator|==
name|j
condition|?
literal|2
else|:
name|REGISTER_MOVE_COST
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
for|for
control|(
name|p2
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p2
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p2
operator|++
control|)
if|if
condition|(
operator|*
name|p2
operator|!=
name|i
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|REGISTER_MOVE_COST
argument_list|(
name|i
argument_list|,
operator|*
name|p2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
operator|&
name|reg_class_subclasses
index|[
name|i
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p1
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
name|j
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|REGISTER_MOVE_COST
argument_list|(
operator|*
name|p1
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p2
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p2
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p2
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|REGISTER_MOVE_COST
argument_list|(
operator|*
name|p1
argument_list|,
operator|*
name|p2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|move_cost
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cost
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
name|may_move_cost
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cost
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the table of register modes.    These values are used to record death information for individual registers    (as opposed to a multi-register mode).  */
end_comment

begin_function
specifier|static
name|void
name|init_reg_modes
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|reg_raw_mode
index|[
name|i
index|]
operator|=
name|choose_hard_reg_mode
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we couldn't find a valid mode, just use the previous mode.          ??? One situation in which we need to do this is on the mips where 	 HARD_REGNO_NREGS (fpreg, [SD]Fmode) returns 2.  Ideally we'd like 	 to use DF mode for the even registers and VOIDmode for the odd 	 (for the cpu models where the odd ones are inaccessible).  */
if|if
condition|(
name|reg_raw_mode
index|[
name|i
index|]
operator|==
name|VOIDmode
condition|)
name|reg_raw_mode
index|[
name|i
index|]
operator|=
name|i
operator|==
literal|0
condition|?
name|word_mode
else|:
name|reg_raw_mode
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish initializing the register sets and    initialize the register modes.  */
end_comment

begin_function
name|void
name|init_regs
parameter_list|()
block|{
comment|/* This finishes what was started by init_reg_sets, but couldn't be done      until after register usage was specified.  */
name|init_reg_sets_1
argument_list|()
expr_stmt|;
name|init_reg_modes
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
block|{
comment|/* Make some fake stack-frame MEM references for use in        memory_move_secondary_cost.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MACHINE_MODE
condition|;
name|i
operator|++
control|)
name|top_of_stack
index|[
name|i
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|i
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
end_ifdef

begin_comment
comment|/* Compute extra cost of moving registers to/from memory due to reloads.    Only needed if secondary reloads are required for memory moves.  */
end_comment

begin_function
name|int
name|memory_move_secondary_cost
parameter_list|(
name|mode
parameter_list|,
name|class
parameter_list|,
name|in
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|in
decl_stmt|;
block|{
name|enum
name|reg_class
name|altclass
decl_stmt|;
name|int
name|partial_cost
init|=
literal|0
decl_stmt|;
comment|/* We need a memory reference to feed to SECONDARY... macros.  */
name|rtx
name|mem
init|=
name|top_of_stack
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|in
condition|)
block|{
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
name|altclass
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|#
directive|else
name|altclass
operator|=
name|NO_REGS
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
name|altclass
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|#
directive|else
name|altclass
operator|=
name|NO_REGS
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|altclass
operator|==
name|NO_REGS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|in
condition|)
name|partial_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|altclass
argument_list|,
name|class
argument_list|)
expr_stmt|;
else|else
name|partial_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|class
argument_list|,
name|altclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|altclass
condition|)
comment|/* This isn't simply a copy-to-temporary situation.  Can't guess        what it is, so MEMORY_MOVE_COST really ought not to be calling        here in that case.         I'm tempted to put in an abort here, but returning this will        probably only give poor estimates, which is what we would've        had before this code anyways.  */
return|return
name|partial_cost
return|;
comment|/* Check if the secondary reload register will also need a      secondary reload.  */
return|return
name|memory_move_secondary_cost
argument_list|(
name|mode
argument_list|,
name|altclass
argument_list|,
name|in
argument_list|)
operator|+
name|partial_cost
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a machine mode that is legitimate for hard reg REGNO and large    enough to save nregs.  If we can't find one, return VOIDmode.  */
end_comment

begin_function
name|enum
name|machine_mode
name|choose_hard_reg_mode
parameter_list|(
name|regno
parameter_list|,
name|nregs
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|enum
name|machine_mode
name|found_mode
init|=
name|VOIDmode
decl_stmt|,
name|mode
decl_stmt|;
comment|/* We first look for the largest integer mode that can be validly      held in REGNO.  If none, we look for the largest floating-point mode.      If we still didn't find a valid mode, try CCmode.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|found_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|found_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|found_mode
return|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|found_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|found_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|found_mode
return|;
if|if
condition|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|CCmode
argument_list|)
operator|==
name|nregs
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|CCmode
argument_list|)
condition|)
return|return
name|CCmode
return|;
comment|/* We can't find a mode valid for this register.  */
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Specify the usage characteristics of the register named NAME.    It should be a fixed register if FIXED and a    call-used register if CALL_USED.  */
end_comment

begin_function
name|void
name|fix_register
parameter_list|(
name|name
parameter_list|,
name|fixed
parameter_list|,
name|call_used
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fixed
decl_stmt|,
name|call_used
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Decode the name and update the primary form of      the register info.  */
if|if
condition|(
operator|(
name|i
operator|=
name|decode_reg_name
argument_list|(
name|name
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
name|STACK_POINTER_REGNUM
ifdef|#
directive|ifdef
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
else|#
directive|else
operator|||
name|i
operator|==
name|FRAME_POINTER_REGNUM
endif|#
directive|endif
operator|)
operator|&&
operator|(
name|fixed
operator|==
literal|0
operator|||
name|call_used
operator|==
literal|0
operator|)
condition|)
block|{
specifier|static
name|char
modifier|*
name|what_option
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|"call-saved"
block|,
literal|"call-used"
block|}
block|,
block|{
literal|"no-such-option"
block|,
literal|"fixed"
block|}
block|}
decl_stmt|;
name|error
argument_list|(
literal|"can't use '%s' as a %s register"
argument_list|,
name|name
argument_list|,
name|what_option
index|[
name|fixed
index|]
index|[
name|call_used
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixed_regs
index|[
name|i
index|]
operator|=
name|fixed
expr_stmt|;
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_used
expr_stmt|;
block|}
block|}
else|else
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark register number I as global.  */
end_comment

begin_function
name|void
name|globalize_reg
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"register used for two global register variables"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|warning
argument_list|(
literal|"call-clobbered register used for global register variable"
argument_list|)
expr_stmt|;
name|global_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If already fixed, nothing else to do.  */
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
return|return;
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|n_non_fixed_regs
operator|--
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Now the data and code for the `regclass' pass, which happens    just before local-alloc.  */
end_comment

begin_comment
comment|/* The `costs' struct records the cost of using a hard register of each class    and of using memory for each pseudo.  We use this data to set up    register class preferences.  */
end_comment

begin_struct
struct|struct
name|costs
block|{
name|int
name|cost
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|mem_cost
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record the cost of each class for each pseudo.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|costs
modifier|*
name|costs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialized once, and used to initialize cost values for each insn.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|costs
name|init_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the same data by operand number, accumulated for each alternative    in an insn.  The contribution to a pseudo is that of the minimum-cost    alternative.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|costs
name|op_costs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (enum reg_class) prefclass[R] is the preferred class for pseudo number R.    This is available after `regclass' is run.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* altclass[R] is a register class that we should use for allocating    pseudo number R if no register in the preferred class is available.    If no register in this class is available, memory is preferred.     It might appear to be more general to have a bitmask of classes here,    but since it is recommended that there be a class corresponding to the    union of most major pair of classes, that generality is not required.      This is available after `regclass' is run.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|altclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocated buffers for prefclass and altclass. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefclass_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|altclass_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the depth of loops that we are in.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Account for the fact that insns within a loop are executed very commonly,    but don't keep doing this as loops go too deep.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|scan_one_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_reg_classes
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|machine_mode
operator|*
operator|,
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|copy_cost
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|reg_class
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_address_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|reg_class
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|auto_inc_dec_reg_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|reg_scan_mark_refs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the reg_class in which pseudo reg number REGNO is best allocated.    This function is sometimes called before the info has been computed.    When that happens, just return GENERAL_REGS, which is innocuous.  */
end_comment

begin_function
name|enum
name|reg_class
name|reg_preferred_class
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|prefclass
operator|==
literal|0
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
operator|(
expr|enum
name|reg_class
operator|)
name|prefclass
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
name|enum
name|reg_class
name|reg_alternate_class
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|prefclass
operator|==
literal|0
condition|)
return|return
name|ALL_REGS
return|;
return|return
operator|(
expr|enum
name|reg_class
operator|)
name|altclass
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* Initialize some global data for this pass.  */
end_comment

begin_function
name|void
name|regclass_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|init_cost
operator|.
name|mem_cost
operator|=
literal|10000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|init_cost
operator|.
name|cost
index|[
name|i
index|]
operator|=
literal|10000
expr_stmt|;
comment|/* This prevents dump_flow_info from losing if called      before regclass is run.  */
name|prefclass
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of regclass, processes one insn INSN.  Scan it and record each    time it would save code to put a certain register in a certain class.    PASS, when nonzero, inhibits some optimizations which need only be done    once.    Return the last insn processed, so that the scan can be continued from    there.  */
end_comment

begin_function
specifier|static
name|rtx
name|scan_one_insn
parameter_list|(
name|insn
parameter_list|,
name|pass
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|pass
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|pat_code
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|modes
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|subreg_changes_size
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|note
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Show that an insn inside a loop is likely to be executed three      times more than insns outside a loop.  This is much more aggressive      than the assumptions made elsewhere and is being tried as an      experiment.  */
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
operator|,
name|loop_cost
operator|=
literal|1
operator|<<
operator|(
literal|2
operator|*
name|MIN
argument_list|(
name|loop_depth
argument_list|,
literal|5
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
operator|,
name|loop_cost
operator|=
literal|1
operator|<<
operator|(
literal|2
operator|*
name|MIN
argument_list|(
name|loop_depth
argument_list|,
literal|5
argument_list|)
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
name|insn
return|;
name|pat_code
operator|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat_code
operator|==
name|USE
operator|||
name|pat_code
operator|==
name|CLOBBER
operator|||
name|pat_code
operator|==
name|ASM_INPUT
operator|||
name|pat_code
operator|==
name|ADDR_VEC
operator|||
name|pat_code
operator|==
name|ADDR_DIFF_VEC
condition|)
return|return
name|insn
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|constraints
index|[
name|i
index|]
operator|=
name|recog_constraints
index|[
name|i
index|]
expr_stmt|;
name|modes
index|[
name|i
index|]
operator|=
name|recog_operand_mode
index|[
name|i
index|]
expr_stmt|;
block|}
name|memset
argument_list|(
name|subreg_changes_size
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|subreg_changes_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this insn loads a parameter from its stack slot, then      it represents a savings, rather than a cost, if the      parameter is stored in memory.  Record this fact.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|costs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|mem_cost
operator|-=
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|GENERAL_REGS
argument_list|,
literal|1
argument_list|)
operator|*
name|loop_cost
operator|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|loop_cost
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
comment|/* Improve handling of two-address insns such as      (set X (ashift CONST Y)) where CONST must be made to      match X. Change it into two insns: (set X CONST)      (set X (ashift X Y)).  If we left this for reloading, it      would probably get three insns because X and Y might go      in the same place. This prevents X and Y from receiving      the same hard reg.       We can only do this if the modes of operands 0 and 1      (which might not be the same) are tieable and we only need      do this during our first pass.  */
if|if
condition|(
name|pass
operator|==
literal|0
operator|&&
name|optimize
operator|&&
name|recog_n_operands
operator|>=
literal|3
operator|&&
name|recog_constraints
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|recog_constraints
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|recog_operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|recog_operand
index|[
literal|2
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|recog_operand_mode
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|previnsn
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|gen_lowpart
argument_list|(
name|recog_operand_mode
index|[
literal|1
index|]
argument_list|,
name|recog_operand
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|newinsn
init|=
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|dest
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If this insn was the start of a basic block, 	 include the new insn in that block. 	 We need not check for code_label here; 	 while a basic block can start with a code_label, 	 INSN could not be at the beginning of that block.  */
if|if
condition|(
name|previnsn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|previnsn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
if|if
condition|(
name|insn
operator|==
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
condition|)
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|newinsn
expr_stmt|;
block|}
comment|/* This makes one more setting of new insns's dest.  */
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|++
expr_stmt|;
operator|*
name|recog_operand_loc
index|[
literal|1
index|]
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_n_dups
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|recog_dup_num
index|[
name|i
index|]
operator|==
literal|1
condition|)
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
return|return
name|PREV_INSN
argument_list|(
name|newinsn
argument_list|)
return|;
block|}
comment|/* If we get here, we are set up to record the costs of all the      operands for this insn.  Start by initializing the costs.      Then handle any address registers.  Finally record the desired      classes for any pseudos, doing it twice if some pair of      operands are commutative.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|op_costs
index|[
name|i
index|]
operator|=
name|init_cost
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|modes
index|[
name|i
index|]
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
condition|)
name|subreg_changes_size
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|recog_operand
index|[
name|i
index|]
operator|=
name|inner
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|loop_cost
operator|*
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
name|record_address_regs
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|loop_cost
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for commutative in a separate loop so everything will      have been initialized.  We must do this even if one operand      is a constant--see addsi3 in m68k.md.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
specifier|const
name|char
modifier|*
name|xconstraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Handle commutative operands by swapping the constraints. 	   We assume the modes are the same.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_n_operands
condition|;
name|j
operator|++
control|)
name|xconstraints
index|[
name|j
index|]
operator|=
name|constraints
index|[
name|j
index|]
expr_stmt|;
name|xconstraints
index|[
name|i
index|]
operator|=
name|constraints
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|xconstraints
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
name|record_reg_classes
argument_list|(
name|recog_n_alternatives
argument_list|,
name|recog_n_operands
argument_list|,
name|recog_operand
argument_list|,
name|modes
argument_list|,
name|subreg_changes_size
argument_list|,
name|xconstraints
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|record_reg_classes
argument_list|(
name|recog_n_alternatives
argument_list|,
name|recog_n_operands
argument_list|,
name|recog_operand
argument_list|,
name|modes
argument_list|,
name|subreg_changes_size
argument_list|,
name|constraints
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Now add the cost for each operand to the total costs for      its register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|struct
name|costs
modifier|*
name|p
init|=
operator|&
name|costs
index|[
name|regno
index|]
decl_stmt|,
modifier|*
name|q
init|=
operator|&
name|op_costs
index|[
name|i
index|]
decl_stmt|;
name|p
operator|->
name|mem_cost
operator|+=
name|q
operator|->
name|mem_cost
operator|*
name|loop_cost
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
name|p
operator|->
name|cost
index|[
name|j
index|]
operator|+=
name|q
operator|->
name|cost
index|[
name|j
index|]
operator|*
name|loop_cost
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* This is a pass of the compiler that scans all instructions    and calculates the preferred class for each pseudo-register.    This information can be accessed later by calling `reg_preferred_class'.    This pass comes just before local register allocation.  */
end_comment

begin_function
name|void
name|regclass
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|costs
operator|=
operator|(
expr|struct
name|costs
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|costs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|in_inc_dec
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
comment|/* Initialize information about which register classes can be used for      pseudos that are auto-incremented or auto-decremented.  It would      seem better to put this in init_reg_sets, but we need to be able      to allocate rtx, which we can't do that early.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|r
init|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|m
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|REGNO
argument_list|(
name|r
argument_list|)
operator|=
name|j
expr_stmt|;
for|for
control|(
name|m
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|m
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|m
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|m
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* If a register is not directly suitable for an 		     auto-increment or decrement addressing mode and 		     requires secondary reloads, disallow its class from 		     being used in such addresses.  */
if|if
condition|(
operator|(
literal|0
ifdef|#
directive|ifdef
name|SECONDARY_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_RELOAD_CLASS
argument_list|(
name|BASE_REG_CLASS
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
else|#
directive|else
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|BASE_REG_CLASS
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|BASE_REG_CLASS
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
endif|#
directive|endif
operator|)
operator|&&
operator|!
name|auto_inc_dec_reg_p
argument_list|(
name|r
argument_list|,
name|m
argument_list|)
condition|)
name|forbidden_inc_dec_class
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* FORBIDDEN_INC_DEC_CLASSES */
comment|/* Normally we scan the insns once and determine the best class to use for      each register.  However, if -fexpensive_optimizations are on, we do so      twice, the second time using the tentative best classes to guide the      selection.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
name|flag_expensive_optimizations
condition|;
name|pass
operator|++
control|)
block|{
comment|/* Zero out our accumulation of the cost of each class for each reg.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|costs
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|costs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|bzero
argument_list|(
name|in_inc_dec
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loop_depth
operator|=
literal|0
operator|,
name|loop_cost
operator|=
literal|1
expr_stmt|;
comment|/* Scan the instructions and record each time it would 	 save code to put a certain register in a certain class.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|insn
operator|=
name|scan_one_insn
argument_list|(
name|insn
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
comment|/* Now for each register look at how desirable each class is 	 and find which class is preferred.  Store that in 	 `prefclass[REGNO]'.  Record in `altclass[REGNO]' the largest register 	 class any of whose registers is better than memory.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|prefclass
operator|=
name|prefclass_buffer
expr_stmt|;
name|altclass
operator|=
name|altclass_buffer
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|best_cost
init|=
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|-
literal|2
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|enum
name|reg_class
name|best
init|=
name|ALL_REGS
decl_stmt|,
name|alt
init|=
name|NO_REGS
decl_stmt|;
comment|/* This is an enum reg_class, but we call it an int 	     to save lots of casts.  */
specifier|register
name|int
name|class
decl_stmt|;
specifier|register
name|struct
name|costs
modifier|*
name|p
init|=
operator|&
name|costs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|class
operator|=
operator|(
name|int
operator|)
name|ALL_REGS
operator|-
literal|1
init|;
name|class
operator|>
literal|0
condition|;
name|class
operator|--
control|)
block|{
comment|/* Ignore classes that are too small for this operand or 		 invalid for a operand that was auto-incremented.  */
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
name|reg_class_size
index|[
name|class
index|]
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
operator|||
operator|(
name|in_inc_dec
index|[
name|i
index|]
operator|&&
name|forbidden_inc_dec_class
index|[
name|class
index|]
operator|)
endif|#
directive|endif
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|p
operator|->
name|cost
index|[
name|class
index|]
expr_stmt|;
name|best
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|==
name|best_cost
condition|)
name|best
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|best
index|]
index|[
name|class
index|]
expr_stmt|;
block|}
comment|/* Record the alternate register class; i.e., a class for which 	     every register in it is better than using memory.  If adding a 	     class would make a smaller class (i.e., no union of just those 	     classes exists), skip that class.  The major unions of classes 	     should be provided as a register class.  Don't do this if we 	     will be doing it again later.  */
if|if
condition|(
name|pass
operator|==
literal|1
operator|||
operator|!
name|flag_expensive_optimizations
condition|)
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|<
name|p
operator|->
name|mem_cost
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|alt
index|]
index|[
name|class
index|]
index|]
operator|>
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|alt
index|]
operator|)
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
operator|&&
operator|!
operator|(
name|in_inc_dec
index|[
name|i
index|]
operator|&&
name|forbidden_inc_dec_class
index|[
name|class
index|]
operator|)
endif|#
directive|endif
condition|)
name|alt
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|alt
index|]
index|[
name|class
index|]
expr_stmt|;
comment|/* If we don't add any classes, nothing to try.  */
if|if
condition|(
name|alt
operator|==
name|best
condition|)
name|alt
operator|=
name|NO_REGS
expr_stmt|;
comment|/* We cast to (int) because (char) hits bugs in some compilers.  */
name|prefclass
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|best
expr_stmt|;
name|altclass
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|alt
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REGISTER_CONSTRAINTS */
name|free
argument_list|(
name|costs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Record the cost of using memory or registers of various classes for    the operands in INSN.     N_ALTS is the number of alternatives.     N_OPS is the number of operands.     OPS is an array of the operands.     MODES are the modes of the operands, in case any are VOIDmode.     CONSTRAINTS are the constraints to use for the operands.  This array    is modified by this procedure.     This procedure works alternative by alternative.  For each alternative    we assume that we will be able to allocate all pseudos to their ideal    register class and calculate the cost of using that alternative.  Then    we compute for each operand that is a pseudo-register, the cost of     having the pseudo allocated to each register class and using it in that    alternative.  To this cost is added the cost of the alternative.     The cost of each class for this insn is its lowest cost among all the    alternatives.  */
end_comment

begin_function
specifier|static
name|void
name|record_reg_classes
parameter_list|(
name|n_alts
parameter_list|,
name|n_ops
parameter_list|,
name|ops
parameter_list|,
name|modes
parameter_list|,
name|subreg_changes_size
parameter_list|,
name|constraints
parameter_list|,
name|insn
parameter_list|)
name|int
name|n_alts
decl_stmt|;
name|int
name|n_ops
decl_stmt|;
name|rtx
modifier|*
name|ops
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|modes
decl_stmt|;
name|char
modifier|*
name|subreg_changes_size
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|alt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Process each alternative, each time minimizing an operand's cost with      the cost for each operand in that alternative.  */
for|for
control|(
name|alt
operator|=
literal|0
init|;
name|alt
operator|<
name|n_alts
condition|;
name|alt
operator|++
control|)
block|{
name|struct
name|costs
name|this_op_costs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|alt_fail
init|=
literal|0
decl_stmt|;
name|int
name|alt_cost
init|=
literal|0
decl_stmt|;
name|enum
name|reg_class
name|classes
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|class
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|op
init|=
name|ops
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|modes
index|[
name|i
index|]
decl_stmt|;
name|int
name|allows_addr
init|=
literal|0
decl_stmt|;
name|int
name|allows_mem
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Initially show we know nothing about the register class.  */
name|classes
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
comment|/* If this operand has no constraints at all, we can conclude  	     nothing about it since anything is valid.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|this_op_costs
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
name|this_op_costs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this alternative is only relevant when this operand 	     matches a previous operand, we do different things depending 	     on whether this operand is a pseudo-reg or not.  We must process 	     any modifiers for the operand before we can make this test.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|||
operator|*
name|p
operator|==
literal|'='
operator|||
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'&'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'0'
operator|+
name|i
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|','
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|j
operator|=
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|classes
index|[
name|i
index|]
operator|=
name|classes
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If this matches the other operand, we have no added 		     cost and we win.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|,
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* If we can put the other operand into a register, add to 		     the cost of this alternative the cost to copy this 		     operand to the register used for the other operand.  */
elseif|else
if|if
condition|(
name|classes
index|[
name|j
index|]
operator|!=
name|NO_REGS
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
operator|,
name|win
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* This op is a pseudo but the one it matches is not.  */
comment|/* If we can't put the other operand into a register, this 		     alternative can't be used.  */
if|if
condition|(
name|classes
index|[
name|j
index|]
operator|==
name|NO_REGS
condition|)
name|alt_fail
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, add to the cost of this alternative the cost 		     to copy the other operand to the register used for this 		     operand.  */
else|else
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The costs of this operand are the same as that of the 		     other operand.  However, if we cannot tie them, this 		     alternative needs to do a copy, which is one 		     instruction.  */
name|this_op_costs
index|[
name|i
index|]
operator|=
name|this_op_costs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|op
argument_list|)
condition|)
name|alt_cost
operator|+=
literal|2
expr_stmt|;
comment|/* This is in place of ordinary cost computation 		     for this operand, so skip to the end of the 		     alternative (should be just one character).  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|constraints
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Scan all the constraint letters.  See if the operand matches 	     any of the constraints.  Collect the valid register classes 	     and see if this operand accepts memory.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* Ignore the next letter for this pass.  */
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|alt_cost
operator|+=
literal|2
expr_stmt|;
case|case
literal|'!'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
break|break;
case|case
literal|'p'
case|:
name|allows_addr
operator|=
literal|1
expr_stmt|;
name|win
operator|=
name|address_operand
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We know this operand is an address, so we want it to be 		   allocated to a register that can be the base of an 		   address, ie BASE_REG_CLASS.  */
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|BASE_REG_CLASS
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
case|case
literal|'V'
case|:
comment|/* It doesn't seem worth distinguishing between offsettable 		   and non-offsettable addresses here.  */
name|allows_mem
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
comment|/* Match any floating double constant, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|win
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'g'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
name|allows_mem
operator|=
literal|1
expr_stmt|;
case|case
literal|'r'
case|:
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
block|}
name|constraints
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_SIZE
comment|/* If we noted a subreg earlier, and the selected class is a  	     subclass of CLASS_CANNOT_CHANGE_SIZE, zap it.  */
if|if
condition|(
name|subreg_changes_size
index|[
name|i
index|]
operator|&&
operator|(
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_SIZE
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
operator|==
name|CLASS_CANNOT_CHANGE_SIZE
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
endif|#
directive|endif
comment|/* How we account for this operand now depends on whether it is  a 	     pseudo register or not.  If it is, we first check if any 	     register classes are valid.  If not, we ignore this alternative, 	     since we want to assume that all pseudos get allocated for 	     register preferencing.  If some register class is valid, compute 	     the costs of moving the pseudo into that class.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|NO_REGS
condition|)
block|{
comment|/* We must always fail if the operand is a REG, but 		       we did not find a suitable class.  		       Otherwise we may perform an uninitialized read 		       from this_op_costs after the `continue' statement 		       below.  */
name|alt_fail
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|this_op_costs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|class
index|]
operator|=
name|may_move_cost
index|[
name|class
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* If the alternative actually allows memory, make things 		     a bit cheaper since we won't need an extra insn to 		     load it.  */
name|pp
operator|->
name|mem_cost
operator|=
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|-
name|allows_mem
operator|)
expr_stmt|;
comment|/* If we have assigned a class to this register in our 		     first pass, add a cost to this alternative corresponding 		     to what we would add if this register were not in the 		     appropriate class.  */
if|if
condition|(
name|prefclass
condition|)
name|alt_cost
operator|+=
name|may_move_cost
index|[
operator|(
name|unsigned
name|char
operator|)
name|prefclass
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
block|}
comment|/* Otherwise, if this alternative wins, either because we 	     have already determined that or if we have a hard register of 	     the proper class, there is no cost for this alternative.  */
elseif|else
if|if
condition|(
name|win
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* If registers are valid, the cost of this alternative includes 	     copying the object to and/or from a register.  */
elseif|else
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|!=
name|NO_REGS
condition|)
block|{
if|if
condition|(
name|recog_op_type
index|[
name|i
index|]
operator|!=
name|OP_OUT
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_op_type
index|[
name|i
index|]
operator|!=
name|OP_IN
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The only other way this alternative can be used is if this is a 	     constant that could be placed into memory.  */
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|allows_addr
operator|||
name|allows_mem
operator|)
condition|)
name|alt_cost
operator|+=
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|alt_fail
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|alt_fail
condition|)
continue|continue;
comment|/* Finally, update the costs with the information we've calculated 	 about this alternative.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|op_costs
index|[
name|i
index|]
decl_stmt|,
modifier|*
name|qq
init|=
operator|&
name|this_op_costs
index|[
name|i
index|]
decl_stmt|;
name|int
name|scale
init|=
literal|1
operator|+
operator|(
name|recog_op_type
index|[
name|i
index|]
operator|==
name|OP_INOUT
operator|)
decl_stmt|;
name|pp
operator|->
name|mem_cost
operator|=
name|MIN
argument_list|(
name|pp
operator|->
name|mem_cost
argument_list|,
operator|(
name|qq
operator|->
name|mem_cost
operator|+
name|alt_cost
operator|)
operator|*
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|class
index|]
operator|=
name|MIN
argument_list|(
name|pp
operator|->
name|cost
index|[
name|class
index|]
argument_list|,
operator|(
name|qq
operator|->
name|cost
index|[
name|class
index|]
operator|+
name|alt_cost
operator|)
operator|*
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this insn is a single set copying operand 1 to operand 0      and one is a pseudo with the other a hard reg that is in its      own register class, set the cost of that register class to -1.  */
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|ops
index|[
literal|0
index|]
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|&&
name|ops
index|[
literal|1
index|]
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|ops
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|ops
index|[
operator|!
name|i
index|]
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|ops
index|[
operator|!
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|nr
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|prefclass
operator|!=
literal|0
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|unsigned
name|char
operator|)
name|prefclass
index|[
name|regno
index|]
index|]
operator|==
name|CLASS_MAX_NREGS
argument_list|(
name|prefclass
index|[
name|regno
index|]
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|op_costs
index|[
name|i
index|]
operator|.
name|cost
index|[
operator|(
name|unsigned
name|char
operator|)
name|prefclass
index|[
name|regno
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|reg_class_size
index|[
name|class
index|]
operator|==
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_class_size
index|[
name|class
index|]
operator|==
literal|1
condition|)
name|op_costs
index|[
name|i
index|]
operator|.
name|cost
index|[
name|class
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|;
name|nr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
operator|+
name|nr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|nr
operator|==
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|op_costs
index|[
name|i
index|]
operator|.
name|cost
index|[
name|class
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the cost of loading X into (if TO_P is non-zero) or from (if    TO_P is zero) a register of class CLASS in mode MODE.     X must not be a pseudo.  */
end_comment

begin_function
specifier|static
name|int
name|copy_cost
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|class
parameter_list|,
name|to_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|to_p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
name|enum
name|reg_class
name|secondary_class
init|=
name|NO_REGS
decl_stmt|;
endif|#
directive|endif
comment|/* If X is a SCRATCH, there is actually nothing to move since we are      assuming optimal allocation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|0
return|;
comment|/* Get the class we will actually use for a reload.  */
name|class
operator|=
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|x
argument_list|,
name|class
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
comment|/* If we need a secondary reload (we assume here that we are using       the secondary reload as an intermediate, not a scratch register), the      cost is that to load the input into the intermediate register, then      to copy them.  We use a special value of TO_P to avoid recursion.  */
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|to_p
operator|==
literal|1
condition|)
name|secondary_class
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
operator|!
name|to_p
condition|)
name|secondary_class
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|secondary_class
operator|!=
name|NO_REGS
condition|)
return|return
operator|(
name|move_cost
index|[
operator|(
name|int
operator|)
name|secondary_class
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+
name|copy_cost
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|secondary_class
argument_list|,
literal|2
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_SECONDARY_RELOADS */
comment|/* For memory, use the memory move cost, for (hard) registers, use the      cost to move between the register classes, and use 2 for everything      else (constants).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
name|class
operator|==
name|NO_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class
argument_list|,
name|to_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|move_cost
index|[
operator|(
name|int
operator|)
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
return|;
else|else
comment|/* If this is a constant, we may eventually want to call rtx_cost here.  */
return|return
literal|2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the pseudo registers we must reload into hard registers    in a subexpression of a memory address, X.     CLASS is the class that the register needs to be in and is either    BASE_REG_CLASS or INDEX_REG_CLASS.     SCALE is twice the amount to multiply the cost by (it is twice so we    can represent half-cost adjustments).  */
end_comment

begin_function
specifier|static
name|void
name|record_address_regs
parameter_list|(
name|x
parameter_list|,
name|class
parameter_list|,
name|scale
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|scale
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|PLUS
case|:
comment|/* When we have an address that is a sum, 	 we must determine whether registers are "base" or "index" regs. 	 If there is a sum of two registers, we must choose one to be 	 the "base".  Luckily, we can use the REGNO_POINTER_FLAG 	 to make a good choice most of the time.  We only need to do this 	 on machines that can have two registers in an address and where 	 the base and index register classes are different.  	 ??? This code used to set REGNO_POINTER_FLAG in some cases, but 	 that seems bogus since it should only be set when we are sure 	 the register is being used as a pointer.  */
block|{
name|rtx
name|arg0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|arg1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Look inside subregs.  */
if|if
condition|(
name|code0
operator|==
name|SUBREG
condition|)
name|arg0
operator|=
name|SUBREG_REG
argument_list|(
name|arg0
argument_list|)
operator|,
name|code0
operator|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|SUBREG
condition|)
name|arg1
operator|=
name|SUBREG_REG
argument_list|(
name|arg1
argument_list|)
operator|,
name|code1
operator|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* If this machine only allows one register per address, it must 	   be in the first operand.  */
if|if
condition|(
name|MAX_REGS_PER_ADDRESS
operator|==
literal|1
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If index and base registers are the same on this machine, just 	   record registers in any non-constant operands.  We assume here, 	   as well as in the tests below, that all addresses are in  	   canonical form.  */
elseif|else
if|if
condition|(
name|INDEX_REG_CLASS
operator|==
name|BASE_REG_CLASS
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|arg1
argument_list|)
condition|)
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/* If the second operand is a constant integer, it doesn't change 	   what class the first operand must be.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|||
name|code1
operator|==
name|CONST_DOUBLE
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If the second operand is a symbolic constant, the first operand 	   must be an index register.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|CONST
operator|||
name|code1
operator|==
name|LABEL_REF
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If both operands are registers but one is already a hard register 	   of index or base class, give the other the class that the hard 	   register is not.  */
ifdef|#
directive|ifdef
name|REG_OK_FOR_BASE_P
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|arg0
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg0
argument_list|)
operator|||
name|REG_OK_FOR_INDEX_P
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg0
argument_list|)
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|arg1
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg1
argument_list|)
operator|||
name|REG_OK_FOR_INDEX_P
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|REG_OK_FOR_BASE_P
argument_list|(
name|arg1
argument_list|)
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If one operand is known to be a pointer, it must be the base 	   with the other operand the index.  Likewise if the other operand 	   is a MULT.  */
elseif|else
if|if
condition|(
operator|(
name|code0
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|||
name|code1
operator|==
name|MULT
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|||
name|code0
operator|==
name|MULT
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, count equal chances that each might be a base 	   or index register.  This case should be rare.  */
else|else
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
comment|/* Double the importance of a pseudo register that is incremented 	 or decremented, since it would take two extra insns 	 if it ends up in the wrong place.  If the operand is a pseudo, 	 show it is being used in an INC_DEC context.  */
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|in_inc_dec
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|class
argument_list|,
literal|2
operator|*
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
specifier|register
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|costs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pp
operator|->
name|mem_cost
operator|+=
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|Pmode
argument_list|,
name|class
argument_list|,
literal|1
argument_list|)
operator|*
name|scale
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|i
index|]
operator|+=
operator|(
name|may_move_cost
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|*
name|scale
operator|)
operator|/
literal|2
expr_stmt|;
block|}
break|break;
default|default:
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
end_ifdef

begin_comment
comment|/* Return 1 if REG is valid as an auto-increment memory reference    to an object of MODE.  */
end_comment

begin_function
specifier|static
name|int
name|auto_inc_dec_reg_p
parameter_list|(
name|reg
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_POST_DECREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_PRE_INCREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PRE_INC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_CONSTRAINTS */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|short
modifier|*
name|renumber
init|=
operator|(
name|short
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|regno_allocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate enough space to hold NUM_REGS registers for the tables used for    reg_scan and flow_analysis that are indexed by the register number.  If    NEW_P is non zero, initialize all of the registers, otherwise only    initialize the new registers allocated.  The same table is kept from    function to function, only reallocating it when we need more room.  If    RENUMBER_P is non zero, allocate the reg_renumber array also.  */
end_comment

begin_function
name|void
name|allocate_reg_info
parameter_list|(
name|num_regs
parameter_list|,
name|new_p
parameter_list|,
name|renumber_p
parameter_list|)
name|size_t
name|num_regs
decl_stmt|;
name|int
name|new_p
decl_stmt|;
name|int
name|renumber_p
decl_stmt|;
block|{
name|size_t
name|size_info
decl_stmt|;
name|size_t
name|size_renumber
decl_stmt|;
name|size_t
name|min
init|=
operator|(
name|new_p
operator|)
condition|?
literal|0
else|:
name|reg_n_max
decl_stmt|;
name|struct
name|reg_info_data
modifier|*
name|reg_data
decl_stmt|;
name|struct
name|reg_info_data
modifier|*
name|reg_next
decl_stmt|;
if|if
condition|(
name|num_regs
operator|>
name|regno_allocated
condition|)
block|{
name|size_t
name|old_allocated
init|=
name|regno_allocated
decl_stmt|;
name|regno_allocated
operator|=
name|num_regs
operator|+
operator|(
name|num_regs
operator|/
literal|20
operator|)
expr_stmt|;
comment|/* add some slop space */
name|size_renumber
operator|=
name|regno_allocated
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_n_info
condition|)
block|{
name|VARRAY_REG_INIT
argument_list|(
name|reg_n_info
argument_list|,
name|regno_allocated
argument_list|,
literal|"reg_n_info"
argument_list|)
expr_stmt|;
name|renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|size_renumber
argument_list|)
expr_stmt|;
name|prefclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|regno_allocated
argument_list|)
expr_stmt|;
name|altclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|regno_allocated
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VARRAY_GROW
argument_list|(
name|reg_n_info
argument_list|,
name|regno_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_p
condition|)
comment|/* if we're zapping everything, no need to realloc */
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|renumber
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prefclass_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|altclass_buffer
argument_list|)
expr_stmt|;
name|renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|size_renumber
argument_list|)
expr_stmt|;
name|prefclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|regno_allocated
argument_list|)
expr_stmt|;
name|altclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|regno_allocated
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|renumber
argument_list|,
name|size_renumber
argument_list|)
expr_stmt|;
name|prefclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prefclass_buffer
argument_list|,
name|regno_allocated
argument_list|)
expr_stmt|;
name|altclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|altclass_buffer
argument_list|,
name|regno_allocated
argument_list|)
expr_stmt|;
block|}
block|}
name|size_info
operator|=
operator|(
name|regno_allocated
operator|-
name|old_allocated
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|reg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|reg_info_data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|reg_info
argument_list|)
expr_stmt|;
name|reg_data
operator|=
operator|(
expr|struct
name|reg_info_data
operator|*
operator|)
name|xcalloc
argument_list|(
name|size_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_data
operator|->
name|min_index
operator|=
name|old_allocated
expr_stmt|;
name|reg_data
operator|->
name|max_index
operator|=
name|regno_allocated
operator|-
literal|1
expr_stmt|;
name|reg_data
operator|->
name|next
operator|=
name|reg_info_head
expr_stmt|;
name|reg_info_head
operator|=
name|reg_data
expr_stmt|;
block|}
name|reg_n_max
operator|=
name|num_regs
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|num_regs
condition|)
block|{
comment|/* Loop through each of the segments allocated for the actual 	 reg_info pages, and set up the pointers, zero the pages, etc.  */
for|for
control|(
name|reg_data
operator|=
name|reg_info_head
init|;
name|reg_data
condition|;
name|reg_data
operator|=
name|reg_next
control|)
block|{
name|size_t
name|min_index
init|=
name|reg_data
operator|->
name|min_index
decl_stmt|;
name|size_t
name|max_index
init|=
name|reg_data
operator|->
name|max_index
decl_stmt|;
name|reg_next
operator|=
name|reg_data
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|min
operator|<=
name|max_index
condition|)
block|{
name|size_t
name|max
init|=
name|max_index
decl_stmt|;
name|size_t
name|local_min
init|=
name|min
operator|-
name|min_index
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|min
operator|<
name|min_index
condition|)
name|local_min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|reg_data
operator|->
name|used_p
condition|)
comment|/* page just allocated with calloc */
name|reg_data
operator|->
name|used_p
operator|=
literal|1
expr_stmt|;
comment|/* no need to zero */
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reg_data
operator|->
name|data
index|[
name|local_min
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_info
argument_list|)
operator|*
operator|(
name|max
operator|-
name|min_index
operator|-
name|local_min
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_index
operator|+
name|local_min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|VARRAY_REG
argument_list|(
name|reg_n_info
argument_list|,
name|i
argument_list|)
operator|=
operator|&
name|reg_data
operator|->
name|data
index|[
name|i
operator|-
name|min_index
index|]
expr_stmt|;
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
name|renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|prefclass_buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|NO_REGS
expr_stmt|;
name|altclass_buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|NO_REGS
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If {pref,alt}class have already been allocated, update the pointers to      the newly realloced ones.  */
if|if
condition|(
name|prefclass
condition|)
block|{
name|prefclass
operator|=
name|prefclass_buffer
expr_stmt|;
name|altclass
operator|=
name|altclass_buffer
expr_stmt|;
block|}
if|if
condition|(
name|renumber_p
condition|)
name|reg_renumber
operator|=
name|renumber
expr_stmt|;
comment|/* Tell the regset code about the new number of registers */
name|MAX_REGNO_REG_SET
argument_list|(
name|num_regs
argument_list|,
name|new_p
argument_list|,
name|renumber_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free up the space allocated by allocate_reg_info.  */
end_comment

begin_function
name|void
name|free_reg_info
parameter_list|()
block|{
if|if
condition|(
name|reg_n_info
condition|)
block|{
name|struct
name|reg_info_data
modifier|*
name|reg_data
decl_stmt|;
name|struct
name|reg_info_data
modifier|*
name|reg_next
decl_stmt|;
name|VARRAY_FREE
argument_list|(
name|reg_n_info
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_data
operator|=
name|reg_info_head
init|;
name|reg_data
condition|;
name|reg_data
operator|=
name|reg_next
control|)
block|{
name|reg_next
operator|=
name|reg_data
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|prefclass_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|altclass_buffer
argument_list|)
expr_stmt|;
name|prefclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|altclass_buffer
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|reg_info_head
operator|=
operator|(
expr|struct
name|reg_info_data
operator|*
operator|)
literal|0
expr_stmt|;
name|renumber
operator|=
operator|(
name|short
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|regno_allocated
operator|=
literal|0
expr_stmt|;
name|reg_n_max
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the `regscan' pass of the compiler, run just before cse    and again just before loop.     It finds the first and last use of each pseudo-register    and records them in the vectors regno_first_uid, regno_last_uid    and counts the number of sets in the vector reg_n_sets.     REPEAT is nonzero the second time this is called.  */
end_comment

begin_comment
comment|/* Maximum number of parallel sets and clobbers in any insn in this fn.    Always at least 3, since the combiner could put that many together    and we want this to remain correct for all the remaining passes.  */
end_comment

begin_decl_stmt
name|int
name|max_parallel
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|reg_scan
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|repeat
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|repeat
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|allocate_reg_info
argument_list|(
name|nregs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|max_parallel
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|max_parallel
condition|)
name|max_parallel
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_scan_mark_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update 'regscan' information by looking at the insns    from FIRST to LAST.  Some new REGs have been created,    and any REG with number greater than OLD_MAX_REGNO is    such a REG.  We only update information for those.  */
end_comment

begin_function
name|void
name|reg_scan_update
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|,
name|old_max_regno
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|int
name|old_max_regno
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|max_parallel
condition|)
name|max_parallel
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_scan_mark_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|old_max_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|,
name|old_max_regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* X is the expression to scan.  INSN is the insn it appears in.    NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.    We should only record information for REGs with numbers    greater than or equal to MIN_REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|reg_scan_mark_refs
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|note_flag
parameter_list|,
name|min_regno
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|note_flag
decl_stmt|;
name|int
name|min_regno
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|rtx
name|dest
decl_stmt|;
specifier|register
name|rtx
name|note
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|REG
case|:
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|min_regno
condition|)
block|{
name|REGNO_LAST_NOTE_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note_flag
condition|)
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EXPR_LIST
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN_LIST
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* Count a set of the destination if it is a register.  */
for|for
control|(
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTEND
condition|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|min_regno
condition|)
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|++
expr_stmt|;
comment|/* If this is setting a pseudo from another pseudo or the sum of a 	 pseudo and a constant integer and the other pseudo is known to be 	 a pointer, set the destination to be a pointer as well.  	 Likewise if it is setting the destination from an address or from a 	 value equivalent to an address or to the sum of an address and 	 something else. 		      	 But don't do any of this if the pseudo corresponds to a user 	 variable since it should have already been set as a pointer based 	 on the type.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|min_regno
comment|/* If the destination pseudo is set more than once, then other 	     sets might not be to a pointer value (consider access to a 	     union in two threads of control in the presense of global 	     optimizations).  So only set REGNO_POINTER_FLAG on the destination 	     pseudo if this is the only set of that pseudo.  */
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LO_SUM
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LO_SUM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|||
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
condition|)
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ... fall through ...  */
default|default:
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
operator|&&
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|reg_scan_mark_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|note_flag
argument_list|,
name|min_regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if C1 is a subset of C2, i.e., if every register in C1    is also in C2.  */
end_comment

begin_function
name|int
name|reg_class_subset_p
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|enum
name|reg_class
name|c1
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|c2
decl_stmt|;
block|{
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c2
operator|==
name|ALL_REGS
condition|)
name|win
label|:
return|return
literal|1
return|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there is a register that is in both C1 and C2.  */
end_comment

begin_function
name|int
name|reg_classes_intersect_p
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|enum
name|reg_class
name|c1
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|c2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
endif|#
directive|endif
name|HARD_REG_SET
name|c
decl_stmt|;
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c1
operator|==
name|ALL_REGS
operator|||
name|c2
operator|==
name|ALL_REGS
condition|)
return|return
literal|1
return|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|lose
label|:
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Release any memory allocated by register sets.  */
end_comment

begin_function
name|void
name|regset_release_memory
parameter_list|()
block|{
name|bitmap_release_memory
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

