begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process machine description and calculate constant conditions.    Copyright (C) 2001, 2002 Free Software Foundation, Inc.     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU CC is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GNU CC; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* In a machine description, all of the insn patterns - define_insn,    define_expand, define_split, define_peephole, define_peephole2 -    contain an optional C expression which makes the final decision    about whether or not this pattern is usable.  That expression may    turn out to be always false when the compiler is built.  If it is,    most of the programs that generate code from the machine    description can simply ignore the entire pattern.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* so we can include except.h in the generated file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|saw_eh_return
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|htab_t
name|condition_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_condition
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_header
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_conditions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_one_condition
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the C test expression EXPR in the condition_table.    Duplicates clobber previous entries, which leaks memory, but    we don't care for this application.  */
end_comment

begin_function
specifier|static
name|void
name|add_condition
parameter_list|(
name|expr
parameter_list|)
specifier|const
name|char
modifier|*
name|expr
decl_stmt|;
block|{
name|struct
name|c_test
modifier|*
name|test
decl_stmt|;
if|if
condition|(
name|expr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return;
name|test
operator|=
operator|(
expr|struct
name|c_test
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|c_test
argument_list|)
argument_list|)
expr_stmt|;
name|test
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
operator|*
operator|(
name|htab_find_slot
argument_list|(
name|condition_table
argument_list|,
name|test
argument_list|,
name|INSERT
argument_list|)
operator|)
operator|=
name|test
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the header for insn-conditions.c.  */
end_comment

begin_function
specifier|static
name|void
name|write_header
parameter_list|()
block|{
name|puts
argument_list|(
literal|"\ /* Generated automatically by the program `genconditions' from the target\n\    machine description file.  */\n\ \n\ #include \"hconfig.h\"\n\ #include \"insn-constants.h\"\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ /* Do not allow checking to confuse the issue.  */\n\ #undef ENABLE_CHECKING\n\ #undef ENABLE_TREE_CHECKING\n\ #undef ENABLE_RTL_CHECKING\n\ #undef ENABLE_RTL_FLAG_CHECKING\n\ #undef ENABLE_GC_CHECKING\n\ #undef ENABLE_GC_ALWAYS_COLLECT\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ #include \"system.h\"\n\ #include \"rtl.h\"\n\ #include \"tm_p.h\"\n\ #include \"function.h\"\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ /* Fake - insn-config.h doesn't exist yet.  */\n\ #define MAX_RECOG_OPERANDS 10\n\ #define MAX_DUP_OPERANDS 10\n\ #define MAX_INSNS_PER_SPLIT 5\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ #include \"regs.h\"\n\ #include \"recog.h\"\n\ #include \"real.h\"\n\ #include \"output.h\"\n\ #include \"flags.h\"\n\ #include \"hard-reg-set.h\"\n\ #include \"resource.h\"\n\ #include \"toplev.h\"\n\ #include \"reload.h\"\n\ #include \"gensupport.h\"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_eh_return
condition|)
name|puts
argument_list|(
literal|"#define HAVE_eh_return 1"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"except.h\"\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ /* Dummy external declarations.  */\n\ extern rtx insn;\n\ extern rtx ins1;\n\ extern rtx operands[];\n\ extern int next_insn_tests_no_inequality PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ /* If we don't have __builtin_constant_p, or it's not acceptable in\n\    array initializers, fall back to assuming that all conditions\n\    potentially vary at run time.  It works in 3.0.1 and later; 3.0\n\    only when not optimizing.  */\n\ #if (GCC_VERSION>= 3001) || ((GCC_VERSION == 3000)&& !__OPTIMIZE__)\n\ # define MAYBE_EVAL(expr) (__builtin_constant_p(expr) ? (int) (expr) : -1)\n\ #else\n\ # define MAYBE_EVAL(expr) -1\n\ #endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out one entry in the conditions table, using the data pointed    to by SLOT.  Each entry looks like this:   { "! optimize_size&& ! TARGET_READ_MODIFY_WRITE",     MAYBE_EVAL (! optimize_size&& ! TARGET_READ_MODIFY_WRITE) },  */
end_comment

begin_function
specifier|static
name|int
name|write_one_condition
parameter_list|(
name|slot
parameter_list|,
name|dummy
parameter_list|)
name|PTR
modifier|*
name|slot
decl_stmt|;
name|PTR
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|struct
name|c_test
modifier|*
name|test
init|=
operator|*
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|*
operator|)
name|slot
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|fputs
argument_list|(
literal|"  { \""
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|test
operator|->
name|expr
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|fputs
argument_list|(
literal|"\\n\\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|fputs
argument_list|(
literal|"\\\""
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\",\n    MAYBE_EVAL (%s) },\n"
argument_list|,
name|test
operator|->
name|expr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Write out the complete conditions table, its size, and a flag    indicating that gensupport.c can now do insn elision.  */
end_comment

begin_function
specifier|static
name|void
name|write_conditions
parameter_list|()
block|{
name|puts
argument_list|(
literal|"\ /* This table lists each condition found in the machine description.\n\    Each condition is mapped to its truth value (0 or 1), or -1 if that\n\    cannot be calculated at compile time. */\n\ \n\ const struct c_test insn_conditions[] = {"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|condition_table
argument_list|,
name|write_one_condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"const size_t n_insn_conditions = %lu;\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|htab_elements
argument_list|(
name|condition_table
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"const int insn_elision_unavailable = 0;"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|int
name|pattern_lineno
decl_stmt|;
comment|/* not used */
name|int
name|code
decl_stmt|;
name|progname
operator|=
literal|"genconditions"
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|condition_table
operator|=
name|htab_create
argument_list|(
literal|1000
argument_list|,
name|hash_c_test
argument_list|,
name|cmp_c_test
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|pattern_lineno
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
comment|/* N.B. define_insn_and_split, define_cond_exec are handled 	 entirely within read_md_rtx; we never see them.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|DEFINE_INSN
case|:
case|case
name|DEFINE_EXPAND
case|:
name|add_condition
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* except.h needs to know whether there is an eh_return 	     pattern in the machine description.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"eh_return"
argument_list|)
condition|)
name|saw_eh_return
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DEFINE_SPLIT
case|:
case|case
name|DEFINE_PEEPHOLE
case|:
case|case
name|DEFINE_PEEPHOLE2
case|:
name|add_condition
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|write_header
argument_list|()
expr_stmt|;
name|write_conditions
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

