begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Emit RTL for the GNU C-Compiler expander.    Copyright (C) 1987, 88, 92-97, 1998, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Middle-to-low level generation of rtx code and insns.     This file contains the functions `gen_rtx', `gen_reg_rtx'    and `gen_label_rtx' that are the usual ways of creating rtl    expressions for most purposes.     It also has the functions for creating insns and linking    them in the doubly-linked chain.     The patterns of the insns are created by machine-dependent    routines in insn-emit.c, which is generated automatically from    the machine description.  These routines use `gen_rtx' to make    the individual rtx's of the pattern; what is machine dependent    is the kind of rtx's they make and what arguments they use.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_comment
comment|/* Commonly used modes.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|byte_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is BITS_PER_UNIT.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|word_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is BITS_PER_WORD.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|double_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is DOUBLE_TYPE_SIZE.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|ptr_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is POINTER_SIZE.  */
end_comment

begin_comment
comment|/* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.    After rtl generation, it is 1 plus the largest register number used.  */
end_comment

begin_decl_stmt
name|int
name|reg_rtx_no
init|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is *not* reset after each function.  It gives each CODE_LABEL    in the entire compilation a unique label number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|label_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lowest label number in current function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest label number in current function.    Zero means use the value of label_num instead.    This is nonzero only when belatedly compiling an inline function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value label_num had when set_new_first_and_last_label_number was called.    If label_num has not changed since then, last_label_num is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|base_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do not generate NOTEs for source line numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_line_numbers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Commonly used rtx's, so that we only need space for one copy.    These are initialized once for the entire compilation.    All of these except perhaps the floating-point CONST_DOUBLEs    are unique; no other rtx-object will be equal to any of these.  */
end_comment

begin_comment
comment|/* Avoid warnings by initializing the `fld' field.  Since its a union,    bypass problems with KNR compilers by only doing so when __GNUC__. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FLDI
value|, {{0}}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FLDI
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|_global_rtl
name|global_rtl
init|=
block|{
block|{
name|PC
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* pc_rtx */
block|{
name|CC0
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* cc0_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* stack_pointer_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* frame_pointer_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* hard_frame_pointer_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* arg_pointer_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* virtual_incoming_args_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* virtual_stack_vars_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* virtual_stack_dynamic_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* virtual_outgoing_args_rtx */
block|{
name|REG
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
name|FLDI
block|}
block|,
comment|/* virtual_cfa_rtx */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We record floating-point CONST_DOUBLEs in each floating-point mode for    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we    record a copy of const[012]_rtx.  */
end_comment

begin_decl_stmt
name|rtx
name|const_tiny_rtx
index|[
literal|3
index|]
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|const_true_rtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconstm1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All references to the following fixed hard registers go through    these unique rtl objects.  On machines where the frame-pointer and    arg-pointer are the same register, they use the same unique object.     After register allocation, other rtl objects which used to be pseudo-regs    may be clobbered to refer to the frame-pointer register.    But references that were originally to the frame-pointer can be    distinguished from the others because they contain frame_pointer_rtx.     When to use frame_pointer_rtx and hard_frame_pointer_rtx is a little    tricky: until register elimination has taken place hard_frame_pointer_rtx    should be used if it is being set, and frame_pointer_rtx otherwise.  After     register elimination hard_frame_pointer_rtx should always be used.    On machines where the two registers are same (most) then these are the    same.     In an inline procedure, the stack and frame pointer rtxs may not be    used for anything else.  */
end_comment

begin_decl_stmt
name|rtx
name|struct_value_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STRUCT_VALUE_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|struct_value_incoming_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STRUCT_VALUE_INCOMING_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_incoming_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_INCOMING_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|pic_offset_table_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */
end_comment

begin_comment
comment|/* This is used to implement __builtin_return_address for some machines.    See for instance the MIPS port.  */
end_comment

begin_decl_stmt
name|rtx
name|return_address_pointer_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */
end_comment

begin_comment
comment|/* We make one copy of (const_int C) where C is in    [- MAX_SAVED_CONST_INT, MAX_SAVED_CONST_INT]    to save space during the compilation and simplify comparisons of    integers.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
name|const_int_rtx
index|[
name|MAX_SAVED_CONST_INT
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The ends of the doubly-linked chain of rtl for the current function.    Both are reset to null at the start of rtl generation for the function.        start_sequence saves both of these on `sequence_stack' along with    `sequence_rtl_expr' and then starts a new, nested sequence of insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|first_insn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|last_insn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RTL_EXPR within which the current sequence will be placed.  Use to    prevent reuse of any temporaries within the sequence until after the    RTL_EXPR is emitted.  */
end_comment

begin_decl_stmt
name|tree
name|sequence_rtl_expr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN_UID for next insn emitted.    Reset to 1 for each function compiled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_insn_uid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number and source file of the last line-number NOTE emitted.    This is used to avoid generating duplicates.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_linenum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_filename
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by pseudo reg number.  The allocated length    of this vector is regno_pointer_flag_length.  Since this    vector is needed during the expansion phase when the total    number of registers in the function is not yet known,    it is copied and made bigger when necessary.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|regno_pointer_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regno_pointer_flag_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by pseudo register number, if nonzero gives the known alignment    for that pseudo (if regno_pointer_flag is set).    Allocated in parallel with regno_pointer_flag.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|regno_pointer_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by pseudo register number, gives the rtx for that pseudo.    Allocated in parallel with regno_pointer_flag.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|regno_reg_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of pending (incomplete) sequences saved by `start_sequence'.    Each element describes one pending sequence.    The main insn-chain is saved in the last element of the chain,    unless the chain is empty.  */
end_comment

begin_decl_stmt
name|struct
name|sequence_stack
modifier|*
name|sequence_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start_sequence and gen_sequence can make a lot of rtx expressions which are    shortly thrown away.  We use two mechanisms to prevent this waste:     First, we keep a list of the expressions used to represent the sequence    stack in sequence_element_free_list.     Second, for sizes up to 5 elements, we keep a SEQUENCE and its associated    rtvec for use by gen_sequence.  One entry for each size is sufficient    because most cases are calls to gen_sequence followed by immediately    emitting the SEQUENCE.  Reuse is safe since emitting a sequence is    destructive on the insn in it anyway and hence can't be redone.     We do not bother to save this cached data over nested function calls.    Instead, we just reinitialize them.  */
end_comment

begin_define
define|#
directive|define
name|SEQUENCE_RESULT_SIZE
value|5
end_define

begin_decl_stmt
specifier|static
name|struct
name|sequence_stack
modifier|*
name|sequence_element_free_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|sequence_result
index|[
name|SEQUENCE_RESULT_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During RTL generation, we also keep a list of free INSN rtl codes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|free_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename and line number of last line-number note,    whether we actually emitted it or not.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|emit_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|emit_lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|make_jump_insn_raw
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|make_call_insn_raw
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_line_note
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|rtx
name|gen_rtx_CONST_INT
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|>=
operator|-
name|MAX_SAVED_CONST_INT
operator|&&
name|arg
operator|<=
name|MAX_SAVED_CONST_INT
condition|)
return|return
operator|&
name|const_int_rtx
index|[
name|arg
operator|+
name|MAX_SAVED_CONST_INT
index|]
return|;
if|#
directive|if
name|STORE_FLAG_VALUE
operator|!=
literal|1
operator|&&
name|STORE_FLAG_VALUE
operator|!=
operator|-
literal|1
if|if
condition|(
name|const_true_rtx
operator|&&
name|arg
operator|==
name|STORE_FLAG_VALUE
condition|)
return|return
name|const_true_rtx
return|;
endif|#
directive|endif
return|return
name|gen_rtx_raw_CONST_INT
argument_list|(
name|mode
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* CONST_DOUBLEs needs special handling because its length is known    only at run-time.  */
end_comment

begin_function
name|rtx
name|gen_rtx_CONST_DOUBLE
parameter_list|(
name|mode
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|arg0
decl_stmt|;
name|HOST_WIDE_INT
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|rtx
name|r
init|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|XWINT
argument_list|(
name|r
argument_list|,
literal|2
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|XWINT
argument_list|(
name|r
argument_list|,
literal|3
argument_list|)
operator|=
name|arg2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|3
condition|;
operator|--
name|i
control|)
name|XWINT
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_REG
parameter_list|(
name|mode
parameter_list|,
name|regno
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
comment|/* In case the MD file explicitly references the frame pointer, have      all such references point to the same frame pointer.  This is      used during frame pointer elimination to distinguish the explicit      references to these registers from pseudos that happened to be      assigned to them.       If we have eliminated the frame pointer or arg pointer, we will      be using it as a normal register, for example as a spill      register.  In such cases, we might be accessing it in a mode that      is not Pmode and therefore cannot use the pre-allocated rtx.       Also don't do this when we are making new REGs in reload, since      we don't want to get confused with the real pointers.  */
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
operator|!
name|reload_in_progress
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
condition|)
return|return
name|frame_pointer_rtx
return|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|hard_frame_pointer_rtx
return|;
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|arg_pointer_rtx
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RETURN_ADDRESS_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|RETURN_ADDRESS_POINTER_REGNUM
condition|)
return|return
name|return_address_pointer_rtx
return|;
endif|#
directive|endif
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
name|stack_pointer_rtx
return|;
block|}
return|return
name|gen_rtx_raw_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_MEM
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|rt
init|=
name|gen_rtx_raw_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* This field is not cleared by the mere allocation of the rtx, so      we clear it here.  */
name|MEM_ALIAS_SET
argument_list|(
name|rt
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* rtx gen_rtx (code, mode, [element1, ..., elementn]) ** **	    This routine generates an RTX of the size specified by **<code>, which is an RTX code.   The RTX structure is initialized **	from the arguments<element1> through<elementn>, which are **	interpreted according to the specific RTX type's format.   The **	special machine mode associated with the rtx (if any) is specified **	in<mode>. ** **	    gen_rtx can be invoked in a way which resembles the lisp-like **	rtx it will generate.   For example, the following rtx structure: ** **	      (plus:QI (mem:QI (reg:SI 1)) **		       (mem:QI (plusw:SI (reg:SI 2) (reg:SI 3)))) ** **		...would be generated by the following C code: ** **	    	gen_rtx (PLUS, QImode, **		    gen_rtx (MEM, QImode, **			gen_rtx (REG, SImode, 1)), **		    gen_rtx (MEM, QImode, **			gen_rtx (PLUS, SImode, **			    gen_rtx (REG, SImode, 2), **			    gen_rtx (REG, SImode, 3)))), */
end_comment

begin_comment
comment|/*VARARGS2*/
end_comment

begin_decl_stmt
name|rtx
name|gen_rtx
name|VPROTO
argument_list|(
operator|(
expr|enum
name|rtx_code
name|code
operator|,
expr|enum
name|machine_mode
name|mode
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
endif|#
directive|endif
name|va_list
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Array indices...			*/
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Current rtx's format...		*/
specifier|register
name|rtx
name|rt_val
decl_stmt|;
comment|/* RTX to return to caller...		*/
name|VA_START
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|rtx_code
argument_list|)
expr_stmt|;
name|mode
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
name|rt_val
operator|=
name|gen_rtx_CONST_INT
argument_list|(
name|mode
argument_list|,
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
block|{
name|rtx
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|arg2
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
decl_stmt|;
name|rt_val
operator|=
name|gen_rtx_CONST_DOUBLE
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG
case|:
name|rt_val
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|rt_val
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Allocate the storage space.  */
name|rt_val
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
comment|/* Store the machine mode...  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Find the right format...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Unused field.  */
break|break;
case|case
literal|'i'
case|:
comment|/* An integer?  */
name|XINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* A wide integer? */
name|XWINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* A string?  */
name|XSTR
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* An expression?  */
case|case
literal|'u'
case|:
comment|/* An insn?  Same except when printing.  */
name|XEXP
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* An RTX vector?  */
name|XVEC
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtvec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* A bitmap? */
name|XBITMAP
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* A tree? */
name|XTREE
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_decl_stmt

begin_comment
comment|/* gen_rtvec (n, [rt1, ..., rtn]) ** **	    This routine creates an rtvec and stores within it the **	pointers to rtx's which are its arguments. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_decl_stmt
name|rtvec
name|gen_rtvec
name|VPROTO
argument_list|(
operator|(
name|int
name|n
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|int
name|n
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|rtx
modifier|*
name|vector
decl_stmt|;
name|VA_START
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|n
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|vector
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|vector
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|gen_rtvec_v
argument_list|(
name|n
argument_list|,
name|vector
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|rtvec
name|gen_rtvec_v
parameter_list|(
name|n
parameter_list|,
name|argp
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtx
modifier|*
name|argp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtvec
name|rt_val
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|rt_val
operator|=
name|rtvec_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Allocate an rtvec...			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rt_val
operator|->
name|elem
index|[
name|i
index|]
operator|.
name|rtx
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_function

begin_function
name|rtvec
name|gen_rtvec_vv
parameter_list|(
name|n
parameter_list|,
name|argp
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtunion
modifier|*
name|argp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtvec
name|rt_val
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|rt_val
operator|=
name|rtvec_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Allocate an rtvec...			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rt_val
operator|->
name|elem
index|[
name|i
index|]
operator|.
name|rtx
operator|=
operator|(
name|argp
operator|++
operator|)
operator|->
name|rtx
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a REG rtx for a new pseudo register of mode MODE.    This pseudo is assigned the next sequential register number.  */
end_comment

begin_function
name|rtx
name|gen_reg_rtx
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|val
decl_stmt|;
comment|/* Don't let anything called after initial flow analysis create new      registers.  */
if|if
condition|(
name|no_new_pseudos
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
comment|/* For complex modes, don't make a single pseudo. 	 Instead, make a CONCAT of two pseudos. 	 This allows noncontiguous allocation of the real and imaginary parts, 	 which makes much better code.  Besides, allocating DCmode 	 pseudos overstrains reload on some machines like the 386.  */
name|rtx
name|realpart
decl_stmt|,
name|imagpart
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|partmode
init|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
name|MODE_FLOAT
else|:
name|MODE_INT
operator|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|realpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
name|imagpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_CONCAT
argument_list|(
name|mode
argument_list|,
name|realpart
argument_list|,
name|imagpart
argument_list|)
return|;
block|}
comment|/* Make sure regno_pointer_flag and regno_reg_rtx are large      enough to have an element for this pseudo reg number.  */
if|if
condition|(
name|reg_rtx_no
operator|==
name|regno_pointer_flag_length
condition|)
block|{
name|rtx
modifier|*
name|new1
decl_stmt|;
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
operator|*
literal|2
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|regno_pointer_flag
argument_list|,
name|new
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|new
index|[
name|regno_pointer_flag_length
index|]
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|regno_pointer_flag
operator|=
name|new
expr_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regno_pointer_align
argument_list|,
name|new
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|new
index|[
name|regno_pointer_flag_length
index|]
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|regno_pointer_align
operator|=
name|new
expr_stmt|;
name|new1
operator|=
operator|(
name|rtx
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regno_reg_rtx
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new1
argument_list|,
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|new1
index|[
name|regno_pointer_flag_length
index|]
argument_list|,
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
name|new1
expr_stmt|;
name|regno_pointer_flag_length
operator|*=
literal|2
expr_stmt|;
block|}
name|val
operator|=
name|gen_rtx_raw_REG
argument_list|(
name|mode
argument_list|,
name|reg_rtx_no
argument_list|)
expr_stmt|;
name|regno_reg_rtx
index|[
name|reg_rtx_no
operator|++
index|]
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Identify REG (which may be a CONCAT) as a user register.  */
end_comment

begin_function
name|void
name|mark_user_reg
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|REG_USERVAR_P
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify REG as a probable pointer register and show its alignment    as ALIGN, if nonzero.  */
end_comment

begin_function
name|void
name|mark_reg_pointer
parameter_list|(
name|reg
parameter_list|,
name|align
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|&&
name|align
operator|<
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
comment|/* We can no-longer be sure just how aligned this pointer is */
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 plus largest pseudo reg number used in the current function.  */
end_comment

begin_function
name|int
name|max_reg_num
parameter_list|()
block|{
return|return
name|reg_rtx_no
return|;
block|}
end_function

begin_comment
comment|/* Return 1 + the largest label number used so far in the current function.  */
end_comment

begin_function
name|int
name|max_label_num
parameter_list|()
block|{
if|if
condition|(
name|last_label_num
operator|&&
name|label_num
operator|==
name|base_label_num
condition|)
return|return
name|last_label_num
return|;
return|return
name|label_num
return|;
block|}
end_function

begin_comment
comment|/* Return first label number used in this function (if any were used).  */
end_comment

begin_function
name|int
name|get_first_label_num
parameter_list|()
block|{
return|return
name|first_label_num
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a value representing some low-order bits of X, where the number    of low-order bits is given by MODE.  Note that no conversion is done    between floating-point and fixed-point values, rather, the bit     representation is returned.     This function handles the cases in common between gen_lowpart, below,    and two variants in cse.c and combine.c.  These are the cases that can    be safely handled at all points in the compilation.     If this is not a case we can handle, return 0.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_common
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|word
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
condition|)
return|return
name|x
return|;
comment|/* MODE must occupy no more words than the mode of X.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|>
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|word
operator|=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
condition|)
block|{
comment|/* If we are getting the low-order part of something that has been 	 sign- or zero-extended, we can either just use the object being 	 extended or make a narrower extension.  If we want an even smaller 	 piece than the size of the object being extended, call ourselves 	 recursively.  	 This case is used mostly by combine and cse.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|?
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
else|:
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|+
name|word
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Let the backend decide how many registers to skip.  This is needed          in particular for Sparc64 where fp regs are smaller than a word.  */
comment|/* ??? Note that subregs are now ambiguous, in that those against 	 pseudos are sized by the Word Size, while those against hard 	 regs are sized by the underlying register size.  Better would be 	 to always interpret the subreg offset parameter as bytes or bits.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|word
operator|=
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
comment|/* If the register is not valid for MODE, return 0.  If we don't 	 do this, there is no way to fix up the resulting REG later.   	 But we do do this if the current REG is not valid for its 	 mode.  This latter is a kludge, but is required due to the 	 way that parameters are passed on some machines, most 	 notably Sparc.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|word
argument_list|,
name|mode
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
comment|/* integrate.c can't handle parts of a return value register. */
operator|&&
operator|(
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|rtx_equal_function_value_matters
operator|)
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_SIZE
operator|&&
operator|!
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_SIZE
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
endif|#
directive|endif
comment|/* We want to keep the stack, frame, and arg pointers 		  special.  */
operator|&&
name|x
operator|!=
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|x
operator|!=
name|arg_pointer_rtx
endif|#
directive|endif
operator|&&
name|x
operator|!=
name|stack_pointer_rtx
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|word
argument_list|)
return|;
else|else
return|return
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|word
argument_list|)
return|;
block|}
comment|/* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits      from the low-order part of the constant.  */
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
comment|/* If MODE is twice the host word size, X is already the desired 	 representation.  Otherwise, if MODE is wider than a word, we can't 	 do this.  If MODE is exactly a word, return just one CONST_INT. 	 If MODE is smaller than a word, clear the bits that don't belong 	 in our mode, unless they and our sign bit are all one.  So we get 	 either a reasonable negative value or a reasonable unsigned value 	 for this mode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|?
name|x
else|:
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* MODE must be narrower than HOST_BITS_PER_WIDE_INT.  */
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val
init|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|x
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|)
decl_stmt|;
comment|/* Sign extend to HOST_WIDE_INT.  */
name|val
operator|=
name|val
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|val
condition|?
name|x
else|:
name|GEN_INT
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* If X is an integral constant but we want it in floating-point, it      must be the case that we have a union of an integer and a floating-point      value.  If the machine-parameters allow it, simulate that union here      and return the result.  The two-word and single-word cases are       different.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|HOST_BITS_PER_CHAR
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|i
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_FROM_TARGET_SINGLE
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
else|#
directive|else
block|{
union|union
block|{
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|float
name|d
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|HOST_BITS_PER_CHAR
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|i
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|,
name|high
operator|=
name|low
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|,
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* REAL_VALUE_TARGET_DOUBLE takes the addressing order of the 	 target machine.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|i
index|[
literal|0
index|]
operator|=
name|high
operator|,
name|i
index|[
literal|1
index|]
operator|=
name|low
expr_stmt|;
else|else
name|i
index|[
literal|0
index|]
operator|=
name|low
operator|,
name|i
index|[
literal|1
index|]
operator|=
name|high
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_FROM_TARGET_DOUBLE
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
else|#
directive|else
block|{
union|union
block|{
name|HOST_WIDE_INT
name|i
index|[
literal|2
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|u
union|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|,
name|high
operator|=
name|low
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|,
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|high
operator|,
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|low
expr_stmt|;
else|#
directive|else
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|low
operator|,
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|high
expr_stmt|;
endif|#
directive|endif
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* We need an extra case for machines where HOST_BITS_PER_WIDE_INT is the      same as sizeof (double) or when sizeof (float) is larger than the      size of a word on the target machine.  */
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|i
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_FROM_TARGET_SINGLE
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|HOST_BITS_PER_CHAR
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|i
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_FROM_TARGET_DOUBLE
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* Similarly, if this is converting a floating-point value into a      single-word integer.  Only do this is the host and target parameters are      compatible.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_WORD
condition|)
return|return
name|operand_subword
argument_list|(
name|x
argument_list|,
name|word
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
comment|/* Similarly, if this is converting a floating-point value into a      two-word integer, we can do this one word at a time and make an      integer.  Only do this is the host and target parameters are      compatible.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|BITS_PER_WORD
condition|)
block|{
name|rtx
name|lowpart
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|word
operator|+
name|WORDS_BIG_ENDIAN
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|highpart
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|word
operator|+
operator|!
name|WORDS_BIG_ENDIAN
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lowpart
operator|&&
name|GET_CODE
argument_list|(
name|lowpart
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|highpart
operator|&&
name|GET_CODE
argument_list|(
name|highpart
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|immed_double_const
argument_list|(
name|INTVAL
argument_list|(
name|lowpart
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|highpart
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Otherwise, we can't do this.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the real part (which has mode MODE) of a complex value X.    This always comes at the low address in memory.  */
end_comment

begin_function
name|rtx
name|gen_realpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|fatal
argument_list|(
literal|"Unable to access real part of complex value in a hard register on this target"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
return|return
name|gen_highpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the imaginary part (which has mode MODE) of a complex value X.    This always comes at the high address in memory.  */
end_comment

begin_function
name|rtx
name|gen_imagpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|fatal
argument_list|(
literal|"Unable to access imaginary part of complex value in a hard register on this target"
argument_list|)
expr_stmt|;
else|else
return|return
name|gen_highpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff X, assumed to be a SUBREG,    refers to the real part of the complex value in its containing reg.    Complex values are always stored with the real part in the first word,    regardless of WORDS_BIG_ENDIAN.  */
end_comment

begin_function
name|int
name|subreg_realpart_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
operator|<
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming that X is an rtx (e.g., MEM, REG or SUBREG) for a value,    return an rtx (MEM, SUBREG, or CONST_INT) that refers to the    least-significant part of X.    MODE specifies how big a part of X to return;    it usually should not be larger than a word.    If X is a MEM whose address is a QUEUED, the value may be so also.  */
end_comment

begin_function
name|rtx
name|gen_lowpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|result
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Must be a hard reg that's not valid in MODE.  */
name|result
operator|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|copy_to_reg
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* The only additional case we can do is MEM.  */
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Adjust the address so that the address-after-the-data 	   is unchanged.  */
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like `gen_lowpart', but refer to the most significant part.     This is used to access the imaginary part of a complex number.  */
end_comment

begin_function
name|rtx
name|gen_highpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
comment|/* This case loses if X is a subreg.  To catch bugs early,      complain if an invalid MODE is used even in other cases.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
if|#
directive|if
operator|!
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|HOST_FLOAT_FORMAT
operator|||
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
endif|#
directive|endif
condition|)
return|return
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<=
name|BITS_PER_WORD
condition|)
return|return
name|const0_rtx
return|;
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|BITS_PER_WORD
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|offset
operator|-=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* The only time this should occur is when we are looking at a 	 multi-word item with a SUBREG whose mode is the same as that of the 	 item.  It isn't clear what we would do if it wasn't.  */
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|gen_highpart
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|word
decl_stmt|;
comment|/* Let the backend decide how many registers to skip.  This is needed          in particular for sparc64 where fp regs are smaller than a word.  */
comment|/* ??? Note that subregs are now ambiguous, in that those against 	 pseudos are sized by the word size, while those against hard 	 regs are sized by the underlying register size.  Better would be 	 to always interpret the subreg offset parameter as bytes or bits.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|word
operator|=
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
else|else
name|word
operator|=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
comment|/* integrate.c can't handle parts of a return value register.  */
operator|&&
operator|(
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|rtx_equal_function_value_matters
operator|)
comment|/* We want to keep the stack, frame, and arg pointers special.  */
operator|&&
name|x
operator|!=
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|x
operator|!=
name|arg_pointer_rtx
endif|#
directive|endif
operator|&&
name|x
operator|!=
name|stack_pointer_rtx
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|word
argument_list|)
return|;
else|else
return|return
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|word
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 iff X, assumed to be a SUBREG,    refers to the least significant part of its containing reg.    If X is not a SUBREG, always return 1 (it is its own low part!).  */
end_comment

begin_function
name|int
name|subreg_lowpart_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
operator|(
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
return|;
return|return
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return subword I of operand OP.    The word number, I, is interpreted as the word number starting at the    low-order address.  Word 0 is the low-order word if not WORDS_BIG_ENDIAN,    otherwise it is the high-order word.     If we cannot extract the required word, we return zero.  Otherwise, an    rtx corresponding to the requested word will be returned.     VALIDATE_ADDRESS is nonzero if the address should be validated.  Before    reload has completed, a valid address will always be returned.  After    reload, if a valid address cannot be returned, we return zero.     If VALIDATE_ADDRESS is zero, we simply form the required address; validating    it is the responsibility of the caller.     MODE is the mode of OP in case it is a CONST_INT.  */
end_comment

begin_function
name|rtx
name|operand_subword
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|validate_address
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|validate_address
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|int
name|size_ratio
init|=
name|HOST_BITS_PER_WIDE_INT
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|int
name|bits_per_word
init|=
name|BITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If OP is narrower than a word, fail. */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If we want a word outside OP, return zero. */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* If OP is already an integer word, return it.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
condition|)
return|return
name|op
return|;
comment|/* If OP is a REG or SUBREG, we can handle it very simply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* ??? There is a potential problem with this code.  It does not 	 properly handle extractions of a subword from a hard register 	 that is larger than word_mode.  Presumably the check for 	 HARD_REGNO_MODE_OK catches these most of these cases.  */
comment|/* If OP is a hard register, but OP + I is not a hard register, 	 then extracting a subword is impossible.  	 For example, consider if OP is the last hard register and it is 	 larger than word_mode.  If we wanted word N (for N> 0) because a 	 part of that hard register was known to contain a useful value, 	 then OP + I would refer to a pseudo, not the hard register we 	 actually wanted.  */
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|+
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
comment|/* If the register is not valid for MODE, return 0.  Note we 	 have to check both OP and OP + I since they may refer to 	 different parts of the register file.  	 Consider if OP refers to the last 96bit FP register and we want 	 subword 3 because that subword is known to contain a value we 	 needed.  */
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|,
name|word_mode
argument_list|)
operator|||
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|+
name|i
argument_list|,
name|word_mode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|op
argument_list|)
operator|&&
name|rtx_equal_function_value_matters
operator|)
comment|/* We want to keep the stack, frame, and arg pointers 		  special.  */
operator|||
name|op
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|op
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|||
name|op
operator|==
name|stack_pointer_rtx
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|word_mode
argument_list|,
name|op
argument_list|,
name|i
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
operator|+
name|i
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|word_mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|i
operator|+
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|int
name|partwords
init|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|partwords
condition|)
return|return
name|operand_subword
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|validate_address
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|operand_subword
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|i
operator|-
name|partwords
argument_list|,
name|validate_address
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Form a new MEM at the requested address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|validate_address
condition|)
block|{
if|if
condition|(
name|reload_completed
condition|)
block|{
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|word_mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|word_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
comment|/* The only remaining cases are when OP is a constant.  If the host and      target floating formats are the same, handling two-word floating      constants are easy.  Note that REAL_VALUE_TO_TARGET_{SINGLE,DOUBLE}      are defined as returning one or two 32 bit values, respectively,      and not values of BITS_PER_WORD bits.  */
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
comment|/*  The output is some bits, the width of the target machine's word.     A wider-word host can surely hold them in a CONST_INT. A narrower-word     host can't.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|BITS_PER_WORD
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|long
name|k
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* We handle 32-bit and>= 64-bit words here.  Note that the order in 	 which the words are written depends on the word endianness. 	 ??? This is a potential portability problem and should 	 be fixed at some point.  	 We must excercise caution with the sign bit.  By definition there 	 are 32 significant bits in K; there may be more in a HOST_WIDE_INT. 	 Consider a host with a 32-bit long and a 64-bit HOST_WIDE_INT. 	 So we explicitly mask and sign-extend as necessary.  */
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|k
index|[
name|i
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
elseif|else
if|if
condition|(
name|BITS_PER_WORD
operator|>=
literal|64
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|k
index|[
operator|!
name|WORDS_BIG_ENDIAN
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
operator|<<
literal|32
expr_stmt|;
name|val
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
name|WORDS_BIG_ENDIAN
index|]
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|16
condition|)
block|{
name|val
operator|=
name|k
index|[
name|i
operator|>>
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|val
operator|>>=
literal|16
expr_stmt|;
name|val
operator|&=
literal|0xffff
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|BITS_PER_WORD
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|long
name|k
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|k
index|[
name|i
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* no REAL_ARITHMETIC */
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* The constant is stored in the host's word-ordering, 	 but we want to access it in the target's word-ordering.  Some 	 compilers don't like a conditional inside macro args, so we have two 	 copies of the return.  */
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
return|return
name|GEN_INT
argument_list|(
name|i
operator|==
name|WORDS_BIG_ENDIAN
condition|?
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|GEN_INT
argument_list|(
name|i
operator|!=
name|WORDS_BIG_ENDIAN
condition|?
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
comment|/* Single word float is a little harder, since single- and double-word      values often do not have the same high-order bits.  We have already      verified that we want the only defined word of the single-word value.  */
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|32
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|long
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Sign extend from known 32-bit value to HOST_WIDE_INT.  */
name|val
operator|=
name|l
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|16
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|val
operator|>>=
literal|16
expr_stmt|;
name|val
operator|&=
literal|0xffff
expr_stmt|;
block|}
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
literal|8
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|double
name|d
decl_stmt|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|}
name|u
union|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|u
operator|.
name|f
operator|=
name|d
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|u
operator|.
name|i
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
literal|8
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|double
name|d
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|}
name|u
union|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|u
operator|.
name|d
operator|=
name|d
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|u
operator|.
name|i
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
comment|/* The only remaining cases that we can handle are integers.      Convert to proper endianness now since these cases need it.      At this point, i == 0 means the low-order word.         We do not want to handle the case when BITS_PER_WORD<= HOST_BITS_PER_INT      in general.  However, if OP is (const_int 0), we can just return      it for any word.  */
if|if
condition|(
name|op
operator|==
name|const0_rtx
condition|)
return|return
name|op
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|)
operator|||
name|BITS_PER_WORD
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|i
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|-
literal|1
operator|-
name|i
expr_stmt|;
comment|/* Find out which word on the host machine this value is in and get      it from the constant.  */
name|val
operator|=
operator|(
name|i
operator|/
name|size_ratio
operator|==
literal|0
condition|?
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|op
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|)
else|:
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|?
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0
condition|?
operator|~
literal|0
else|:
literal|0
operator|)
else|:
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Get the value we want into the low bits of val.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|=
operator|(
operator|(
name|val
operator|>>
operator|(
operator|(
name|i
operator|%
name|size_ratio
operator|)
operator|*
name|BITS_PER_WORD
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Clear the bits that don't belong in our mode, unless they and our sign      bit are all one.  So we get either a reasonable negative value or a      reasonable unsigned value for this mode.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|bits_per_word
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|bits_per_word
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits_per_word
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this would be an entire word for the target, but is not for      the host, then sign-extend on the host so that the number will look      the same way on the host that it would on the target.       For example, when building a 64 bit alpha hosted 32 bit sparc      targeted compiler, then we want the 32 bit unsigned value -1 to be      represented as a 64 bit value -1, and not as 0x00000000ffffffff.      The later confuses the sparc backend.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bits_per_word
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|bits_per_word
operator|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to `operand_subword', but never return 0.  If we can't extract    the required subword, put OP into a register and try again.  If that fails,    abort.  We always validate the address in this case.  It is not valid    to call this function after reload; it is mostly meant for RTL    generation.      MODE is the mode of OP, in case it is CONST_INT.  */
end_comment

begin_function
name|rtx
name|operand_subword_force
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|result
init|=
name|operand_subword
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* If this is a register which can not be accessed by words, copy it 	 to a pseudo register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
name|op
operator|=
name|copy_to_reg
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|op
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|operand_subword
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a compare instruction, swap the operands.    A test instruction is changed into a compare of 0 against the operand.  */
end_comment

begin_function
name|void
name|reverse_comparison
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|comp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
name|comp
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
else|else
name|comp
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comp
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|0
argument_list|)
operator|=
name|op1
expr_stmt|;
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|1
argument_list|)
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|new
init|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|comp
argument_list|)
argument_list|)
argument_list|,
name|comp
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|new
expr_stmt|;
else|else
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed    to MODE and its address changed to ADDR.    (VOIDmode means don't change the mode.    NULL for ADDR means don't change the address.)  */
end_comment

begin_function
name|rtx
name|change_address
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|addr
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If reload is in progress or has completed, ADDR must be valid.      Otherwise, we can call memory_address to make it valid.  */
if|if
condition|(
name|reload_completed
operator|||
name|reload_in_progress
condition|)
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|addr
argument_list|,
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
return|return
name|memref
return|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|memref
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|memref
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly created CODE_LABEL rtx with a unique label number.  */
end_comment

begin_function
name|rtx
name|gen_label_rtx
parameter_list|()
block|{
specifier|register
name|rtx
name|label
decl_stmt|;
name|label
operator|=
name|gen_rtx_CODE_LABEL
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label_num
operator|++
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For procedure integration.  */
end_comment

begin_comment
comment|/* Return a newly created INLINE_HEADER rtx.  Should allocate this    from a permanent obstack when the opportunity arises.  */
end_comment

begin_function
name|rtx
name|gen_inline_header_rtx
parameter_list|(
name|first_insn
parameter_list|,
name|first_parm_insn
parameter_list|,
name|first_labelno
parameter_list|,
name|last_labelno
parameter_list|,
name|max_parm_regnum
parameter_list|,
name|max_regnum
parameter_list|,
name|args_size
parameter_list|,
name|pops_args
parameter_list|,
name|stack_slots
parameter_list|,
name|forced_labels
parameter_list|,
name|function_flags
parameter_list|,
name|outgoing_args_size
parameter_list|,
name|original_arg_vector
parameter_list|,
name|original_decl_initial
parameter_list|,
name|regno_rtx
parameter_list|,
name|regno_flag
parameter_list|,
name|regno_align
parameter_list|,
name|parm_reg_stack_loc
parameter_list|)
name|rtx
name|first_insn
decl_stmt|,
name|first_parm_insn
decl_stmt|;
name|int
name|first_labelno
decl_stmt|,
name|last_labelno
decl_stmt|,
name|max_parm_regnum
decl_stmt|,
name|max_regnum
decl_stmt|,
name|args_size
decl_stmt|;
name|int
name|pops_args
decl_stmt|;
name|rtx
name|stack_slots
decl_stmt|;
name|rtx
name|forced_labels
decl_stmt|;
name|int
name|function_flags
decl_stmt|;
name|int
name|outgoing_args_size
decl_stmt|;
name|rtvec
name|original_arg_vector
decl_stmt|;
name|rtx
name|original_decl_initial
decl_stmt|;
name|rtvec
name|regno_rtx
decl_stmt|;
name|char
modifier|*
name|regno_flag
decl_stmt|;
name|char
modifier|*
name|regno_align
decl_stmt|;
name|rtvec
name|parm_reg_stack_loc
decl_stmt|;
block|{
name|rtx
name|header
init|=
name|gen_rtx_INLINE_HEADER
argument_list|(
name|VOIDmode
argument_list|,
name|cur_insn_uid
operator|++
argument_list|,
name|NULL_RTX
argument_list|,
name|first_insn
argument_list|,
name|first_parm_insn
argument_list|,
name|first_labelno
argument_list|,
name|last_labelno
argument_list|,
name|max_parm_regnum
argument_list|,
name|max_regnum
argument_list|,
name|args_size
argument_list|,
name|pops_args
argument_list|,
name|stack_slots
argument_list|,
name|forced_labels
argument_list|,
name|function_flags
argument_list|,
name|outgoing_args_size
argument_list|,
name|original_arg_vector
argument_list|,
name|original_decl_initial
argument_list|,
name|regno_rtx
argument_list|,
name|regno_flag
argument_list|,
name|regno_align
argument_list|,
name|parm_reg_stack_loc
argument_list|)
decl_stmt|;
return|return
name|header
return|;
block|}
end_function

begin_comment
comment|/* Install new pointers to the first and last insns in the chain.    Also, set cur_insn_uid to one higher than the last in use.    Used for an inline-procedure after copying the insn chain.  */
end_comment

begin_function
name|void
name|set_new_first_and_last_insn
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
name|cur_insn_uid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|cur_insn_uid
operator|=
name|MAX
argument_list|(
name|cur_insn_uid
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|cur_insn_uid
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the range of label numbers found in the current function.    This is used when belatedly compiling an inline function.  */
end_comment

begin_function
name|void
name|set_new_first_and_last_label_num
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|base_label_num
operator|=
name|label_num
expr_stmt|;
name|first_label_num
operator|=
name|first
expr_stmt|;
name|last_label_num
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save all variables describing the current status into the structure *P.    This is used before starting a nested function.  */
end_comment

begin_function
name|void
name|save_emit_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|reg_rtx_no
operator|=
name|reg_rtx_no
expr_stmt|;
name|p
operator|->
name|first_label_num
operator|=
name|first_label_num
expr_stmt|;
name|p
operator|->
name|first_insn
operator|=
name|first_insn
expr_stmt|;
name|p
operator|->
name|last_insn
operator|=
name|last_insn
expr_stmt|;
name|p
operator|->
name|sequence_rtl_expr
operator|=
name|sequence_rtl_expr
expr_stmt|;
name|p
operator|->
name|sequence_stack
operator|=
name|sequence_stack
expr_stmt|;
name|p
operator|->
name|cur_insn_uid
operator|=
name|cur_insn_uid
expr_stmt|;
name|p
operator|->
name|last_linenum
operator|=
name|last_linenum
expr_stmt|;
name|p
operator|->
name|last_filename
operator|=
name|last_filename
expr_stmt|;
name|p
operator|->
name|regno_pointer_flag
operator|=
name|regno_pointer_flag
expr_stmt|;
name|p
operator|->
name|regno_pointer_align
operator|=
name|regno_pointer_align
expr_stmt|;
name|p
operator|->
name|regno_pointer_flag_length
operator|=
name|regno_pointer_flag_length
expr_stmt|;
name|p
operator|->
name|regno_reg_rtx
operator|=
name|regno_reg_rtx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore all variables describing the current status from the structure *P.    This is used after a nested function.  */
end_comment

begin_function
name|void
name|restore_emit_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|reg_rtx_no
operator|=
name|p
operator|->
name|reg_rtx_no
expr_stmt|;
name|first_label_num
operator|=
name|p
operator|->
name|first_label_num
expr_stmt|;
name|last_label_num
operator|=
literal|0
expr_stmt|;
name|first_insn
operator|=
name|p
operator|->
name|first_insn
expr_stmt|;
name|last_insn
operator|=
name|p
operator|->
name|last_insn
expr_stmt|;
name|sequence_rtl_expr
operator|=
name|p
operator|->
name|sequence_rtl_expr
expr_stmt|;
name|sequence_stack
operator|=
name|p
operator|->
name|sequence_stack
expr_stmt|;
name|cur_insn_uid
operator|=
name|p
operator|->
name|cur_insn_uid
expr_stmt|;
name|last_linenum
operator|=
name|p
operator|->
name|last_linenum
expr_stmt|;
name|last_filename
operator|=
name|p
operator|->
name|last_filename
expr_stmt|;
name|regno_pointer_flag
operator|=
name|p
operator|->
name|regno_pointer_flag
expr_stmt|;
name|regno_pointer_align
operator|=
name|p
operator|->
name|regno_pointer_align
expr_stmt|;
name|regno_pointer_flag_length
operator|=
name|p
operator|->
name|regno_pointer_flag_length
expr_stmt|;
name|regno_reg_rtx
operator|=
name|p
operator|->
name|regno_reg_rtx
expr_stmt|;
comment|/* Clear our cache of rtx expressions for start_sequence and      gen_sequence.  */
name|sequence_element_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SEQUENCE_RESULT_SIZE
condition|;
name|i
operator|++
control|)
name|sequence_result
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|free_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared structure.    It does not work to do this twice, because the mark bits set here    are not cleared afterwards.  */
end_comment

begin_function
name|void
name|unshare_all_rtl
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the addresses of stack slots found outside the insn chain      (such as, in DECL_RTL of a variable) are not shared      with the insn chain.       This special care is necessary when the stack slot MEM does not      actually appear in the insn chain.  If it does appear, its address      is unshared from all else at that point.  */
name|copy_rtx_if_shared
argument_list|(
name|stack_slot_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark ORIG as in use, and return a copy of it if it was already in use.    Recursively does the same for subexpressions.  */
end_comment

begin_function
name|rtx
name|copy_rtx_if_shared
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|orig
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
comment|/* SCRATCH must be shared because they represent distinct values.  */
return|return
name|x
return|;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|x
return|;
break|break;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return
name|x
return|;
case|case
name|MEM
case|:
comment|/* A MEM is allowed to be shared if its address is constant 	 or is a constant plus one of the special registers.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This MEM can appear in more than one place, 	     but its address better not be shared with anything else.  */
if|if
condition|(
operator|!
name|x
operator|->
name|used
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|used
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* This rtx may not be shared.  If it has already been seen,      replace it with a copy of itself.  */
if|if
condition|(
name|x
operator|->
name|used
condition|)
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|copy
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|copy
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|copy
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|copy
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|copy
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|->
name|used
operator|=
literal|1
expr_stmt|;
comment|/* Now scan the subexpressions recursively.      We can store any replaced subexpressions directly into X      since we know X is not shared!  Any vectors in X      must be copied if X was copied.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|copied
operator|&&
name|len
operator|>
literal|0
condition|)
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtvec_vv
argument_list|(
name|len
argument_list|,
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|->
name|elem
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Clear all the USED bits in X to allow copy_rtx_if_shared to be used    to look for shared sub-parts.  */
end_comment

begin_function
name|void
name|reset_used_flags
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared so we needn't do any resetting      for them.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return;
default|default:
break|break;
block|}
name|x
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|reset_used_flags
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|reset_used_flags
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy X if necessary so that it won't be altered by changes in OTHER.    Return X or the rtx for the pseudo reg the value of X was copied into.    OTHER must be valid as a SET_DEST.  */
end_comment

begin_function
name|rtx
name|make_safe_from
parameter_list|(
name|x
parameter_list|,
name|other
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|other
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
name|other
operator|=
name|SUBREG_REG
argument_list|(
name|other
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRICT_LOW_PART
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|other
operator|=
name|XEXP
argument_list|(
name|other
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|other
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_mentioned_p
argument_list|(
name|other
argument_list|,
name|x
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emission of insns (adding them to the doubly-linked list).  */
end_comment

begin_comment
comment|/* Return the first insn of the current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_insns
parameter_list|()
block|{
return|return
name|first_insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last insn emitted in current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_last_insn
parameter_list|()
block|{
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Specify a new insn as the last in the chain.  */
end_comment

begin_function
name|void
name|set_last_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the last insn emitted, even if it is in a sequence now pushed.  */
end_comment

begin_function
name|rtx
name|get_last_insn_anywhere
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|;
if|if
condition|(
name|last_insn
condition|)
return|return
name|last_insn
return|;
for|for
control|(
name|stack
operator|=
name|sequence_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|stack
operator|->
name|last
operator|!=
literal|0
condition|)
return|return
name|stack
operator|->
name|last
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a number larger than any instruction's uid in this function.  */
end_comment

begin_function
name|int
name|get_max_uid
parameter_list|()
block|{
return|return
name|cur_insn_uid
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the next insn.  If it is a SEQUENCE, return the first insn    of the sequence.  */
end_comment

begin_function
name|rtx
name|next_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the previous insn.  If it is a SEQUENCE, return the last insn    of the sequence.  */
end_comment

begin_function
name|rtx
name|previous_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next insn after INSN that is not a NOTE.  This routine does not    look inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|next_nonnote_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the previous insn before INSN that is not a NOTE.  This routine does    not look inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|prev_nonnote_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;    or 0, if there is none.  This routine does not look inside    SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|next_real_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last INSN, CALL_INSN or JUMP_INSN before INSN;    or 0, if there is none.  This routine does not look inside    SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|prev_real_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Find the next insn after INSN that really does something.  This routine    does not look inside SEQUENCEs.  Until reload has completed, this is the    same as next_real_insn.  */
end_comment

begin_function
name|rtx
name|next_active_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Find the last insn before INSN that really does something.  This routine    does not look inside SEQUENCEs.  Until reload has completed, this is the    same as prev_real_insn.  */
end_comment

begin_function
name|rtx
name|prev_active_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next CODE_LABEL after the insn INSN, or 0 if there is none.  */
end_comment

begin_function
name|rtx
name|next_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last CODE_LABEL before the insn INSN, or 0 if there is none.  */
end_comment

begin_function
name|rtx
name|prev_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER    and REG_CC_USER notes so we can find it.  */
end_comment

begin_function
name|void
name|link_cc0_insns
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|user
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|user
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|user
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|user
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|user
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|user
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_CC_SETTER
argument_list|,
name|insn
argument_list|,
name|REG_NOTES
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_CC_USER
argument_list|,
name|user
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the next insn that uses CC0 after INSN, which is assumed to    set it.  This is the inverse of prev_cc0_setter (i.e., prev_cc0_setter    applied to the result of this function should yield INSN).     Normally, this is simply the next insn.  However, if a REG_CC_USER note    is present, it contains the insn that uses CC0.     Return 0 if we can't find the insn.  */
end_comment

begin_function
name|rtx
name|next_cc0_user
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_USER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
return|return
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
return|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|insn
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the insn that set CC0 for INSN.  Unless INSN has a REG_CC_SETTER    note, it is the previous insn.  */
end_comment

begin_function
name|rtx
name|prev_cc0_setter
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
return|return
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
return|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Try splitting insns that can be split for better scheduling.    PAT is the pattern which might split.    TRIAL is the insn providing PAT.    LAST is non-zero if we should return the last insn of the sequence produced.     If this routine succeeds in splitting, it returns the first or last    replacement insn depending on the value of LAST.  Otherwise, it    returns TRIAL.  If the insn to be returned can be split, it will be.  */
end_comment

begin_function
name|rtx
name|try_split
parameter_list|(
name|pat
parameter_list|,
name|trial
parameter_list|,
name|last
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|trial
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
name|rtx
name|before
init|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|after
init|=
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|seq
init|=
name|split_insns
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|)
decl_stmt|;
name|int
name|has_barrier
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If we are splitting a JUMP_INSN, it might be followed by a BARRIER.      We may need to handle this specially.  */
if|if
condition|(
name|after
operator|&&
name|GET_CODE
argument_list|(
name|after
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|has_barrier
operator|=
literal|1
expr_stmt|;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seq
condition|)
block|{
comment|/* SEQ can either be a SEQUENCE or the pattern of a single insn. 	 The latter case will normally arise only when being done so that 	 it, in turn, will be split (SFmode on the 29k is an example).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* If we are splitting a JUMP_INSN, look for the JUMP_INSN in 	     SEQ and copy our JUMP_LABEL to it.  If JUMP_LABEL is non-zero, 	     increment the usage count so we don't delete the label.  */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|JUMP_INSN
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|trial
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
name|tem
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_barrier
condition|)
name|emit_barrier_after
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Recursively call try_split for each new insn created; by the 	     time control returns here that insn will be fully split, so 	     set LAST and continue from the insn after the one returned. 	     We can't use next_active_insn here since AFTER may be a note. 	     Ignore deleted insns, which can be occur if not optimizing.  */
for|for
control|(
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|before
argument_list|)
init|;
name|tem
operator|!=
name|after
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|tem
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|tem
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid infinite loop if the result matches the original pattern.  */
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|seq
argument_list|,
name|pat
argument_list|)
condition|)
return|return
name|trial
return|;
else|else
block|{
name|PATTERN
argument_list|(
name|trial
argument_list|)
operator|=
name|seq
expr_stmt|;
name|INSN_CODE
argument_list|(
name|trial
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|try_split
argument_list|(
name|seq
argument_list|,
name|trial
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* Return either the first or the last insn, depending on which was 	 requested.  */
return|return
name|last
condition|?
name|prev_active_insn
argument_list|(
name|after
argument_list|)
else|:
name|next_active_insn
argument_list|(
name|before
argument_list|)
return|;
block|}
return|return
name|trial
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make and return an INSN rtx, initializing all its slots.    Store PATTERN in the pattern slots.  */
end_comment

begin_function
name|rtx
name|make_insn_raw
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
comment|/* If in RTL generation phase, see if FREE_INSN can be used.  */
if|if
condition|(
name|free_insn
operator|!=
literal|0
operator|&&
name|rtx_equal_function_value_matters
condition|)
block|{
name|insn
operator|=
name|free_insn
expr_stmt|;
name|free_insn
operator|=
name|NEXT_INSN
argument_list|(
name|free_insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|INSN
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like `make_insn' but make a JUMP_INSN instead of an insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_jump_insn_raw
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|JUMP_INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like `make_insn' but make a CALL_INSN instead of an insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_call_insn_raw
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|CALL_INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add INSN to the end of the doubly-linked list.    INSN may be an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER or NOTE.  */
end_comment

begin_function
name|void
name|add_insn
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last_insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|last_insn
condition|)
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|first_insn
condition|)
name|first_insn
operator|=
name|insn
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN into the doubly-linked list after insn AFTER.  This and    the next should be the only functions called to insert an insn once    delay slots have been filled since only they know how to update a    SEQUENCE.  */
end_comment

begin_function
name|void
name|add_insn_after
parameter_list|(
name|insn
parameter_list|,
name|after
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|after
decl_stmt|;
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|INSN_DELETED_P
argument_list|(
name|after
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_insn
operator|==
name|after
condition|)
name|last_insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|sequence_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|after
operator|==
name|stack
operator|->
name|last
condition|)
block|{
name|stack
operator|->
name|last
operator|=
name|insn
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|after
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add INSN into the doubly-linked list before insn BEFORE.  This and    the previous should be the only functions called to insert an insn once    delay slots have been filled since only they know how to update a    SEQUENCE.  */
end_comment

begin_function
name|void
name|add_insn_before
parameter_list|(
name|insn
parameter_list|,
name|before
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|before
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|INSN_DELETED_P
argument_list|(
name|before
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_insn
operator|==
name|before
condition|)
name|first_insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|sequence_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|before
operator|==
name|stack
operator|->
name|first
condition|)
block|{
name|stack
operator|->
name|first
operator|=
name|insn
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|PREV_INSN
argument_list|(
name|before
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove an insn from its doubly-linked list.  This function knows how    to handle sequences.  */
end_comment

begin_function
name|void
name|remove_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_insn
operator|==
name|insn
condition|)
name|first_insn
operator|=
name|next
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|sequence_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|insn
operator|==
name|stack
operator|->
name|first
condition|)
block|{
name|stack
operator|->
name|first
operator|=
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
block|{
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_insn
operator|==
name|insn
condition|)
name|last_insn
operator|=
name|prev
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|sequence_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|insn
operator|==
name|stack
operator|->
name|last
condition|)
block|{
name|stack
operator|->
name|last
operator|=
name|prev
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all insns made since FROM.    FROM becomes the new last instruction.  */
end_comment

begin_function
name|void
name|delete_insns_since
parameter_list|(
name|from
parameter_list|)
name|rtx
name|from
decl_stmt|;
block|{
if|if
condition|(
name|from
operator|==
literal|0
condition|)
name|first_insn
operator|=
literal|0
expr_stmt|;
else|else
name|NEXT_INSN
argument_list|(
name|from
argument_list|)
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
name|from
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is deprecated, please use sequences instead.     Move a consecutive bunch of insns to a different place in the chain.    The insns to be moved are those between FROM and TO.    They are moved to a new position after the insn AFTER.    AFTER must not be FROM or TO or any insn in between.     This function does not know about SEQUENCEs and hence should not be    called after delay-slot filling has been done.  */
end_comment

begin_function
name|void
name|reorder_insns
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|after
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|after
decl_stmt|;
block|{
comment|/* Splice this bunch out of where it is now.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_insn
operator|==
name|to
condition|)
name|last_insn
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_insn
operator|==
name|from
condition|)
name|first_insn
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Make the new neighbors point to it and it to them.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|=
name|to
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|from
argument_list|)
operator|=
name|after
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last_insn
condition|)
name|last_insn
operator|=
name|to
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the line note insn preceding INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_line_note
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|no_line_numbers
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
break|break;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like reorder_insns, but inserts line notes to preserve the line numbers    of the moved insns when debugging.  This may insert a note between AFTER    and FROM, and another one after TO.  */
end_comment

begin_function
name|void
name|reorder_insns_with_line_notes
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|after
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|after
decl_stmt|;
block|{
name|rtx
name|from_line
init|=
name|find_line_note
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|rtx
name|after_line
init|=
name|find_line_note
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|reorder_insns
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_line
operator|==
name|after_line
condition|)
return|return;
if|if
condition|(
name|from_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn of given code and pattern    at a specified place within the doubly-linked list.  */
end_comment

begin_comment
comment|/* Make an instruction with body PATTERN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|before
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|<
name|SEQUENCE_RESULT_SIZE
condition|)
name|sequence_result
index|[
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|pattern
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body PATTERN and code JUMP_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body PATTERN and code CALL_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|make_call_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|CALL_INSN
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and output it before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_barrier_before
parameter_list|(
name|before
parameter_list|)
specifier|register
name|rtx
name|before
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the label LABEL before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_label_before
parameter_list|(
name|label
parameter_list|,
name|before
parameter_list|)
name|rtx
name|label
decl_stmt|,
name|before
decl_stmt|;
block|{
comment|/* This can be called twice for the same label as a result of the      confusion that follows a syntax error!  So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_before
argument_list|(
name|label
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Emit a note of subtype SUBTYPE before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_note_before
parameter_list|(
name|subtype
parameter_list|,
name|before
parameter_list|)
name|int
name|subtype
decl_stmt|;
name|rtx
name|before
decl_stmt|;
block|{
specifier|register
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|add_insn_before
argument_list|(
name|note
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an insn of code INSN with body PATTERN    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_insn_after
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|after
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|after
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|<
name|SEQUENCE_RESULT_SIZE
condition|)
name|sequence_result
index|[
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|pattern
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Similar to emit_insn_after, except that line notes are to be inserted so    as to act as if this insn were at FROM.  */
end_comment

begin_function
name|void
name|emit_insn_after_with_line_notes
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|,
name|from
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|,
name|from
decl_stmt|;
block|{
name|rtx
name|from_line
init|=
name|find_line_note
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|rtx
name|after_line
init|=
name|find_line_note
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|emit_insn_after
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|from_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with body PATTERN    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_after
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_barrier_after
parameter_list|(
name|after
parameter_list|)
specifier|register
name|rtx
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the label LABEL after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_label_after
parameter_list|(
name|label
parameter_list|,
name|after
parameter_list|)
name|rtx
name|label
decl_stmt|,
name|after
decl_stmt|;
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|label
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Emit a note of subtype SUBTYPE after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_note_after
parameter_list|(
name|subtype
parameter_list|,
name|after
parameter_list|)
name|int
name|subtype
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Emit a line note for FILE and LINE after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_line_note_after
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|after
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|no_line_numbers
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
name|file
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|line
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an insn of code INSN with pattern PATTERN    and add it to the end of the doubly-linked list.    If PATTERN is a SEQUENCE, take the elements of it    and emit an insn for each element.     Returns the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|last_insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|<
name|SEQUENCE_RESULT_SIZE
condition|)
name|sequence_result
index|[
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|pattern
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the insns in a chain starting with INSN.    Return the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insns
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|last
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Emit the insns in a chain starting with INSN and place them in front of    the insn BEFORE.  Return the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insns_before
parameter_list|(
name|insn
parameter_list|,
name|before
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|before
decl_stmt|;
block|{
name|rtx
name|last
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Emit the insns in a chain starting with FIRST and place them in back of    the insn AFTER.  Return the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insns_after
parameter_list|(
name|first
parameter_list|,
name|after
parameter_list|)
specifier|register
name|rtx
name|first
decl_stmt|;
specifier|register
name|rtx
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|last
decl_stmt|;
specifier|register
name|rtx
name|after_after
decl_stmt|;
if|if
condition|(
operator|!
name|after
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|first
return|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
continue|continue;
name|after_after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|first
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first
argument_list|)
operator|=
name|after
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|after_after
expr_stmt|;
if|if
condition|(
name|after_after
condition|)
name|PREV_INSN
argument_list|(
name|after_after
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last_insn
condition|)
name|last_insn
operator|=
name|last
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with pattern PATTERN    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
return|return
name|emit_insn
argument_list|(
name|pattern
argument_list|)
return|;
else|else
block|{
specifier|register
name|rtx
name|insn
init|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
end_function

begin_comment
comment|/* Make an insn of code CALL_INSN with pattern PATTERN    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_call_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
return|return
name|emit_insn
argument_list|(
name|pattern
argument_list|)
return|;
else|else
block|{
specifier|register
name|rtx
name|insn
init|=
name|make_call_insn_raw
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|CALL_INSN
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add the label LABEL to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_label
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_barrier
parameter_list|()
block|{
specifier|register
name|rtx
name|barrier
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|barrier
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
return|return
name|barrier
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code NOTE    with data-fields specified by FILE and LINE    and add it to the end of the doubly-linked list,    but only if line-numbers are desired for debugging info.  */
end_comment

begin_function
name|rtx
name|emit_line_note
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|emit_filename
operator|=
name|file
expr_stmt|;
name|emit_lineno
operator|=
name|line
expr_stmt|;
if|#
directive|if
literal|0
block|if (no_line_numbers)     return 0;
endif|#
directive|endif
return|return
name|emit_note
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code NOTE    with data-fields specified by FILE and LINE    and add it to the end of the doubly-linked list.    If it is a line-number NOTE, omit it if it matches the previous one.  */
end_comment

begin_function
name|rtx
name|emit_note
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
specifier|register
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|line
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|file
operator|&&
name|last_filename
operator|&&
operator|!
name|strcmp
argument_list|(
name|file
argument_list|,
name|last_filename
argument_list|)
operator|&&
name|line
operator|==
name|last_linenum
condition|)
return|return
literal|0
return|;
name|last_filename
operator|=
name|file
expr_stmt|;
name|last_linenum
operator|=
name|line
expr_stmt|;
block|}
if|if
condition|(
name|no_line_numbers
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
name|file
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|line
expr_stmt|;
name|add_insn
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Emit a NOTE, and don't omit it even if LINE is the previous note.  */
end_comment

begin_function
name|rtx
name|emit_line_note_force
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|last_linenum
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|emit_line_note
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cause next statement to emit a line note even if the line number    has not changed.  This is used at the beginning of a function.  */
end_comment

begin_function
name|void
name|force_next_line_note
parameter_list|()
block|{
name|last_linenum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place a note of KIND on insn INSN with DATUM as the datum. If a    note of this type already exists, remove it first. */
end_comment

begin_function
name|void
name|set_unique_reg_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|datum
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|rtx
name|datum
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|kind
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
comment|/* First remove the note if there already is one.  */
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|kind
argument_list|,
name|datum
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an indication of which type of insn should have X as a body.    The value is CODE_LABEL, INSN, CALL_INSN or JUMP_INSN.  */
end_comment

begin_function
name|enum
name|rtx_code
name|classify_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
name|CODE_LABEL
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|JUMP_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
else|else
return|return
name|INSN
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
block|}
return|return
name|INSN
return|;
block|}
end_function

begin_comment
comment|/* Emit the rtl pattern X as an appropriate kind of insn.    If X is a label, it is simply added into the insn chain.  */
end_comment

begin_function
name|rtx
name|emit
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|classify_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
return|return
name|emit_label
argument_list|(
name|x
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INSN
condition|)
return|return
name|emit_insn
argument_list|(
name|x
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
specifier|register
name|rtx
name|insn
init|=
name|emit_jump_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|emit_barrier
argument_list|()
return|;
return|return
name|insn
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
return|return
name|emit_call_insn
argument_list|(
name|x
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin emitting insns to a sequence which can be packaged in an    RTL_EXPR.  If this sequence will contain something that might cause    the compiler to pop arguments to function calls (because those    pops have previously been deferred; see INHIBIT_DEFER_POP for more    details), use do_pending_stack_adjust before calling this function.    That will ensure that the deferred pops are not accidentally    emitted in the middel of this sequence.  */
end_comment

begin_function
name|void
name|start_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|sequence_element_free_list
condition|)
block|{
comment|/* Reuse a previously-saved struct sequence_stack.  */
name|tem
operator|=
name|sequence_element_free_list
expr_stmt|;
name|sequence_element_free_list
operator|=
name|tem
operator|->
name|next
expr_stmt|;
block|}
else|else
name|tem
operator|=
operator|(
expr|struct
name|sequence_stack
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sequence_stack
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|->
name|next
operator|=
name|sequence_stack
expr_stmt|;
name|tem
operator|->
name|first
operator|=
name|first_insn
expr_stmt|;
name|tem
operator|->
name|last
operator|=
name|last_insn
expr_stmt|;
name|tem
operator|->
name|sequence_rtl_expr
operator|=
name|sequence_rtl_expr
expr_stmt|;
name|sequence_stack
operator|=
name|tem
expr_stmt|;
name|first_insn
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, but indicate that this sequence will be placed in T, an    RTL_EXPR.  See the documentation for start_sequence for more    information about how to use this function.  */
end_comment

begin_function
name|void
name|start_sequence_for_rtl_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|sequence_rtl_expr
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the insn chain starting with FIRST as the current sequence,    saving the previously current one.  See the documentation for    start_sequence for more information about how to use this function.  */
end_comment

begin_function
name|void
name|push_to_sequence
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|last
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|last
operator|&&
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
empty_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the outer-level insn chain    as the current sequence, saving the previously current one.  */
end_comment

begin_function
name|void
name|push_topmost_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|,
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|stack
operator|=
name|sequence_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
name|top
operator|=
name|stack
expr_stmt|;
name|first_insn
operator|=
name|top
operator|->
name|first
expr_stmt|;
name|last_insn
operator|=
name|top
operator|->
name|last
expr_stmt|;
name|sequence_rtl_expr
operator|=
name|top
operator|->
name|sequence_rtl_expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After emitting to the outer-level insn chain, update the outer-level    insn chain, and restore the previous saved state.  */
end_comment

begin_function
name|void
name|pop_topmost_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|,
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|stack
operator|=
name|sequence_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
name|top
operator|=
name|stack
expr_stmt|;
name|top
operator|->
name|first
operator|=
name|first_insn
expr_stmt|;
name|top
operator|->
name|last
operator|=
name|last_insn
expr_stmt|;
comment|/* ??? Why don't we save sequence_rtl_expr here?  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After emitting to a sequence, restore previous saved state.     To get the contents of the sequence just made, you must call    `gen_sequence' *before* calling here.       If the compiler might have deferred popping arguments while    generating this sequence, and this sequence will not be immediately    inserted into the instruction stream, use do_pending_stack_adjust    before calling gen_sequence.  That will ensure that the deferred    pops are inserted into this sequence, and not into some random    location in the instruction stream.  See INHIBIT_DEFER_POP for more    information about deferred popping of arguments.  */
end_comment

begin_function
name|void
name|end_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|tem
init|=
name|sequence_stack
decl_stmt|;
name|first_insn
operator|=
name|tem
operator|->
name|first
expr_stmt|;
name|last_insn
operator|=
name|tem
operator|->
name|last
expr_stmt|;
name|sequence_rtl_expr
operator|=
name|tem
operator|->
name|sequence_rtl_expr
expr_stmt|;
name|sequence_stack
operator|=
name|tem
operator|->
name|next
expr_stmt|;
name|tem
operator|->
name|next
operator|=
name|sequence_element_free_list
expr_stmt|;
name|sequence_element_free_list
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if currently emitting into a sequence.  */
end_comment

begin_function
name|int
name|in_sequence_p
parameter_list|()
block|{
return|return
name|sequence_stack
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate a SEQUENCE rtx containing the insns already emitted    to the current sequence.     This is how the gen_... function from a DEFINE_EXPAND    constructs the SEQUENCE that it returns.  */
end_comment

begin_function
name|rtx
name|gen_sequence
parameter_list|()
block|{
name|rtx
name|result
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Count the insns in the chain.  */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|first_insn
init|;
name|tem
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
name|len
operator|++
expr_stmt|;
comment|/* If only one insn, return its pattern rather than a SEQUENCE.      (Now that we cache SEQUENCE expressions, it isn't worth special-casing      the case of an empty list.)  */
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|first_insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* Don't discard the call usage field.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|NULL_RTX
operator|)
operator|)
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|free_insn
expr_stmt|;
name|free_insn
operator|=
name|first_insn
expr_stmt|;
return|return
name|PATTERN
argument_list|(
name|first_insn
argument_list|)
return|;
block|}
comment|/* Put them in a vector.  See if we already have a SEQUENCE of the      appropriate length around.  */
if|if
condition|(
name|len
operator|<
name|SEQUENCE_RESULT_SIZE
operator|&&
operator|(
name|result
operator|=
name|sequence_result
index|[
name|len
index|]
operator|)
operator|!=
literal|0
condition|)
name|sequence_result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Ensure that this rtl goes in saveable_obstack, since we may 	 cache it.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
name|result
operator|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tem
operator|=
name|first_insn
init|;
name|tem
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
operator|,
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|tem
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Put the various virtual registers into REGNO_REG_RTX.  */
end_comment

begin_function
name|void
name|init_virtual_regs
parameter_list|()
block|{
name|regno_reg_rtx
index|[
name|VIRTUAL_INCOMING_ARGS_REGNUM
index|]
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|regno_reg_rtx
index|[
name|VIRTUAL_STACK_VARS_REGNUM
index|]
operator|=
name|virtual_stack_vars_rtx
expr_stmt|;
name|regno_reg_rtx
index|[
name|VIRTUAL_STACK_DYNAMIC_REGNUM
index|]
operator|=
name|virtual_stack_dynamic_rtx
expr_stmt|;
name|regno_reg_rtx
index|[
name|VIRTUAL_OUTGOING_ARGS_REGNUM
index|]
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
name|regno_reg_rtx
index|[
name|VIRTUAL_CFA_REGNUM
index|]
operator|=
name|virtual_cfa_rtx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize data structures and variables in this file    before generating rtl for each function.  */
end_comment

begin_function
name|void
name|init_emit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|NULL
expr_stmt|;
name|sequence_rtl_expr
operator|=
name|NULL
expr_stmt|;
name|cur_insn_uid
operator|=
literal|1
expr_stmt|;
name|reg_rtx_no
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
expr_stmt|;
name|last_linenum
operator|=
literal|0
expr_stmt|;
name|last_filename
operator|=
literal|0
expr_stmt|;
name|first_label_num
operator|=
name|label_num
expr_stmt|;
name|last_label_num
operator|=
literal|0
expr_stmt|;
name|sequence_stack
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the start_sequence/gen_sequence cache.  */
name|sequence_element_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SEQUENCE_RESULT_SIZE
condition|;
name|i
operator|++
control|)
name|sequence_result
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|free_insn
operator|=
literal|0
expr_stmt|;
comment|/* Init the tables that describe all the pseudo regs.  */
name|regno_pointer_flag_length
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|101
expr_stmt|;
name|regno_pointer_flag
operator|=
operator|(
name|char
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regno_pointer_flag
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|regno_pointer_align
operator|=
operator|(
name|char
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regno_pointer_align
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
operator|(
name|rtx
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regno_reg_rtx
argument_list|,
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put copies of all the virtual register rtx into regno_reg_rtx.  */
name|init_virtual_regs
argument_list|()
expr_stmt|;
comment|/* Indicate that the virtual registers and stack locations are      all pointers.  */
name|REGNO_POINTER_FLAG
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|ARG_POINTER_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|VIRTUAL_INCOMING_ARGS_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|VIRTUAL_STACK_VARS_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|VIRTUAL_STACK_DYNAMIC_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|VIRTUAL_OUTGOING_ARGS_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REGNO_POINTER_FLAG
argument_list|(
name|VIRTUAL_CFA_REGNUM
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|REGNO_POINTER_ALIGN
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|ARG_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_INCOMING_ARGS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_STACK_VARS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_STACK_DYNAMIC_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_OUTGOING_ARGS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_CFA_REGNUM
argument_list|)
operator|=
name|UNITS_PER_WORD
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_EXPANDERS
name|INIT_EXPANDERS
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Create some permanent unique rtl objects shared between all functions.    LINE_NUMBERS is nonzero if line numbers are to be generated.  */
end_comment

begin_function
name|void
name|init_emit_once
parameter_list|(
name|line_numbers
parameter_list|)
name|int
name|line_numbers
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|double_mode
decl_stmt|;
name|no_line_numbers
operator|=
operator|!
name|line_numbers
expr_stmt|;
name|sequence_stack
operator|=
name|NULL
expr_stmt|;
comment|/* Compute the word and byte modes.  */
name|byte_mode
operator|=
name|VOIDmode
expr_stmt|;
name|word_mode
operator|=
name|VOIDmode
expr_stmt|;
name|double_mode
operator|=
name|VOIDmode
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_UNIT
operator|&&
name|byte_mode
operator|==
name|VOIDmode
condition|)
name|byte_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_WORD
operator|&&
name|word_mode
operator|==
name|VOIDmode
condition|)
name|word_mode
operator|=
name|mode
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
endif|#
directive|endif
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|DOUBLE_TYPE_SIZE
operator|&&
name|double_mode
operator|==
name|VOIDmode
condition|)
name|double_mode
operator|=
name|mode
expr_stmt|;
block|}
name|ptr_mode
operator|=
name|mode_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create the unique rtx's for certain rtx codes and operand values.  */
for|for
control|(
name|i
operator|=
operator|-
name|MAX_SAVED_CONST_INT
init|;
name|i
operator|<=
name|MAX_SAVED_CONST_INT
condition|;
name|i
operator|++
control|)
block|{
name|PUT_CODE
argument_list|(
operator|&
name|const_int_rtx
index|[
name|i
operator|+
name|MAX_SAVED_CONST_INT
index|]
argument_list|,
name|CONST_INT
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
operator|&
name|const_int_rtx
index|[
name|i
operator|+
name|MAX_SAVED_CONST_INT
index|]
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|INTVAL
argument_list|(
operator|&
name|const_int_rtx
index|[
name|i
operator|+
name|MAX_SAVED_CONST_INT
index|]
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|STORE_FLAG_VALUE
operator|>=
operator|-
name|MAX_SAVED_CONST_INT
operator|&&
name|STORE_FLAG_VALUE
operator|<=
name|MAX_SAVED_CONST_INT
condition|)
name|const_true_rtx
operator|=
operator|&
name|const_int_rtx
index|[
name|STORE_FLAG_VALUE
operator|+
name|MAX_SAVED_CONST_INT
index|]
expr_stmt|;
else|else
name|const_true_rtx
operator|=
name|gen_rtx_CONST_INT
argument_list|(
name|VOIDmode
argument_list|,
name|STORE_FLAG_VALUE
argument_list|)
expr_stmt|;
name|dconst0
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"0"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|dconst1
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"1"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|dconst2
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"2"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|dconstm1
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"-1"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|rtx
name|tem
init|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
comment|/* Zero any holes in a structure.  */
name|u
operator|.
name|d
operator|=
name|i
operator|==
literal|0
condition|?
name|dconst0
else|:
name|i
operator|==
literal|1
condition|?
name|dconst1
else|:
name|dconst2
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|tem
argument_list|)
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_MEM
argument_list|(
name|tem
argument_list|)
operator|=
name|cc0_rtx
expr_stmt|;
name|PUT_MODE
argument_list|(
name|tem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|tem
expr_stmt|;
block|}
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|VOIDmode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_PARTIAL_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_CC
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Assign register numbers to the globally defined register rtx.      This must be done at runtime because the register number field      is in a union and some compilers can't initialize unions.  */
name|REGNO
argument_list|(
name|stack_pointer_rtx
argument_list|)
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|frame_pointer_rtx
argument_list|)
operator|=
name|FRAME_POINTER_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|REGNO
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
name|REGNO
argument_list|(
name|arg_pointer_rtx
argument_list|)
operator|=
name|ARG_POINTER_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REGNO
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
operator|=
name|VIRTUAL_INCOMING_ARGS_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|virtual_stack_vars_rtx
argument_list|)
operator|=
name|VIRTUAL_STACK_VARS_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|)
operator|=
name|VIRTUAL_STACK_DYNAMIC_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|)
operator|=
name|VIRTUAL_OUTGOING_ARGS_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|virtual_cfa_rtx
argument_list|)
operator|=
name|VIRTUAL_CFA_REGNUM
expr_stmt|;
name|PUT_MODE
argument_list|(
name|virtual_cfa_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ADDRESS_POINTER_REGNUM
name|return_address_pointer_rtx
operator|=
name|gen_rtx_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_ADDRESS_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRUCT_VALUE
name|struct_value_rtx
operator|=
name|STRUCT_VALUE
expr_stmt|;
else|#
directive|else
name|struct_value_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING
name|struct_value_incoming_rtx
operator|=
name|STRUCT_VALUE_INCOMING
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING_REGNUM
name|struct_value_incoming_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct_value_incoming_rtx
operator|=
name|struct_value_rtx
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
name|static_chain_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
if|if
condition|(
name|STATIC_CHAIN_INCOMING_REGNUM
operator|!=
name|STATIC_CHAIN_REGNUM
condition|)
name|static_chain_incoming_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|static_chain_incoming_rtx
operator|=
name|static_chain_rtx
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN
name|static_chain_rtx
operator|=
name|STATIC_CHAIN
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING
name|static_chain_incoming_rtx
operator|=
name|STATIC_CHAIN_INCOMING
expr_stmt|;
else|#
directive|else
name|static_chain_incoming_rtx
operator|=
name|static_chain_rtx
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIC_OFFSET_TABLE_REGNUM
name|pic_offset_table_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_EXPANDERS
comment|/* This is to initialize save_machine_status and restore_machine_status before      the first call to push_function_context_to.  This is needed by the Chill      front end which calls push_function_context_to before the first cal to      init_function_start.  */
name|INIT_EXPANDERS
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Query and clear/ restore no_line_numbers.  This is used by the    switch / case handling in stmt.c to give proper line numbers in    warnings about unreachable code.  */
end_comment

begin_function
name|int
name|force_line_numbers
parameter_list|()
block|{
name|int
name|old
init|=
name|no_line_numbers
decl_stmt|;
name|no_line_numbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old
condition|)
name|force_next_line_note
argument_list|()
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_function
name|void
name|restore_line_number_status
parameter_list|(
name|old_value
parameter_list|)
name|int
name|old_value
decl_stmt|;
block|{
name|no_line_numbers
operator|=
name|old_value
expr_stmt|;
block|}
end_function

end_unit

