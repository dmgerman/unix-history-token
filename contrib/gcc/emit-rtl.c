begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Emit RTL for the GNU C-Compiler expander.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Middle-to-low level generation of rtx code and insns.     This file contains the functions `gen_rtx', `gen_reg_rtx'    and `gen_label_rtx' that are the usual ways of creating rtl    expressions for most purposes.     It also has the functions for creating insns and linking    them in the doubly-linked chain.     The patterns of the insns are created by machine-dependent    routines in insn-emit.c, which is generated automatically from    the machine description.  These routines use `gen_rtx' to make    the individual rtx's of the pattern; what is machine dependent    is the kind of rtx's they make and what arguments they use.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Commonly used modes.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|byte_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is BITS_PER_UNIT.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|word_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is BITS_PER_WORD.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|double_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is DOUBLE_TYPE_SIZE.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|ptr_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is POINTER_SIZE.  */
end_comment

begin_comment
comment|/* This is *not* reset after each function.  It gives each CODE_LABEL    in the entire compilation a unique label number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|label_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest label number in current function.    Zero means use the value of label_num instead.    This is nonzero only when belatedly compiling an inline function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value label_num had when set_new_first_and_last_label_number was called.    If label_num has not changed since then, last_label_num is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|base_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do not generate NOTEs for source line numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_line_numbers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Commonly used rtx's, so that we only need space for one copy.    These are initialized once for the entire compilation.    All of these except perhaps the floating-point CONST_DOUBLEs    are unique; no other rtx-object will be equal to any of these.  */
end_comment

begin_decl_stmt
name|rtx
name|global_rtl
index|[
name|GR_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We record floating-point CONST_DOUBLEs in each floating-point mode for    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we    record a copy of const[012]_rtx.  */
end_comment

begin_decl_stmt
name|rtx
name|const_tiny_rtx
index|[
literal|3
index|]
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|const_true_rtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconstm1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All references to the following fixed hard registers go through    these unique rtl objects.  On machines where the frame-pointer and    arg-pointer are the same register, they use the same unique object.     After register allocation, other rtl objects which used to be pseudo-regs    may be clobbered to refer to the frame-pointer register.    But references that were originally to the frame-pointer can be    distinguished from the others because they contain frame_pointer_rtx.     When to use frame_pointer_rtx and hard_frame_pointer_rtx is a little    tricky: until register elimination has taken place hard_frame_pointer_rtx    should be used if it is being set, and frame_pointer_rtx otherwise.  After    register elimination hard_frame_pointer_rtx should always be used.    On machines where the two registers are same (most) then these are the    same.     In an inline procedure, the stack and frame pointer rtxs may not be    used for anything else.  */
end_comment

begin_decl_stmt
name|rtx
name|struct_value_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STRUCT_VALUE_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|struct_value_incoming_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STRUCT_VALUE_INCOMING_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_incoming_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_INCOMING_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|pic_offset_table_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */
end_comment

begin_comment
comment|/* This is used to implement __builtin_return_address for some machines.    See for instance the MIPS port.  */
end_comment

begin_decl_stmt
name|rtx
name|return_address_pointer_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */
end_comment

begin_comment
comment|/* We make one copy of (const_int C) where C is in    [- MAX_SAVED_CONST_INT, MAX_SAVED_CONST_INT]    to save space during the compilation and simplify comparisons of    integers.  */
end_comment

begin_decl_stmt
name|rtx
name|const_int_rtx
index|[
name|MAX_SAVED_CONST_INT
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hash table storing CONST_INTs whose absolute value is greater    than MAX_SAVED_CONST_INT.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|const_int_htab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hash table storing memory attribute structures.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|mem_attrs_htab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start_sequence and gen_sequence can make a lot of rtx expressions which are    shortly thrown away.  We use two mechanisms to prevent this waste:     For sizes up to 5 elements, we keep a SEQUENCE and its associated    rtvec for use by gen_sequence.  One entry for each size is    sufficient because most cases are calls to gen_sequence followed by    immediately emitting the SEQUENCE.  Reuse is safe since emitting a    sequence is destructive on the insn in it anyway and hence can't be    redone.     We do not bother to save this cached data over nested function calls.    Instead, we just reinitialize them.  */
end_comment

begin_define
define|#
directive|define
name|SEQUENCE_RESULT_SIZE
value|5
end_define

begin_decl_stmt
specifier|static
name|rtx
name|sequence_result
index|[
name|SEQUENCE_RESULT_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During RTL generation, we also keep a list of free INSN rtl codes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|free_insn
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|first_insn
value|(cfun->emit->x_first_insn)
end_define

begin_define
define|#
directive|define
name|last_insn
value|(cfun->emit->x_last_insn)
end_define

begin_define
define|#
directive|define
name|cur_insn_uid
value|(cfun->emit->x_cur_insn_uid)
end_define

begin_define
define|#
directive|define
name|last_linenum
value|(cfun->emit->x_last_linenum)
end_define

begin_define
define|#
directive|define
name|last_filename
value|(cfun->emit->x_last_filename)
end_define

begin_define
define|#
directive|define
name|first_label_num
value|(cfun->emit->x_first_label_num)
end_define

begin_decl_stmt
specifier|static
name|rtx
name|make_jump_insn_raw
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|make_call_insn_raw
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_line_note
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_sequence_stack
name|PARAMS
argument_list|(
operator|(
expr|struct
name|sequence_stack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|change_address_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unshare_all_rtl_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unshare_all_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_used_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_label_nuses
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|const_int_htab_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_int_htab_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|mem_attrs_htab_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mem_attrs_htab_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mem_attrs_mark
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mem_attrs
modifier|*
name|get_mem_attrs
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|,
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|unsigned
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|component_ref_for_mem_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Probability of the conditional branch currently proceeded by try_split.    Set to -1 otherwise.  */
end_comment

begin_decl_stmt
name|int
name|split_branch_probability
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns a hash code for X (which is a really a CONST_INT).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_int_htab_hash
parameter_list|(
name|x
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
block|{
return|return
operator|(
name|hashval_t
operator|)
name|INTVAL
argument_list|(
operator|(
specifier|const
expr|struct
name|rtx_def
operator|*
operator|)
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value represented by X (which is really a    CONST_INT) is the same as that given by Y (which is really a    HOST_WIDE_INT *).  */
end_comment

begin_function
specifier|static
name|int
name|const_int_htab_eq
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
specifier|const
name|void
modifier|*
name|y
decl_stmt|;
block|{
return|return
operator|(
name|INTVAL
argument_list|(
operator|(
specifier|const
expr|struct
name|rtx_def
operator|*
operator|)
name|x
argument_list|)
operator|==
operator|*
operator|(
operator|(
specifier|const
name|HOST_WIDE_INT
operator|*
operator|)
name|y
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for X (which is a really a mem_attrs *).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mem_attrs_htab_hash
parameter_list|(
name|x
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
block|{
name|mem_attrs
modifier|*
name|p
init|=
operator|(
name|mem_attrs
operator|*
operator|)
name|x
decl_stmt|;
return|return
operator|(
name|p
operator|->
name|alias
operator|^
operator|(
name|p
operator|->
name|align
operator|*
literal|1000
operator|)
operator|^
operator|(
operator|(
name|p
operator|->
name|offset
condition|?
name|INTVAL
argument_list|(
name|p
operator|->
name|offset
argument_list|)
else|:
literal|0
operator|)
operator|*
literal|50000
operator|)
operator|^
operator|(
operator|(
name|p
operator|->
name|size
condition|?
name|INTVAL
argument_list|(
name|p
operator|->
name|size
argument_list|)
else|:
literal|0
operator|)
operator|*
literal|2500000
operator|)
operator|^
operator|(
name|size_t
operator|)
name|p
operator|->
name|expr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value represented by X (which is really a    mem_attrs *) is the same as that given by Y (which is also really a    mem_attrs *).  */
end_comment

begin_function
specifier|static
name|int
name|mem_attrs_htab_eq
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
specifier|const
name|void
modifier|*
name|y
decl_stmt|;
block|{
name|mem_attrs
modifier|*
name|p
init|=
operator|(
name|mem_attrs
operator|*
operator|)
name|x
decl_stmt|;
name|mem_attrs
modifier|*
name|q
init|=
operator|(
name|mem_attrs
operator|*
operator|)
name|y
decl_stmt|;
return|return
operator|(
name|p
operator|->
name|alias
operator|==
name|q
operator|->
name|alias
operator|&&
name|p
operator|->
name|expr
operator|==
name|q
operator|->
name|expr
operator|&&
name|p
operator|->
name|offset
operator|==
name|q
operator|->
name|offset
operator|&&
name|p
operator|->
name|size
operator|==
name|q
operator|->
name|size
operator|&&
name|p
operator|->
name|align
operator|==
name|q
operator|->
name|align
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine is called when we determine that we need a mem_attrs entry.    It marks the associated decl and RTL as being used, if present.  */
end_comment

begin_function
specifier|static
name|void
name|mem_attrs_mark
parameter_list|(
name|x
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
block|{
name|mem_attrs
modifier|*
name|p
init|=
operator|(
name|mem_attrs
operator|*
operator|)
name|x
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|expr
condition|)
name|ggc_mark_tree
argument_list|(
name|p
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|offset
condition|)
name|ggc_mark_rtx
argument_list|(
name|p
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|size
condition|)
name|ggc_mark_rtx
argument_list|(
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a new mem_attrs structure and insert it into the hash table if    one identical to it is not already in the table.  We are doing this for    MEM of mode MODE.  */
end_comment

begin_function
specifier|static
name|mem_attrs
modifier|*
name|get_mem_attrs
parameter_list|(
name|alias
parameter_list|,
name|expr
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|mode
parameter_list|)
name|HOST_WIDE_INT
name|alias
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|mem_attrs
name|attrs
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* If everything is the default, we can just return zero.  */
if|if
condition|(
name|alias
operator|==
literal|0
operator|&&
name|expr
operator|==
literal|0
operator|&&
name|offset
operator|==
literal|0
operator|&&
operator|(
name|size
operator|==
literal|0
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|align
operator|==
name|BITS_PER_UNIT
operator|||
operator|(
name|STRICT_ALIGNMENT
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|align
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|attrs
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
name|attrs
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|attrs
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|attrs
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|attrs
operator|.
name|align
operator|=
name|align
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|mem_attrs_htab
argument_list|,
operator|&
name|attrs
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
block|{
operator|*
name|slot
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mem_attrs
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|slot
argument_list|,
operator|&
name|attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Generate a new REG rtx.  Make sure ORIGINAL_REGNO is set properly, and    don't attempt to share with the various global pieces of rtl (such as    frame_pointer_rtx).  */
end_comment

begin_function
name|rtx
name|gen_raw_REG
parameter_list|(
name|mode
parameter_list|,
name|regno
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|gen_rtx_raw_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|regno
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* There are some RTL codes that require special attention; the generation    functions do the raw handling.  If you add to this list, modify    special_rtx in gengenrtl.c as well.  */
end_comment

begin_function
name|rtx
name|gen_rtx_CONST_INT
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|arg
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|arg
operator|>=
operator|-
name|MAX_SAVED_CONST_INT
operator|&&
name|arg
operator|<=
name|MAX_SAVED_CONST_INT
condition|)
return|return
name|const_int_rtx
index|[
name|arg
operator|+
name|MAX_SAVED_CONST_INT
index|]
return|;
if|#
directive|if
name|STORE_FLAG_VALUE
operator|!=
literal|1
operator|&&
name|STORE_FLAG_VALUE
operator|!=
operator|-
literal|1
if|if
condition|(
name|const_true_rtx
operator|&&
name|arg
operator|==
name|STORE_FLAG_VALUE
condition|)
return|return
name|const_true_rtx
return|;
endif|#
directive|endif
comment|/* Look up the CONST_INT in the hash table.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|const_int_htab
argument_list|,
operator|&
name|arg
argument_list|,
operator|(
name|hashval_t
operator|)
name|arg
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
operator|*
name|slot
operator|=
name|gen_rtx_raw_CONST_INT
argument_list|(
name|VOIDmode
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtx
operator|)
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* CONST_DOUBLEs needs special handling because their length is known    only at run-time.  */
end_comment

begin_function
name|rtx
name|gen_rtx_CONST_DOUBLE
parameter_list|(
name|mode
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
name|rtx
name|r
init|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|X0EXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|XWINT
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XWINT
argument_list|(
name|r
argument_list|,
literal|2
argument_list|)
operator|=
name|arg1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|2
condition|;
operator|--
name|i
control|)
name|XWINT
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_REG
parameter_list|(
name|mode
parameter_list|,
name|regno
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
comment|/* In case the MD file explicitly references the frame pointer, have      all such references point to the same frame pointer.  This is      used during frame pointer elimination to distinguish the explicit      references to these registers from pseudos that happened to be      assigned to them.       If we have eliminated the frame pointer or arg pointer, we will      be using it as a normal register, for example as a spill      register.  In such cases, we might be accessing it in a mode that      is not Pmode and therefore cannot use the pre-allocated rtx.       Also don't do this when we are making new REGs in reload, since      we don't want to get confused with the real pointers.  */
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
operator|!
name|reload_in_progress
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
condition|)
return|return
name|frame_pointer_rtx
return|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|hard_frame_pointer_rtx
return|;
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|arg_pointer_rtx
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RETURN_ADDRESS_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|RETURN_ADDRESS_POINTER_REGNUM
condition|)
return|return
name|return_address_pointer_rtx
return|;
endif|#
directive|endif
if|if
condition|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
return|return
name|pic_offset_table_rtx
return|;
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
name|stack_pointer_rtx
return|;
block|}
return|return
name|gen_raw_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_MEM
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|rt
init|=
name|gen_rtx_raw_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* This field is not cleared by the mere allocation of the rtx, so      we clear it here.  */
name|MEM_ATTRS
argument_list|(
name|rt
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_SUBREG
parameter_list|(
name|mode
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
comment|/* This is the most common failure type.      Catch it early so we can see who does it.  */
if|if
condition|(
operator|(
name|offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This check isn't usable right now because combine will      throw arbitrary crap like a CALL into a SUBREG in      gen_lowpart_for_combine so we must just eat it.  */
if|#
directive|if
literal|0
comment|/* Check for this too.  */
block|if (offset>= GET_MODE_SIZE (GET_MODE (reg)))     abort ();
endif|#
directive|endif
return|return
name|gen_rtx_fmt_ei
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a SUBREG representing the least-significant part of REG if MODE    is smaller than mode of REG, otherwise paradoxical SUBREG.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_SUBREG
parameter_list|(
name|mode
parameter_list|,
name|reg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|enum
name|machine_mode
name|inmode
decl_stmt|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|==
name|VOIDmode
condition|)
name|inmode
operator|=
name|mode
expr_stmt|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|reg
argument_list|,
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|inmode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* rtx gen_rtx (code, mode, [element1, ..., elementn]) ** **	    This routine generates an RTX of the size specified by **<code>, which is an RTX code.   The RTX structure is initialized **	from the arguments<element1> through<elementn>, which are **	interpreted according to the specific RTX type's format.   The **	special machine mode associated with the rtx (if any) is specified **	in<mode>. ** **	    gen_rtx can be invoked in a way which resembles the lisp-like **	rtx it will generate.   For example, the following rtx structure: ** **	      (plus:QI (mem:QI (reg:SI 1)) **		       (mem:QI (plusw:SI (reg:SI 2) (reg:SI 3)))) ** **		...would be generated by the following C code: ** **		gen_rtx (PLUS, QImode, **		    gen_rtx (MEM, QImode, **			gen_rtx (REG, SImode, 1)), **		    gen_rtx (MEM, QImode, **			gen_rtx (PLUS, SImode, **			    gen_rtx (REG, SImode, 2), **			    gen_rtx (REG, SImode, 3)))), */
end_comment

begin_comment
comment|/*VARARGS2*/
end_comment

begin_decl_stmt
name|rtx
name|gen_rtx
name|VPARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
name|code
operator|,
expr|enum
name|machine_mode
name|mode
operator|,
operator|...
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Array indices...			*/
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Current rtx's format...		*/
name|rtx
name|rt_val
decl_stmt|;
comment|/* RTX to return to caller...		*/
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|rtx_code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
name|rt_val
operator|=
name|gen_rtx_CONST_INT
argument_list|(
name|mode
argument_list|,
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
block|{
name|HOST_WIDE_INT
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
decl_stmt|;
name|rt_val
operator|=
name|gen_rtx_CONST_DOUBLE
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG
case|:
name|rt_val
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|rt_val
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Allocate the storage space.  */
name|rt_val
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
comment|/* Store the machine mode...  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Find the right format...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Unused field.  */
break|break;
case|case
literal|'i'
case|:
comment|/* An integer?  */
name|XINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* A wide integer? */
name|XWINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* A string?  */
name|XSTR
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* An expression?  */
case|case
literal|'u'
case|:
comment|/* An insn?  Same except when printing.  */
name|XEXP
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* An RTX vector?  */
name|XVEC
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtvec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* A bitmap? */
name|XBITMAP
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* A tree? */
name|XTREE
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_decl_stmt

begin_comment
comment|/* gen_rtvec (n, [rt1, ..., rtn]) ** **	    This routine creates an rtvec and stores within it the **	pointers to rtx's which are its arguments. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_decl_stmt
name|rtvec
name|gen_rtvec
name|VPARAMS
argument_list|(
operator|(
name|int
name|n
operator|,
operator|...
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|,
name|save_n
decl_stmt|;
name|rtx
modifier|*
name|vector
decl_stmt|;
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|int
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|vector
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|vector
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
comment|/* The definition of VA_* in K&R C causes `n' to go out of scope.  */
name|save_n
operator|=
name|n
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|gen_rtvec_v
argument_list|(
name|save_n
argument_list|,
name|vector
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|rtvec
name|gen_rtvec_v
parameter_list|(
name|n
parameter_list|,
name|argp
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtx
modifier|*
name|argp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtvec
name|rt_val
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|rt_val
operator|=
name|rtvec_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Allocate an rtvec...			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rt_val
operator|->
name|elem
index|[
name|i
index|]
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a REG rtx for a new pseudo register of mode MODE.    This pseudo is assigned the next sequential register number.  */
end_comment

begin_function
name|rtx
name|gen_reg_rtx
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|struct
name|function
modifier|*
name|f
init|=
name|cfun
decl_stmt|;
name|rtx
name|val
decl_stmt|;
comment|/* Don't let anything called after initial flow analysis create new      registers.  */
if|if
condition|(
name|no_new_pseudos
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|generating_concat_p
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|)
condition|)
block|{
comment|/* For complex modes, don't make a single pseudo. 	 Instead, make a CONCAT of two pseudos. 	 This allows noncontiguous allocation of the real and imaginary parts, 	 which makes much better code.  Besides, allocating DCmode 	 pseudos overstrains reload on some machines like the 386.  */
name|rtx
name|realpart
decl_stmt|,
name|imagpart
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|partmode
init|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
name|MODE_FLOAT
else|:
name|MODE_INT
operator|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|realpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
name|imagpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_CONCAT
argument_list|(
name|mode
argument_list|,
name|realpart
argument_list|,
name|imagpart
argument_list|)
return|;
block|}
comment|/* Make sure regno_pointer_align, regno_decl, and regno_reg_rtx are large      enough to have an element for this pseudo reg number.  */
if|if
condition|(
name|reg_rtx_no
operator|==
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
condition|)
block|{
name|int
name|old_size
init|=
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|rtx
modifier|*
name|new1
decl_stmt|;
name|tree
modifier|*
name|new2
decl_stmt|;
name|new
operator|=
name|xrealloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align
argument_list|,
name|old_size
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
operator|+
name|old_size
argument_list|,
literal|0
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|new
expr_stmt|;
name|new1
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xrealloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|x_regno_reg_rtx
argument_list|,
name|old_size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new1
operator|+
name|old_size
argument_list|,
literal|0
argument_list|,
name|old_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
name|new1
expr_stmt|;
name|new2
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_decl
argument_list|,
name|old_size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new2
operator|+
name|old_size
argument_list|,
literal|0
argument_list|,
name|old_size
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_decl
operator|=
name|new2
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
operator|=
name|old_size
operator|*
literal|2
expr_stmt|;
block|}
name|val
operator|=
name|gen_raw_REG
argument_list|(
name|mode
argument_list|,
name|reg_rtx_no
argument_list|)
expr_stmt|;
name|regno_reg_rtx
index|[
name|reg_rtx_no
operator|++
index|]
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Identify REG (which may be a CONCAT) as a user register.  */
end_comment

begin_function
name|void
name|mark_user_reg
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|REG_USERVAR_P
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify REG as a probable pointer register and show its alignment    as ALIGN, if nonzero.  */
end_comment

begin_function
name|void
name|mark_reg_pointer
parameter_list|(
name|reg
parameter_list|,
name|align
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|REG_POINTER
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|REG_POINTER
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|&&
name|align
operator|<
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
comment|/* We can no-longer be sure just how aligned this pointer is */
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 plus largest pseudo reg number used in the current function.  */
end_comment

begin_function
name|int
name|max_reg_num
parameter_list|()
block|{
return|return
name|reg_rtx_no
return|;
block|}
end_function

begin_comment
comment|/* Return 1 + the largest label number used so far in the current function.  */
end_comment

begin_function
name|int
name|max_label_num
parameter_list|()
block|{
if|if
condition|(
name|last_label_num
operator|&&
name|label_num
operator|==
name|base_label_num
condition|)
return|return
name|last_label_num
return|;
return|return
name|label_num
return|;
block|}
end_function

begin_comment
comment|/* Return first label number used in this function (if any were used).  */
end_comment

begin_function
name|int
name|get_first_label_num
parameter_list|()
block|{
return|return
name|first_label_num
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the final regno of X, which is a SUBREG of a hard    register.  */
end_comment

begin_function
name|int
name|subreg_hard_regno
parameter_list|(
name|x
parameter_list|,
name|check_mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|check_mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|byte_offset
decl_stmt|,
name|base_regno
decl_stmt|,
name|final_regno
decl_stmt|;
name|rtx
name|reg
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* This is where we attempt to catch illegal subregs      created by the compiler.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|check_mode
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|base_regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Catch non-congruent offsets too.  */
name|byte_offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|byte_offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|final_regno
operator|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|final_regno
return|;
block|}
end_function

begin_comment
comment|/* Return a value representing some low-order bits of X, where the number    of low-order bits is given by MODE.  Note that no conversion is done    between floating-point and fixed-point values, rather, the bit    representation is returned.     This function handles the cases in common between gen_lowpart, below,    and two variants in cse.c and combine.c.  These are the cases that can    be safely handled at all points in the compilation.     If this is not a case we can handle, return 0.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_common
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|msize
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|xsize
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
condition|)
return|return
name|x
return|;
comment|/* MODE must occupy no more words than the mode of X.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
name|msize
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|>
operator|(
operator|(
name|xsize
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
condition|)
block|{
comment|/* If we are getting the low-order part of something that has been 	 sign- or zero-extended, we can either just use the object being 	 extended or make a narrower extension.  If we want an even smaller 	 piece than the size of the object being extended, call ourselves 	 recursively.  	 This case is used mostly by combine and cse.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
condition|)
return|return
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|offset
argument_list|)
return|;
comment|/* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits      from the low-order part of the constant.  */
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
comment|/* If MODE is twice the host word size, X is already the desired 	 representation.  Otherwise, if MODE is wider than a word, we can't 	 do this.  If MODE is exactly a word, return just one CONST_INT.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|?
name|x
else|:
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* MODE must be narrower than HOST_BITS_PER_WIDE_INT.  */
name|HOST_WIDE_INT
name|val
init|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|x
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|)
decl_stmt|;
comment|/* Sign extend to HOST_WIDE_INT.  */
name|val
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|val
condition|?
name|x
else|:
name|GEN_INT
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
comment|/* If X is an integral constant but we want it in floating-point, it      must be the case that we have a union of an integer and a floating-point      value.  If the machine-parameters allow it, simulate that union here      and return the result.  The two-word and single-word cases are      different.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|HOST_BITS_PER_CHAR
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
union|union
block|{
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|float
name|d
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|HOST_BITS_PER_CHAR
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
block|{
union|union
block|{
name|HOST_WIDE_INT
name|i
index|[
literal|2
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|u
union|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|,
name|high
operator|=
name|low
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|,
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|high
operator|,
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|low
expr_stmt|;
else|#
directive|else
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|low
operator|,
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|high
expr_stmt|;
endif|#
directive|endif
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Similarly, if this is converting a floating-point value into a      single-word integer.  Only do this is the host and target parameters are      compatible.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_WORD
condition|)
return|return
name|constant_subword
argument_list|(
name|x
argument_list|,
operator|(
name|offset
operator|/
name|UNITS_PER_WORD
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
comment|/* Similarly, if this is converting a floating-point value into a      two-word integer, we can do this one word at a time and make an      integer.  Only do this is the host and target parameters are      compatible.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|BITS_PER_WORD
condition|)
block|{
name|rtx
name|lowpart
decl_stmt|,
name|highpart
decl_stmt|;
name|lowpart
operator|=
name|constant_subword
argument_list|(
name|x
argument_list|,
operator|(
name|offset
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
name|WORDS_BIG_ENDIAN
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|highpart
operator|=
name|constant_subword
argument_list|(
name|x
argument_list|,
operator|(
name|offset
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
operator|!
name|WORDS_BIG_ENDIAN
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowpart
operator|&&
name|GET_CODE
argument_list|(
name|lowpart
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|highpart
operator|&&
name|GET_CODE
argument_list|(
name|highpart
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|immed_double_const
argument_list|(
name|INTVAL
argument_list|(
name|lowpart
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|highpart
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
else|#
directive|else
comment|/* ifndef REAL_ARITHMETIC */
comment|/* When we have a FP emulator, we can handle all conversions between      FP and integer operands.  This simplifies reload because it      doesn't have to deal with constructs like (subreg:DI      (const_double:SF ...)) or (subreg:DF (const_int ...)).  */
comment|/* Single-precision floats are always 32-bits and double-precision      floats are always 64-bits.  */
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|32
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|i
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_FROM_TARGET_SINGLE
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|64
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|i
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
name|low
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
comment|/* REAL_VALUE_TARGET_DOUBLE takes the addressing order of the 	 target machine.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|i
index|[
literal|0
index|]
operator|=
name|high
operator|,
name|i
index|[
literal|1
index|]
operator|=
name|low
expr_stmt|;
else|else
name|i
index|[
literal|0
index|]
operator|=
name|low
operator|,
name|i
index|[
literal|1
index|]
operator|=
name|high
expr_stmt|;
else|#
directive|else
name|i
index|[
literal|0
index|]
operator|=
name|low
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|REAL_VALUE_FROM_TARGET_DOUBLE
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
index|[
literal|4
index|]
decl_stmt|;
comment|/* Only the low 32 bits of each 'long' are used.  */
name|int
name|endian
init|=
name|WORDS_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* Convert 'r' into an array of four 32-bit words in target word          order.  */
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|32
case|:
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
index|[
literal|3
operator|*
name|endian
index|]
argument_list|)
expr_stmt|;
name|i
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|i
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|i
index|[
literal|3
operator|-
literal|3
operator|*
name|endian
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|i
operator|+
literal|2
operator|*
name|endian
argument_list|)
expr_stmt|;
name|i
index|[
literal|2
operator|-
literal|2
operator|*
name|endian
index|]
operator|=
literal|0
expr_stmt|;
name|i
index|[
literal|3
operator|-
literal|2
operator|*
name|endian
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|96
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|i
operator|+
name|endian
argument_list|)
expr_stmt|;
name|i
index|[
literal|3
operator|-
literal|3
operator|*
name|endian
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now, pack the 32-bit elements of the array into a CONST_DOUBLE 	 and return it.  */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
return|return
name|immed_double_const
argument_list|(
name|i
index|[
literal|3
operator|*
name|endian
index|]
argument_list|,
name|i
index|[
literal|1
operator|+
name|endian
index|]
argument_list|,
name|mode
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|immed_double_const
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|i
index|[
literal|3
operator|*
name|endian
index|]
operator|)
operator||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|i
index|[
literal|1
operator|+
name|endian
index|]
operator|<<
literal|32
operator|)
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|i
index|[
literal|2
operator|-
name|endian
index|]
operator|)
operator||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|i
index|[
literal|3
operator|-
literal|3
operator|*
name|endian
index|]
operator|<<
literal|32
operator|)
operator|)
argument_list|,
name|mode
argument_list|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* ifndef REAL_ARITHMETIC */
comment|/* Otherwise, we can't do this.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the real part (which has mode MODE) of a complex value X.    This always comes at the low address in memory.  */
end_comment

begin_function
name|rtx
name|gen_realpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|internal_error
argument_list|(
literal|"can't access real part of complex value in hard register"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
return|return
name|gen_highpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the imaginary part (which has mode MODE) of a complex value X.    This always comes at the high address in memory.  */
end_comment

begin_function
name|rtx
name|gen_imagpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|internal_error
argument_list|(
literal|"can't access imaginary part of complex value in hard register"
argument_list|)
expr_stmt|;
else|else
return|return
name|gen_highpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff X, assumed to be a SUBREG,    refers to the real part of the complex value in its containing reg.    Complex values are always stored with the real part in the first word,    regardless of WORDS_BIG_ENDIAN.  */
end_comment

begin_function
name|int
name|subreg_realpart_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|int
operator|)
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|<
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming that X is an rtx (e.g., MEM, REG or SUBREG) for a value,    return an rtx (MEM, SUBREG, or CONST_INT) that refers to the    least-significant part of X.    MODE specifies how big a part of X to return;    it usually should not be larger than a word.    If X is a MEM whose address is a QUEUED, the value may be so also.  */
end_comment

begin_function
name|rtx
name|gen_lowpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|result
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Must be a hard reg that's not valid in MODE.  */
name|result
operator|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|copy_to_reg
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* The only additional case we can do is MEM.  */
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Adjust the address so that the address-after-the-data 	   is unchanged.  */
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|adjust_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like `gen_lowpart', but refer to the most significant part.    This is used to access the imaginary part of a complex number.  */
end_comment

begin_function
name|rtx
name|gen_highpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|msize
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* This case loses if X is a subreg.  To catch bugs early,      complain if an invalid MODE is used even in other cases.  */
if|if
condition|(
name|msize
operator|>
name|UNITS_PER_WORD
operator|&&
name|msize
operator|!=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|subreg_highpart_offset
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* simplify_gen_subreg is not guaranteed to return a valid operand for      the target if we have a MEM.  gen_highpart must return a valid operand,      emitting code if necessary to do so.  */
if|if
condition|(
name|result
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|MEM
condition|)
name|result
operator|=
name|validize_mem
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like gen_highpart_mode, but accept mode of EXP operand in case EXP can    be VOIDmode constant.  */
end_comment

begin_function
name|rtx
name|gen_highpart_mode
parameter_list|(
name|outermode
parameter_list|,
name|innermode
parameter_list|,
name|exp
parameter_list|)
name|enum
name|machine_mode
name|outermode
decl_stmt|,
name|innermode
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|innermode
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|gen_highpart
argument_list|(
name|outermode
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|simplify_gen_subreg
argument_list|(
name|outermode
argument_list|,
name|exp
argument_list|,
name|innermode
argument_list|,
name|subreg_highpart_offset
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return offset in bytes to get OUTERMODE low part    of the value in mode INNERMODE stored in memory in target format.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_lowpart_offset
parameter_list|(
name|outermode
parameter_list|,
name|innermode
parameter_list|)
name|enum
name|machine_mode
name|outermode
decl_stmt|,
name|innermode
decl_stmt|;
block|{
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|difference
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return offset in bytes to get OUTERMODE high part    of the value in mode INNERMODE stored in memory in target format.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_highpart_offset
parameter_list|(
name|outermode
parameter_list|,
name|innermode
parameter_list|)
name|enum
name|machine_mode
name|outermode
decl_stmt|,
name|innermode
decl_stmt|;
block|{
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|difference
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff X, assumed to be a SUBREG,    refers to the least significant part of its containing reg.    If X is not a SUBREG, always return 1 (it is its own low part!).  */
end_comment

begin_function
name|int
name|subreg_lowpart_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|subreg_lowpart_offset
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper routine for all the constant cases of operand_subword.    Some places invoke this directly.  */
end_comment

begin_function
name|rtx
name|constant_subword
parameter_list|(
name|op
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|size_ratio
init|=
name|HOST_BITS_PER_WIDE_INT
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
comment|/* If OP is already an integer word, return it.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
condition|)
return|return
name|op
return|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
comment|/* The output is some bits, the width of the target machine's word.      A wider-word host can surely hold them in a CONST_INT. A narrower-word      host can't.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|BITS_PER_WORD
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|long
name|k
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* We handle 32-bit and>= 64-bit words here.  Note that the order in 	 which the words are written depends on the word endianness. 	 ??? This is a potential portability problem and should 	 be fixed at some point.  	 We must exercise caution with the sign bit.  By definition there 	 are 32 significant bits in K; there may be more in a HOST_WIDE_INT. 	 Consider a host with a 32-bit long and a 64-bit HOST_WIDE_INT. 	 So we explicitly mask and sign-extend as necessary.  */
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|k
index|[
name|offset
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
elseif|else
if|if
condition|(
name|BITS_PER_WORD
operator|>=
literal|64
operator|&&
name|offset
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|k
index|[
operator|!
name|WORDS_BIG_ENDIAN
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
operator|<<
literal|32
expr_stmt|;
name|val
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
name|WORDS_BIG_ENDIAN
index|]
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|16
condition|)
block|{
name|val
operator|=
name|k
index|[
name|offset
operator|>>
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|1
operator|)
operator|==
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|val
operator|>>=
literal|16
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|BITS_PER_WORD
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|long
name|k
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|k
index|[
name|offset
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
elseif|else
if|if
condition|(
name|BITS_PER_WORD
operator|>=
literal|64
operator|&&
name|offset
operator|<=
literal|1
condition|)
block|{
name|val
operator|=
name|k
index|[
name|offset
operator|*
literal|2
operator|+
operator|!
name|WORDS_BIG_ENDIAN
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
operator|<<
literal|32
expr_stmt|;
name|val
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
name|offset
operator|*
literal|2
operator|+
name|WORDS_BIG_ENDIAN
index|]
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
endif|#
directive|endif
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* no REAL_ARITHMETIC */
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* The constant is stored in the host's word-ordering, 	 but we want to access it in the target's word-ordering.  Some 	 compilers don't like a conditional inside macro args, so we have two 	 copies of the return.  */
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
return|return
name|GEN_INT
argument_list|(
name|offset
operator|==
name|WORDS_BIG_ENDIAN
condition|?
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|GEN_INT
argument_list|(
name|offset
operator|!=
name|WORDS_BIG_ENDIAN
condition|?
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
comment|/* Single word float is a little harder, since single- and double-word      values often do not have the same high-order bits.  We have already      verified that we want the only defined word of the single-word value.  */
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|32
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|long
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Sign extend from known 32-bit value to HOST_WIDE_INT.  */
name|val
operator|=
name|l
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|BITS_PER_WORD
operator|==
literal|16
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|&
literal|1
operator|)
operator|==
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|val
operator|>>=
literal|16
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
block|}
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
literal|8
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|double
name|d
decl_stmt|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|}
name|u
union|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|u
operator|.
name|f
operator|=
name|d
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|u
operator|.
name|i
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
operator|)
operator|||
name|flag_pretend_float
operator|)
operator|&&
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
literal|8
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|double
name|d
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|}
name|u
union|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|u
operator|.
name|d
operator|=
name|d
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|u
operator|.
name|i
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
comment|/* The only remaining cases that we can handle are integers.      Convert to proper endianness now since these cases need it.      At this point, offset == 0 means the low-order word.       We do not want to handle the case when BITS_PER_WORD<= HOST_BITS_PER_INT      in general.  However, if OP is (const_int 0), we can just return      it for any word.  */
if|if
condition|(
name|op
operator|==
name|const0_rtx
condition|)
return|return
name|op
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|)
operator|||
name|BITS_PER_WORD
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|-
literal|1
operator|-
name|offset
expr_stmt|;
comment|/* Find out which word on the host machine this value is in and get      it from the constant.  */
name|val
operator|=
operator|(
name|offset
operator|/
name|size_ratio
operator|==
literal|0
condition|?
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|op
argument_list|)
else|:
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|)
else|:
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|?
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0
condition|?
operator|~
literal|0
else|:
literal|0
operator|)
else|:
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Get the value we want into the low bits of val.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|=
operator|(
operator|(
name|val
operator|>>
operator|(
operator|(
name|offset
operator|%
name|size_ratio
operator|)
operator|*
name|BITS_PER_WORD
operator|)
operator|)
operator|)
expr_stmt|;
name|val
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return subword OFFSET of operand OP.    The word number, OFFSET, is interpreted as the word number starting    at the low-order address.  OFFSET 0 is the low-order word if not    WORDS_BIG_ENDIAN, otherwise it is the high-order word.     If we cannot extract the required word, we return zero.  Otherwise,    an rtx corresponding to the requested word will be returned.     VALIDATE_ADDRESS is nonzero if the address should be validated.  Before    reload has completed, a valid address will always be returned.  After    reload, if a valid address cannot be returned, we return zero.     If VALIDATE_ADDRESS is zero, we simply form the required address; validating    it is the responsibility of the caller.     MODE is the mode of OP in case it is a CONST_INT.     ??? This is still rather broken for some cases.  The problem for the    moment is that all callers of this thing provide no 'goal mode' to    tell us to work with.  This exists because all callers were written    in a word based SUBREG world.    Now use of this function can be deprecated by simplify_subreg in most    cases.  */
end_comment

begin_function
name|rtx
name|operand_subword
parameter_list|(
name|op
parameter_list|,
name|offset
parameter_list|,
name|validate_address
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|int
name|validate_address
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If OP is narrower than a word, fail.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If we want a word outside OP, return zero.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|offset
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Form a new MEM at the requested address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|new
init|=
name|adjust_address_nv
argument_list|(
name|op
argument_list|,
name|word_mode
argument_list|,
name|offset
operator|*
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_address
condition|)
return|return
name|new
return|;
elseif|else
if|if
condition|(
name|reload_completed
condition|)
block|{
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|word_mode
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
name|replace_equiv_address
argument_list|(
name|new
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Rest can be handled by simplify_subreg.  */
return|return
name|simplify_gen_subreg
argument_list|(
name|word_mode
argument_list|,
name|op
argument_list|,
name|mode
argument_list|,
operator|(
name|offset
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to `operand_subword', but never return 0.  If we can't extract    the required subword, put OP into a register and try again.  If that fails,    abort.  We always validate the address in this case.     MODE is the mode of OP, in case it is CONST_INT.  */
end_comment

begin_function
name|rtx
name|operand_subword_force
parameter_list|(
name|op
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|result
init|=
name|operand_subword
argument_list|(
name|op
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* If this is a register which can not be accessed by words, copy it 	 to a pseudo register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
name|op
operator|=
name|copy_to_reg
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|op
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|operand_subword
argument_list|(
name|op
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a compare instruction, swap the operands.    A test instruction is changed into a compare of 0 against the operand.  */
end_comment

begin_function
name|void
name|reverse_comparison
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|comp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
name|comp
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
else|else
name|comp
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comp
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|0
argument_list|)
operator|=
name|op1
expr_stmt|;
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|1
argument_list|)
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|new
init|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|comp
argument_list|)
argument_list|)
argument_list|,
name|comp
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|new
expr_stmt|;
else|else
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Within a MEM_EXPR, we care about either (1) a component ref of a decl,    or (2) a component ref of something variable.  Represent the later with    a NULL expression.  */
end_comment

begin_function
specifier|static
name|tree
name|component_ref_for_mem_expr
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|inner
operator|=
name|component_ref_for_mem_expr
argument_list|(
name|inner
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|placeholder_ptr
init|=
literal|0
decl_stmt|;
comment|/* Now remove any conversions: they don't change what the underlying 	 object is.  Likewise for SAVE_EXPR.  Also handle PLACEHOLDER_EXPR.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SAVE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
name|inner
operator|=
name|find_placeholder
argument_list|(
name|inner
argument_list|,
operator|&
name|placeholder_ptr
argument_list|)
expr_stmt|;
else|else
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|inner
argument_list|)
condition|)
name|inner
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|inner
operator|==
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ref
return|;
else|else
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|inner
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given REF, a MEM, and T, either the type of X or the expression    corresponding to REF, set the memory attributes.  OBJECTP is nonzero    if we are making a new object of this type.  */
end_comment

begin_function
name|void
name|set_mem_attributes
parameter_list|(
name|ref
parameter_list|,
name|t
parameter_list|,
name|objectp
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|objectp
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|alias
init|=
name|MEM_ALIAS_SET
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|tree
name|expr
init|=
name|MEM_EXPR
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
name|MEM_OFFSET
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|size
init|=
name|MEM_SIZE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|align
init|=
name|MEM_ALIGN
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* It can happen that type_for_mode was given a mode for which there      is no language-level type.  In which case it returns NULL, which      we can see here.  */
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
name|type
operator|=
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|t
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we have already set DECL_RTL = ref, get_alias_set will get the      wrong answer, as it assumes that DECL_RTL already has the right alias      info.  Callers should not set DECL_RTL until after the call to      set_mem_attributes.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|ref
operator|==
name|DECL_RTL_IF_SET
argument_list|(
name|t
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the alias set from the expression or type (perhaps using a      front-end routine) and use it.  */
name|alias
operator|=
name|get_alias_set
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
operator||=
operator|(
operator|(
name|lang_hooks
operator|.
name|honor_readonly
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If we are making an object of this type, or if this is a DECL, we know      that it is a scalar if the type is not an aggregate.  */
if|if
condition|(
operator|(
name|objectp
operator|||
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|MEM_SCALAR_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can set the alignment from the type if we are making an object,      this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */
if|if
condition|(
name|objectp
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TYPE_ALIGN_OK
argument_list|(
name|type
argument_list|)
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the size is known, we can set that.  */
if|if
condition|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If T is not a type, we may be able to deduce some more information about      the expression.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|maybe_set_unchanging
argument_list|(
name|ref
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now remove any conversions: they don't change what the underlying 	 object is.  Likewise for SAVE_EXPR.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this expression can't be addressed (e.g., it contains a reference 	 to a non-addressable field), show we don't change its alias set.  */
if|if
condition|(
operator|!
name|can_address_p
argument_list|(
name|t
argument_list|)
condition|)
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is a decl, set the attributes of the MEM from it.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expr
operator|=
name|t
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|size
operator|=
operator|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|?
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a constant, we know the alignment.  */
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|t
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this is a field reference and not a bit-field, record it.  */
comment|/* ??? There is some information that can be gleened from bit-fields, 	 such as the word offset in the structure that might be modified. 	 But skip it for now.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|expr
operator|=
name|component_ref_for_mem_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
comment|/* ??? Any reason the field size would be different than 	     the size we got from the type?  */
block|}
comment|/* If this is an array reference, look for an outer field reference.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|off_tree
init|=
name|size_zero_node
decl_stmt|;
do|do
block|{
name|off_tree
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|off_tree
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
condition|)
do|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|expr
operator|=
name|component_ref_for_mem_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|off_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|offset
operator|=
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|off_tree
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Any reason the field size would be different than 		 the size we got from the type?  */
block|}
block|}
block|}
comment|/* Now set the attributes we computed above.  */
name|MEM_ATTRS
argument_list|(
name|ref
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|alias
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is already known to be a scalar or aggregate, we are done.  */
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
operator|||
name|MEM_SCALAR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return;
comment|/* If it is a reference into an aggregate, this is part of an aggregate.      Otherwise we don't know.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the alias set of MEM to SET.  */
end_comment

begin_function
name|void
name|set_mem_alias_set
parameter_list|(
name|mem
parameter_list|,
name|set
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|HOST_WIDE_INT
name|set
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* If the new and old alias sets don't conflict, something is wrong.  */
if|if
condition|(
operator|!
name|alias_sets_conflict_p
argument_list|(
name|set
argument_list|,
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|set
argument_list|,
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the alignment of MEM to ALIGN bits.  */
end_comment

begin_function
name|void
name|set_mem_align
parameter_list|(
name|mem
parameter_list|,
name|align
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|align
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the expr for MEM to EXPR.  */
end_comment

begin_function
name|void
name|set_mem_expr
parameter_list|(
name|mem
parameter_list|,
name|expr
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|expr
argument_list|,
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the offset of MEM to OFFSET.  */
end_comment

begin_function
name|void
name|set_mem_offset
parameter_list|(
name|mem
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|mem
decl_stmt|,
name|offset
decl_stmt|;
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|offset
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed to MODE    and its address changed to ADDR.  (VOIDmode means don't change the mode.    NULL for ADDR means don't change the address.)  VALIDATE is nonzero if the    returned memory location is required to be valid.  The memory    attributes are not changed.  */
end_comment

begin_function
specifier|static
name|rtx
name|change_address_1
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|addr
parameter_list|,
name|validate
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|int
name|validate
decl_stmt|;
block|{
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|addr
argument_list|,
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
return|return
name|memref
return|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|memref
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Like change_address_1 with VALIDATE nonzero, but we are not saying in what    way we are changing MEMREF, so we only preserve the alias set.  */
end_comment

begin_function
name|rtx
name|change_address
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|addr
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|new
init|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mmode
init|=
name|GET_MODE
argument_list|(
name|new
argument_list|)
decl_stmt|;
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|memref
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mmode
operator|==
name|BLKmode
condition|?
literal|0
else|:
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mmode
argument_list|)
argument_list|)
argument_list|,
operator|(
name|mmode
operator|==
name|BLKmode
condition|?
name|BITS_PER_UNIT
else|:
name|GET_MODE_ALIGNMENT
argument_list|(
name|mmode
argument_list|)
operator|)
argument_list|,
name|mmode
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed    to MODE and its address offset by OFFSET bytes.  If VALIDATE is    nonzero, the memory address is forced to be valid.    If ADJUST is zero, OFFSET is only used to update MEM_ATTRS    and caller is responsible for adjusting MEMREF base register.  */
end_comment

begin_function
name|rtx
name|adjust_address_1
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|offset
parameter_list|,
name|validate
parameter_list|,
name|adjust
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|validate
decl_stmt|,
name|adjust
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|rtx
name|memoffset
init|=
name|MEM_OFFSET
argument_list|(
name|memref
argument_list|)
decl_stmt|;
name|rtx
name|size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|memalign
init|=
name|MEM_ALIGN
argument_list|(
name|memref
argument_list|)
decl_stmt|;
comment|/* ??? Prefer to create garbage instead of creating shared rtl.      This may happen even if offset is non-zero -- consider      (plus (plus reg reg) const_int) -- so do this always.  */
name|addr
operator|=
name|copy_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust
condition|)
block|{
comment|/* If MEMREF is a LO_SUM and the offset is within the alignment of the 	 object, we can merge it into the LO_SUM.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|offset
operator|>=
literal|0
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
condition|)
name|addr
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|,
name|validate
argument_list|)
expr_stmt|;
comment|/* Compute the new values of the memory attributes due to this adjustment.      We add the offsets and update the alignment.  */
if|if
condition|(
name|memoffset
condition|)
name|memoffset
operator|=
name|GEN_INT
argument_list|(
name|offset
operator|+
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the new alignment by taking the MIN of the alignment and the      lowest-order set bit in OFFSET, but don't change the alignment if OFFSET      if zero.  */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|memalign
operator|=
name|MIN
argument_list|(
name|memalign
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|offset
operator|&
operator|-
name|offset
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* We can compute the size in a number of ways.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|BLKmode
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_SIZE
argument_list|(
name|memref
argument_list|)
condition|)
name|size
operator|=
name|plus_constant
argument_list|(
name|MEM_SIZE
argument_list|(
name|memref
argument_list|)
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|memref
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|memref
argument_list|)
argument_list|,
name|memoffset
argument_list|,
name|size
argument_list|,
name|memalign
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At some point, we should validate that this offset is within the object,      if all the appropriate values are known.  */
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed    to MODE and its address changed to ADDR, which is assumed to be    MEMREF offseted by OFFSET bytes.  If VALIDATE is    nonzero, the memory address is forced to be valid.  */
end_comment

begin_function
name|rtx
name|adjust_automodify_address_1
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|addr
parameter_list|,
name|offset
parameter_list|,
name|validate
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|validate
decl_stmt|;
block|{
name|memref
operator|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|,
name|validate
argument_list|)
expr_stmt|;
return|return
name|adjust_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|,
name|validate
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but whose address is changed by    adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor    known to be in OFFSET (possibly 1).  */
end_comment

begin_function
name|rtx
name|offset_address
parameter_list|(
name|memref
parameter_list|,
name|offset
parameter_list|,
name|pow2
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|HOST_WIDE_INT
name|pow2
decl_stmt|;
block|{
name|rtx
name|new
init|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Update the alignment to reflect the offset.  Reset the offset, which      we don't know.  */
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|memref
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|memref
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|memref
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|pow2
operator|*
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its address changed to    ADDR.  The caller is asserting that the actual piece of memory pointed    to is the same, just the form of the address is being changed, such as    by putting something into a register.  */
end_comment

begin_function
name|rtx
name|replace_equiv_address
parameter_list|(
name|memref
parameter_list|,
name|addr
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
comment|/* change_address_1 copies the memory attribute structure without change      and that's exactly what we want here.  */
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but the reference is not required to be valid.  */
end_comment

begin_function
name|rtx
name|replace_equiv_address_nv
parameter_list|(
name|memref
parameter_list|,
name|addr
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
return|return
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode widened to    MODE and offset by OFFSET.  This would be used by targets that e.g.    cannot issue QImode memory operations and have to use SImode memory    operations plus masking logic.  */
end_comment

begin_function
name|rtx
name|widen_memory_access
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|{
name|rtx
name|new
init|=
name|adjust_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|expr
init|=
name|MEM_EXPR
argument_list|(
name|new
argument_list|)
decl_stmt|;
name|rtx
name|memoffset
init|=
name|MEM_OFFSET
argument_list|(
name|new
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* If we don't know what offset we were at within the expression, then      we can't know if we've overstepped the bounds.  */
if|if
condition|(
operator|!
name|memoffset
operator|&&
name|offset
operator|!=
literal|0
condition|)
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|expr
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
comment|/* Is the field at least as large as the access?  If so, ok, 	     otherwise strip back to the containing structure.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
name|size
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memoffset
operator|=
operator|(
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Similarly for the decl.  */
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|DECL_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
operator|&&
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|size
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|memoffset
operator|||
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
operator|>=
literal|0
operator|)
condition|)
break|break;
else|else
block|{
comment|/* The widened memory access overflows the expression, which means 	     that it could alias another expression.  Zap it.  */
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|expr
condition|)
name|memoffset
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* The widened memory may alias other stuff, so zap the alias set.  */
comment|/* ??? Maybe use get_alias_set on any remaining expression.  */
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
literal|0
argument_list|,
name|expr
argument_list|,
name|memoffset
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|new
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly created CODE_LABEL rtx with a unique label number.  */
end_comment

begin_function
name|rtx
name|gen_label_rtx
parameter_list|()
block|{
name|rtx
name|label
decl_stmt|;
name|label
operator|=
name|gen_rtx_CODE_LABEL
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label_num
operator|++
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LABEL_ALTERNATE_NAME
argument_list|(
name|label
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For procedure integration.  */
end_comment

begin_comment
comment|/* Install new pointers to the first and last insns in the chain.    Also, set cur_insn_uid to one higher than the last in use.    Used for an inline-procedure after copying the insn chain.  */
end_comment

begin_function
name|void
name|set_new_first_and_last_insn
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
name|cur_insn_uid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|cur_insn_uid
operator|=
name|MAX
argument_list|(
name|cur_insn_uid
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|cur_insn_uid
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the range of label numbers found in the current function.    This is used when belatedly compiling an inline function.  */
end_comment

begin_function
name|void
name|set_new_first_and_last_label_num
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|base_label_num
operator|=
name|label_num
expr_stmt|;
name|first_label_num
operator|=
name|first
expr_stmt|;
name|last_label_num
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the last label number found in the current function.    This is used when belatedly compiling an inline function.  */
end_comment

begin_function
name|void
name|set_new_last_label_num
parameter_list|(
name|last
parameter_list|)
name|int
name|last
decl_stmt|;
block|{
name|base_label_num
operator|=
name|label_num
expr_stmt|;
name|last_label_num
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Restore all variables describing the current status from the structure *P.    This is used after a nested function.  */
end_comment

begin_function
name|void
name|restore_emit_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|last_label_num
operator|=
literal|0
expr_stmt|;
name|clear_emit_caches
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out all parts of the state in F that can safely be discarded    after the function has been compiled, to let garbage collection    reclaim the memory.  */
end_comment

begin_function
name|void
name|free_emit_status
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|free
argument_list|(
name|f
operator|->
name|emit
operator|->
name|x_regno_reg_rtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_decl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|emit
argument_list|)
expr_stmt|;
name|f
operator|->
name|emit
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared    structure.  This routine should only be called once.  */
end_comment

begin_function
name|void
name|unshare_all_rtl
parameter_list|(
name|fndecl
parameter_list|,
name|insn
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Make sure that virtual parameters are not shared.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|copy_rtx_if_shared
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that virtual stack slots are not shared.  */
name|unshare_all_decls
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unshare just about everything else.  */
name|unshare_all_rtl_1
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Make sure the addresses of stack slots found outside the insn chain      (such as, in DECL_RTL of a variable) are not shared      with the insn chain.       This special care is necessary when the stack slot MEM does not      actually appear in the insn chain.  If it does appear, its address      is unshared from all else at that point.  */
name|stack_slot_list
operator|=
name|copy_rtx_if_shared
argument_list|(
name|stack_slot_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared    structure, again.  This is a fairly expensive thing to do so it    should be done sparingly.  */
end_comment

begin_function
name|void
name|unshare_all_rtl_again
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|p
operator|=
name|insn
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|reset_used_flags
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|LOG_LINKS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that virtual stack slots are not shared.  */
name|reset_used_decls
argument_list|(
name|DECL_INITIAL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that virtual parameters are not shared.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|reset_used_flags
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|stack_slot_list
argument_list|)
expr_stmt|;
name|unshare_all_rtl
argument_list|(
name|cfun
operator|->
name|decl
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared structure.    Assumes the mark bits are cleared at entry.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_all_rtl_1
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Go through all virtual stack slots of a function and copy any    shared structure.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_all_decls
parameter_list|(
name|blk
parameter_list|)
name|tree
name|blk
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* Copy shared decls.  */
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|t
argument_list|,
name|copy_rtx_if_shared
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now process sub-blocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|unshare_all_decls
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through all virtual stack slots of a function and mark them as    not shared.  */
end_comment

begin_function
specifier|static
name|void
name|reset_used_decls
parameter_list|(
name|blk
parameter_list|)
name|tree
name|blk
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* Mark decls.  */
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|reset_used_flags
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now process sub-blocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|reset_used_decls
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark ORIG as in use, and return a copy of it if it was already in use.    Recursively does the same for subexpressions.  */
end_comment

begin_function
name|rtx
name|copy_rtx_if_shared
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|orig
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
comment|/* SCRATCH must be shared because they represent distinct values.  */
return|return
name|x
return|;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|x
return|;
break|break;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return
name|x
return|;
case|case
name|MEM
case|:
comment|/* A MEM is allowed to be shared if its address is constant.  	 We used to allow sharing of MEMs which referenced 	 virtual_stack_vars_rtx or virtual_incoming_args_rtx, but 	 that can lose.  instantiate_virtual_regs will not unshare 	 the MEMs, and combine may change the structure of the address 	 because it looks safe and profitable in one context, but 	 in some other context it creates unrecognizable RTL.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
break|break;
default|default:
break|break;
block|}
comment|/* This rtx may not be shared.  If it has already been seen,      replace it with a copy of itself.  */
if|if
condition|(
name|x
operator|->
name|used
condition|)
block|{
name|rtx
name|copy
decl_stmt|;
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|copy
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|copy
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|copy
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|copy
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|->
name|used
operator|=
literal|1
expr_stmt|;
comment|/* Now scan the subexpressions recursively.      We can store any replaced subexpressions directly into X      since we know X is not shared!  Any vectors in X      must be copied if X was copied.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|copied
operator|&&
name|len
operator|>
literal|0
condition|)
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtvec_v
argument_list|(
name|len
argument_list|,
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|->
name|elem
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Clear all the USED bits in X to allow copy_rtx_if_shared to be used    to look for shared sub-parts.  */
end_comment

begin_function
name|void
name|reset_used_flags
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared so we needn't do any resetting      for them.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return;
default|default:
break|break;
block|}
name|x
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|reset_used_flags
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|reset_used_flags
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy X if necessary so that it won't be altered by changes in OTHER.    Return X or the rtx for the pseudo reg the value of X was copied into.    OTHER must be valid as a SET_DEST.  */
end_comment

begin_function
name|rtx
name|make_safe_from
parameter_list|(
name|x
parameter_list|,
name|other
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|other
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
name|other
operator|=
name|SUBREG_REG
argument_list|(
name|other
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRICT_LOW_PART
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|other
operator|=
name|XEXP
argument_list|(
name|other
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|other
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_mentioned_p
argument_list|(
name|other
argument_list|,
name|x
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emission of insns (adding them to the doubly-linked list).  */
end_comment

begin_comment
comment|/* Return the first insn of the current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_insns
parameter_list|()
block|{
return|return
name|first_insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last insn emitted in current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_last_insn
parameter_list|()
block|{
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Specify a new insn as the last in the chain.  */
end_comment

begin_function
name|void
name|set_last_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the last insn emitted, even if it is in a sequence now pushed.  */
end_comment

begin_function
name|rtx
name|get_last_insn_anywhere
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|;
if|if
condition|(
name|last_insn
condition|)
return|return
name|last_insn
return|;
for|for
control|(
name|stack
operator|=
name|seq_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|stack
operator|->
name|last
operator|!=
literal|0
condition|)
return|return
name|stack
operator|->
name|last
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a number larger than any instruction's uid in this function.  */
end_comment

begin_function
name|int
name|get_max_uid
parameter_list|()
block|{
return|return
name|cur_insn_uid
return|;
block|}
end_function

begin_comment
comment|/* Renumber instructions so that no instruction UIDs are wasted.  */
end_comment

begin_function
name|void
name|renumber_insns
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* If we're not supposed to renumber instructions, don't.  */
if|if
condition|(
operator|!
name|flag_renumber_insns
condition|)
return|return;
comment|/* If there aren't that many instructions, then it's not really      worth renumbering them.  */
if|if
condition|(
name|flag_renumber_insns
operator|==
literal|1
operator|&&
name|get_max_uid
argument_list|()
operator|<
literal|25000
condition|)
return|return;
name|cur_insn_uid
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|stream
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Renumbering insn %d to %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|cur_insn_uid
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the next insn.  If it is a SEQUENCE, return the first insn    of the sequence.  */
end_comment

begin_function
name|rtx
name|next_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the previous insn.  If it is a SEQUENCE, return the last insn    of the sequence.  */
end_comment

begin_function
name|rtx
name|previous_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next insn after INSN that is not a NOTE.  This routine does not    look inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|next_nonnote_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the previous insn before INSN that is not a NOTE.  This routine does    not look inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|prev_nonnote_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;    or 0, if there is none.  This routine does not look inside    SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|next_real_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last INSN, CALL_INSN or JUMP_INSN before INSN;    or 0, if there is none.  This routine does not look inside    SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|prev_real_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Find the next insn after INSN that really does something.  This routine    does not look inside SEQUENCEs.  Until reload has completed, this is the    same as next_real_insn.  */
end_comment

begin_function
name|int
name|active_insn_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|rtx
name|next_active_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Find the last insn before INSN that really does something.  This routine    does not look inside SEQUENCEs.  Until reload has completed, this is the    same as prev_real_insn.  */
end_comment

begin_function
name|rtx
name|prev_active_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next CODE_LABEL after the insn INSN, or 0 if there is none.  */
end_comment

begin_function
name|rtx
name|next_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last CODE_LABEL before the insn INSN, or 0 if there is none.  */
end_comment

begin_function
name|rtx
name|prev_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER    and REG_CC_USER notes so we can find it.  */
end_comment

begin_function
name|void
name|link_cc0_insns
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|user
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|user
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|user
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|user
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|user
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|user
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_CC_SETTER
argument_list|,
name|insn
argument_list|,
name|REG_NOTES
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_CC_USER
argument_list|,
name|user
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the next insn that uses CC0 after INSN, which is assumed to    set it.  This is the inverse of prev_cc0_setter (i.e., prev_cc0_setter    applied to the result of this function should yield INSN).     Normally, this is simply the next insn.  However, if a REG_CC_USER note    is present, it contains the insn that uses CC0.     Return 0 if we can't find the insn.  */
end_comment

begin_function
name|rtx
name|next_cc0_user
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_USER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
return|return
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
return|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|insn
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the insn that set CC0 for INSN.  Unless INSN has a REG_CC_SETTER    note, it is the previous insn.  */
end_comment

begin_function
name|rtx
name|prev_cc0_setter
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
return|return
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
return|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Increment the label uses for all labels present in rtx.  */
end_comment

begin_function
specifier|static
name|void
name|mark_label_nuses
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_label_nuses
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|mark_label_nuses
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try splitting insns that can be split for better scheduling.    PAT is the pattern which might split.    TRIAL is the insn providing PAT.    LAST is non-zero if we should return the last insn of the sequence produced.     If this routine succeeds in splitting, it returns the first or last    replacement insn depending on the value of LAST.  Otherwise, it    returns TRIAL.  If the insn to be returned can be split, it will be.  */
end_comment

begin_function
name|rtx
name|try_split
parameter_list|(
name|pat
parameter_list|,
name|trial
parameter_list|,
name|last
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|trial
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
name|rtx
name|before
init|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|after
init|=
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|int
name|has_barrier
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|probability
decl_stmt|;
if|if
condition|(
name|any_condjump_p
argument_list|(
name|trial
argument_list|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|trial
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|split_branch_probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|probability
operator|=
name|split_branch_probability
expr_stmt|;
name|seq
operator|=
name|split_insns
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|split_branch_probability
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we are splitting a JUMP_INSN, it might be followed by a BARRIER.      We may need to handle this specially.  */
if|if
condition|(
name|after
operator|&&
name|GET_CODE
argument_list|(
name|after
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|has_barrier
operator|=
literal|1
expr_stmt|;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seq
condition|)
block|{
comment|/* SEQ can either be a SEQUENCE or the pattern of a single insn. 	 The latter case will normally arise only when being done so that 	 it, in turn, will be split (SFmode on the 29k is an example).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|,
name|njumps
init|=
literal|0
decl_stmt|;
comment|/* Avoid infinite loop if any insn of the result matches 	     the original pattern.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|pat
argument_list|)
condition|)
return|return
name|trial
return|;
comment|/* Mark labels.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|njumps
operator|++
expr_stmt|;
if|if
condition|(
name|probability
operator|!=
operator|-
literal|1
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We can preserve the REG_BR_PROB notes only if exactly 		       one jump is created, otherwise the machine description 		       is responsible for this step using 		       split_branch_probability variable.  */
if|if
condition|(
name|njumps
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are splitting a CALL_INSN, look for the CALL_INSN 	     in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Copy notes, particularly those related to the CFG.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|trial
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_EH_REGION
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_NORETURN
case|:
case|case
name|REG_SETJMP
case|:
case|case
name|REG_ALWAYS_RETURN
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_NON_LOCAL_GOTO
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If there are LABELS inside the split insns increment the 	     usage count so we don't delete the label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|INSN
condition|)
name|mark_label_nuses
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_barrier
condition|)
name|emit_barrier_after
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Recursively call try_split for each new insn created; by the 	     time control returns here that insn will be fully split, so 	     set LAST and continue from the insn after the one returned. 	     We can't use next_active_insn here since AFTER may be a note. 	     Ignore deleted insns, which can be occur if not optimizing.  */
for|for
control|(
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|before
argument_list|)
init|;
name|tem
operator|!=
name|after
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|tem
argument_list|)
operator|&&
name|INSN_P
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid infinite loop if the result matches the original pattern.  */
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|seq
argument_list|,
name|pat
argument_list|)
condition|)
return|return
name|trial
return|;
else|else
block|{
name|PATTERN
argument_list|(
name|trial
argument_list|)
operator|=
name|seq
expr_stmt|;
name|INSN_CODE
argument_list|(
name|trial
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|try_split
argument_list|(
name|seq
argument_list|,
name|trial
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* Return either the first or the last insn, depending on which was 	 requested.  */
return|return
name|last
condition|?
operator|(
name|after
condition|?
name|PREV_INSN
argument_list|(
name|after
argument_list|)
else|:
name|last_insn
operator|)
else|:
name|NEXT_INSN
argument_list|(
name|before
argument_list|)
return|;
block|}
return|return
name|trial
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make and return an INSN rtx, initializing all its slots.    Store PATTERN in the pattern slots.  */
end_comment

begin_function
name|rtx
name|make_insn_raw
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
if|if
condition|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|returnjump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|insn
argument_list|)
operator|==
name|pc_rtx
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"ICE: emit_insn used where emit_jump_insn needed:\n"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like `make_insn' but make a JUMP_INSN instead of an insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_jump_insn_raw
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|JUMP_INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like `make_insn' but make a CALL_INSN instead of an insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_call_insn_raw
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|CALL_INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add INSN to the end of the doubly-linked list.    INSN may be an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER or NOTE.  */
end_comment

begin_function
name|void
name|add_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last_insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|last_insn
condition|)
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|first_insn
condition|)
name|first_insn
operator|=
name|insn
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN into the doubly-linked list after insn AFTER.  This and    the next should be the only functions called to insert an insn once    delay slots have been filled since only they know how to update a    SEQUENCE.  */
end_comment

begin_function
name|void
name|add_insn_after
parameter_list|(
name|insn
parameter_list|,
name|after
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|after
decl_stmt|;
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|INSN_DELETED_P
argument_list|(
name|after
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_insn
operator|==
name|after
condition|)
name|last_insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|after
operator|==
name|stack
operator|->
name|last
condition|)
block|{
name|stack
operator|->
name|last
operator|=
name|insn
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|basic_block_for_insn
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INSN_UID
argument_list|(
name|after
argument_list|)
operator|<
name|basic_block_for_insn
operator|->
name|num_elements
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|after
argument_list|)
operator|)
condition|)
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Should not happen as first in the BB is always 	 either NOTE or LABEL.  */
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|after
comment|/* Avoid clobbering of structure when creating new BB.  */
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
name|bb
operator|->
name|end
operator|=
name|insn
expr_stmt|;
block|}
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|after
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add INSN into the doubly-linked list before insn BEFORE.  This and    the previous should be the only functions called to insert an insn once    delay slots have been filled since only they know how to update a    SEQUENCE.  */
end_comment

begin_function
name|void
name|add_insn_before
parameter_list|(
name|insn
parameter_list|,
name|before
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|before
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|INSN_DELETED_P
argument_list|(
name|before
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_insn
operator|==
name|before
condition|)
name|first_insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|before
operator|==
name|stack
operator|->
name|first
condition|)
block|{
name|stack
operator|->
name|first
operator|=
name|insn
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|basic_block_for_insn
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INSN_UID
argument_list|(
name|before
argument_list|)
operator|<
name|basic_block_for_insn
operator|->
name|num_elements
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|before
argument_list|)
operator|)
condition|)
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Should not happen as first in the BB is always 	 either NOTE or LABEl.  */
if|if
condition|(
name|bb
operator|->
name|head
operator|==
name|insn
comment|/* Avoid clobbering of structure when creating new BB.  */
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|PREV_INSN
argument_list|(
name|before
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove an insn from its doubly-linked list.  This function knows how    to handle sequences.  */
end_comment

begin_function
name|void
name|remove_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_insn
operator|==
name|insn
condition|)
name|first_insn
operator|=
name|next
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|insn
operator|==
name|stack
operator|->
name|first
condition|)
block|{
name|stack
operator|->
name|first
operator|=
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
block|{
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_insn
operator|==
name|insn
condition|)
name|last_insn
operator|=
name|prev
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|insn
operator|==
name|stack
operator|->
name|last
condition|)
block|{
name|stack
operator|->
name|last
operator|=
name|prev
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|basic_block_for_insn
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|basic_block_for_insn
operator|->
name|num_elements
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bb
operator|->
name|head
operator|==
name|insn
condition|)
block|{
comment|/* Never ever delete the basic block note without deleting whole basic 	     block.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb
operator|->
name|head
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|insn
condition|)
name|bb
operator|->
name|end
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all insns made since FROM.    FROM becomes the new last instruction.  */
end_comment

begin_function
name|void
name|delete_insns_since
parameter_list|(
name|from
parameter_list|)
name|rtx
name|from
decl_stmt|;
block|{
if|if
condition|(
name|from
operator|==
literal|0
condition|)
name|first_insn
operator|=
literal|0
expr_stmt|;
else|else
name|NEXT_INSN
argument_list|(
name|from
argument_list|)
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
name|from
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is deprecated, please use sequences instead.     Move a consecutive bunch of insns to a different place in the chain.    The insns to be moved are those between FROM and TO.    They are moved to a new position after the insn AFTER.    AFTER must not be FROM or TO or any insn in between.     This function does not know about SEQUENCEs and hence should not be    called after delay-slot filling has been done.  */
end_comment

begin_function
name|void
name|reorder_insns_nobb
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|after
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|after
decl_stmt|;
block|{
comment|/* Splice this bunch out of where it is now.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_insn
operator|==
name|to
condition|)
name|last_insn
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_insn
operator|==
name|from
condition|)
name|first_insn
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Make the new neighbors point to it and it to them.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|=
name|to
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|from
argument_list|)
operator|=
name|after
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last_insn
condition|)
name|last_insn
operator|=
name|to
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as function above, but take care to update BB boundaries.  */
end_comment

begin_function
name|void
name|reorder_insns
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|after
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|after
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|bb2
decl_stmt|;
name|reorder_insns_nobb
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_block_for_insn
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INSN_UID
argument_list|(
name|after
argument_list|)
operator|<
name|basic_block_for_insn
operator|->
name|num_elements
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|after
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|basic_block_for_insn
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INSN_UID
argument_list|(
name|from
argument_list|)
operator|<
name|basic_block_for_insn
operator|->
name|num_elements
operator|&&
operator|(
name|bb2
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bb2
operator|->
name|end
operator|==
name|to
condition|)
name|bb2
operator|->
name|end
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|after
condition|)
name|bb
operator|->
name|end
operator|=
name|to
expr_stmt|;
for|for
control|(
name|x
operator|=
name|from
init|;
name|x
operator|!=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|x
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the line note insn preceding INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_line_note
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|no_line_numbers
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
break|break;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like reorder_insns, but inserts line notes to preserve the line numbers    of the moved insns when debugging.  This may insert a note between AFTER    and FROM, and another one after TO.  */
end_comment

begin_function
name|void
name|reorder_insns_with_line_notes
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|after
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|after
decl_stmt|;
block|{
name|rtx
name|from_line
init|=
name|find_line_note
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|rtx
name|after_line
init|=
name|find_line_note
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|reorder_insns
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_line
operator|==
name|after_line
condition|)
return|return;
if|if
condition|(
name|from_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove unnecessary notes from the instruction stream.  */
end_comment

begin_function
name|void
name|remove_unnecessary_notes
parameter_list|()
block|{
name|rtx
name|block_stack
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|eh_stack
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* We must not remove the first instruction in the function because      the compiler depends on the first instruction being a note.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
comment|/* Remember what's next.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We're only interested in notes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
continue|continue;
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_DELETED
case|:
case|case
name|NOTE_INSN_LOOP_END_TOP_COND
case|:
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
name|eh_stack
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|eh_stack
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_END
case|:
comment|/* Too many end notes.  */
if|if
condition|(
name|eh_stack
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Mismatched nesting.  */
if|if
condition|(
name|NOTE_EH_HANDLER
argument_list|(
name|XEXP
argument_list|(
name|eh_stack
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOTE_EH_HANDLER
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|eh_stack
expr_stmt|;
name|eh_stack
operator|=
name|XEXP
argument_list|(
name|eh_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BLOCK_BEG
case|:
comment|/* By now, all notes indicating lexical blocks should have 	     NOTE_BLOCK filled in.  */
if|if
condition|(
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|block_stack
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|block_stack
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BLOCK_END
case|:
comment|/* Too many end notes.  */
if|if
condition|(
name|block_stack
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Mismatched nesting.  */
if|if
condition|(
name|NOTE_BLOCK
argument_list|(
name|XEXP
argument_list|(
name|block_stack
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|block_stack
expr_stmt|;
name|block_stack
operator|=
name|XEXP
argument_list|(
name|block_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Scan back to see if there are any non-note instructions 	     between INSN and the beginning of this block.  If not, 	     then there is no PC range in the generated code that will 	     actually be in this block, so there's no point in 	     remembering the existence of the block.  */
for|for
control|(
name|tmp
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
control|)
block|{
comment|/* This block contains a real instruction.  Note that we 		 don't include labels; if the only thing in the block 		 is a label, then there are still no PC values that 		 lie within the block.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|tmp
argument_list|)
condition|)
break|break;
comment|/* We're only interested in NOTEs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
comment|/* We just verified that this BLOCK matches us with 		     the block_stack check above.  Never delete the 		     BLOCK for the outermost scope of the function; we 		     can refer to names from that scope even if the 		     block notes are messed up.  */
if|if
condition|(
operator|!
name|is_body_block
argument_list|(
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
call|(
modifier|*
name|debug_hooks
operator|->
name|ignore_block
call|)
argument_list|(
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|remove_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
comment|/* There's a nested block.  We need to leave the 		   current block in place since otherwise the debugger 		   wouldn't be able to show symbols from our block in 		   the nested block.  */
break|break;
block|}
block|}
block|}
comment|/* Too many begin notes.  */
if|if
condition|(
name|block_stack
operator|||
name|eh_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn of given code and pattern    at a specified place within the doubly-linked list.  */
end_comment

begin_comment
comment|/* Make an instruction with body PATTERN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|before
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body PATTERN and code JUMP_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body PATTERN and code CALL_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|make_call_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|CALL_INSN
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and output it before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_barrier_before
parameter_list|(
name|before
parameter_list|)
name|rtx
name|before
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the label LABEL before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_label_before
parameter_list|(
name|label
parameter_list|,
name|before
parameter_list|)
name|rtx
name|label
decl_stmt|,
name|before
decl_stmt|;
block|{
comment|/* This can be called twice for the same label as a result of the      confusion that follows a syntax error!  So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_before
argument_list|(
name|label
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Emit a note of subtype SUBTYPE before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_note_before
parameter_list|(
name|subtype
parameter_list|,
name|before
parameter_list|)
name|int
name|subtype
decl_stmt|;
name|rtx
name|before
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|add_insn_before
argument_list|(
name|note
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an insn of code INSN with body PATTERN    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_insn_after
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|after
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|after
operator|=
name|insn
expr_stmt|;
block|}
block|}
else|else
block|{
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Similar to emit_insn_after, except that line notes are to be inserted so    as to act as if this insn were at FROM.  */
end_comment

begin_function
name|void
name|emit_insn_after_with_line_notes
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|,
name|from
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|,
name|from
decl_stmt|;
block|{
name|rtx
name|from_line
init|=
name|find_line_note
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|rtx
name|after_line
init|=
name|find_line_note
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|emit_insn_after
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|from_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|from_line
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_line
condition|)
name|emit_line_note_after
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|after_line
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with body PATTERN    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_after
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_barrier_after
parameter_list|(
name|after
parameter_list|)
name|rtx
name|after
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the label LABEL after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_label_after
parameter_list|(
name|label
parameter_list|,
name|after
parameter_list|)
name|rtx
name|label
decl_stmt|,
name|after
decl_stmt|;
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|label
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Emit a note of subtype SUBTYPE after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_note_after
parameter_list|(
name|subtype
parameter_list|,
name|after
parameter_list|)
name|int
name|subtype
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Emit a line note for FILE and LINE after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_line_note_after
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|after
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|no_line_numbers
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
name|file
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|line
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an insn of code INSN with pattern PATTERN    and add it to the end of the doubly-linked list.    If PATTERN is a SEQUENCE, take the elements of it    and emit an insn for each element.     Returns the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|last_insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the insns in a chain starting with INSN.    Return the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insns
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|last
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Emit the insns in a chain starting with INSN and place them in front of    the insn BEFORE.  Return the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insns_before
parameter_list|(
name|insn
parameter_list|,
name|before
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|before
decl_stmt|;
block|{
name|rtx
name|last
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Emit the insns in a chain starting with FIRST and place them in back of    the insn AFTER.  Return the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insns_after
parameter_list|(
name|first
parameter_list|,
name|after
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
name|rtx
name|last
decl_stmt|;
name|rtx
name|after_after
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|after
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|after
return|;
if|if
condition|(
name|basic_block_for_insn
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INSN_UID
argument_list|(
name|after
argument_list|)
operator|<
name|basic_block_for_insn
operator|->
name|num_elements
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|after
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|last
operator|=
name|first
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|last
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|set_block_for_insn
argument_list|(
name|last
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|after
condition|)
name|bb
operator|->
name|end
operator|=
name|last
expr_stmt|;
block|}
else|else
for|for
control|(
name|last
operator|=
name|first
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
continue|continue;
name|after_after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|first
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first
argument_list|)
operator|=
name|after
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|after_after
expr_stmt|;
if|if
condition|(
name|after_after
condition|)
name|PREV_INSN
argument_list|(
name|after_after
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last_insn
condition|)
name|last_insn
operator|=
name|last
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with pattern PATTERN    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
return|return
name|emit_insn
argument_list|(
name|pattern
argument_list|)
return|;
else|else
block|{
name|rtx
name|insn
init|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
end_function

begin_comment
comment|/* Make an insn of code CALL_INSN with pattern PATTERN    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_call_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
return|return
name|emit_insn
argument_list|(
name|pattern
argument_list|)
return|;
else|else
block|{
name|rtx
name|insn
init|=
name|make_call_insn_raw
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|CALL_INSN
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add the label LABEL to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_label
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_barrier
parameter_list|()
block|{
name|rtx
name|barrier
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|barrier
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
return|return
name|barrier
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code NOTE    with data-fields specified by FILE and LINE    and add it to the end of the doubly-linked list,    but only if line-numbers are desired for debugging info.  */
end_comment

begin_function
name|rtx
name|emit_line_note
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|set_file_and_line_for_stmt
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (no_line_numbers)     return 0;
endif|#
directive|endif
return|return
name|emit_note
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code NOTE    with data-fields specified by FILE and LINE    and add it to the end of the doubly-linked list.    If it is a line-number NOTE, omit it if it matches the previous one.  */
end_comment

begin_function
name|rtx
name|emit_note
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|line
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|file
operator|&&
name|last_filename
operator|&&
operator|!
name|strcmp
argument_list|(
name|file
argument_list|,
name|last_filename
argument_list|)
operator|&&
name|line
operator|==
name|last_linenum
condition|)
return|return
literal|0
return|;
name|last_filename
operator|=
name|file
expr_stmt|;
name|last_linenum
operator|=
name|line
expr_stmt|;
block|}
if|if
condition|(
name|no_line_numbers
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
name|file
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|line
expr_stmt|;
name|add_insn
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Emit a NOTE, and don't omit it even if LINE is the previous note.  */
end_comment

begin_function
name|rtx
name|emit_line_note_force
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|last_linenum
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|emit_line_note
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cause next statement to emit a line note even if the line number    has not changed.  This is used at the beginning of a function.  */
end_comment

begin_function
name|void
name|force_next_line_note
parameter_list|()
block|{
name|last_linenum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place a note of KIND on insn INSN with DATUM as the datum. If a    note of this type already exists, remove it first.  */
end_comment

begin_function
name|rtx
name|set_unique_reg_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|datum
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|rtx
name|datum
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|kind
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|REG_EQUAL
case|:
case|case
name|REG_EQUIV
case|:
comment|/* Don't add REG_EQUAL/REG_EQUIV notes if the insn 	 has multiple sets (some callers assume single_set 	 means the insn only has one set, when in fact it 	 means the insn only has one * useful * set).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|multiple_sets
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|note
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Don't add ASM_OPERAND REG_EQUAL/REG_EQUIV notes. 	 It serves no useful purpose and breaks eliminate_regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|datum
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|NULL_RTX
return|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|note
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|datum
expr_stmt|;
return|return
name|note
return|;
block|}
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|kind
argument_list|,
name|datum
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an indication of which type of insn should have X as a body.    The value is CODE_LABEL, INSN, CALL_INSN or JUMP_INSN.  */
end_comment

begin_function
name|enum
name|rtx_code
name|classify_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
name|CODE_LABEL
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|JUMP_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
else|else
return|return
name|INSN
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
block|}
return|return
name|INSN
return|;
block|}
end_function

begin_comment
comment|/* Emit the rtl pattern X as an appropriate kind of insn.    If X is a label, it is simply added into the insn chain.  */
end_comment

begin_function
name|rtx
name|emit
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|classify_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
return|return
name|emit_label
argument_list|(
name|x
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INSN
condition|)
return|return
name|emit_insn
argument_list|(
name|x
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|insn
init|=
name|emit_jump_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|emit_barrier
argument_list|()
return|;
return|return
name|insn
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
return|return
name|emit_call_insn
argument_list|(
name|x
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin emitting insns to a sequence which can be packaged in an    RTL_EXPR.  If this sequence will contain something that might cause    the compiler to pop arguments to function calls (because those    pops have previously been deferred; see INHIBIT_DEFER_POP for more    details), use do_pending_stack_adjust before calling this function.    That will ensure that the deferred pops are not accidentally    emitted in the middle of this sequence.  */
end_comment

begin_function
name|void
name|start_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
operator|(
expr|struct
name|sequence_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sequence_stack
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|->
name|next
operator|=
name|seq_stack
expr_stmt|;
name|tem
operator|->
name|first
operator|=
name|first_insn
expr_stmt|;
name|tem
operator|->
name|last
operator|=
name|last_insn
expr_stmt|;
name|tem
operator|->
name|sequence_rtl_expr
operator|=
name|seq_rtl_expr
expr_stmt|;
name|seq_stack
operator|=
name|tem
expr_stmt|;
name|first_insn
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, but indicate that this sequence will be placed in T, an    RTL_EXPR.  See the documentation for start_sequence for more    information about how to use this function.  */
end_comment

begin_function
name|void
name|start_sequence_for_rtl_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|seq_rtl_expr
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the insn chain starting with FIRST as the current sequence,    saving the previously current one.  See the documentation for    start_sequence for more information about how to use this function.  */
end_comment

begin_function
name|void
name|push_to_sequence
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|last
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|last
operator|&&
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
empty_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the insn chain from a chain stort in FIRST to LAST.  */
end_comment

begin_function
name|void
name|push_to_full_sequence
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
comment|/* We really should have the end of the insn chain here.  */
if|if
condition|(
name|last
operator|&&
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the outer-level insn chain    as the current sequence, saving the previously current one.  */
end_comment

begin_function
name|void
name|push_topmost_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|,
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|stack
operator|=
name|seq_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
name|top
operator|=
name|stack
expr_stmt|;
name|first_insn
operator|=
name|top
operator|->
name|first
expr_stmt|;
name|last_insn
operator|=
name|top
operator|->
name|last
expr_stmt|;
name|seq_rtl_expr
operator|=
name|top
operator|->
name|sequence_rtl_expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After emitting to the outer-level insn chain, update the outer-level    insn chain, and restore the previous saved state.  */
end_comment

begin_function
name|void
name|pop_topmost_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|,
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|stack
operator|=
name|seq_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
name|top
operator|=
name|stack
expr_stmt|;
name|top
operator|->
name|first
operator|=
name|first_insn
expr_stmt|;
name|top
operator|->
name|last
operator|=
name|last_insn
expr_stmt|;
comment|/* ??? Why don't we save seq_rtl_expr here?  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After emitting to a sequence, restore previous saved state.     To get the contents of the sequence just made, you must call    `gen_sequence' *before* calling here.     If the compiler might have deferred popping arguments while    generating this sequence, and this sequence will not be immediately    inserted into the instruction stream, use do_pending_stack_adjust    before calling gen_sequence.  That will ensure that the deferred    pops are inserted into this sequence, and not into some random    location in the instruction stream.  See INHIBIT_DEFER_POP for more    information about deferred popping of arguments.  */
end_comment

begin_function
name|void
name|end_sequence
parameter_list|()
block|{
name|struct
name|sequence_stack
modifier|*
name|tem
init|=
name|seq_stack
decl_stmt|;
name|first_insn
operator|=
name|tem
operator|->
name|first
expr_stmt|;
name|last_insn
operator|=
name|tem
operator|->
name|last
expr_stmt|;
name|seq_rtl_expr
operator|=
name|tem
operator|->
name|sequence_rtl_expr
expr_stmt|;
name|seq_stack
operator|=
name|tem
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This works like end_sequence, but records the old sequence in FIRST    and LAST.  */
end_comment

begin_function
name|void
name|end_full_sequence
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
modifier|*
name|first
decl_stmt|,
decl|*
name|last
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|first
operator|=
name|first_insn
expr_stmt|;
operator|*
name|last
operator|=
name|last_insn
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return 1 if currently emitting into a sequence.  */
end_comment

begin_function
name|int
name|in_sequence_p
parameter_list|()
block|{
return|return
name|seq_stack
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate a SEQUENCE rtx containing the insns already emitted    to the current sequence.     This is how the gen_... function from a DEFINE_EXPAND    constructs the SEQUENCE that it returns.  */
end_comment

begin_function
name|rtx
name|gen_sequence
parameter_list|()
block|{
name|rtx
name|result
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Count the insns in the chain.  */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|first_insn
init|;
name|tem
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
name|len
operator|++
expr_stmt|;
comment|/* If only one insn, return it rather than a SEQUENCE.      (Now that we cache SEQUENCE expressions, it isn't worth special-casing      the case of an empty list.)      We only return the pattern of an insn if its code is INSN and it      has no notes.  This ensures that no information gets lost.  */
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|first_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|INSN
comment|/* Don't throw away any reg notes.  */
operator|&&
name|REG_NOTES
argument_list|(
name|first_insn
argument_list|)
operator|==
literal|0
condition|)
return|return
name|PATTERN
argument_list|(
name|first_insn
argument_list|)
return|;
name|result
operator|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tem
operator|=
name|first_insn
init|;
name|tem
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
operator|,
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|tem
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Put the various virtual registers into REGNO_REG_RTX.  */
end_comment

begin_function
name|void
name|init_virtual_regs
parameter_list|(
name|es
parameter_list|)
name|struct
name|emit_status
modifier|*
name|es
decl_stmt|;
block|{
name|rtx
modifier|*
name|ptr
init|=
name|es
operator|->
name|x_regno_reg_rtx
decl_stmt|;
name|ptr
index|[
name|VIRTUAL_INCOMING_ARGS_REGNUM
index|]
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_STACK_VARS_REGNUM
index|]
operator|=
name|virtual_stack_vars_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_STACK_DYNAMIC_REGNUM
index|]
operator|=
name|virtual_stack_dynamic_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_OUTGOING_ARGS_REGNUM
index|]
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_CFA_REGNUM
index|]
operator|=
name|virtual_cfa_rtx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_emit_caches
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Clear the start_sequence/gen_sequence cache.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SEQUENCE_RESULT_SIZE
condition|;
name|i
operator|++
control|)
name|sequence_result
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|free_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used by copy_insn_1 to avoid copying SCRATCHes more than once.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|copy_insn_scratch_in
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|copy_insn_scratch_out
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|copy_insn_n_scratches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_insn_1, this is nonzero if we have    copied an ASM_OPERANDS.    In that case, it is the original input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|orig_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_insn_1, this is nonzero if we have    copied an ASM_OPERANDS.    In that case, it is the copied input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for the constraints vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|orig_asm_constraints_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_constraints_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Recursively create a new copy of an rtx for copy_insn.    This function differs from copy_rtx in that it handles SCRATCHes and    ASM_OPERANDs properly.    Normally, this function is not used directly; use copy_insn as front end.    However, you could first copy an insn pattern with copy_insn and then use    this function afterwards to properly copy any REG_NOTEs containing    SCRATCHes.  */
end_comment

begin_function
name|rtx
name|copy_insn_1
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
name|rtx
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDRESSOF
case|:
return|return
name|orig
return|;
case|case
name|SCRATCH
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_insn_n_scratches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|copy_insn_scratch_in
index|[
name|i
index|]
operator|==
name|orig
condition|)
return|return
name|copy_insn_scratch_out
index|[
name|i
index|]
return|;
break|break;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|orig
return|;
break|break;
comment|/* A MEM with a constant address is not sharable.  The problem is that 	 the constant address may need to be reloaded.  If the mem is shared, 	 then reloading one copy of this mem will cause all copies to appear 	 to have been reloaded.  */
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Copy the various flags, and other information.  We assume that      all fields need copying, and then clear the fields that should      not be copied.  That is the sensible default behavior, and forces      us to explicitly document why we are *not* copying a flag.  */
name|memcpy
argument_list|(
name|copy
argument_list|,
name|orig
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not copy the USED flag, which is used as a mark bit during      walks over the RTL.  */
name|copy
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* We do not copy JUMP, CALL, or FRAME_RELATED for INSNs.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|copy
operator|->
name|jump
operator|=
literal|0
expr_stmt|;
name|copy
operator|->
name|call
operator|=
literal|0
expr_stmt|;
name|copy
operator|->
name|frame_related
operator|=
literal|0
expr_stmt|;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|copy
operator|->
name|fld
index|[
name|i
index|]
operator|=
name|orig
operator|->
name|fld
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|==
name|orig_asm_constraints_vector
condition|)
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_asm_constraints_vector
expr_stmt|;
elseif|else
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|==
name|orig_asm_operands_vector
condition|)
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_asm_operands_vector
expr_stmt|;
elseif|else
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
case|case
literal|'w'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'u'
case|:
case|case
literal|'0'
case|:
comment|/* These are left unchanged.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|SCRATCH
condition|)
block|{
name|i
operator|=
name|copy_insn_n_scratches
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAX_RECOG_OPERANDS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|copy_insn_scratch_in
index|[
name|i
index|]
operator|=
name|orig
expr_stmt|;
name|copy_insn_scratch_out
index|[
name|i
index|]
operator|=
name|copy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|orig_asm_operands_vector
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|copy_asm_operands_vector
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|orig_asm_constraints_vector
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Create a new copy of an rtx.    This function differs from copy_rtx in that it handles SCRATCHes and    ASM_OPERANDs properly.    INSN doesn't really have to be a full INSN; it could be just the    pattern.  */
end_comment

begin_function
name|rtx
name|copy_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|copy_insn_n_scratches
operator|=
literal|0
expr_stmt|;
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
name|orig_asm_constraints_vector
operator|=
literal|0
expr_stmt|;
name|copy_asm_operands_vector
operator|=
literal|0
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
literal|0
expr_stmt|;
return|return
name|copy_insn_1
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize data structures and variables in this file    before generating rtl for each function.  */
end_comment

begin_function
name|void
name|init_emit
parameter_list|()
block|{
name|struct
name|function
modifier|*
name|f
init|=
name|cfun
decl_stmt|;
name|f
operator|->
name|emit
operator|=
operator|(
expr|struct
name|emit_status
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emit_status
argument_list|)
argument_list|)
expr_stmt|;
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|NULL
expr_stmt|;
name|seq_rtl_expr
operator|=
name|NULL
expr_stmt|;
name|cur_insn_uid
operator|=
literal|1
expr_stmt|;
name|reg_rtx_no
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
expr_stmt|;
name|last_linenum
operator|=
literal|0
expr_stmt|;
name|last_filename
operator|=
literal|0
expr_stmt|;
name|first_label_num
operator|=
name|label_num
expr_stmt|;
name|last_label_num
operator|=
literal|0
expr_stmt|;
name|seq_stack
operator|=
name|NULL
expr_stmt|;
name|clear_emit_caches
argument_list|()
expr_stmt|;
comment|/* Init the tables that describe all the pseudo regs.  */
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|101
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_decl
operator|=
operator|(
name|tree
operator|*
operator|)
name|xcalloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put copies of all the virtual register rtx into regno_reg_rtx.  */
name|init_virtual_regs
argument_list|(
name|f
operator|->
name|emit
argument_list|)
expr_stmt|;
comment|/* Indicate that the virtual registers and stack locations are      all pointers.  */
name|REG_POINTER
argument_list|(
name|stack_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|frame_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|arg_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_stack_vars_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_cfa_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|REGNO_POINTER_ALIGN
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|ARG_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_INCOMING_ARGS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_STACK_VARS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_STACK_DYNAMIC_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_OUTGOING_ARGS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_CFA_REGNUM
argument_list|)
operator|=
name|BITS_PER_WORD
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_EXPANDERS
name|INIT_EXPANDERS
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Mark SS for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_sequence_stack
parameter_list|(
name|ss
parameter_list|)
name|struct
name|sequence_stack
modifier|*
name|ss
decl_stmt|;
block|{
while|while
condition|(
name|ss
condition|)
block|{
name|ggc_mark_rtx
argument_list|(
name|ss
operator|->
name|first
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|ss
operator|->
name|sequence_rtl_expr
argument_list|)
expr_stmt|;
name|ss
operator|=
name|ss
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark ES for GC.  */
end_comment

begin_function
name|void
name|mark_emit_status
parameter_list|(
name|es
parameter_list|)
name|struct
name|emit_status
modifier|*
name|es
decl_stmt|;
block|{
name|rtx
modifier|*
name|r
decl_stmt|;
name|tree
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|es
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|es
operator|->
name|regno_pointer_align_length
operator|,
name|r
operator|=
name|es
operator|->
name|x_regno_reg_rtx
operator|,
name|t
operator|=
name|es
operator|->
name|regno_decl
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|r
operator|,
operator|++
name|t
control|)
block|{
name|ggc_mark_rtx
argument_list|(
operator|*
name|r
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
name|mark_sequence_stack
argument_list|(
name|es
operator|->
name|sequence_stack
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|es
operator|->
name|sequence_rtl_expr
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|es
operator|->
name|x_first_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create some permanent unique rtl objects shared between all functions.    LINE_NUMBERS is nonzero if line numbers are to be generated.  */
end_comment

begin_function
name|void
name|init_emit_once
parameter_list|(
name|line_numbers
parameter_list|)
name|int
name|line_numbers
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|double_mode
decl_stmt|;
comment|/* Initialize the CONST_INT and memory attribute hash tables.  */
name|const_int_htab
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|const_int_htab_hash
argument_list|,
name|const_int_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ggc_add_deletable_htab
argument_list|(
name|const_int_htab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_attrs_htab
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|mem_attrs_htab_hash
argument_list|,
name|mem_attrs_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ggc_add_deletable_htab
argument_list|(
name|mem_attrs_htab
argument_list|,
literal|0
argument_list|,
name|mem_attrs_mark
argument_list|)
expr_stmt|;
name|no_line_numbers
operator|=
operator|!
name|line_numbers
expr_stmt|;
comment|/* Compute the word and byte modes.  */
name|byte_mode
operator|=
name|VOIDmode
expr_stmt|;
name|word_mode
operator|=
name|VOIDmode
expr_stmt|;
name|double_mode
operator|=
name|VOIDmode
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_UNIT
operator|&&
name|byte_mode
operator|==
name|VOIDmode
condition|)
name|byte_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_WORD
operator|&&
name|word_mode
operator|==
name|VOIDmode
condition|)
name|word_mode
operator|=
name|mode
expr_stmt|;
block|}
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|DOUBLE_TYPE_SIZE
operator|&&
name|double_mode
operator|==
name|VOIDmode
condition|)
name|double_mode
operator|=
name|mode
expr_stmt|;
block|}
name|ptr_mode
operator|=
name|mode_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Assign register numbers to the globally defined register rtx.      This must be done at runtime because the register number field      is in a union and some compilers can't initialize unions.  */
name|pc_rtx
operator|=
name|gen_rtx
argument_list|(
name|PC
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|cc0_rtx
operator|=
name|gen_rtx
argument_list|(
name|CC0
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|stack_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|frame_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_frame_pointer_rtx
operator|==
literal|0
condition|)
name|hard_frame_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_pointer_rtx
operator|==
literal|0
condition|)
name|arg_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|virtual_incoming_args_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_INCOMING_ARGS_REGNUM
argument_list|)
expr_stmt|;
name|virtual_stack_vars_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_STACK_VARS_REGNUM
argument_list|)
expr_stmt|;
name|virtual_stack_dynamic_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_STACK_DYNAMIC_REGNUM
argument_list|)
expr_stmt|;
name|virtual_outgoing_args_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_OUTGOING_ARGS_REGNUM
argument_list|)
expr_stmt|;
name|virtual_cfa_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_CFA_REGNUM
argument_list|)
expr_stmt|;
comment|/* These rtx must be roots if GC is enabled.  */
name|ggc_add_rtx_root
argument_list|(
name|global_rtl
argument_list|,
name|GR_MAX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXPANDERS
comment|/* This is to initialize {init|mark|free}_machine_status before the first      call to push_function_context_to.  This is needed by the Chill front      end which calls push_function_context_to before the first call to      init_function_start.  */
name|INIT_EXPANDERS
expr_stmt|;
endif|#
directive|endif
comment|/* Create the unique rtx's for certain rtx codes and operand values.  */
comment|/* Don't use gen_rtx here since gen_rtx in this case      tries to use these variables.  */
for|for
control|(
name|i
operator|=
operator|-
name|MAX_SAVED_CONST_INT
init|;
name|i
operator|<=
name|MAX_SAVED_CONST_INT
condition|;
name|i
operator|++
control|)
name|const_int_rtx
index|[
name|i
operator|+
name|MAX_SAVED_CONST_INT
index|]
operator|=
name|gen_rtx_raw_CONST_INT
argument_list|(
name|VOIDmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
name|const_int_rtx
argument_list|,
literal|2
operator|*
name|MAX_SAVED_CONST_INT
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|>=
operator|-
name|MAX_SAVED_CONST_INT
operator|&&
name|STORE_FLAG_VALUE
operator|<=
name|MAX_SAVED_CONST_INT
condition|)
name|const_true_rtx
operator|=
name|const_int_rtx
index|[
name|STORE_FLAG_VALUE
operator|+
name|MAX_SAVED_CONST_INT
index|]
expr_stmt|;
else|else
name|const_true_rtx
operator|=
name|gen_rtx_CONST_INT
argument_list|(
name|VOIDmode
argument_list|,
name|STORE_FLAG_VALUE
argument_list|)
expr_stmt|;
name|dconst0
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"0"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|dconst1
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"1"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|dconst2
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"2"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|dconstm1
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"-1"
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|rtx
name|tem
init|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
comment|/* Zero any holes in a structure.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|u
operator|.
name|d
operator|=
name|i
operator|==
literal|0
condition|?
name|dconst0
else|:
name|i
operator|==
literal|1
condition|?
name|dconst1
else|:
name|dconst2
expr_stmt|;
comment|/* Avoid trailing garbage in the rtx.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|u
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
name|CONST_DOUBLE_LOW
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|u
argument_list|)
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|tem
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_CHAIN
argument_list|(
name|tem
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|PUT_MODE
argument_list|(
name|tem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|tem
expr_stmt|;
block|}
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|VOIDmode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_PARTIAL_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|CCmode
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
name|i
argument_list|)
operator|==
name|MODE_CC
condition|)
name|const_tiny_rtx
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|const_tiny_rtx
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
name|BImode
index|]
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|)
name|const_tiny_rtx
index|[
literal|1
index|]
index|[
operator|(
name|int
operator|)
name|BImode
index|]
operator|=
name|const1_rtx
expr_stmt|;
comment|/* For bounded pointers, `&const_tiny_rtx[0][0]' is not the same as      `(rtx *) const_tiny_rtx'.  The former has bounds that only cover      `const_tiny_rtx[0]', whereas the latter has bounds that cover all.  */
name|ggc_add_rtx_root
argument_list|(
operator|(
name|rtx
operator|*
operator|)
name|const_tiny_rtx
argument_list|,
sizeof|sizeof
name|const_tiny_rtx
operator|/
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|const_true_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ADDRESS_POINTER_REGNUM
name|return_address_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_ADDRESS_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRUCT_VALUE
name|struct_value_rtx
operator|=
name|STRUCT_VALUE
expr_stmt|;
else|#
directive|else
name|struct_value_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING
name|struct_value_incoming_rtx
operator|=
name|STRUCT_VALUE_INCOMING
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING_REGNUM
name|struct_value_incoming_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct_value_incoming_rtx
operator|=
name|struct_value_rtx
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
name|static_chain_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
if|if
condition|(
name|STATIC_CHAIN_INCOMING_REGNUM
operator|!=
name|STATIC_CHAIN_REGNUM
condition|)
name|static_chain_incoming_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|static_chain_incoming_rtx
operator|=
name|static_chain_rtx
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN
name|static_chain_rtx
operator|=
name|STATIC_CHAIN
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING
name|static_chain_incoming_rtx
operator|=
name|STATIC_CHAIN_INCOMING
expr_stmt|;
else|#
directive|else
name|static_chain_incoming_rtx
operator|=
name|static_chain_rtx
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
condition|)
name|pic_offset_table_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|pic_offset_table_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|struct_value_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|struct_value_incoming_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|static_chain_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|static_chain_incoming_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|return_address_pointer_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Query and clear/ restore no_line_numbers.  This is used by the    switch / case handling in stmt.c to give proper line numbers in    warnings about unreachable code.  */
end_comment

begin_function
name|int
name|force_line_numbers
parameter_list|()
block|{
name|int
name|old
init|=
name|no_line_numbers
decl_stmt|;
name|no_line_numbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old
condition|)
name|force_next_line_note
argument_list|()
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_function
name|void
name|restore_line_number_status
parameter_list|(
name|old_value
parameter_list|)
name|int
name|old_value
decl_stmt|;
block|{
name|no_line_numbers
operator|=
name|old_value
expr_stmt|;
block|}
end_function

end_unit

