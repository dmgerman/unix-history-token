begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Emit RTL for the GCC expander.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Middle-to-low level generation of rtx code and insns.     This file contains support functions for creating rtl expressions    and manipulating them in the doubly-linked chain of insns.     The patterns of the insns are created by machine-dependent    routines in insn-emit.c, which is generated automatically from    the machine description.  These routines make the individual rtx's    of the pattern with `gen_rtx_fmt_ee' and others in genrtl.[ch],    which are automatically generated from rtl.def; what is machine    dependent is the kind of rtx's they make and what arguments they    use.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* Commonly used modes.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|byte_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is BITS_PER_UNIT.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|word_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is BITS_PER_WORD.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|double_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is DOUBLE_TYPE_SIZE.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|ptr_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is POINTER_SIZE.  */
end_comment

begin_comment
comment|/* This is *not* reset after each function.  It gives each CODE_LABEL    in the entire compilation a unique label number.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|label_num
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Nonzero means do not generate NOTEs for source line numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_line_numbers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Commonly used rtx's, so that we only need space for one copy.    These are initialized once for the entire compilation.    All of these are unique; no other rtx-object will be equal to any    of these.  */
end_comment

begin_decl_stmt
name|rtx
name|global_rtl
index|[
name|GR_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Commonly used RTL for hard registers.  These objects are not necessarily    unique, so we allocate them separately from global_rtl.  They are    initialized once per compilation unit, then copied into regno_reg_rtx    at the beginning of each function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|static_regno_reg_rtx
index|[
name|FIRST_PSEUDO_REGISTER
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We record floating-point CONST_DOUBLEs in each floating-point mode for    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we    record a copy of const[012]_rtx.  */
end_comment

begin_decl_stmt
name|rtx
name|const_tiny_rtx
index|[
literal|3
index|]
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|const_true_rtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconst10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconstm1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconstm2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconsthalf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconstthird
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconstpi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REAL_VALUE_TYPE
name|dconste
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All references to the following fixed hard registers go through    these unique rtl objects.  On machines where the frame-pointer and    arg-pointer are the same register, they use the same unique object.     After register allocation, other rtl objects which used to be pseudo-regs    may be clobbered to refer to the frame-pointer register.    But references that were originally to the frame-pointer can be    distinguished from the others because they contain frame_pointer_rtx.     When to use frame_pointer_rtx and hard_frame_pointer_rtx is a little    tricky: until register elimination has taken place hard_frame_pointer_rtx    should be used if it is being set, and frame_pointer_rtx otherwise.  After    register elimination hard_frame_pointer_rtx should always be used.    On machines where the two registers are same (most) then these are the    same.     In an inline procedure, the stack and frame pointer rtxs may not be    used for anything else.  */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_incoming_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_INCOMING_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|pic_offset_table_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */
end_comment

begin_comment
comment|/* This is used to implement __builtin_return_address for some machines.    See for instance the MIPS port.  */
end_comment

begin_decl_stmt
name|rtx
name|return_address_pointer_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */
end_comment

begin_comment
comment|/* We make one copy of (const_int C) where C is in    [- MAX_SAVED_CONST_INT, MAX_SAVED_CONST_INT]    to save space during the compilation and simplify comparisons of    integers.  */
end_comment

begin_decl_stmt
name|rtx
name|const_int_rtx
index|[
name|MAX_SAVED_CONST_INT
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hash table storing CONST_INTs whose absolute value is greater    than MAX_SAVED_CONST_INT.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"ggc_marked_p"
argument|), param_is (struct rtx_def))
argument_list|)
name|htab_t
name|const_int_htab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A hash table storing memory attribute structures.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"ggc_marked_p"
argument|), param_is (struct mem_attrs))
argument_list|)
name|htab_t
name|mem_attrs_htab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A hash table storing register attribute structures.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"ggc_marked_p"
argument|), param_is (struct reg_attrs))
argument_list|)
name|htab_t
name|reg_attrs_htab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A hash table storing all CONST_DOUBLEs.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"ggc_marked_p"
argument|), param_is (struct rtx_def))
argument_list|)
name|htab_t
name|const_double_htab
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|first_insn
value|(cfun->emit->x_first_insn)
end_define

begin_define
define|#
directive|define
name|last_insn
value|(cfun->emit->x_last_insn)
end_define

begin_define
define|#
directive|define
name|cur_insn_uid
value|(cfun->emit->x_cur_insn_uid)
end_define

begin_define
define|#
directive|define
name|last_location
value|(cfun->emit->x_last_location)
end_define

begin_define
define|#
directive|define
name|first_label_num
value|(cfun->emit->x_first_label_num)
end_define

begin_function_decl
specifier|static
name|rtx
name|make_call_insn_raw
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|find_line_note
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|change_address_1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unshare_all_decls
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_used_decls
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_label_nuses
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|const_int_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|const_int_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|const_double_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|const_double_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|lookup_const_double
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|mem_attrs_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_attrs_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mem_attrs
modifier|*
name|get_mem_attrs
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|reg_attrs_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reg_attrs_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_attrs
modifier|*
name|get_reg_attrs
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|component_ref_for_mem_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_const_vector
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_rtx_if_shared_1
parameter_list|(
name|rtx
modifier|*
name|orig
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Probability of the conditional branch currently proceeded by try_split.    Set to -1 otherwise.  */
end_comment

begin_decl_stmt
name|int
name|split_branch_probability
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns a hash code for X (which is a really a CONST_INT).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_int_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
return|return
operator|(
name|hashval_t
operator|)
name|INTVAL
argument_list|(
operator|(
name|rtx
operator|)
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the value represented by X (which is really a    CONST_INT) is the same as that given by Y (which is really a    HOST_WIDE_INT *).  */
end_comment

begin_function
specifier|static
name|int
name|const_int_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|(
name|INTVAL
argument_list|(
operator|(
name|rtx
operator|)
name|x
argument_list|)
operator|==
operator|*
operator|(
operator|(
specifier|const
name|HOST_WIDE_INT
operator|*
operator|)
name|y
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for X (which is really a CONST_DOUBLE).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_double_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
name|rtx
name|value
init|=
operator|(
name|rtx
operator|)
name|x
decl_stmt|;
name|hashval_t
name|h
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
condition|)
name|h
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
operator|^
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|h
operator|=
name|real_hash
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MODE is used in the comparison, so it should be in the hash.  */
name|h
operator|^=
name|GET_MODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the value represented by X (really a ...)    is the same as that represented by Y (really a ...) */
end_comment

begin_function
specifier|static
name|int
name|const_double_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|rtx
name|a
init|=
operator|(
name|rtx
operator|)
name|x
decl_stmt|,
name|b
init|=
operator|(
name|rtx
operator|)
name|y
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_DOUBLE_LOW
argument_list|(
name|b
argument_list|)
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_DOUBLE_HIGH
argument_list|(
name|b
argument_list|)
operator|)
return|;
else|else
return|return
name|real_identical
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for X (which is a really a mem_attrs *).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mem_attrs_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
name|mem_attrs
modifier|*
name|p
init|=
operator|(
name|mem_attrs
operator|*
operator|)
name|x
decl_stmt|;
return|return
operator|(
name|p
operator|->
name|alias
operator|^
operator|(
name|p
operator|->
name|align
operator|*
literal|1000
operator|)
operator|^
operator|(
operator|(
name|p
operator|->
name|offset
condition|?
name|INTVAL
argument_list|(
name|p
operator|->
name|offset
argument_list|)
else|:
literal|0
operator|)
operator|*
literal|50000
operator|)
operator|^
operator|(
operator|(
name|p
operator|->
name|size
condition|?
name|INTVAL
argument_list|(
name|p
operator|->
name|size
argument_list|)
else|:
literal|0
operator|)
operator|*
literal|2500000
operator|)
operator|^
operator|(
name|size_t
operator|)
name|iterative_hash_expr
argument_list|(
name|p
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the value represented by X (which is really a    mem_attrs *) is the same as that given by Y (which is also really a    mem_attrs *).  */
end_comment

begin_function
specifier|static
name|int
name|mem_attrs_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|mem_attrs
modifier|*
name|p
init|=
operator|(
name|mem_attrs
operator|*
operator|)
name|x
decl_stmt|;
name|mem_attrs
modifier|*
name|q
init|=
operator|(
name|mem_attrs
operator|*
operator|)
name|y
decl_stmt|;
return|return
operator|(
name|p
operator|->
name|alias
operator|==
name|q
operator|->
name|alias
operator|&&
name|p
operator|->
name|offset
operator|==
name|q
operator|->
name|offset
operator|&&
name|p
operator|->
name|size
operator|==
name|q
operator|->
name|size
operator|&&
name|p
operator|->
name|align
operator|==
name|q
operator|->
name|align
operator|&&
operator|(
name|p
operator|->
name|expr
operator|==
name|q
operator|->
name|expr
operator|||
operator|(
name|p
operator|->
name|expr
operator|!=
name|NULL_TREE
operator|&&
name|q
operator|->
name|expr
operator|!=
name|NULL_TREE
operator|&&
name|operand_equal_p
argument_list|(
name|p
operator|->
name|expr
argument_list|,
name|q
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new mem_attrs structure and insert it into the hash table if    one identical to it is not already in the table.  We are doing this for    MEM of mode MODE.  */
end_comment

begin_function
specifier|static
name|mem_attrs
modifier|*
name|get_mem_attrs
parameter_list|(
name|HOST_WIDE_INT
name|alias
parameter_list|,
name|tree
name|expr
parameter_list|,
name|rtx
name|offset
parameter_list|,
name|rtx
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|mem_attrs
name|attrs
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* If everything is the default, we can just return zero.      This must match what the corresponding MEM_* macros return when the      field is not present.  */
if|if
condition|(
name|alias
operator|==
literal|0
operator|&&
name|expr
operator|==
literal|0
operator|&&
name|offset
operator|==
literal|0
operator|&&
operator|(
name|size
operator|==
literal|0
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|STRICT_ALIGNMENT
operator|&&
name|mode
operator|!=
name|BLKmode
condition|?
name|align
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
else|:
name|align
operator|==
name|BITS_PER_UNIT
operator|)
condition|)
return|return
literal|0
return|;
name|attrs
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
name|attrs
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|attrs
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|attrs
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|attrs
operator|.
name|align
operator|=
name|align
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|mem_attrs_htab
argument_list|,
operator|&
name|attrs
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
block|{
operator|*
name|slot
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mem_attrs
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|slot
argument_list|,
operator|&
name|attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for X (which is a really a reg_attrs *).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|reg_attrs_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
name|reg_attrs
modifier|*
name|p
init|=
operator|(
name|reg_attrs
operator|*
operator|)
name|x
decl_stmt|;
return|return
operator|(
operator|(
name|p
operator|->
name|offset
operator|*
literal|1000
operator|)
operator|^
operator|(
name|long
operator|)
name|p
operator|->
name|decl
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the value represented by X (which is really a    reg_attrs *) is the same as that given by Y (which is also really a    reg_attrs *).  */
end_comment

begin_function
specifier|static
name|int
name|reg_attrs_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|reg_attrs
modifier|*
name|p
init|=
operator|(
name|reg_attrs
operator|*
operator|)
name|x
decl_stmt|;
name|reg_attrs
modifier|*
name|q
init|=
operator|(
name|reg_attrs
operator|*
operator|)
name|y
decl_stmt|;
return|return
operator|(
name|p
operator|->
name|decl
operator|==
name|q
operator|->
name|decl
operator|&&
name|p
operator|->
name|offset
operator|==
name|q
operator|->
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new reg_attrs structure and insert it into the hash table if    one identical to it is not already in the table.  We are doing this for    MEM of mode MODE.  */
end_comment

begin_function
specifier|static
name|reg_attrs
modifier|*
name|get_reg_attrs
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|reg_attrs
name|attrs
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* If everything is the default, we can just return zero.  */
if|if
condition|(
name|decl
operator|==
literal|0
operator|&&
name|offset
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|attrs
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
name|attrs
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|reg_attrs_htab
argument_list|,
operator|&
name|attrs
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
block|{
operator|*
name|slot
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|reg_attrs
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|slot
argument_list|,
operator|&
name|attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Generate a new REG rtx.  Make sure ORIGINAL_REGNO is set properly, and    don't attempt to share with the various global pieces of rtl (such as    frame_pointer_rtx).  */
end_comment

begin_function
name|rtx
name|gen_raw_REG
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|x
init|=
name|gen_rtx_raw_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|regno
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* There are some RTL codes that require special attention; the generation    functions do the raw handling.  If you add to this list, modify    special_rtx in gengenrtl.c as well.  */
end_comment

begin_function
name|rtx
name|gen_rtx_CONST_INT
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|arg
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|arg
operator|>=
operator|-
name|MAX_SAVED_CONST_INT
operator|&&
name|arg
operator|<=
name|MAX_SAVED_CONST_INT
condition|)
return|return
name|const_int_rtx
index|[
name|arg
operator|+
name|MAX_SAVED_CONST_INT
index|]
return|;
if|#
directive|if
name|STORE_FLAG_VALUE
operator|!=
literal|1
operator|&&
name|STORE_FLAG_VALUE
operator|!=
operator|-
literal|1
if|if
condition|(
name|const_true_rtx
operator|&&
name|arg
operator|==
name|STORE_FLAG_VALUE
condition|)
return|return
name|const_true_rtx
return|;
endif|#
directive|endif
comment|/* Look up the CONST_INT in the hash table.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|const_int_htab
argument_list|,
operator|&
name|arg
argument_list|,
operator|(
name|hashval_t
operator|)
name|arg
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
operator|*
name|slot
operator|=
name|gen_rtx_raw_CONST_INT
argument_list|(
name|VOIDmode
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtx
operator|)
operator|*
name|slot
return|;
block|}
end_function

begin_function
name|rtx
name|gen_int_mode
parameter_list|(
name|HOST_WIDE_INT
name|c
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* CONST_DOUBLEs might be created from pairs of integers, or from    REAL_VALUE_TYPEs.  Also, their length is known only at run time,    so we cannot use gen_rtx_raw_CONST_DOUBLE.  */
end_comment

begin_comment
comment|/* Determine whether REAL, a CONST_DOUBLE, already exists in the    hash table.  If so, return its counterpart; otherwise add it    to the hash table and return it.  */
end_comment

begin_function
specifier|static
name|rtx
name|lookup_const_double
parameter_list|(
name|rtx
name|real
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
init|=
name|htab_find_slot
argument_list|(
name|const_double_htab
argument_list|,
name|real
argument_list|,
name|INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
operator|*
name|slot
operator|=
name|real
expr_stmt|;
return|return
operator|(
name|rtx
operator|)
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE rtx for a floating-point value specified by    VALUE in mode MODE.  */
end_comment

begin_function
name|rtx
name|const_double_from_real_value
parameter_list|(
name|REAL_VALUE_TYPE
name|value
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|real
init|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|real
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|real
operator|->
name|u
operator|.
name|rv
operator|=
name|value
expr_stmt|;
return|return
name|lookup_const_double
argument_list|(
name|real
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair    of ints: I0 is the low-order word and I1 is the high-order word.    Do not use this routine for non-integer modes; convert to    REAL_VALUE_TYPE and use CONST_DOUBLE_FROM_REAL_VALUE.  */
end_comment

begin_function
name|rtx
name|immed_double_const
parameter_list|(
name|HOST_WIDE_INT
name|i0
parameter_list|,
name|HOST_WIDE_INT
name|i1
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|value
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* There are the following cases (note that there are no modes with      HOST_BITS_PER_WIDE_INT< GET_MODE_BITSIZE (mode)< 2 * HOST_BITS_PER_WIDE_INT):       1) If GET_MODE_BITSIZE (mode)<= HOST_BITS_PER_WIDE_INT, then we use 	gen_int_mode.      2) GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT, but the value of 	the integer fits into HOST_WIDE_INT anyway (i.e., i1 consists only 	from copies of the sign bit, and sign of i0 and i1 are the same),  then  	we return a CONST_INT for i0.      3) Otherwise, we create a CONST_DOUBLE for i0 and i1.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
comment|/* We can get a 0 for an error mark.  */
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|gen_int_mode
argument_list|(
name|i0
argument_list|,
name|mode
argument_list|)
return|;
name|gcc_assert
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
block|}
comment|/* If this integer fits in one word, return a CONST_INT.  */
if|if
condition|(
operator|(
name|i1
operator|==
literal|0
operator|&&
name|i0
operator|>=
literal|0
operator|)
operator|||
operator|(
name|i1
operator|==
operator|~
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
condition|)
return|return
name|GEN_INT
argument_list|(
name|i0
argument_list|)
return|;
comment|/* We use VOIDmode for integers.  */
name|value
operator|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
operator|=
name|i0
expr_stmt|;
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
operator|=
name|i1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
operator|(
sizeof|sizeof
name|CONST_DOUBLE_FORMAT
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|XWINT
argument_list|(
name|value
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|lookup_const_double
argument_list|(
name|value
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_REG
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
comment|/* In case the MD file explicitly references the frame pointer, have      all such references point to the same frame pointer.  This is      used during frame pointer elimination to distinguish the explicit      references to these registers from pseudos that happened to be      assigned to them.       If we have eliminated the frame pointer or arg pointer, we will      be using it as a normal register, for example as a spill      register.  In such cases, we might be accessing it in a mode that      is not Pmode and therefore cannot use the pre-allocated rtx.       Also don't do this when we are making new REGs in reload, since      we don't want to get confused with the real pointers.  */
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
operator|!
name|reload_in_progress
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
condition|)
return|return
name|frame_pointer_rtx
return|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
condition|)
return|return
name|hard_frame_pointer_rtx
return|;
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|arg_pointer_rtx
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RETURN_ADDRESS_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|RETURN_ADDRESS_POINTER_REGNUM
condition|)
return|return
name|return_address_pointer_rtx
return|;
endif|#
directive|endif
if|if
condition|(
name|regno
operator|==
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
return|return
name|pic_offset_table_rtx
return|;
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
name|stack_pointer_rtx
return|;
block|}
if|#
directive|if
literal|0
comment|/* If the per-function register table has been set up, try to re-use      an existing entry in that table to avoid useless generation of RTL.       This code is disabled for now until we can fix the various backends      which depend on having non-shared hard registers in some cases.   Long      term we want to re-enable this code as it can significantly cut down      on the amount of useless RTL that gets generated.       We'll also need to fix some code that runs after reload that wants to      set ORIGINAL_REGNO.  */
block|if (cfun&& cfun->emit&& regno_reg_rtx&& regno< FIRST_PSEUDO_REGISTER&& reg_raw_mode[regno] == mode)     return regno_reg_rtx[regno];
endif|#
directive|endif
return|return
name|gen_raw_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_MEM
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|rt
init|=
name|gen_rtx_raw_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* This field is not cleared by the mere allocation of the rtx, so      we clear it here.  */
name|MEM_ATTRS
argument_list|(
name|rt
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* Generate a memory referring to non-trapping constant memory.  */
end_comment

begin_function
name|rtx
name|gen_const_mem
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|MEM_READONLY_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* Generate a MEM referring to fixed portions of the frame, e.g., register    save areas.  */
end_comment

begin_function
name|rtx
name|gen_frame_mem
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* Generate a MEM referring to a temporary use of the stack, not part     of the fixed stack frame.  For example, something which is pushed     by a target splitter.  */
end_comment

begin_function
name|rtx
name|gen_tmp_stack_mem
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|current_function_calls_alloca
condition|)
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* We want to create (subreg:OMODE (obj:IMODE) OFFSET).  Return true if    this construct would be valid, and false otherwise.  */
end_comment

begin_function
name|bool
name|validate_subreg
parameter_list|(
name|enum
name|machine_mode
name|omode
parameter_list|,
name|enum
name|machine_mode
name|imode
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
block|{
name|unsigned
name|int
name|isize
init|=
name|GET_MODE_SIZE
argument_list|(
name|imode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|osize
init|=
name|GET_MODE_SIZE
argument_list|(
name|omode
argument_list|)
decl_stmt|;
comment|/* All subregs must be aligned.  */
if|if
condition|(
name|offset
operator|%
name|osize
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* The subreg offset cannot be outside the inner object.  */
if|if
condition|(
name|offset
operator|>=
name|isize
condition|)
return|return
name|false
return|;
comment|/* ??? This should not be here.  Temporarily continue to allow word_mode      subregs of anything.  The most common offender is (subreg:SI (reg:DF)).      Generally, backends are doing something sketchy but it'll take time to      fix them all.  */
if|if
condition|(
name|omode
operator|==
name|word_mode
condition|)
empty_stmt|;
comment|/* ??? Similarly, e.g. with (subreg:DF (reg:TI)).  Though store_bit_field      is the culprit here, and not the backends.  */
elseif|else
if|if
condition|(
name|osize
operator|>=
name|UNITS_PER_WORD
operator|&&
name|isize
operator|>=
name|osize
condition|)
empty_stmt|;
comment|/* Allow component subregs of complex and vector.  Though given the below      extraction rules, it's not always clear what that means.  */
elseif|else
if|if
condition|(
operator|(
name|COMPLEX_MODE_P
argument_list|(
name|imode
argument_list|)
operator|||
name|VECTOR_MODE_P
argument_list|(
name|imode
argument_list|)
operator|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|imode
argument_list|)
operator|==
name|omode
condition|)
empty_stmt|;
comment|/* ??? x86 sse code makes heavy use of *paradoxical* vector subregs,      i.e. (subreg:V4SF (reg:SF) 0).  This surely isn't the cleanest way to      represent this.  It's questionable if this ought to be represented at      all -- why can't this all be hidden in post-reload splitters that make      arbitrarily mode changes to the registers themselves.  */
elseif|else
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|omode
argument_list|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|omode
argument_list|)
operator|==
name|imode
condition|)
empty_stmt|;
comment|/* Subregs involving floating point modes are not allowed to      change size.  Therefore (subreg:DI (reg:DF) 0) is fine, but      (subreg:SI (reg:DF) 0) isn't.  */
elseif|else
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|imode
argument_list|)
operator|||
name|FLOAT_MODE_P
argument_list|(
name|omode
argument_list|)
condition|)
block|{
if|if
condition|(
name|isize
operator|!=
name|osize
condition|)
return|return
name|false
return|;
block|}
comment|/* Paradoxical subregs must have offset zero.  */
if|if
condition|(
name|osize
operator|>
name|isize
condition|)
return|return
name|offset
operator|==
literal|0
return|;
comment|/* This is a normal subreg.  Verify that the offset is representable.  */
comment|/* For hard registers, we already have most of these rules collected in      subreg_offset_representable_p.  */
if|if
condition|(
name|reg
operator|&&
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
name|HARD_REGISTER_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
operator|(
name|COMPLEX_MODE_P
argument_list|(
name|imode
argument_list|)
operator|||
name|VECTOR_MODE_P
argument_list|(
name|imode
argument_list|)
operator|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|imode
argument_list|)
operator|==
name|omode
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|REG_CANNOT_CHANGE_MODE_P
argument_list|(
name|regno
argument_list|,
name|imode
argument_list|,
name|omode
argument_list|)
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|subreg_offset_representable_p
argument_list|(
name|regno
argument_list|,
name|imode
argument_list|,
name|offset
argument_list|,
name|omode
argument_list|)
return|;
block|}
comment|/* For pseudo registers, we want most of the same checks.  Namely:      If the register no larger than a word, the subreg must be lowpart.      If the register is larger than a word, the subreg must be the lowpart      of a subword.  A subreg does *not* perform arbitrary bit extraction.      Given that we've already checked mode/offset alignment, we only have      to check subword subregs here.  */
if|if
condition|(
name|osize
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|enum
name|machine_mode
name|wmode
init|=
name|isize
operator|>
name|UNITS_PER_WORD
condition|?
name|word_mode
else|:
name|imode
decl_stmt|;
name|unsigned
name|int
name|low_off
init|=
name|subreg_lowpart_offset
argument_list|(
name|omode
argument_list|,
name|wmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|%
name|UNITS_PER_WORD
operator|!=
name|low_off
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|rtx
name|gen_rtx_SUBREG
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|validate_subreg
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_raw_SUBREG
argument_list|(
name|mode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a SUBREG representing the least-significant part of REG if MODE    is smaller than mode of REG, otherwise paradoxical SUBREG.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_SUBREG
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|enum
name|machine_mode
name|inmode
decl_stmt|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|==
name|VOIDmode
condition|)
name|inmode
operator|=
name|mode
expr_stmt|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|reg
argument_list|,
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|inmode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* gen_rtvec (n, [rt1, ..., rtn]) ** **	    This routine creates an rtvec and stores within it the **	pointers to rtx's which are its arguments. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|rtvec
name|gen_rtvec
parameter_list|(
name|int
name|n
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|save_n
decl_stmt|;
name|rtx
modifier|*
name|vector
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|vector
operator|=
name|alloca
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|vector
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
comment|/* The definition of VA_* in K&R C causes `n' to go out of scope.  */
name|save_n
operator|=
name|n
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|gen_rtvec_v
argument_list|(
name|save_n
argument_list|,
name|vector
argument_list|)
return|;
block|}
end_function

begin_function
name|rtvec
name|gen_rtvec_v
parameter_list|(
name|int
name|n
parameter_list|,
name|rtx
modifier|*
name|argp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtvec
name|rt_val
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|rt_val
operator|=
name|rtvec_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Allocate an rtvec...			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rt_val
operator|->
name|elem
index|[
name|i
index|]
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a REG rtx for a new pseudo register of mode MODE.    This pseudo is assigned the next sequential register number.  */
end_comment

begin_function
name|rtx
name|gen_reg_rtx
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|f
init|=
name|cfun
decl_stmt|;
name|rtx
name|val
decl_stmt|;
comment|/* Don't let anything called after initial flow analysis create new      registers.  */
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
if|if
condition|(
name|generating_concat_p
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|)
condition|)
block|{
comment|/* For complex modes, don't make a single pseudo. 	 Instead, make a CONCAT of two pseudos. 	 This allows noncontiguous allocation of the real and imaginary parts, 	 which makes much better code.  Besides, allocating DCmode 	 pseudos overstrains reload on some machines like the 386.  */
name|rtx
name|realpart
decl_stmt|,
name|imagpart
decl_stmt|;
name|enum
name|machine_mode
name|partmode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|realpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
name|imagpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_CONCAT
argument_list|(
name|mode
argument_list|,
name|realpart
argument_list|,
name|imagpart
argument_list|)
return|;
block|}
comment|/* Make sure regno_pointer_align, and regno_reg_rtx are large      enough to have an element for this pseudo reg number.  */
if|if
condition|(
name|reg_rtx_no
operator|==
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
condition|)
block|{
name|int
name|old_size
init|=
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|rtx
modifier|*
name|new1
decl_stmt|;
name|new
operator|=
name|ggc_realloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align
argument_list|,
name|old_size
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
operator|+
name|old_size
argument_list|,
literal|0
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|new
expr_stmt|;
name|new1
operator|=
name|ggc_realloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|x_regno_reg_rtx
argument_list|,
name|old_size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new1
operator|+
name|old_size
argument_list|,
literal|0
argument_list|,
name|old_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
name|new1
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
operator|=
name|old_size
operator|*
literal|2
expr_stmt|;
block|}
name|val
operator|=
name|gen_raw_REG
argument_list|(
name|mode
argument_list|,
name|reg_rtx_no
argument_list|)
expr_stmt|;
name|regno_reg_rtx
index|[
name|reg_rtx_no
operator|++
index|]
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Generate a register with same attributes as REG, but offsetted by OFFSET.    Do the big endian correction if needed.  */
end_comment

begin_function
name|rtx
name|gen_rtx_REG_offset
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|rtx
name|new
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|HOST_WIDE_INT
name|var_size
decl_stmt|;
comment|/* PR middle-end/14084      The problem appears when a variable is stored in a larger register      and later it is used in the original mode or some mode in between      or some part of variable is accessed.       On little endian machines there is no problem because      the REG_OFFSET of the start of the variable is the same when      accessed in any mode (it is 0).       However, this is not true on big endian machines.      The offset of the start of the variable is different when accessed      in different modes.      When we are taking a part of the REG we have to change the OFFSET      from offset WRT size of mode of REG to offset WRT size of variable.       If we would not do the big endian correction the resulting REG_OFFSET      would be larger than the size of the DECL.       Examples of correction, for BYTES_BIG_ENDIAN WORDS_BIG_ENDIAN machine:       REG.mode  MODE  DECL size  old offset  new offset  description      DI        SI    4          4           0           int32 in SImode      DI        SI    1          4           0           char in SImode      DI        QI    1          7           0           char in QImode      DI        QI    4          5           1           1st element in QImode                                                         of char[4]      DI        HI    4          6           2           1st element in HImode                                                         of int16[2]       If the size of DECL is equal or greater than the size of REG      we can't do this correction because the register holds the      whole variable or a part of the variable and thus the REG_OFFSET      is already correct.  */
name|decl
operator|=
name|REG_EXPR
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BYTES_BIG_ENDIAN
operator|||
name|WORDS_BIG_ENDIAN
operator|)
operator|&&
name|decl
operator|!=
name|NULL
operator|&&
name|offset
operator|>
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|var_size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|var_size
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|offset_le
decl_stmt|;
comment|/* Convert machine endian to little endian WRT size of mode of REG.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset_le
operator|=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
operator|-
name|offset
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|offset_le
operator|=
operator|(
name|offset
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset_le
operator|+=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
operator|-
name|offset
operator|)
operator|%
name|UNITS_PER_WORD
operator|)
expr_stmt|;
else|else
name|offset_le
operator|+=
name|offset
operator|%
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|offset_le
operator|>=
name|var_size
condition|)
block|{
comment|/* MODE is wider than the variable so the new reg will cover 	     the whole variable so the resulting OFFSET should be 0.  */
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Convert little endian to machine endian WRT size of variable.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
operator|(
name|var_size
operator|-
literal|1
operator|-
name|offset_le
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|offset
operator|=
operator|(
name|offset_le
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
operator|(
name|var_size
operator|-
literal|1
operator|-
name|offset_le
operator|)
operator|%
name|UNITS_PER_WORD
operator|)
expr_stmt|;
else|else
name|offset
operator|+=
name|offset_le
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
name|REG_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|REG_EXPR
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REG_OFFSET
argument_list|(
name|reg
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Set the decl for MEM to DECL.  */
end_comment

begin_function
name|void
name|set_reg_attrs_from_mem
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
if|if
condition|(
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|REG_ATTRS
argument_list|(
name|reg
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the register attributes for registers contained in PARM_RTX.    Use needed values from memory attributes of MEM.  */
end_comment

begin_function
name|void
name|set_reg_attrs_for_parm
parameter_list|(
name|rtx
name|parm_rtx
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|parm_rtx
argument_list|)
condition|)
name|set_reg_attrs_from_mem
argument_list|(
name|parm_rtx
argument_list|,
name|mem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|parm_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* Check for a NULL entry in the first slot, used to indicate that the 	 parameter goes both on the stack and in registers.  */
name|int
name|i
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|parm_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|parm_rtx
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|parm_rtx
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Assign the RTX X to declaration T.  */
end_comment

begin_function
name|void
name|set_decl_rtl
parameter_list|(
name|tree
name|t
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|DECL_WRTL_CHECK
argument_list|(
name|t
argument_list|)
operator|->
name|decl_with_rtl
operator|.
name|rtl
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
comment|/* For register, we maintain the reverse information too.  */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|x
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|REG_ATTRS
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
operator|-
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Assign the RTX X to parameter declaration T.  */
end_comment

begin_function
name|void
name|set_decl_incoming_rtl
parameter_list|(
name|tree
name|t
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|DECL_INCOMING_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
comment|/* For register, we maintain the reverse information too.  */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|x
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|REG_ATTRS
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
operator|-
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
comment|/* Check for a NULL entry, used to indicate that the parameter goes 	 both on the stack and in registers.  */
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|REG_ATTRS
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|get_reg_attrs
argument_list|(
name|t
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Identify REG (which may be a CONCAT) as a user register.  */
end_comment

begin_function
name|void
name|mark_user_reg
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|REG_USERVAR_P
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Identify REG as a probable pointer register and show its alignment    as ALIGN, if nonzero.  */
end_comment

begin_function
name|void
name|mark_reg_pointer
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
operator|!
name|REG_POINTER
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|REG_POINTER
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|&&
name|align
operator|<
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
comment|/* We can no-longer be sure just how aligned this pointer is.  */
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 plus largest pseudo reg number used in the current function.  */
end_comment

begin_function
name|int
name|max_reg_num
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|reg_rtx_no
return|;
block|}
end_function

begin_comment
comment|/* Return 1 + the largest label number used so far in the current function.  */
end_comment

begin_function
name|int
name|max_label_num
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|label_num
return|;
block|}
end_function

begin_comment
comment|/* Return first label number used in this function (if any were used).  */
end_comment

begin_function
name|int
name|get_first_label_num
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|first_label_num
return|;
block|}
end_function

begin_comment
comment|/* If the rtx for label was created during the expansion of a nested    function, then first_label_num won't include this label number.    Fix this now so that array indicies work later.  */
end_comment

begin_function
name|void
name|maybe_set_first_label_num
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
operator|<
name|first_label_num
condition|)
name|first_label_num
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a value representing some low-order bits of X, where the number    of low-order bits is given by MODE.  Note that no conversion is done    between floating-point and fixed-point values, rather, the bit    representation is returned.     This function handles the cases in common between gen_lowpart, below,    and two variants in cse.c and combine.c.  These are the cases that can    be safely handled at all points in the compilation.     If this is not a case we can handle, return 0.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_common
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|msize
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|xsize
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|innermode
decl_stmt|;
comment|/* Unfortunately, this routine doesn't take a parameter for the mode of X,      so we have to make one up.  Yuk.  */
name|innermode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|msize
operator|*
name|BITS_PER_UNIT
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|innermode
operator|=
name|mode_for_size
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|innermode
operator|==
name|VOIDmode
condition|)
name|innermode
operator|=
name|mode_for_size
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xsize
operator|=
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|innermode
operator|!=
name|VOIDmode
operator|&&
name|innermode
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|innermode
operator|==
name|mode
condition|)
return|return
name|x
return|;
comment|/* MODE must occupy no more words than the mode of X.  */
if|if
condition|(
operator|(
name|msize
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|>
operator|(
operator|(
name|xsize
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Don't allow generating paradoxical FLOAT_MODE subregs.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|msize
operator|>
name|xsize
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|innermode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|)
condition|)
block|{
comment|/* If we are getting the low-order part of something that has been 	 sign- or zero-extended, we can either just use the object being 	 extended or make a narrower extension.  If we want an even smaller 	 piece than the size of the object being extended, call ourselves 	 recursively.  	 This case is used mostly by combine and cse.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|msize
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|msize
operator|<
name|xsize
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|||
name|REG_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|innermode
argument_list|,
name|offset
argument_list|)
return|;
comment|/* Otherwise, we can't do this.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|rtx
name|gen_highpart
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|msize
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* This case loses if X is a subreg.  To catch bugs early,      complain if an invalid MODE is used even in other cases.  */
name|gcc_assert
argument_list|(
name|msize
operator|<=
name|UNITS_PER_WORD
operator|||
name|msize
operator|==
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|subreg_highpart_offset
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* simplify_gen_subreg is not guaranteed to return a valid operand for      the target if we have a MEM.  gen_highpart must return a valid operand,      emitting code if necessary to do so.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|=
name|validize_mem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like gen_highpart, but accept mode of EXP operand in case EXP can    be VOIDmode constant.  */
end_comment

begin_function
name|rtx
name|gen_highpart_mode
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|,
name|rtx
name|exp
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|innermode
argument_list|)
expr_stmt|;
return|return
name|gen_highpart
argument_list|(
name|outermode
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|simplify_gen_subreg
argument_list|(
name|outermode
argument_list|,
name|exp
argument_list|,
name|innermode
argument_list|,
name|subreg_highpart_offset
argument_list|(
name|outermode
argument_list|,
name|innermode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return offset in bytes to get OUTERMODE low part    of the value in mode INNERMODE stored in memory in target format.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_lowpart_offset
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|)
block|{
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|difference
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return offset in bytes to get OUTERMODE high part    of the value in mode INNERMODE stored in memory in target format.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_highpart_offset
parameter_list|(
name|enum
name|machine_mode
name|outermode
parameter_list|,
name|enum
name|machine_mode
name|innermode
parameter_list|)
block|{
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
operator|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|outermode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|difference
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff X, assumed to be a SUBREG,    refers to the least significant part of its containing reg.    If X is not a SUBREG, always return 1 (it is its own low part!).  */
end_comment

begin_function
name|int
name|subreg_lowpart_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|subreg_lowpart_offset
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return subword OFFSET of operand OP.    The word number, OFFSET, is interpreted as the word number starting    at the low-order address.  OFFSET 0 is the low-order word if not    WORDS_BIG_ENDIAN, otherwise it is the high-order word.     If we cannot extract the required word, we return zero.  Otherwise,    an rtx corresponding to the requested word will be returned.     VALIDATE_ADDRESS is nonzero if the address should be validated.  Before    reload has completed, a valid address will always be returned.  After    reload, if a valid address cannot be returned, we return zero.     If VALIDATE_ADDRESS is zero, we simply form the required address; validating    it is the responsibility of the caller.     MODE is the mode of OP in case it is a CONST_INT.     ??? This is still rather broken for some cases.  The problem for the    moment is that all callers of this thing provide no 'goal mode' to    tell us to work with.  This exists because all callers were written    in a word based SUBREG world.    Now use of this function can be deprecated by simplify_subreg in most    cases.  */
end_comment

begin_function
name|rtx
name|operand_subword
parameter_list|(
name|rtx
name|op
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|int
name|validate_address
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* If OP is narrower than a word, fail.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If we want a word outside OP, return zero.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|offset
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Form a new MEM at the requested address.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|rtx
name|new
init|=
name|adjust_address_nv
argument_list|(
name|op
argument_list|,
name|word_mode
argument_list|,
name|offset
operator|*
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_address
condition|)
return|return
name|new
return|;
elseif|else
if|if
condition|(
name|reload_completed
condition|)
block|{
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|word_mode
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
name|replace_equiv_address
argument_list|(
name|new
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Rest can be handled by simplify_subreg.  */
return|return
name|simplify_gen_subreg
argument_list|(
name|word_mode
argument_list|,
name|op
argument_list|,
name|mode
argument_list|,
operator|(
name|offset
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to `operand_subword', but never return 0.  If we can't    extract the required subword, put OP into a register and try again.    The second attempt must succeed.  We always validate the address in    this case.     MODE is the mode of OP, in case it is CONST_INT.  */
end_comment

begin_function
name|rtx
name|operand_subword_force
parameter_list|(
name|rtx
name|op
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|result
init|=
name|operand_subword
argument_list|(
name|op
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* If this is a register which can not be accessed by words, copy it 	 to a pseudo register.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
condition|)
name|op
operator|=
name|copy_to_reg
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|op
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|operand_subword
argument_list|(
name|op
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Within a MEM_EXPR, we care about either (1) a component ref of a decl,    or (2) a component ref of something variable.  Represent the later with    a NULL expression.  */
end_comment

begin_function
specifier|static
name|tree
name|component_ref_for_mem_expr
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|inner
operator|=
name|component_ref_for_mem_expr
argument_list|(
name|inner
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Now remove any conversions: they don't change what the underlying 	 object is.  Likewise for SAVE_EXPR.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|inner
argument_list|)
condition|)
name|inner
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|inner
operator|==
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ref
return|;
else|else
return|return
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|inner
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if both MEM_EXPR can be considered equal    and 0 otherwise.  */
end_comment

begin_function
name|int
name|mem_expr_equal_p
parameter_list|(
name|tree
name|expr1
parameter_list|,
name|tree
name|expr2
parameter_list|)
block|{
if|if
condition|(
name|expr1
operator|==
name|expr2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|expr1
operator|||
operator|!
name|expr2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|expr2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr1
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
return|return
name|mem_expr_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|mem_expr_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr1
argument_list|,
literal|1
argument_list|)
argument_list|,
comment|/* field decl */
name|TREE_OPERAND
argument_list|(
name|expr2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|INDIRECT_REF_P
argument_list|(
name|expr1
argument_list|)
condition|)
return|return
name|mem_expr_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* ARRAY_REFs, ARRAY_RANGE_REFs and BIT_FIELD_REFs should already 	      have been resolved here.  */
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|expr1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decls with different pointers can't be equal.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given REF, a MEM, and T, either the type of X or the expression    corresponding to REF, set the memory attributes.  OBJECTP is nonzero    if we are making a new object of this type.  BITPOS is nonzero if    there is an offset outstanding on T that will be applied later.  */
end_comment

begin_function
name|void
name|set_mem_attributes_minus_bitpos
parameter_list|(
name|rtx
name|ref
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|objectp
parameter_list|,
name|HOST_WIDE_INT
name|bitpos
parameter_list|)
block|{
name|HOST_WIDE_INT
name|alias
init|=
name|MEM_ALIAS_SET
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|tree
name|expr
init|=
name|MEM_EXPR
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
name|MEM_OFFSET
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|size
init|=
name|MEM_SIZE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|align
init|=
name|MEM_ALIGN
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|apply_bitpos
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* It can happen that type_for_mode was given a mode for which there      is no language-level type.  In which case it returns NULL, which      we can see here.  */
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
name|type
operator|=
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|t
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* If we have already set DECL_RTL = ref, get_alias_set will get the      wrong answer, as it assumes that DECL_RTL already has the right alias      info.  Callers should not set DECL_RTL until after the call to      set_mem_attributes.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|||
name|ref
operator|!=
name|DECL_RTL_IF_SET
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the alias set from the expression or type (perhaps using a      front-end routine) and use it.  */
name|alias
operator|=
name|get_alias_set
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|MEM_POINTER
argument_list|(
name|ref
argument_list|)
operator|=
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If we are making an object of this type, or if this is a DECL, we know      that it is a scalar if the type is not an aggregate.  */
if|if
condition|(
operator|(
name|objectp
operator|||
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|MEM_SCALAR_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can set the alignment from the type if we are making an object,      this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */
if|if
condition|(
name|objectp
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ALIGN_INDIRECT_REF
operator|||
name|TYPE_ALIGN_OK
argument_list|(
name|type
argument_list|)
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MISALIGNED_INDIRECT_REF
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
comment|/* We don't know anything about the alignment.  */
name|align
operator|=
name|BITS_PER_UNIT
expr_stmt|;
else|else
name|align
operator|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If the size is known, we can set that.  */
if|if
condition|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If T is not a type, we may be able to deduce some more information about      the expression.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|base
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now remove any conversions: they don't change what the underlying 	 object is.  Likewise for SAVE_EXPR.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We may look through structure-like accesses for the purposes of 	 examining TREE_THIS_NOTRAP, but not array-like accesses.  */
name|base
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|TS_DECL_WITH_VIS
argument_list|)
condition|)
name|MEM_NOTRAP_P
argument_list|(
name|ref
argument_list|)
operator|=
operator|!
name|DECL_WEAK
argument_list|(
name|base
argument_list|)
expr_stmt|;
else|else
name|MEM_NOTRAP_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|MEM_NOTRAP_P
argument_list|(
name|ref
argument_list|)
operator|=
name|TREE_THIS_NOTRAP
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|get_base_address
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|&&
name|DECL_P
argument_list|(
name|base
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|base
argument_list|)
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|base
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|base
argument_list|)
operator|)
condition|)
block|{
name|tree
name|base_type
init|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|base_type
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|base_type
argument_list|)
operator|)
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_READONLY_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this expression uses it's parent's alias set, mark it such 	 that we won't change it.  */
if|if
condition|(
name|component_uses_parent_alias_set
argument_list|(
name|t
argument_list|)
condition|)
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is a decl, set the attributes of the MEM from it.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expr
operator|=
name|t
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|apply_bitpos
operator|=
name|bitpos
expr_stmt|;
name|size
operator|=
operator|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|?
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a constant, we know the alignment.  */
elseif|else
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|t
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this is a field reference and not a bit-field, record it.  */
comment|/* ??? There is some information that can be gleened from bit-fields, 	 such as the word offset in the structure that might be modified. 	 But skip it for now.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|expr
operator|=
name|component_ref_for_mem_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|apply_bitpos
operator|=
name|bitpos
expr_stmt|;
comment|/* ??? Any reason the field size would be different than 	     the size we got from the type?  */
block|}
comment|/* If this is an array reference, look for an outer field reference.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|off_tree
init|=
name|size_zero_node
decl_stmt|;
comment|/* We can't modify t, because we use it at the end of the 	     function.  */
name|tree
name|t2
init|=
name|t
decl_stmt|;
do|do
block|{
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|array_ref_low_bound
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|unit_size
init|=
name|array_ref_element_size
argument_list|(
name|t2
argument_list|)
decl_stmt|;
comment|/* We assume all arrays have sizes that are a multiple of a byte. 		 First subtract the lower bound, if any, in the type of the 		 index, then convert to sizetype and multiply by the size of 		 the array element.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|low_bound
argument_list|)
expr_stmt|;
name|off_tree
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|index
argument_list|)
argument_list|,
name|unit_size
argument_list|)
argument_list|,
name|off_tree
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ARRAY_REF
condition|)
do|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|expr
operator|=
name|t2
expr_stmt|;
name|offset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|off_tree
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|ioff
init|=
name|tree_low_cst
argument_list|(
name|off_tree
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|aoff
init|=
operator|(
name|ioff
operator|&
operator|-
name|ioff
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|aoff
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|aoff
operator|<
name|align
condition|)
name|align
operator|=
name|aoff
expr_stmt|;
name|offset
operator|=
name|GEN_INT
argument_list|(
name|ioff
argument_list|)
expr_stmt|;
name|apply_bitpos
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|expr
operator|=
name|component_ref_for_mem_expr
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|off_tree
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|offset
operator|=
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|off_tree
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|apply_bitpos
operator|=
name|bitpos
expr_stmt|;
block|}
comment|/* ??? Any reason the field size would be different than 		 the size we got from the type?  */
block|}
elseif|else
if|if
condition|(
name|flag_argument_noalias
operator|>
literal|1
operator|&&
operator|(
name|INDIRECT_REF_P
argument_list|(
name|t2
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|expr
operator|=
name|t2
expr_stmt|;
name|offset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If this is a Fortran indirect argument reference, record the 	 parameter decl.  */
elseif|else
if|if
condition|(
name|flag_argument_noalias
operator|>
literal|1
operator|&&
operator|(
name|INDIRECT_REF_P
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|expr
operator|=
name|t
expr_stmt|;
name|offset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If we modified OFFSET based on T, then subtract the outstanding      bit position offset.  Similarly, increase the size of the accessed      object to contain the negative offset.  */
if|if
condition|(
name|apply_bitpos
condition|)
block|{
name|offset
operator|=
name|plus_constant
argument_list|(
name|offset
argument_list|,
operator|-
operator|(
name|apply_bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|size
operator|=
name|plus_constant
argument_list|(
name|size
argument_list|,
name|apply_bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ALIGN_INDIRECT_REF
condition|)
block|{
comment|/* Force EXPR and OFFSE to NULL, since we don't know exactly what 	 we're overlapping.  */
name|offset
operator|=
name|NULL
expr_stmt|;
name|expr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now set the attributes we computed above.  */
name|MEM_ATTRS
argument_list|(
name|ref
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|alias
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is already known to be a scalar or aggregate, we are done.  */
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
operator|||
name|MEM_SCALAR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return;
comment|/* If it is a reference into an aggregate, this is part of an aggregate.      Otherwise we don't know.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_mem_attributes
parameter_list|(
name|rtx
name|ref
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|objectp
parameter_list|)
block|{
name|set_mem_attributes_minus_bitpos
argument_list|(
name|ref
argument_list|,
name|t
argument_list|,
name|objectp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the decl for MEM to DECL.  */
end_comment

begin_function
name|void
name|set_mem_attrs_from_reg
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|REG_EXPR
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|REG_OFFSET
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the alias set of MEM to SET.  */
end_comment

begin_function
name|void
name|set_mem_alias_set
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|HOST_WIDE_INT
name|set
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* If the new and old alias sets don't conflict, something is wrong.  */
name|gcc_assert
argument_list|(
name|alias_sets_conflict_p
argument_list|(
name|set
argument_list|,
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|set
argument_list|,
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the alignment of MEM to ALIGN bits.  */
end_comment

begin_function
name|void
name|set_mem_align
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|align
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the expr for MEM to EXPR.  */
end_comment

begin_function
name|void
name|set_mem_expr
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|expr
argument_list|,
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the offset of MEM to OFFSET.  */
end_comment

begin_function
name|void
name|set_mem_offset
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|offset
parameter_list|)
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|offset
argument_list|,
name|MEM_SIZE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the size of MEM to SIZE.  */
end_comment

begin_function
name|void
name|set_mem_size
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|size
parameter_list|)
block|{
name|MEM_ATTRS
argument_list|(
name|mem
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|,
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|,
name|size
argument_list|,
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed to MODE    and its address changed to ADDR.  (VOIDmode means don't change the mode.    NULL for ADDR means don't change the address.)  VALIDATE is nonzero if the    returned memory location is required to be valid.  The memory    attributes are not changed.  */
end_comment

begin_function
specifier|static
name|rtx
name|change_address_1
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|int
name|validate
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|memref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
operator|&&
name|addr
operator|==
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|!
name|validate
operator|||
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
return|return
name|memref
return|;
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|gcc_assert
argument_list|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|addr
argument_list|,
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
return|return
name|memref
return|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|memref
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Like change_address_1 with VALIDATE nonzero, but we are not saying in what    way we are changing MEMREF, so we only preserve the alias set.  */
end_comment

begin_function
name|rtx
name|change_address
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|new
init|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|,
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mmode
init|=
name|GET_MODE
argument_list|(
name|new
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|size
operator|=
name|mmode
operator|==
name|BLKmode
condition|?
literal|0
else|:
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mmode
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|mmode
operator|==
name|BLKmode
condition|?
name|BITS_PER_UNIT
else|:
name|GET_MODE_ALIGNMENT
argument_list|(
name|mmode
argument_list|)
expr_stmt|;
comment|/* If there are no changes, just return the original memory reference.  */
if|if
condition|(
name|new
operator|==
name|memref
condition|)
block|{
if|if
condition|(
name|MEM_ATTRS
argument_list|(
name|memref
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|MEM_EXPR
argument_list|(
name|memref
argument_list|)
operator|==
name|NULL
operator|&&
name|MEM_OFFSET
argument_list|(
name|memref
argument_list|)
operator|==
name|NULL
operator|&&
name|MEM_SIZE
argument_list|(
name|memref
argument_list|)
operator|==
name|size
operator|&&
name|MEM_ALIGN
argument_list|(
name|memref
argument_list|)
operator|==
name|align
operator|)
condition|)
return|return
name|new
return|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|mmode
argument_list|,
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|memref
argument_list|)
expr_stmt|;
block|}
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|memref
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|mmode
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed    to MODE and its address offset by OFFSET bytes.  If VALIDATE is    nonzero, the memory address is forced to be valid.    If ADJUST is zero, OFFSET is only used to update MEM_ATTRS    and caller is responsible for adjusting MEMREF base register.  */
end_comment

begin_function
name|rtx
name|adjust_address_1
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|int
name|validate
parameter_list|,
name|int
name|adjust
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|rtx
name|memoffset
init|=
name|MEM_OFFSET
argument_list|(
name|memref
argument_list|)
decl_stmt|;
name|rtx
name|size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|memalign
init|=
name|MEM_ALIGN
argument_list|(
name|memref
argument_list|)
decl_stmt|;
comment|/* If there are no changes, just return the original memory reference.  */
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
operator|&&
operator|!
name|offset
operator|&&
operator|(
operator|!
name|validate
operator|||
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
return|return
name|memref
return|;
comment|/* ??? Prefer to create garbage instead of creating shared rtl.      This may happen even if offset is nonzero -- consider      (plus (plus reg reg) const_int) -- so do this always.  */
name|addr
operator|=
name|copy_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust
condition|)
block|{
comment|/* If MEMREF is a LO_SUM and the offset is within the alignment of the 	 object, we can merge it into the LO_SUM.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|offset
operator|>=
literal|0
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
condition|)
name|addr
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|,
name|validate
argument_list|)
expr_stmt|;
comment|/* Compute the new values of the memory attributes due to this adjustment.      We add the offsets and update the alignment.  */
if|if
condition|(
name|memoffset
condition|)
name|memoffset
operator|=
name|GEN_INT
argument_list|(
name|offset
operator|+
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the new alignment by taking the MIN of the alignment and the      lowest-order set bit in OFFSET, but don't change the alignment if OFFSET      if zero.  */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|memalign
operator|=
name|MIN
argument_list|(
name|memalign
argument_list|,
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|offset
operator|&
operator|-
name|offset
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* We can compute the size in a number of ways.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|BLKmode
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_SIZE
argument_list|(
name|memref
argument_list|)
condition|)
name|size
operator|=
name|plus_constant
argument_list|(
name|MEM_SIZE
argument_list|(
name|memref
argument_list|)
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|memref
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|memref
argument_list|)
argument_list|,
name|memoffset
argument_list|,
name|size
argument_list|,
name|memalign
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At some point, we should validate that this offset is within the object,      if all the appropriate values are known.  */
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed    to MODE and its address changed to ADDR, which is assumed to be    MEMREF offseted by OFFSET bytes.  If VALIDATE is    nonzero, the memory address is forced to be valid.  */
end_comment

begin_function
name|rtx
name|adjust_automodify_address_1
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|int
name|validate
parameter_list|)
block|{
name|memref
operator|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|,
name|validate
argument_list|)
expr_stmt|;
return|return
name|adjust_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|,
name|validate
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but whose address is changed by    adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor    known to be in OFFSET (possibly 1).  */
end_comment

begin_function
name|rtx
name|offset_address
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|rtx
name|offset
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|pow2
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|,
name|addr
init|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|new
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* At this point we don't know _why_ the address is invalid.  It      could have secondary memory references, multiplies or anything.       However, if we did go and rearrange things, we can wind up not      being able to recognize the magic around pic_offset_table_rtx.      This stuff is fragile, and is yet another example of why it is      bad to expose PIC machinery too early.  */
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|,
name|new
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
block|{
name|addr
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If there are no changes, just return the original memory reference.  */
if|if
condition|(
name|new
operator|==
name|memref
condition|)
return|return
name|new
return|;
comment|/* Update the alignment to reflect the offset.  Reset the offset, which      we don't know.  */
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|memref
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|memref
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|memref
argument_list|)
argument_list|,
name|pow2
operator|*
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its address changed to    ADDR.  The caller is asserting that the actual piece of memory pointed    to is the same, just the form of the address is being changed, such as    by putting something into a register.  */
end_comment

begin_function
name|rtx
name|replace_equiv_address
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
comment|/* change_address_1 copies the memory attribute structure without change      and that's exactly what we want here.  */
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but the reference is not required to be valid.  */
end_comment

begin_function
name|rtx
name|replace_equiv_address_nv
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
return|return
name|change_address_1
argument_list|(
name|memref
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode widened to    MODE and offset by OFFSET.  This would be used by targets that e.g.    cannot issue QImode memory operations and have to use SImode memory    operations plus masking logic.  */
end_comment

begin_function
name|rtx
name|widen_memory_access
parameter_list|(
name|rtx
name|memref
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|rtx
name|new
init|=
name|adjust_address_1
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|expr
init|=
name|MEM_EXPR
argument_list|(
name|new
argument_list|)
decl_stmt|;
name|rtx
name|memoffset
init|=
name|MEM_OFFSET
argument_list|(
name|new
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* If there are no changes, just return the original memory reference.  */
if|if
condition|(
name|new
operator|==
name|memref
condition|)
return|return
name|new
return|;
comment|/* If we don't know what offset we were at within the expression, then      we can't know if we've overstepped the bounds.  */
if|if
condition|(
operator|!
name|memoffset
condition|)
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|expr
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|component_ref_field_offset
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
comment|/* Is the field at least as large as the access?  If so, ok, 	     otherwise strip back to the containing structure.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
name|size
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memoffset
operator|=
operator|(
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
operator|+
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Similarly for the decl.  */
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|DECL_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|size
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|memoffset
operator|||
name|INTVAL
argument_list|(
name|memoffset
argument_list|)
operator|>=
literal|0
operator|)
condition|)
break|break;
else|else
block|{
comment|/* The widened memory access overflows the expression, which means 	     that it could alias another expression.  Zap it.  */
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|expr
condition|)
name|memoffset
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* The widened memory may alias other stuff, so zap the alias set.  */
comment|/* ??? Maybe use get_alias_set on any remaining expression.  */
name|MEM_ATTRS
argument_list|(
name|new
argument_list|)
operator|=
name|get_mem_attrs
argument_list|(
literal|0
argument_list|,
name|expr
argument_list|,
name|memoffset
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|new
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly created CODE_LABEL rtx with a unique label number.  */
end_comment

begin_function
name|rtx
name|gen_label_rtx
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gen_rtx_CODE_LABEL
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
argument_list|\
name|NULL
argument_list|,
name|label_num
operator|++
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\ }
end_function

begin_escape
end_escape

begin_comment
comment|/* For procedure integration.  */
end_comment

begin_comment
comment|/* Install new pointers to the first and last insns in the chain.    Also, set cur_insn_uid to one higher than the last in use.    Used for an inline-procedure after copying the insn chain.  */
end_comment

begin_function
name|void
name|set_new_first_and_last_insn
parameter_list|(
name|rtx
name|first
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
name|cur_insn_uid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|cur_insn_uid
operator|=
name|MAX
argument_list|(
name|cur_insn_uid
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|cur_insn_uid
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared    structure.  This routine should only be called once.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_all_rtl_1
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Make sure that virtual parameters are not shared.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|copy_rtx_if_shared
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that virtual stack slots are not shared.  */
name|unshare_all_decls
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unshare just about everything else.  */
name|unshare_all_rtl_in_chain
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Make sure the addresses of stack slots found outside the insn chain      (such as, in DECL_RTL of a variable) are not shared      with the insn chain.       This special care is necessary when the stack slot MEM does not      actually appear in the insn chain.  If it does appear, its address      is unshared from all else at that point.  */
name|stack_slot_list
operator|=
name|copy_rtx_if_shared
argument_list|(
name|stack_slot_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared    structure, again.  This is a fairly expensive thing to do so it    should be done sparingly.  */
end_comment

begin_function
name|void
name|unshare_all_rtl_again
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|p
operator|=
name|insn
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|reset_used_flags
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|LOG_LINKS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that virtual stack slots are not shared.  */
name|reset_used_decls
argument_list|(
name|DECL_INITIAL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that virtual parameters are not shared.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|reset_used_flags
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|stack_slot_list
argument_list|)
expr_stmt|;
name|unshare_all_rtl_1
argument_list|(
name|cfun
operator|->
name|decl
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|unshare_all_rtl
parameter_list|(
name|void
parameter_list|)
block|{
name|unshare_all_rtl_1
argument_list|(
name|current_function_decl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_unshare_all_rtl
init|=
block|{
literal|"unshare"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|unshare_all_rtl
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check that ORIG is not marked when it should not be and mark ORIG as in use,    Recursively does the same for subexpressions.  */
end_comment

begin_function
specifier|static
name|void
name|verify_rtx_sharing
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|orig
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
return|return;
comment|/* SCRATCH must be shared because they represent distinct values.  */
case|case
name|CLOBBER
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
break|break;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return;
break|break;
case|case
name|MEM
case|:
comment|/* A MEM is allowed to be shared if its address is constant.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|reload_completed
operator|||
name|reload_in_progress
condition|)
return|return;
break|break;
default|default:
break|break;
block|}
comment|/* This rtx may not be shared.  If it has already been seen,      replace it with a copy of itself.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|x
argument_list|,
name|used
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid rtl sharing found in the insn"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"shared rtx"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"internal consistency failure"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|gcc_assert
argument_list|(
operator|!
name|RTX_FLAG
argument_list|(
name|x
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FLAG
argument_list|(
name|x
argument_list|,
name|used
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now scan the subexpressions recursively.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|verify_rtx_sharing
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
comment|/* We allow sharing of ASM_OPERANDS inside single 		     instruction.  */
if|if
condition|(
name|j
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|)
condition|)
name|verify_rtx_sharing
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|verify_rtx_sharing
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Go through all the RTL insn bodies and check that there is no unexpected    sharing in between the subexpressions.  */
end_comment

begin_function
name|void
name|verify_rtl_sharing
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|get_insns
argument_list|()
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|reset_used_flags
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|LOG_LINKS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|get_insns
argument_list|()
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|verify_rtx_sharing
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|verify_rtx_sharing
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|verify_rtx_sharing
argument_list|(
name|LOG_LINKS
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared structure.    Assumes the mark bits are cleared at entry.  */
end_comment

begin_function
name|void
name|unshare_all_rtl_in_chain
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Go through all virtual stack slots of a function and copy any    shared structure.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_all_decls
parameter_list|(
name|tree
name|blk
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Copy shared decls.  */
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|t
argument_list|,
name|copy_rtx_if_shared
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now process sub-blocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|unshare_all_decls
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through all virtual stack slots of a function and mark them as    not shared.  */
end_comment

begin_function
specifier|static
name|void
name|reset_used_decls
parameter_list|(
name|tree
name|blk
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Mark decls.  */
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|reset_used_flags
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now process sub-blocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|blk
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|reset_used_decls
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark ORIG as in use, and return a copy of it if it was already in use.    Recursively does the same for subexpressions.  Uses    copy_rtx_if_shared_1 to reduce stack space.  */
end_comment

begin_function
name|rtx
name|copy_rtx_if_shared
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
name|copy_rtx_if_shared_1
argument_list|(
operator|&
name|orig
argument_list|)
expr_stmt|;
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Mark *ORIG1 as in use, and set it to a copy of it if it was already in    use.  Recursively does the same for subexpressions.  */
end_comment

begin_function
specifier|static
name|void
name|copy_rtx_if_shared_1
parameter_list|(
name|rtx
modifier|*
name|orig1
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|last_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
name|x
operator|=
operator|*
name|orig1
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
comment|/* SCRATCH must be shared because they represent distinct values.  */
return|return;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
break|break;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return;
break|break;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return;
default|default:
break|break;
block|}
comment|/* This rtx may not be shared.  If it has already been seen,      replace it with a copy of itself.  */
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|x
argument_list|,
name|used
argument_list|)
condition|)
block|{
name|x
operator|=
name|shallow_copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|RTX_FLAG
argument_list|(
name|x
argument_list|,
name|used
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now scan the subexpressions recursively.      We can store any replaced subexpressions directly into X      since we know X is not shared!  Any vectors in X      must be copied if X was copied.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|last_ptr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|last_ptr
condition|)
name|copy_rtx_if_shared_1
argument_list|(
name|last_ptr
argument_list|)
expr_stmt|;
name|last_ptr
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Copy the vector iff I copied the rtx and the length 		 is nonzero.  */
if|if
condition|(
name|copied
operator|&&
name|len
operator|>
literal|0
condition|)
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtvec_v
argument_list|(
name|len
argument_list|,
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|->
name|elem
argument_list|)
expr_stmt|;
comment|/* Call recursively on all inside the vector.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|last_ptr
condition|)
name|copy_rtx_if_shared_1
argument_list|(
name|last_ptr
argument_list|)
expr_stmt|;
name|last_ptr
operator|=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
operator|*
name|orig1
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|last_ptr
condition|)
block|{
name|orig1
operator|=
name|last_ptr
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Clear all the USED bits in X to allow copy_rtx_if_shared to be used    to look for shared sub-parts.  */
end_comment

begin_function
name|void
name|reset_used_flags
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared so we needn't do any resetting      for them.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return;
default|default:
break|break;
block|}
name|RTX_FLAG
argument_list|(
name|x
argument_list|,
name|used
argument_list|)
operator|=
literal|0
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|i
operator|==
name|length
operator|-
literal|1
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|reset_used_flags
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|reset_used_flags
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set all the USED bits in X to allow copy_rtx_if_shared to be used    to look for shared sub-parts.  */
end_comment

begin_function
name|void
name|set_used_flags
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared so we needn't do any resetting      for them.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return;
default|default:
break|break;
block|}
name|RTX_FLAG
argument_list|(
name|x
argument_list|,
name|used
argument_list|)
operator|=
literal|1
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|set_used_flags
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|set_used_flags
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy X if necessary so that it won't be altered by changes in OTHER.    Return X or the rtx for the pseudo reg the value of X was copied into.    OTHER must be valid as a SET_DEST.  */
end_comment

begin_function
name|rtx
name|make_safe_from
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|other
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
name|other
operator|=
name|SUBREG_REG
argument_list|(
name|other
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRICT_LOW_PART
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|other
operator|=
name|XEXP
argument_list|(
name|other
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|MEM_P
argument_list|(
name|other
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|other
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|other
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_mentioned_p
argument_list|(
name|other
argument_list|,
name|x
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emission of insns (adding them to the doubly-linked list).  */
end_comment

begin_comment
comment|/* Return the first insn of the current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_insns
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|first_insn
return|;
block|}
end_function

begin_comment
comment|/* Specify a new insn as the first in the chain.  */
end_comment

begin_function
name|void
name|set_first_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|first_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the last insn emitted in current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_last_insn
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Specify a new insn as the last in the chain.  */
end_comment

begin_function
name|void
name|set_last_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the last insn emitted, even if it is in a sequence now pushed.  */
end_comment

begin_function
name|rtx
name|get_last_insn_anywhere
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|;
if|if
condition|(
name|last_insn
condition|)
return|return
name|last_insn
return|;
for|for
control|(
name|stack
operator|=
name|seq_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|stack
operator|->
name|last
operator|!=
literal|0
condition|)
return|return
name|stack
operator|->
name|last
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the first nonnote insn emitted in current sequence or current    function.  This routine looks inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|get_first_nonnote_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|first_insn
decl_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|insn
operator|=
name|next_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|next_insn
argument_list|(
name|insn
argument_list|)
control|)
continue|continue;
else|else
block|{
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last nonnote insn emitted in current sequence or current    function.  This routine looks inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|get_last_nonnote_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|last_insn
decl_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|insn
operator|=
name|previous_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|previous_insn
argument_list|(
name|insn
argument_list|)
control|)
continue|continue;
else|else
block|{
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return a number larger than any instruction's uid in this function.  */
end_comment

begin_function
name|int
name|get_max_uid
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cur_insn_uid
return|;
block|}
end_function

begin_comment
comment|/* Renumber instructions so that no instruction UIDs are wasted.  */
end_comment

begin_function
name|void
name|renumber_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* If we're not supposed to renumber instructions, don't.  */
if|if
condition|(
operator|!
name|flag_renumber_insns
condition|)
return|return;
comment|/* If there aren't that many instructions, then it's not really      worth renumbering them.  */
if|if
condition|(
name|flag_renumber_insns
operator|==
literal|1
operator|&&
name|get_max_uid
argument_list|()
operator|<
literal|25000
condition|)
return|return;
name|cur_insn_uid
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Renumbering insn %d to %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|cur_insn_uid
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the next insn.  If it is a SEQUENCE, return the first insn    of the sequence.  */
end_comment

begin_function
name|rtx
name|next_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the previous insn.  If it is a SEQUENCE, return the last insn    of the sequence.  */
end_comment

begin_function
name|rtx
name|previous_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next insn after INSN that is not a NOTE.  This routine does not    look inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|next_nonnote_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the previous insn before INSN that is not a NOTE.  This routine does    not look inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|prev_nonnote_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;    or 0, if there is none.  This routine does not look inside    SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|next_real_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last INSN, CALL_INSN or JUMP_INSN before INSN;    or 0, if there is none.  This routine does not look inside    SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|prev_real_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last CALL_INSN in the current list, or 0 if there is none.    This routine does not look inside SEQUENCEs.  */
end_comment

begin_function
name|rtx
name|last_call_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
operator|&&
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Find the next insn after INSN that really does something.  This routine    does not look inside SEQUENCEs.  Until reload has completed, this is the    same as next_real_insn.  */
end_comment

begin_function
name|int
name|active_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|rtx
name|next_active_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Find the last insn before INSN that really does something.  This routine    does not look inside SEQUENCEs.  Until reload has completed, this is the    same as prev_real_insn.  */
end_comment

begin_function
name|rtx
name|prev_active_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next CODE_LABEL after the insn INSN, or 0 if there is none.  */
end_comment

begin_function
name|rtx
name|next_label
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last CODE_LABEL before the insn INSN, or 0 if there is none.  */
end_comment

begin_function
name|rtx
name|prev_label
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last label to mark the same position as LABEL.  Return null    if LABEL itself is null.  */
end_comment

begin_function
name|rtx
name|skip_consecutive_labels
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|label
init|;
name|insn
operator|!=
literal|0
operator|&&
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|label
operator|=
name|insn
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER    and REG_CC_USER notes so we can find it.  */
end_comment

begin_function
name|void
name|link_cc0_insns
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|user
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|user
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|user
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|user
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|user
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|user
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_CC_SETTER
argument_list|,
name|insn
argument_list|,
name|REG_NOTES
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_CC_USER
argument_list|,
name|user
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the next insn that uses CC0 after INSN, which is assumed to    set it.  This is the inverse of prev_cc0_setter (i.e., prev_cc0_setter    applied to the result of this function should yield INSN).     Normally, this is simply the next insn.  However, if a REG_CC_USER note    is present, it contains the insn that uses CC0.     Return 0 if we can't find the insn.  */
end_comment

begin_function
name|rtx
name|next_cc0_user
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_USER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
return|return
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
return|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|insn
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the insn that set CC0 for INSN.  Unless INSN has a REG_CC_SETTER    note, it is the previous insn.  */
end_comment

begin_function
name|rtx
name|prev_cc0_setter
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
return|return
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
return|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Increment the label uses for all labels present in rtx.  */
end_comment

begin_function
specifier|static
name|void
name|mark_label_nuses
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
operator|&&
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_label_nuses
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|mark_label_nuses
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try splitting insns that can be split for better scheduling.    PAT is the pattern which might split.    TRIAL is the insn providing PAT.    LAST is nonzero if we should return the last insn of the sequence produced.     If this routine succeeds in splitting, it returns the first or last    replacement insn depending on the value of LAST.  Otherwise, it    returns TRIAL.  If the insn to be returned can be split, it will be.  */
end_comment

begin_function
name|rtx
name|try_split
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|rtx
name|trial
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|rtx
name|before
init|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|after
init|=
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|int
name|has_barrier
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|probability
decl_stmt|;
name|rtx
name|insn_last
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|njumps
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|any_condjump_p
argument_list|(
name|trial
argument_list|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|trial
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|split_branch_probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|probability
operator|=
name|split_branch_probability
expr_stmt|;
name|seq
operator|=
name|split_insns
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|split_branch_probability
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we are splitting a JUMP_INSN, it might be followed by a BARRIER.      We may need to handle this specially.  */
if|if
condition|(
name|after
operator|&&
name|BARRIER_P
argument_list|(
name|after
argument_list|)
condition|)
block|{
name|has_barrier
operator|=
literal|1
expr_stmt|;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|trial
return|;
comment|/* Avoid infinite loop if any insn of the result matches      the original pattern.  */
name|insn_last
operator|=
name|seq
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn_last
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|insn_last
argument_list|)
argument_list|,
name|pat
argument_list|)
condition|)
return|return
name|trial
return|;
if|if
condition|(
operator|!
name|NEXT_INSN
argument_list|(
name|insn_last
argument_list|)
condition|)
break|break;
name|insn_last
operator|=
name|NEXT_INSN
argument_list|(
name|insn_last
argument_list|)
expr_stmt|;
block|}
comment|/* Mark labels.  */
for|for
control|(
name|insn
operator|=
name|insn_last
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|njumps
operator|++
expr_stmt|;
if|if
condition|(
name|probability
operator|!=
operator|-
literal|1
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We can preserve the REG_BR_PROB notes only if exactly 		 one jump is created, otherwise the machine description 		 is responsible for this step using 		 split_branch_probability variable.  */
name|gcc_assert
argument_list|(
name|njumps
operator|==
literal|1
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we are splitting a CALL_INSN, look for the CALL_INSN      in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|trial
argument_list|)
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|insn_last
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|p
init|=
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
name|SIBLING_CALL_P
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy notes, particularly those related to the CFG.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|trial
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_EH_REGION
case|:
name|insn
operator|=
name|insn_last
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_NORETURN
case|:
case|case
name|REG_SETJMP
case|:
name|insn
operator|=
name|insn_last
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_NON_LOCAL_GOTO
case|:
name|insn
operator|=
name|insn_last
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If there are LABELS inside the split insns increment the      usage count so we don't delete the label.  */
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|trial
argument_list|)
condition|)
block|{
name|insn
operator|=
name|insn_last
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mark_label_nuses
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|tem
operator|=
name|emit_insn_after_setloc
argument_list|(
name|seq
argument_list|,
name|trial
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|trial
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_barrier
condition|)
name|emit_barrier_after
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Recursively call try_split for each new insn created; by the      time control returns here that insn will be fully split, so      set LAST and continue from the insn after the one returned.      We can't use next_active_insn here since AFTER may be a note.      Ignore deleted insns, which can be occur if not optimizing.  */
for|for
control|(
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|before
argument_list|)
init|;
name|tem
operator|!=
name|after
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|tem
argument_list|)
operator|&&
name|INSN_P
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Return either the first or the last insn, depending on which was      requested.  */
return|return
name|last
condition|?
operator|(
name|after
condition|?
name|PREV_INSN
argument_list|(
name|after
argument_list|)
else|:
name|last_insn
operator|)
else|:
name|NEXT_INSN
argument_list|(
name|before
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make and return an INSN rtx, initializing all its slots.    Store PATTERN in the pattern slots.  */
end_comment

begin_function
name|rtx
name|make_insn_raw
parameter_list|(
name|rtx
name|pattern
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
if|if
condition|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|returnjump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|insn
argument_list|)
operator|==
name|pc_rtx
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ICE: emit_insn used where emit_jump_insn needed:\n"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like `make_insn_raw' but make a JUMP_INSN instead of an insn.  */
end_comment

begin_function
name|rtx
name|make_jump_insn_raw
parameter_list|(
name|rtx
name|pattern
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|JUMP_INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like `make_insn_raw' but make a CALL_INSN instead of an insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_call_insn_raw
parameter_list|(
name|rtx
name|pattern
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|CALL_INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add INSN to the end of the doubly-linked list.    INSN may be an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER or NOTE.  */
end_comment

begin_function
name|void
name|add_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last_insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|last_insn
condition|)
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|first_insn
condition|)
name|first_insn
operator|=
name|insn
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN into the doubly-linked list after insn AFTER.  This and    the next should be the only functions called to insert an insn once    delay slots have been filled since only they know how to update a    SEQUENCE.  */
end_comment

begin_function
name|void
name|add_insn_after
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|optimize
operator|||
operator|!
name|INSN_DELETED_P
argument_list|(
name|after
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_insn
operator|==
name|after
condition|)
name|last_insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|after
operator|==
name|stack
operator|->
name|last
condition|)
block|{
name|stack
operator|->
name|last
operator|=
name|insn
expr_stmt|;
break|break;
block|}
name|gcc_assert
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|after
argument_list|)
operator|&&
operator|!
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|after
argument_list|)
operator|)
condition|)
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
comment|/* Should not happen as first in the BB is always 	 either NOTE or LABEL.  */
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|after
comment|/* Avoid clobbering of structure when creating new BB.  */
operator|&&
operator|!
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|after
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add INSN into the doubly-linked list before insn BEFORE.  This and    the previous should be the only functions called to insert an insn once    delay slots have been filled since only they know how to update a    SEQUENCE.  */
end_comment

begin_function
name|void
name|add_insn_before
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|optimize
operator|||
operator|!
name|INSN_DELETED_P
argument_list|(
name|before
argument_list|)
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|prev
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_insn
operator|==
name|before
condition|)
name|first_insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|before
operator|==
name|stack
operator|->
name|first
condition|)
block|{
name|stack
operator|->
name|first
operator|=
name|insn
expr_stmt|;
break|break;
block|}
name|gcc_assert
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|before
argument_list|)
operator|&&
operator|!
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|before
argument_list|)
operator|)
condition|)
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
comment|/* Should not happen as first in the BB is always either NOTE or 	 LABEL.  */
name|gcc_assert
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|!=
name|insn
comment|/* Avoid clobbering of structure when creating new BB.  */
operator|||
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
argument_list|)
expr_stmt|;
block|}
name|PREV_INSN
argument_list|(
name|before
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|before
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove an insn from its doubly-linked list.  This function knows how    to handle sequences.  */
end_comment

begin_function
name|void
name|remove_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|prev
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|sequence
init|=
name|PATTERN
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_insn
operator|==
name|insn
condition|)
name|first_insn
operator|=
name|next
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|insn
operator|==
name|stack
operator|->
name|first
condition|)
block|{
name|stack
operator|->
name|first
operator|=
name|next
expr_stmt|;
break|break;
block|}
name|gcc_assert
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
block|{
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_insn
operator|==
name|insn
condition|)
name|last_insn
operator|=
name|prev
expr_stmt|;
else|else
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
if|if
condition|(
name|insn
operator|==
name|stack
operator|->
name|last
condition|)
block|{
name|stack
operator|->
name|last
operator|=
name|prev
expr_stmt|;
break|break;
block|}
name|gcc_assert
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
if|if
condition|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
block|{
comment|/* Never ever delete the basic block note without deleting whole 	     basic block.  */
name|gcc_assert
argument_list|(
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append CALL_FUSAGE to the CALL_INSN_FUNCTION_USAGE for CALL_INSN.  */
end_comment

begin_function
name|void
name|add_function_usage_to
parameter_list|(
name|rtx
name|call_insn
parameter_list|,
name|rtx
name|call_fusage
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|call_insn
operator|&&
name|CALL_P
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the register usage information on the CALL.  If there is already      some usage information, put ours at the end.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
empty_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
block|}
else|else
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all insns made since FROM.    FROM becomes the new last instruction.  */
end_comment

begin_function
name|void
name|delete_insns_since
parameter_list|(
name|rtx
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
literal|0
condition|)
name|first_insn
operator|=
literal|0
expr_stmt|;
else|else
name|NEXT_INSN
argument_list|(
name|from
argument_list|)
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
name|from
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is deprecated, please use sequences instead.     Move a consecutive bunch of insns to a different place in the chain.    The insns to be moved are those between FROM and TO.    They are moved to a new position after the insn AFTER.    AFTER must not be FROM or TO or any insn in between.     This function does not know about SEQUENCEs and hence should not be    called after delay-slot filling has been done.  */
end_comment

begin_function
name|void
name|reorder_insns_nobb
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
comment|/* Splice this bunch out of where it is now.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_insn
operator|==
name|to
condition|)
name|last_insn
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_insn
operator|==
name|from
condition|)
name|first_insn
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Make the new neighbors point to it and it to them.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|=
name|to
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|from
argument_list|)
operator|=
name|after
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last_insn
condition|)
name|last_insn
operator|=
name|to
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as function above, but take care to update BB boundaries.  */
end_comment

begin_function
name|void
name|reorder_insns
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|bb2
decl_stmt|;
name|reorder_insns_nobb
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|after
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|after
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|x
decl_stmt|;
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|(
name|bb2
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
operator|==
name|to
condition|)
name|BB_END
argument_list|(
name|bb2
argument_list|)
operator|=
name|prev
expr_stmt|;
name|bb2
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
block|}
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|after
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|to
expr_stmt|;
for|for
control|(
name|x
operator|=
name|from
init|;
name|x
operator|!=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|x
argument_list|)
condition|)
name|set_block_for_insn
argument_list|(
name|x
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the line note insn preceding INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_line_note
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|no_line_numbers
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
break|break;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insn(s) of given code and pattern    at a specified place within the doubly-linked list.     All of the emit_foo global entry points accept an object    X which is either an insn list or a PATTERN of a single    instruction.     There are thus a few canonical ways to generate code and    emit it at a specific place in the instruction stream.  For    example, consider the instruction named SPOT and the fact that    we would like to emit some instructions before SPOT.  We might    do it like this:  	start_sequence (); 	... emit the new instructions ... 	insns_head = get_insns (); 	end_sequence ();  	emit_insn_before (insns_head, SPOT);     It used to be common to generate SEQUENCE rtl instead, but that    is a relic of the past which no longer occurs.  The reason is that    SEQUENCE rtl results in much fragmented RTL memory since the SEQUENCE    generated would almost certainly die right after it was created.  */
end_comment

begin_comment
comment|/* Make X be output before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_insn_before_noloc
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
name|rtx
name|last
init|=
name|before
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|gcc_assert
argument_list|(
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
name|last
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|insn
operator|=
name|x
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|last
argument_list|,
name|before
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body X and code JUMP_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_before_noloc
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|last
init|=
name|NULL_RTX
decl_stmt|;
name|gcc_assert
argument_list|(
name|before
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|insn
operator|=
name|x
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_jump_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|last
argument_list|,
name|before
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body X and code CALL_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_before_noloc
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
name|rtx
name|last
init|=
name|NULL_RTX
decl_stmt|,
name|insn
decl_stmt|;
name|gcc_assert
argument_list|(
name|before
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|insn
operator|=
name|x
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_call_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn_before
argument_list|(
name|last
argument_list|,
name|before
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and output it before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_barrier_before
parameter_list|(
name|rtx
name|before
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the label LABEL before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_label_before
parameter_list|(
name|rtx
name|label
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
comment|/* This can be called twice for the same label as a result of the      confusion that follows a syntax error!  So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_before
argument_list|(
name|label
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Emit a note of subtype SUBTYPE before the insn BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_note_before
parameter_list|(
name|int
name|subtype
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MAPPED_LOCATION
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_insn_before
argument_list|(
name|note
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper for emit_insn_after, handles lists of instructions    efficiently.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|emit_insn_after_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|rtx
name|emit_insn_after_1
parameter_list|(
name|rtx
name|first
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|last
decl_stmt|;
name|rtx
name|after_after
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|after
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|after
argument_list|)
operator|)
condition|)
block|{
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|last
argument_list|)
condition|)
name|set_block_for_insn
argument_list|(
name|last
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|last
argument_list|)
condition|)
name|set_block_for_insn
argument_list|(
name|last
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|after
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|last
expr_stmt|;
block|}
else|else
for|for
control|(
name|last
operator|=
name|first
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
continue|continue;
name|after_after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|first
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first
argument_list|)
operator|=
name|after
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|after_after
expr_stmt|;
if|if
condition|(
name|after_after
condition|)
name|PREV_INSN
argument_list|(
name|after_after
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last_insn
condition|)
name|last_insn
operator|=
name|last
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make X be output after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_insn_after_noloc
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|last
init|=
name|after
decl_stmt|;
name|gcc_assert
argument_list|(
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
name|last
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|last
operator|=
name|emit_insn_after_1
argument_list|(
name|x
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|last
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Similar to emit_insn_after, except that line notes are to be inserted so    as to act as if this insn were at FROM.  */
end_comment

begin_function
name|void
name|emit_insn_after_with_line_notes
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|after
parameter_list|,
name|rtx
name|from
parameter_list|)
block|{
name|rtx
name|from_line
init|=
name|find_line_note
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|rtx
name|after_line
init|=
name|find_line_note
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|emit_insn_after
argument_list|(
name|x
argument_list|,
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|from_line
condition|)
name|emit_note_copy_after
argument_list|(
name|from_line
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_line
condition|)
name|emit_note_copy_after
argument_list|(
name|after_line
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with body X    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_after_noloc
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|last
decl_stmt|;
name|gcc_assert
argument_list|(
name|after
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|last
operator|=
name|emit_insn_after_1
argument_list|(
name|x
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_jump_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|last
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body X and code CALL_INSN    and output it after the instruction AFTER.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_after_noloc
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|last
decl_stmt|;
name|gcc_assert
argument_list|(
name|after
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|last
operator|=
name|emit_insn_after_1
argument_list|(
name|x
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_call_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|last
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_barrier_after
parameter_list|(
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the label LABEL after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_label_after
parameter_list|(
name|rtx
name|label
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|label
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Emit a note of subtype SUBTYPE after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_note_after
parameter_list|(
name|int
name|subtype
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MAPPED_LOCATION
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Emit a copy of note ORIG after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_note_copy_after
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|orig
argument_list|)
operator|>=
literal|0
operator|&&
name|no_line_numbers
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|NOTE_DATA
argument_list|(
name|note
argument_list|)
operator|=
name|NOTE_DATA
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like emit_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */
end_comment

begin_function
name|rtx
name|emit_insn_after_setloc
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|after
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
name|rtx
name|last
init|=
name|emit_insn_after_noloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL_RTX
operator|||
operator|!
name|loc
condition|)
return|return
name|last
return|;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|after
argument_list|)
operator|&&
operator|!
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
operator|=
name|loc
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last
condition|)
break|break;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Like emit_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */
end_comment

begin_function
name|rtx
name|emit_insn_after
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|after
argument_list|)
condition|)
return|return
name|emit_insn_after_setloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
argument_list|)
return|;
else|else
return|return
name|emit_insn_after_noloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like emit_jump_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_after_setloc
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|after
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
name|rtx
name|last
init|=
name|emit_jump_insn_after_noloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL_RTX
operator|||
operator|!
name|loc
condition|)
return|return
name|last
return|;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|after
argument_list|)
operator|&&
operator|!
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
operator|=
name|loc
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last
condition|)
break|break;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Like emit_jump_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_after
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|after
argument_list|)
condition|)
return|return
name|emit_jump_insn_after_setloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
argument_list|)
return|;
else|else
return|return
name|emit_jump_insn_after_noloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like emit_call_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_after_setloc
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|after
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
name|rtx
name|last
init|=
name|emit_call_insn_after_noloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL_RTX
operator|||
operator|!
name|loc
condition|)
return|return
name|last
return|;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|after
argument_list|)
operator|&&
operator|!
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
operator|=
name|loc
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last
condition|)
break|break;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Like emit_call_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_after
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|after
argument_list|)
condition|)
return|return
name|emit_call_insn_after_setloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|after
argument_list|)
argument_list|)
return|;
else|else
return|return
name|emit_call_insn_after_noloc
argument_list|(
name|pattern
argument_list|,
name|after
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to SCOPE.  */
end_comment

begin_function
name|rtx
name|emit_insn_before_setloc
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|before
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
name|rtx
name|first
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|emit_insn_before_noloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL_RTX
operator|||
operator|!
name|loc
condition|)
return|return
name|last
return|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|first
argument_list|)
operator|&&
operator|!
name|INSN_LOCATOR
argument_list|(
name|first
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|first
argument_list|)
operator|=
name|loc
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
break|break;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_insn_before
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|before
argument_list|)
condition|)
return|return
name|emit_insn_before_setloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|before
argument_list|)
argument_list|)
return|;
else|else
return|return
name|emit_insn_before_noloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* like emit_insn_before_noloc, but set insn_locator according to scope.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_before_setloc
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|before
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
name|rtx
name|first
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|emit_jump_insn_before_noloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL_RTX
condition|)
return|return
name|last
return|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|first
argument_list|)
operator|&&
operator|!
name|INSN_LOCATOR
argument_list|(
name|first
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|first
argument_list|)
operator|=
name|loc
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
break|break;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Like emit_jump_insn_before_noloc, but set INSN_LOCATOR according to BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_before
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|before
argument_list|)
condition|)
return|return
name|emit_jump_insn_before_setloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|before
argument_list|)
argument_list|)
return|;
else|else
return|return
name|emit_jump_insn_before_noloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* like emit_insn_before_noloc, but set insn_locator according to scope.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_before_setloc
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|before
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
name|rtx
name|first
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|emit_call_insn_before_noloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL_RTX
condition|)
return|return
name|last
return|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|first
argument_list|)
operator|&&
operator|!
name|INSN_LOCATOR
argument_list|(
name|first
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|first
argument_list|)
operator|=
name|loc
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
break|break;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* like emit_call_insn_before_noloc,    but set insn_locator according to before.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_before
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|before
argument_list|)
condition|)
return|return
name|emit_call_insn_before_setloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|before
argument_list|)
argument_list|)
return|;
else|else
return|return
name|emit_call_insn_before_noloc
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take X and emit it at the end of the doubly-linked    INSN list.     Returns the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insn
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|last
init|=
name|last_insn
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
name|last
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|insn
operator|=
name|x
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with pattern X    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|last
init|=
name|NULL_RTX
decl_stmt|,
name|insn
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|insn
operator|=
name|x
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|last
operator|=
name|make_jump_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code CALL_INSN with pattern X    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_call_insn
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
name|insn
operator|=
name|emit_insn
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ENABLE_RTL_CHECKING
case|case
name|SEQUENCE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|insn
operator|=
name|make_call_insn_raw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Add the label LABEL to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_label
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_barrier
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|barrier
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|barrier
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
return|return
name|barrier
return|;
block|}
end_function

begin_comment
comment|/* Make line numbering NOTE insn for LOCATION add it to the end    of the doubly-linked list, but only if line-numbers are desired for    debugging info and it doesn't match the previous one.  */
end_comment

begin_function
name|rtx
name|emit_line_note
parameter_list|(
name|location_t
name|location
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
if|if
condition|(
name|location
operator|==
name|last_location
condition|)
return|return
name|NULL_RTX
return|;
else|#
directive|else
if|if
condition|(
name|location
operator|.
name|file
operator|&&
name|last_location
operator|.
name|file
operator|&&
operator|!
name|strcmp
argument_list|(
name|location
operator|.
name|file
argument_list|,
name|last_location
operator|.
name|file
argument_list|)
operator|&&
name|location
operator|.
name|line
operator|==
name|last_location
operator|.
name|line
condition|)
return|return
name|NULL_RTX
return|;
endif|#
directive|endif
name|last_location
operator|=
name|location
expr_stmt|;
if|if
condition|(
name|no_line_numbers
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|note
operator|=
name|emit_note
argument_list|(
operator|(
name|int
operator|)
name|location
argument_list|)
expr_stmt|;
else|#
directive|else
name|note
operator|=
name|emit_note
argument_list|(
name|location
operator|.
name|line
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|=
name|location
operator|.
name|file
expr_stmt|;
endif|#
directive|endif
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Emit a copy of note ORIG.  */
end_comment

begin_function
name|rtx
name|emit_note_copy
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|orig
argument_list|)
operator|>=
literal|0
operator|&&
name|no_line_numbers
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_DATA
argument_list|(
name|note
argument_list|)
operator|=
name|NOTE_DATA
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_insn
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code NOTE or type NOTE_NO    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_note
parameter_list|(
name|int
name|note_no
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|note_no
expr_stmt|;
name|memset
argument_list|(
operator|&
name|NOTE_DATA
argument_list|(
name|note
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|NOTE_DATA
argument_list|(
name|note
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_insn
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Cause next statement to emit a line note even if the line number    has not changed.  */
end_comment

begin_function
name|void
name|force_next_line_note
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|last_location
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|last_location
operator|.
name|line
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Place a note of KIND on insn INSN with DATUM as the datum. If a    note of this type already exists, remove it first.  */
end_comment

begin_function
name|rtx
name|set_unique_reg_note
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|reg_note
name|kind
parameter_list|,
name|rtx
name|datum
parameter_list|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|kind
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|REG_EQUAL
case|:
case|case
name|REG_EQUIV
case|:
comment|/* Don't add REG_EQUAL/REG_EQUIV notes if the insn 	 has multiple sets (some callers assume single_set 	 means the insn only has one set, when in fact it 	 means the insn only has one * useful * set).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|multiple_sets
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|note
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Don't add ASM_OPERAND REG_EQUAL/REG_EQUIV notes. 	 It serves no useful purpose and breaks eliminate_regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|datum
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|NULL_RTX
return|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|note
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|datum
expr_stmt|;
return|return
name|note
return|;
block|}
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|kind
argument_list|,
name|datum
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an indication of which type of insn should have X as a body.    The value is CODE_LABEL, INSN, CALL_INSN or JUMP_INSN.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|classify_insn
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|LABEL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|CODE_LABEL
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|JUMP_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
else|else
return|return
name|INSN
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
block|}
return|return
name|INSN
return|;
block|}
end_function

begin_comment
comment|/* Emit the rtl pattern X as an appropriate kind of insn.    If X is a label, it is simply added into the insn chain.  */
end_comment

begin_function
name|rtx
name|emit
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|classify_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CODE_LABEL
case|:
return|return
name|emit_label
argument_list|(
name|x
argument_list|)
return|;
case|case
name|INSN
case|:
return|return
name|emit_insn
argument_list|(
name|x
argument_list|)
return|;
case|case
name|JUMP_INSN
case|:
block|{
name|rtx
name|insn
init|=
name|emit_jump_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|emit_barrier
argument_list|()
return|;
return|return
name|insn
return|;
block|}
case|case
name|CALL_INSN
case|:
return|return
name|emit_call_insn
argument_list|(
name|x
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Space for free sequence stack entries.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
expr|struct
name|sequence_stack
operator|*
name|free_sequence_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Begin emitting insns to a sequence.  If this sequence will contain    something that might cause the compiler to pop arguments to function    calls (because those pops have previously been deferred; see    INHIBIT_DEFER_POP for more details), use do_pending_stack_adjust    before calling this function.  That will ensure that the deferred    pops are not accidentally emitted in the middle of this sequence.  */
end_comment

begin_function
name|void
name|start_sequence
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sequence_stack
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|free_sequence_stack
operator|!=
name|NULL
condition|)
block|{
name|tem
operator|=
name|free_sequence_stack
expr_stmt|;
name|free_sequence_stack
operator|=
name|tem
operator|->
name|next
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sequence_stack
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|->
name|next
operator|=
name|seq_stack
expr_stmt|;
name|tem
operator|->
name|first
operator|=
name|first_insn
expr_stmt|;
name|tem
operator|->
name|last
operator|=
name|last_insn
expr_stmt|;
name|seq_stack
operator|=
name|tem
expr_stmt|;
name|first_insn
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the insn chain starting with FIRST as the current sequence,    saving the previously current one.  See the documentation for    start_sequence for more information about how to use this function.  */
end_comment

begin_function
name|void
name|push_to_sequence
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|rtx
name|last
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|last
operator|&&
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
empty_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the outer-level insn chain    as the current sequence, saving the previously current one.  */
end_comment

begin_function
name|void
name|push_topmost_sequence
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|,
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|stack
operator|=
name|seq_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
name|top
operator|=
name|stack
expr_stmt|;
name|first_insn
operator|=
name|top
operator|->
name|first
expr_stmt|;
name|last_insn
operator|=
name|top
operator|->
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After emitting to the outer-level insn chain, update the outer-level    insn chain, and restore the previous saved state.  */
end_comment

begin_function
name|void
name|pop_topmost_sequence
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sequence_stack
modifier|*
name|stack
decl_stmt|,
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|stack
operator|=
name|seq_stack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
name|top
operator|=
name|stack
expr_stmt|;
name|top
operator|->
name|first
operator|=
name|first_insn
expr_stmt|;
name|top
operator|->
name|last
operator|=
name|last_insn
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After emitting to a sequence, restore previous saved state.     To get the contents of the sequence just made, you must call    `get_insns' *before* calling here.     If the compiler might have deferred popping arguments while    generating this sequence, and this sequence will not be immediately    inserted into the instruction stream, use do_pending_stack_adjust    before calling get_insns.  That will ensure that the deferred    pops are inserted into this sequence, and not into some random    location in the instruction stream.  See INHIBIT_DEFER_POP for more    information about deferred popping of arguments.  */
end_comment

begin_function
name|void
name|end_sequence
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sequence_stack
modifier|*
name|tem
init|=
name|seq_stack
decl_stmt|;
name|first_insn
operator|=
name|tem
operator|->
name|first
expr_stmt|;
name|last_insn
operator|=
name|tem
operator|->
name|last
expr_stmt|;
name|seq_stack
operator|=
name|tem
operator|->
name|next
expr_stmt|;
name|memset
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|->
name|next
operator|=
name|free_sequence_stack
expr_stmt|;
name|free_sequence_stack
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if currently emitting into a sequence.  */
end_comment

begin_function
name|int
name|in_sequence_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|seq_stack
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Put the various virtual registers into REGNO_REG_RTX.  */
end_comment

begin_function
specifier|static
name|void
name|init_virtual_regs
parameter_list|(
name|struct
name|emit_status
modifier|*
name|es
parameter_list|)
block|{
name|rtx
modifier|*
name|ptr
init|=
name|es
operator|->
name|x_regno_reg_rtx
decl_stmt|;
name|ptr
index|[
name|VIRTUAL_INCOMING_ARGS_REGNUM
index|]
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_STACK_VARS_REGNUM
index|]
operator|=
name|virtual_stack_vars_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_STACK_DYNAMIC_REGNUM
index|]
operator|=
name|virtual_stack_dynamic_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_OUTGOING_ARGS_REGNUM
index|]
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
name|ptr
index|[
name|VIRTUAL_CFA_REGNUM
index|]
operator|=
name|virtual_cfa_rtx
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used by copy_insn_1 to avoid copying SCRATCHes more than once.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|copy_insn_scratch_in
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|copy_insn_scratch_out
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|copy_insn_n_scratches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_insn_1, this is nonzero if we have    copied an ASM_OPERANDS.    In that case, it is the original input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|orig_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_insn_1, this is nonzero if we have    copied an ASM_OPERANDS.    In that case, it is the copied input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for the constraints vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|orig_asm_constraints_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_constraints_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Recursively create a new copy of an rtx for copy_insn.    This function differs from copy_rtx in that it handles SCRATCHes and    ASM_OPERANDs properly.    Normally, this function is not used directly; use copy_insn as front end.    However, you could first copy an insn pattern with copy_insn and then use    this function afterwards to properly copy any REG_NOTEs containing    SCRATCHes.  */
end_comment

begin_function
name|rtx
name|copy_insn_1
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
name|rtx
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|orig
return|;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|orig
return|;
break|break;
case|case
name|SCRATCH
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_insn_n_scratches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|copy_insn_scratch_in
index|[
name|i
index|]
operator|==
name|orig
condition|)
return|return
name|copy_insn_scratch_out
index|[
name|i
index|]
return|;
break|break;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|orig
return|;
break|break;
comment|/* A MEM with a constant address is not sharable.  The problem is that 	 the constant address may need to be reloaded.  If the mem is shared, 	 then reloading one copy of this mem will cause all copies to appear 	 to have been reloaded.  */
default|default:
break|break;
block|}
comment|/* Copy the various flags, fields, and other information.  We assume      that all fields need copying, and then clear the fields that should      not be copied.  That is the sensible default behavior, and forces      us to explicitly document why we are *not* copying a flag.  */
name|copy
operator|=
name|shallow_copy_rtx
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* We do not copy the USED flag, which is used as a mark bit during      walks over the RTL.  */
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|used
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We do not copy JUMP, CALL, or FRAME_RELATED for INSNs.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|jump
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|call
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|frame_related
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|==
name|orig_asm_constraints_vector
condition|)
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_asm_constraints_vector
expr_stmt|;
elseif|else
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|==
name|orig_asm_operands_vector
condition|)
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_asm_operands_vector
expr_stmt|;
elseif|else
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
case|case
literal|'w'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'u'
case|:
case|case
literal|'0'
case|:
comment|/* These are left unchanged.  */
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SCRATCH
condition|)
block|{
name|i
operator|=
name|copy_insn_n_scratches
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|<
name|MAX_RECOG_OPERANDS
argument_list|)
expr_stmt|;
name|copy_insn_scratch_in
index|[
name|i
index|]
operator|=
name|orig
expr_stmt|;
name|copy_insn_scratch_out
index|[
name|i
index|]
operator|=
name|copy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|orig_asm_operands_vector
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|copy_asm_operands_vector
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|orig_asm_constraints_vector
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Create a new copy of an rtx.    This function differs from copy_rtx in that it handles SCRATCHes and    ASM_OPERANDs properly.    INSN doesn't really have to be a full INSN; it could be just the    pattern.  */
end_comment

begin_function
name|rtx
name|copy_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|copy_insn_n_scratches
operator|=
literal|0
expr_stmt|;
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
name|orig_asm_constraints_vector
operator|=
literal|0
expr_stmt|;
name|copy_asm_operands_vector
operator|=
literal|0
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
literal|0
expr_stmt|;
return|return
name|copy_insn_1
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize data structures and variables in this file    before generating rtl for each function.  */
end_comment

begin_function
name|void
name|init_emit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|f
init|=
name|cfun
decl_stmt|;
name|f
operator|->
name|emit
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emit_status
argument_list|)
argument_list|)
expr_stmt|;
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|NULL
expr_stmt|;
name|cur_insn_uid
operator|=
literal|1
expr_stmt|;
name|reg_rtx_no
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
expr_stmt|;
name|last_location
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
name|first_label_num
operator|=
name|label_num
expr_stmt|;
name|seq_stack
operator|=
name|NULL
expr_stmt|;
comment|/* Init the tables that describe all the pseudo regs.  */
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|101
expr_stmt|;
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align
operator|=
name|ggc_alloc_cleared
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
name|ggc_alloc
argument_list|(
name|f
operator|->
name|emit
operator|->
name|regno_pointer_align_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put copies of all the hard registers into regno_reg_rtx.  */
name|memcpy
argument_list|(
name|regno_reg_rtx
argument_list|,
name|static_regno_reg_rtx
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put copies of all the virtual register rtx into regno_reg_rtx.  */
name|init_virtual_regs
argument_list|(
name|f
operator|->
name|emit
argument_list|)
expr_stmt|;
comment|/* Indicate that the virtual registers and stack locations are      all pointers.  */
name|REG_POINTER
argument_list|(
name|stack_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|frame_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|arg_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_stack_vars_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_POINTER
argument_list|(
name|virtual_cfa_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|REGNO_POINTER_ALIGN
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|ARG_POINTER_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_INCOMING_ARGS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_STACK_VARS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_STACK_DYNAMIC_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_OUTGOING_ARGS_REGNUM
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|REGNO_POINTER_ALIGN
argument_list|(
name|VIRTUAL_CFA_REGNUM
argument_list|)
operator|=
name|BITS_PER_WORD
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_EXPANDERS
name|INIT_EXPANDERS
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate a vector constant for mode MODE and constant value CONSTANT.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_const_vector
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|constant
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
name|rtvec
name|v
decl_stmt|;
name|int
name|units
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|inner
decl_stmt|;
name|units
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|inner
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|rtvec_alloc
argument_list|(
name|units
argument_list|)
expr_stmt|;
comment|/* We need to call this function after we set the scalar const_tiny_rtx      entries.  */
name|gcc_assert
argument_list|(
name|const_tiny_rtx
index|[
name|constant
index|]
index|[
operator|(
name|int
operator|)
name|inner
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|const_tiny_rtx
index|[
name|constant
index|]
index|[
operator|(
name|int
operator|)
name|inner
index|]
expr_stmt|;
name|tem
operator|=
name|gen_rtx_raw_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Generate a vector like gen_rtx_raw_CONST_VEC, but use the zero vector when    all elements are zero, and the one vector when all elements are one.  */
end_comment

begin_function
name|rtx
name|gen_rtx_CONST_VECTOR
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtvec
name|v
parameter_list|)
block|{
name|enum
name|machine_mode
name|inner
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|nunits
init|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check to see if all of the elements have the same value.  */
name|x
operator|=
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|nunits
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nunits
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|!=
name|x
condition|)
break|break;
comment|/* If the values are all the same, check to see if we can use one of the      standard constant vectors.  */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|inner
argument_list|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|inner
argument_list|)
condition|)
return|return
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
return|return
name|gen_rtx_raw_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create some permanent unique rtl objects shared between all functions.    LINE_NUMBERS is nonzero if line numbers are to be generated.  */
end_comment

begin_function
name|void
name|init_emit_once
parameter_list|(
name|int
name|line_numbers
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|double_mode
decl_stmt|;
comment|/* We need reg_raw_mode, so initialize the modes now.  */
name|init_reg_modes_once
argument_list|()
expr_stmt|;
comment|/* Initialize the CONST_INT, CONST_DOUBLE, and memory attribute hash      tables.  */
name|const_int_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|37
argument_list|,
name|const_int_htab_hash
argument_list|,
name|const_int_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|const_double_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|37
argument_list|,
name|const_double_htab_hash
argument_list|,
name|const_double_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mem_attrs_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|37
argument_list|,
name|mem_attrs_htab_hash
argument_list|,
name|mem_attrs_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|reg_attrs_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|37
argument_list|,
name|reg_attrs_htab_hash
argument_list|,
name|reg_attrs_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|no_line_numbers
operator|=
operator|!
name|line_numbers
expr_stmt|;
comment|/* Compute the word and byte modes.  */
name|byte_mode
operator|=
name|VOIDmode
expr_stmt|;
name|word_mode
operator|=
name|VOIDmode
expr_stmt|;
name|double_mode
operator|=
name|VOIDmode
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_UNIT
operator|&&
name|byte_mode
operator|==
name|VOIDmode
condition|)
name|byte_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_WORD
operator|&&
name|word_mode
operator|==
name|VOIDmode
condition|)
name|word_mode
operator|=
name|mode
expr_stmt|;
block|}
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|DOUBLE_TYPE_SIZE
operator|&&
name|double_mode
operator|==
name|VOIDmode
condition|)
name|double_mode
operator|=
name|mode
expr_stmt|;
block|}
name|ptr_mode
operator|=
name|mode_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Assign register numbers to the globally defined register rtx.      This must be done at runtime because the register number field      is in a union and some compilers can't initialize unions.  */
name|pc_rtx
operator|=
name|gen_rtx_PC
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|cc0_rtx
operator|=
name|gen_rtx_CC0
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|stack_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|frame_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_frame_pointer_rtx
operator|==
literal|0
condition|)
name|hard_frame_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_pointer_rtx
operator|==
literal|0
condition|)
name|arg_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|virtual_incoming_args_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_INCOMING_ARGS_REGNUM
argument_list|)
expr_stmt|;
name|virtual_stack_vars_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_STACK_VARS_REGNUM
argument_list|)
expr_stmt|;
name|virtual_stack_dynamic_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_STACK_DYNAMIC_REGNUM
argument_list|)
expr_stmt|;
name|virtual_outgoing_args_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_OUTGOING_ARGS_REGNUM
argument_list|)
expr_stmt|;
name|virtual_cfa_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|VIRTUAL_CFA_REGNUM
argument_list|)
expr_stmt|;
comment|/* Initialize RTL for commonly used hard registers.  These are      copied into regno_reg_rtx as we begin to compile each function.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|static_regno_reg_rtx
index|[
name|i
index|]
operator|=
name|gen_raw_REG
argument_list|(
name|reg_raw_mode
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXPANDERS
comment|/* This is to initialize {init|mark|free}_machine_status before the first      call to push_function_context_to.  This is needed by the Chill front      end which calls push_function_context_to before the first call to      init_function_start.  */
name|INIT_EXPANDERS
expr_stmt|;
endif|#
directive|endif
comment|/* Create the unique rtx's for certain rtx codes and operand values.  */
comment|/* Don't use gen_rtx_CONST_INT here since gen_rtx_CONST_INT in this case      tries to use these variables.  */
for|for
control|(
name|i
operator|=
operator|-
name|MAX_SAVED_CONST_INT
init|;
name|i
operator|<=
name|MAX_SAVED_CONST_INT
condition|;
name|i
operator|++
control|)
name|const_int_rtx
index|[
name|i
operator|+
name|MAX_SAVED_CONST_INT
index|]
operator|=
name|gen_rtx_raw_CONST_INT
argument_list|(
name|VOIDmode
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|>=
operator|-
name|MAX_SAVED_CONST_INT
operator|&&
name|STORE_FLAG_VALUE
operator|<=
name|MAX_SAVED_CONST_INT
condition|)
name|const_true_rtx
operator|=
name|const_int_rtx
index|[
name|STORE_FLAG_VALUE
operator|+
name|MAX_SAVED_CONST_INT
index|]
expr_stmt|;
else|else
name|const_true_rtx
operator|=
name|gen_rtx_CONST_INT
argument_list|(
name|VOIDmode
argument_list|,
name|STORE_FLAG_VALUE
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|dconst0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|dconst1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|dconst2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|dconst3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|dconst10
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|dconstm1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_INT
argument_list|(
name|dconstm2
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|,
name|double_mode
argument_list|)
expr_stmt|;
name|dconsthalf
operator|=
name|dconst1
expr_stmt|;
name|SET_REAL_EXP
argument_list|(
operator|&
name|dconsthalf
argument_list|,
name|REAL_EXP
argument_list|(
operator|&
name|dconsthalf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|dconstthird
argument_list|,
name|RDIV_EXPR
argument_list|,
operator|&
name|dconst1
argument_list|,
operator|&
name|dconst3
argument_list|)
expr_stmt|;
comment|/* Initialize mathematical constants for constant folding builtins.      These constants need to be given to at least 160 bits precision.  */
name|real_from_string
argument_list|(
operator|&
name|dconstpi
argument_list|,
literal|"3.1415926535897932384626433832795028841971693993751058209749445923078"
argument_list|)
expr_stmt|;
name|real_from_string
argument_list|(
operator|&
name|dconste
argument_list|,
literal|"2.7182818284590452353602874713526624977572470936999595749669676277241"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|const_tiny_rtx
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|REAL_VALUE_TYPE
modifier|*
name|r
init|=
operator|(
name|i
operator|==
literal|0
condition|?
operator|&
name|dconst0
else|:
name|i
operator|==
literal|1
condition|?
operator|&
name|dconst1
else|:
operator|&
name|dconst2
operator|)
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
operator|*
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_DECIMAL_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
operator|*
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|VOIDmode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_PARTIAL_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|const_tiny_rtx
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|const_tiny_rtx
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|gen_const_vector
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|const_tiny_rtx
index|[
literal|1
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|gen_const_vector
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|const_tiny_rtx
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|gen_const_vector
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|const_tiny_rtx
index|[
literal|1
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|gen_const_vector
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|CCmode
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
name|i
argument_list|)
operator|==
name|MODE_CC
condition|)
name|const_tiny_rtx
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|const_tiny_rtx
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
name|BImode
index|]
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|)
name|const_tiny_rtx
index|[
literal|1
index|]
index|[
operator|(
name|int
operator|)
name|BImode
index|]
operator|=
name|const1_rtx
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ADDRESS_POINTER_REGNUM
name|return_address_pointer_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_ADDRESS_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
name|static_chain_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
if|if
condition|(
name|STATIC_CHAIN_INCOMING_REGNUM
operator|!=
name|STATIC_CHAIN_REGNUM
condition|)
name|static_chain_incoming_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|static_chain_incoming_rtx
operator|=
name|static_chain_rtx
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN
name|static_chain_rtx
operator|=
name|STATIC_CHAIN
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING
name|static_chain_incoming_rtx
operator|=
name|STATIC_CHAIN_INCOMING
expr_stmt|;
else|#
directive|else
name|static_chain_incoming_rtx
operator|=
name|static_chain_rtx
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
condition|)
name|pic_offset_table_rtx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Produce exact duplicate of insn INSN after AFTER.    Care updating of libcall regions if present.  */
end_comment

begin_function
name|rtx
name|emit_copy_of_insn_after
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|after
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|;
name|rtx
name|note1
decl_stmt|,
name|note2
decl_stmt|,
name|link
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|new
operator|=
name|emit_insn_after
argument_list|(
name|copy_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|new
operator|=
name|emit_jump_insn_after
argument_list|(
name|copy_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
name|new
operator|=
name|emit_call_insn_after
argument_list|(
name|copy_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|new
argument_list|)
operator|=
name|copy_insn
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|new
argument_list|)
operator|=
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|new
argument_list|)
operator|=
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Update LABEL_NUSES.  */
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_LOCATOR
argument_list|(
name|new
argument_list|)
operator|=
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the old insn is frame related, then so is the new one.  This is      primarily needed for IA-64 unwind info which marks epilogue insns,      which may be duplicated by the basic block reordering code.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Copy all REG_NOTES except REG_LABEL since mark_jump_label will      make them.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_LABEL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|link
argument_list|)
operator|==
name|EXPR_LIST
condition|)
name|REG_NOTES
argument_list|(
name|new
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|new
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix the libcall sequences.  */
if|if
condition|(
operator|(
name|note1
operator|=
name|find_reg_note
argument_list|(
name|new
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rtx
name|p
init|=
name|new
decl_stmt|;
while|while
condition|(
operator|(
name|note2
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note1
argument_list|,
literal|0
argument_list|)
operator|=
name|p
expr_stmt|;
name|XEXP
argument_list|(
name|note2
argument_list|,
literal|0
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
name|INSN_CODE
argument_list|(
name|new
argument_list|)
operator|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
name|rtx
name|hard_reg_clobbers
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|FIRST_PSEUDO_REGISTER
index|]
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|gen_hard_reg_clobber
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|hard_reg_clobbers
index|[
name|mode
index|]
index|[
name|regno
index|]
condition|)
return|return
name|hard_reg_clobbers
index|[
name|mode
index|]
index|[
name|regno
index|]
return|;
else|else
return|return
operator|(
name|hard_reg_clobbers
index|[
name|mode
index|]
index|[
name|regno
index|]
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-emit-rtl.h"
end_include

end_unit

