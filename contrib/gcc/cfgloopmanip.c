begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop manipulation code for GNU compiler.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"cfghooks.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_function_decl
specifier|static
name|void
name|duplicate_subloops
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_loops_to
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|loop_redirect_edge
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|loop_delete_branch_edge
parameter_list|(
name|edge
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_bbs
parameter_list|(
name|basic_block
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rpe_enum_p
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_path
parameter_list|(
name|edge
parameter_list|,
name|basic_block
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|alp_enum_p
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_loop_placements
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|fix_bb_placement
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_bb_placements
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|place_new_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scale_loop_frequencies
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|create_preheader
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unloop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|RDIV
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|(((X) + (Y) / 2) / (Y))
end_define

begin_comment
comment|/* Checks whether basic block BB is dominated by DATA.  */
end_comment

begin_function
specifier|static
name|bool
name|rpe_enum_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove basic blocks BBS from loop structure and dominance info,    and delete them afterwards.  */
end_comment

begin_function
specifier|static
name|void
name|remove_bbs
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|nbbs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|remove_bb_from_loops
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|delete_basic_block
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find path -- i.e. the basic blocks dominated by edge E and put them    into array BBS, that will be allocated large enough to contain them.    E->dest must have exactly one predecessor for this to work (it is    easy to achieve and we do not put it here because we do not want to    alter anything by this function).  The number of basic blocks in the    path is returned.  */
end_comment

begin_function
specifier|static
name|int
name|find_path
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
modifier|*
modifier|*
name|bbs
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|e
operator|->
name|dest
operator|->
name|preds
argument_list|)
operator|<=
literal|1
argument_list|)
expr_stmt|;
comment|/* Find bbs in the path.  */
operator|*
name|bbs
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
return|return
name|dfs_enumerate_from
argument_list|(
name|e
operator|->
name|dest
argument_list|,
literal|0
argument_list|,
name|rpe_enum_p
argument_list|,
operator|*
name|bbs
argument_list|,
name|n_basic_blocks
argument_list|,
name|e
operator|->
name|dest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fix placement of basic block BB inside loop hierarchy stored in LOOPS --    Let L be a loop to that BB belongs.  Then every successor of BB must either      1) belong to some superloop of loop L, or      2) be a header of loop K such that K->outer is superloop of L    Returns true if we had to move BB into other loop to enforce this condition,    false if the placement of BB was already correct (provided that placements    of its successors are correct).  */
end_comment

begin_function
specifier|static
name|bool
name|fix_bb_placement
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|tree_root
decl_stmt|,
modifier|*
name|act
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
name|act
operator|=
name|e
operator|->
name|dest
operator|->
name|loop_father
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|header
operator|==
name|e
operator|->
name|dest
condition|)
name|act
operator|=
name|act
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|loop
argument_list|,
name|act
argument_list|)
condition|)
name|loop
operator|=
name|act
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|==
name|bb
operator|->
name|loop_father
condition|)
return|return
name|false
return|;
name|remove_bb_from_loops
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|bb
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Fix placements of basic blocks inside loop hierarchy stored in loops; i.e.    enforce condition condition stated in description of fix_bb_placement. We    start from basic block FROM that had some of its successors removed, so that    his placement no longer has to be correct, and iteratively fix placement of    its predecessors that may change if placement of FROM changed.  Also fix    placement of subloops of FROM->loop_father, that might also be altered due    to this change; the condition for them is similar, except that instead of    successors we consider edges coming out of the loops.      If the changes may invalidate the information about irreducible regions,    IRRED_INVALIDATED is set to true.  */
end_comment

begin_function
specifier|static
name|void
name|fix_bb_placements
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|basic_block
name|from
parameter_list|,
name|bool
modifier|*
name|irred_invalidated
parameter_list|)
block|{
name|sbitmap
name|in_queue
decl_stmt|;
name|basic_block
modifier|*
name|queue
decl_stmt|,
modifier|*
name|qtop
decl_stmt|,
modifier|*
name|qbeg
decl_stmt|,
modifier|*
name|qend
decl_stmt|;
name|struct
name|loop
modifier|*
name|base_loop
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* We pass through blocks back-reachable from FROM, testing whether some      of their successors moved to outer loop.  It may be necessary to      iterate several times, but it is finite, as we stop unless we move      the basic block up the loop structure.  The whole story is a bit      more complicated due to presence of subloops, those are moved using      fix_loop_placement.  */
name|base_loop
operator|=
name|from
operator|->
name|loop_father
expr_stmt|;
if|if
condition|(
name|base_loop
operator|==
name|loops
operator|->
name|tree_root
condition|)
return|return;
name|in_queue
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|from
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Prevent us from going out of the base_loop.  */
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|base_loop
operator|->
name|header
operator|->
name|index
argument_list|)
expr_stmt|;
name|queue
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|base_loop
operator|->
name|num_nodes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qtop
operator|=
name|queue
operator|+
name|base_loop
operator|->
name|num_nodes
operator|+
literal|1
expr_stmt|;
name|qbeg
operator|=
name|queue
expr_stmt|;
name|qend
operator|=
name|queue
operator|+
literal|1
expr_stmt|;
operator|*
name|qbeg
operator|=
name|from
expr_stmt|;
while|while
condition|(
name|qbeg
operator|!=
name|qend
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|from
operator|=
operator|*
name|qbeg
expr_stmt|;
name|qbeg
operator|++
expr_stmt|;
if|if
condition|(
name|qbeg
operator|==
name|qtop
condition|)
name|qbeg
operator|=
name|queue
expr_stmt|;
name|RESET_BIT
argument_list|(
name|in_queue
argument_list|,
name|from
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|loop_father
operator|->
name|header
operator|==
name|from
condition|)
block|{
comment|/* Subloop header, maybe move the loop upward.  */
if|if
condition|(
operator|!
name|fix_loop_placement
argument_list|(
name|from
operator|->
name|loop_father
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* Ordinary basic block.  */
if|if
condition|(
operator|!
name|fix_bb_placement
argument_list|(
name|loops
argument_list|,
name|from
argument_list|)
condition|)
continue|continue;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|from->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
operator|*
name|irred_invalidated
operator|=
name|true
expr_stmt|;
block|}
comment|/* Something has changed, insert predecessors into queue.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|from->preds
argument_list|)
block|{
name|basic_block
name|pred
init|=
name|e
operator|->
name|src
decl_stmt|;
name|struct
name|loop
modifier|*
name|nca
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
operator|*
name|irred_invalidated
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|in_queue
argument_list|,
name|pred
operator|->
name|index
argument_list|)
condition|)
continue|continue;
comment|/* If it is subloop, then it either was not moved, or 	     the path up the loop tree from base_loop do not contain 	     it.  */
name|nca
operator|=
name|find_common_loop
argument_list|(
name|pred
operator|->
name|loop_father
argument_list|,
name|base_loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|->
name|loop_father
operator|!=
name|base_loop
operator|&&
operator|(
name|nca
operator|==
name|base_loop
operator|||
name|nca
operator|!=
name|pred
operator|->
name|loop_father
operator|)
condition|)
name|pred
operator|=
name|pred
operator|->
name|loop_father
operator|->
name|header
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flow_loop_nested_p
argument_list|(
name|from
operator|->
name|loop_father
argument_list|,
name|pred
operator|->
name|loop_father
argument_list|)
condition|)
block|{
comment|/* No point in processing it.  */
continue|continue;
block|}
if|if
condition|(
name|TEST_BIT
argument_list|(
name|in_queue
argument_list|,
name|pred
operator|->
name|index
argument_list|)
condition|)
continue|continue;
comment|/* Schedule the basic block.  */
operator|*
name|qend
operator|=
name|pred
expr_stmt|;
name|qend
operator|++
expr_stmt|;
if|if
condition|(
name|qend
operator|==
name|qtop
condition|)
name|qend
operator|=
name|queue
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|pred
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes path beginning at edge E, i.e. remove basic blocks dominated by E    and update loop structure stored in LOOPS and dominators.  Return true if    we were able to remove the path, false otherwise (and nothing is affected    then).  */
end_comment

begin_function
name|bool
name|remove_path
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|edge
name|ae
decl_stmt|;
name|basic_block
modifier|*
name|rem_bbs
decl_stmt|,
modifier|*
name|bord_bbs
decl_stmt|,
modifier|*
name|dom_bbs
decl_stmt|,
name|from
decl_stmt|,
name|bb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nrem
decl_stmt|,
name|n_bord_bbs
decl_stmt|,
name|n_dom_bbs
decl_stmt|;
name|sbitmap
name|seen
decl_stmt|;
name|bool
name|deleted
decl_stmt|,
name|irred_invalidated
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|loop_delete_branch_edge
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Keep track of whether we need to update information about irreducible      regions.  This is the case if the removed area is a part of the      irreducible region, or if the set of basic blocks that belong to a loop      that is inside an irreducible region is changed, or if such a loop is      removed.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
name|irred_invalidated
operator|=
name|true
expr_stmt|;
comment|/* We need to check whether basic blocks are dominated by the edge      e, but we only have basic block dominators.  This is easy to      fix -- when e->dest has exactly one predecessor, this corresponds      to blocks dominated by e->dest, if not, split the edge.  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
name|e
operator|=
name|single_pred_edge
argument_list|(
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It may happen that by removing path we remove one or more loops      we belong to.  In this case first unloop the loops, then proceed      normally.   We may assume that e->dest is not a header of any loop,      as it now has exactly one predecessor.  */
while|while
condition|(
name|e
operator|->
name|src
operator|->
name|loop_father
operator|->
name|outer
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|src
operator|->
name|loop_father
operator|->
name|latch
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|unloop
argument_list|(
name|loops
argument_list|,
name|e
operator|->
name|src
operator|->
name|loop_father
argument_list|,
operator|&
name|irred_invalidated
argument_list|)
expr_stmt|;
comment|/* Identify the path.  */
name|nrem
operator|=
name|find_path
argument_list|(
name|e
argument_list|,
operator|&
name|rem_bbs
argument_list|)
expr_stmt|;
name|n_bord_bbs
operator|=
literal|0
expr_stmt|;
name|bord_bbs
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|seen
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
comment|/* Find "border" hexes -- i.e. those with predecessor in removed path.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrem
condition|;
name|i
operator|++
control|)
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|rem_bbs
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrem
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|bb
operator|=
name|rem_bbs
index|[
name|i
index|]
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|ae
argument_list|,
argument|ei
argument_list|,
argument|rem_bbs[i]->succs
argument_list|)
if|if
condition|(
name|ae
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|ae
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|ae
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|bord_bbs
index|[
name|n_bord_bbs
operator|++
index|]
operator|=
name|ae
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|ae
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
name|irred_invalidated
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Remove the path.  */
name|from
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|deleted
operator|=
name|loop_delete_branch_edge
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|deleted
argument_list|)
expr_stmt|;
name|dom_bbs
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Cancel loops contained in the path.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrem
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rem_bbs
index|[
name|i
index|]
operator|->
name|loop_father
operator|->
name|header
operator|==
name|rem_bbs
index|[
name|i
index|]
condition|)
name|cancel_loop_tree
argument_list|(
name|loops
argument_list|,
name|rem_bbs
index|[
name|i
index|]
operator|->
name|loop_father
argument_list|)
expr_stmt|;
name|remove_bbs
argument_list|(
name|rem_bbs
argument_list|,
name|nrem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rem_bbs
argument_list|)
expr_stmt|;
comment|/* Find blocks whose dominators may be affected.  */
name|n_dom_bbs
operator|=
literal|0
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bord_bbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|ldom
decl_stmt|;
name|bb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bord_bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|ldom
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|ldom
condition|;
name|ldom
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|ldom
argument_list|)
control|)
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|from
argument_list|,
name|ldom
argument_list|)
condition|)
name|dom_bbs
index|[
name|n_dom_bbs
operator|++
index|]
operator|=
name|ldom
expr_stmt|;
block|}
name|free
argument_list|(
name|seen
argument_list|)
expr_stmt|;
comment|/* Recount dominators.  */
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dom_bbs
argument_list|,
name|n_dom_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dom_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bord_bbs
argument_list|)
expr_stmt|;
comment|/* Fix placements of basic blocks inside loops and the placement of      loops in the loop tree.  */
name|fix_bb_placements
argument_list|(
name|loops
argument_list|,
name|from
argument_list|,
operator|&
name|irred_invalidated
argument_list|)
expr_stmt|;
name|fix_loop_placements
argument_list|(
name|loops
argument_list|,
name|from
operator|->
name|loop_father
argument_list|,
operator|&
name|irred_invalidated
argument_list|)
expr_stmt|;
if|if
condition|(
name|irred_invalidated
operator|&&
operator|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
operator|)
operator|!=
literal|0
condition|)
name|mark_irreducible_loops
argument_list|(
name|loops
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Predicate for enumeration in add_loop.  */
end_comment

begin_function
specifier|static
name|bool
name|alp_enum_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|alp_header
parameter_list|)
block|{
return|return
name|bb
operator|!=
operator|(
name|basic_block
operator|)
name|alp_header
return|;
block|}
end_function

begin_comment
comment|/* Given LOOP structure with filled header and latch, find the body of the    corresponding loop and add it to LOOPS tree.  */
end_comment

begin_function
specifier|static
name|void
name|add_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* Add it to loop structure.  */
name|place_new_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|level
operator|=
literal|1
expr_stmt|;
comment|/* Find its nodes.  */
name|bbs
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|n
operator|=
name|dfs_enumerate_from
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
literal|1
argument_list|,
name|alp_enum_p
argument_list|,
name|bbs
argument_list|,
name|n_basic_blocks
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|add_bb_to_loop
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiply all frequencies in LOOP by NUM/DEN.  */
end_comment

begin_function
specifier|static
name|void
name|scale_loop_frequencies
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|den
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|scale_bbs_frequencies_int
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|,
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make area between HEADER_EDGE and LATCH_EDGE a loop by connecting    latch to header and update loop tree stored in LOOPS and dominators    accordingly. Everything between them plus LATCH_EDGE destination must    be dominated by HEADER_EDGE destination, and back-reachable from    LATCH_EDGE source.  HEADER_EDGE is redirected to basic block SWITCH_BB,    FALSE_EDGE of SWITCH_BB to original destination of HEADER_EDGE and    TRUE_EDGE of SWITCH_BB to original destination of LATCH_EDGE.    Returns newly created loop.  */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|loopify
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|edge
name|latch_edge
parameter_list|,
name|edge
name|header_edge
parameter_list|,
name|basic_block
name|switch_bb
parameter_list|,
name|edge
name|true_edge
parameter_list|,
name|edge
name|false_edge
parameter_list|,
name|bool
name|redirect_all_edges
parameter_list|)
block|{
name|basic_block
name|succ_bb
init|=
name|latch_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|pred_bb
init|=
name|header_edge
operator|->
name|src
decl_stmt|;
name|basic_block
modifier|*
name|dom_bbs
decl_stmt|,
modifier|*
name|body
decl_stmt|;
name|unsigned
name|n_dom_bbs
decl_stmt|,
name|i
decl_stmt|;
name|sbitmap
name|seen
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|XCNEW
argument_list|(
expr|struct
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|outer
init|=
name|succ_bb
operator|->
name|loop_father
operator|->
name|outer
decl_stmt|;
name|int
name|freq
decl_stmt|,
name|prob
decl_stmt|,
name|tot_prob
decl_stmt|;
name|gcov_type
name|cnt
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|loop
operator|->
name|header
operator|=
name|header_edge
operator|->
name|dest
expr_stmt|;
name|loop
operator|->
name|latch
operator|=
name|latch_edge
operator|->
name|src
expr_stmt|;
name|freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|header_edge
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|header_edge
operator|->
name|count
expr_stmt|;
name|prob
operator|=
name|EDGE_SUCC
argument_list|(
name|switch_bb
argument_list|,
literal|0
argument_list|)
operator|->
name|probability
expr_stmt|;
name|tot_prob
operator|=
name|prob
operator|+
name|EDGE_SUCC
argument_list|(
name|switch_bb
argument_list|,
literal|1
argument_list|)
operator|->
name|probability
expr_stmt|;
if|if
condition|(
name|tot_prob
operator|==
literal|0
condition|)
name|tot_prob
operator|=
literal|1
expr_stmt|;
comment|/* Redirect edges.  */
name|loop_redirect_edge
argument_list|(
name|latch_edge
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|loop_redirect_edge
argument_list|(
name|true_edge
argument_list|,
name|succ_bb
argument_list|)
expr_stmt|;
comment|/* During loop versioning, one of the switch_bb edge is already properly      set. Do not redirect it again unless redirect_all_edges is true.  */
if|if
condition|(
name|redirect_all_edges
condition|)
block|{
name|loop_redirect_edge
argument_list|(
name|header_edge
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
name|loop_redirect_edge
argument_list|(
name|false_edge
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
comment|/* Update dominators.  */
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|switch_bb
argument_list|,
name|pred_bb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|header
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
block|}
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|succ_bb
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
comment|/* Compute new loop.  */
name|add_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|outer
argument_list|,
name|loop
argument_list|)
expr_stmt|;
comment|/* Add switch_bb to appropriate loop.  */
name|add_bb_to_loop
argument_list|(
name|switch_bb
argument_list|,
name|outer
argument_list|)
expr_stmt|;
comment|/* Fix frequencies.  */
name|switch_bb
operator|->
name|frequency
operator|=
name|freq
expr_stmt|;
name|switch_bb
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|switch_bb->succs
argument_list|)
name|e
operator|->
name|count
operator|=
operator|(
name|switch_bb
operator|->
name|count
operator|*
name|e
operator|->
name|probability
operator|)
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|scale_loop_frequencies
argument_list|(
name|loop
argument_list|,
name|prob
argument_list|,
name|tot_prob
argument_list|)
expr_stmt|;
name|scale_loop_frequencies
argument_list|(
name|succ_bb
operator|->
name|loop_father
argument_list|,
name|tot_prob
operator|-
name|prob
argument_list|,
name|tot_prob
argument_list|)
expr_stmt|;
comment|/* Update dominators of blocks outside of LOOP.  */
name|dom_bbs
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|n_dom_bbs
operator|=
literal|0
expr_stmt|;
name|seen
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|body
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|ldom
decl_stmt|;
for|for
control|(
name|ldom
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|body
index|[
name|i
index|]
argument_list|)
init|;
name|ldom
condition|;
name|ldom
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|ldom
argument_list|)
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|ldom
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|ldom
operator|->
name|index
argument_list|)
expr_stmt|;
name|dom_bbs
index|[
name|n_dom_bbs
operator|++
index|]
operator|=
name|ldom
expr_stmt|;
block|}
block|}
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dom_bbs
argument_list|,
name|n_dom_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dom_bbs
argument_list|)
expr_stmt|;
return|return
name|loop
return|;
block|}
end_function

begin_comment
comment|/* Remove the latch edge of a LOOP and update LOOPS tree to indicate that    the LOOP was removed.  After this function, original loop latch will    have no successor, which caller is expected to fix somehow.     If this may cause the information about irreducible regions to become    invalid, IRRED_INVALIDATED is set to true.  */
end_comment

begin_function
specifier|static
name|void
name|unloop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
modifier|*
name|irred_invalidated
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
decl_stmt|;
name|struct
name|loop
modifier|*
name|ploop
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
name|latch
init|=
name|loop
operator|->
name|latch
decl_stmt|;
name|bool
name|dummy
init|=
name|false
decl_stmt|;
if|if
condition|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
operator|*
name|irred_invalidated
operator|=
name|true
expr_stmt|;
comment|/* This is relatively straightforward.  The dominators are unchanged, as      loop header dominates loop latch, so the only thing we have to care of      is the placement of loops and basic blocks inside the loop tree.  We      move them all to the loop->outer, and then let fix_bb_placements do      its work.  */
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|n
operator|=
name|loop
operator|->
name|num_nodes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|body
index|[
name|i
index|]
operator|->
name|loop_father
operator|==
name|loop
condition|)
block|{
name|remove_bb_from_loops
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|body
index|[
name|i
index|]
argument_list|,
name|loop
operator|->
name|outer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
name|ploop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
name|flow_loop_tree_node_remove
argument_list|(
name|ploop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|loop
operator|->
name|outer
argument_list|,
name|ploop
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the loop and free its data.  */
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
index|[
name|loop
operator|->
name|num
index|]
operator|=
name|NULL
expr_stmt|;
name|flow_loop_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|remove_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|latch
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not pass IRRED_INVALIDATED to fix_bb_placements here, as even if      there is an irreducible region inside the cancelled loop, the flags will      be still correct.  */
name|fix_bb_placements
argument_list|(
name|loops
argument_list|,
name|latch
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix placement of LOOP inside loop tree, i.e. find the innermost superloop    FATHER of LOOP such that all of the edges coming out of LOOP belong to    FATHER, and set it as outer loop of LOOP.  Return true if placement of    LOOP changed.  */
end_comment

begin_function
name|int
name|fix_loop_placement
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|struct
name|loop
modifier|*
name|father
init|=
name|loop
operator|->
name|pred
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|act
decl_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|body[i]->succs
argument_list|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|act
operator|=
name|find_common_loop
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|father
argument_list|,
name|act
argument_list|)
condition|)
name|father
operator|=
name|act
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|father
operator|!=
name|loop
operator|->
name|outer
condition|)
block|{
for|for
control|(
name|act
operator|=
name|loop
operator|->
name|outer
init|;
name|act
operator|!=
name|father
condition|;
name|act
operator|=
name|act
operator|->
name|outer
control|)
name|act
operator|->
name|num_nodes
operator|-=
name|loop
operator|->
name|num_nodes
expr_stmt|;
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|father
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fix placement of superloops of LOOP inside loop tree, i.e. ensure that    condition stated in description of fix_loop_placement holds for them.    It is used in case when we removed some edges coming out of LOOP, which    may cause the right placement of LOOP inside loop tree to change.      IRRED_INVALIDATED is set to true if a change in the loop structures might    invalidate the information about irreducible regions.  */
end_comment

begin_function
specifier|static
name|void
name|fix_loop_placements
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
modifier|*
name|irred_invalidated
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|outer
decl_stmt|;
while|while
condition|(
name|loop
operator|->
name|outer
condition|)
block|{
name|outer
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
if|if
condition|(
operator|!
name|fix_loop_placement
argument_list|(
name|loop
argument_list|)
condition|)
break|break;
comment|/* Changing the placement of a loop in the loop tree may alter the 	 validity of condition 2) of the description of fix_bb_placement 	 for its preheader, because the successor is the header and belongs 	 to the loop.  So call fix_bb_placements to fix up the placement 	 of the preheader and (possibly) of its predecessors.  */
name|fix_bb_placements
argument_list|(
name|loops
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
argument_list|,
name|irred_invalidated
argument_list|)
expr_stmt|;
name|loop
operator|=
name|outer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Creates place for a new LOOP in LOOPS structure.  */
end_comment

begin_function
specifier|static
name|void
name|place_new_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|loops
operator|->
name|parray
operator|=
name|xrealloc
argument_list|(
name|loops
operator|->
name|parray
argument_list|,
operator|(
name|loops
operator|->
name|num
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
index|[
name|loops
operator|->
name|num
index|]
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|num
operator|=
name|loops
operator|->
name|num
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copies copy of LOOP as subloop of TARGET loop, placing newly    created loop into LOOPS structure.  */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|duplicate_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|loop
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|cloop
decl_stmt|;
name|cloop
operator|=
name|XCNEW
argument_list|(
expr|struct
name|loop
argument_list|)
expr_stmt|;
name|place_new_loop
argument_list|(
name|loops
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
comment|/* Initialize copied loop.  */
name|cloop
operator|->
name|level
operator|=
name|loop
operator|->
name|level
expr_stmt|;
comment|/* Set it as copy of loop.  */
name|loop
operator|->
name|copy
operator|=
name|cloop
expr_stmt|;
comment|/* Add it to target.  */
name|flow_loop_tree_node_add
argument_list|(
name|target
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
return|return
name|cloop
return|;
block|}
end_function

begin_comment
comment|/* Copies structure of subloops of LOOP into TARGET loop, placing    newly created loops into loop tree stored in LOOPS.  */
end_comment

begin_function
specifier|static
name|void
name|duplicate_subloops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|loop
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|aloop
decl_stmt|,
modifier|*
name|cloop
decl_stmt|;
for|for
control|(
name|aloop
operator|=
name|loop
operator|->
name|inner
init|;
name|aloop
condition|;
name|aloop
operator|=
name|aloop
operator|->
name|next
control|)
block|{
name|cloop
operator|=
name|duplicate_loop
argument_list|(
name|loops
argument_list|,
name|aloop
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|duplicate_subloops
argument_list|(
name|loops
argument_list|,
name|aloop
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copies structure of subloops of N loops, stored in array COPIED_LOOPS,    into TARGET loop, placing newly created loops into loop tree LOOPS.  */
end_comment

begin_function
specifier|static
name|void
name|copy_loops_to
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
modifier|*
name|copied_loops
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|loop
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|aloop
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|aloop
operator|=
name|duplicate_loop
argument_list|(
name|loops
argument_list|,
name|copied_loops
index|[
name|i
index|]
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|duplicate_subloops
argument_list|(
name|loops
argument_list|,
name|copied_loops
index|[
name|i
index|]
argument_list|,
name|aloop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Redirects edge E to basic block DEST.  */
end_comment

begin_function
specifier|static
name|void
name|loop_redirect_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|dest
condition|)
return|return;
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deletes edge E from a branch if possible.  Unless REALLY_DELETE is set,    just test whether it is possible to remove the edge.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_delete_branch_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|int
name|really_delete
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|basic_block
name|newdest
decl_stmt|;
name|int
name|irr
decl_stmt|;
name|edge
name|snd
decl_stmt|;
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|src
operator|->
name|succs
argument_list|)
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* Cannot handle more than two exit edges.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|src
operator|->
name|succs
argument_list|)
operator|>
literal|2
condition|)
return|return
name|false
return|;
comment|/* And it must be just a simple branch.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|snd
operator|=
name|e
operator|==
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|?
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
else|:
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newdest
operator|=
name|snd
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|newdest
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
comment|/* Hopefully the above conditions should suffice.  */
if|if
condition|(
operator|!
name|really_delete
condition|)
return|return
name|true
return|;
comment|/* Redirecting behaves wrongly wrto this flag.  */
name|irr
operator|=
name|snd
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|newdest
argument_list|)
condition|)
return|return
name|false
return|;
name|single_succ_edge
argument_list|(
name|src
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|single_succ_edge
argument_list|(
name|src
argument_list|)
operator|->
name|flags
operator||=
name|irr
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check whether LOOP's body can be duplicated.  */
end_comment

begin_function
name|bool
name|can_duplicate_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|ret
operator|=
name|can_copy_bbs_p
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The NBBS blocks in BBS will get duplicated and the copies will be placed    to LOOP.  Update the single_exit information in superloops of LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|update_single_exits_after_duplication
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|unsigned
name|nbbs
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
name|bbs
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|BB_DUPLICATED
expr_stmt|;
for|for
control|(
init|;
name|loop
operator|->
name|outer
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
block|{
if|if
condition|(
operator|!
name|loop
operator|->
name|single_exit
condition|)
continue|continue;
if|if
condition|(
name|loop
operator|->
name|single_exit
operator|->
name|src
operator|->
name|flags
operator|&
name|BB_DUPLICATED
condition|)
name|loop
operator|->
name|single_exit
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
name|bbs
index|[
name|i
index|]
operator|->
name|flags
operator|&=
operator|~
name|BB_DUPLICATED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating    LOOPS structure and dominators.  E's destination must be LOOP header for    this to work, i.e. it must be entry or latch edge of this loop; these are    unique, as the loops must have preheaders for this function to work    correctly (in case E is latch, the function unrolls the loop, if E is entry    edge, it peels the loop).  Store edges created by copying ORIG edge from    copies corresponding to set bits in WONT_EXIT bitmap (bit 0 corresponds to    original LOOP body, the other copies are numbered in order given by control    flow through them) into TO_REMOVE array.  Returns false if duplication is    impossible.  */
end_comment

begin_function
name|bool
name|duplicate_loop_to_header_edge
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|unsigned
name|int
name|ndupl
parameter_list|,
name|sbitmap
name|wont_exit
parameter_list|,
name|edge
name|orig
parameter_list|,
name|edge
modifier|*
name|to_remove
parameter_list|,
name|unsigned
name|int
modifier|*
name|n_to_remove
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|target
decl_stmt|,
modifier|*
name|aloop
decl_stmt|;
name|struct
name|loop
modifier|*
modifier|*
name|orig_loops
decl_stmt|;
name|unsigned
name|n_orig_loops
decl_stmt|;
name|basic_block
name|header
init|=
name|loop
operator|->
name|header
decl_stmt|,
name|latch
init|=
name|loop
operator|->
name|latch
decl_stmt|;
name|basic_block
modifier|*
name|new_bbs
decl_stmt|,
modifier|*
name|bbs
decl_stmt|,
modifier|*
name|first_active
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|,
name|bb
decl_stmt|,
name|first_active_latch
init|=
name|NULL
decl_stmt|;
name|edge
name|ae
decl_stmt|,
name|latch_edge
decl_stmt|;
name|edge
name|spec_edges
index|[
literal|2
index|]
decl_stmt|,
name|new_spec_edges
index|[
literal|2
index|]
decl_stmt|;
define|#
directive|define
name|SE_LATCH
value|0
define|#
directive|define
name|SE_ORIG
value|1
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|is_latch
init|=
operator|(
name|latch
operator|==
name|e
operator|->
name|src
operator|)
decl_stmt|;
name|int
name|scale_act
init|=
literal|0
decl_stmt|,
modifier|*
name|scale_step
init|=
name|NULL
decl_stmt|,
name|scale_main
init|=
literal|0
decl_stmt|;
name|int
name|p
decl_stmt|,
name|freq_in
decl_stmt|,
name|freq_le
decl_stmt|,
name|freq_out_orig
decl_stmt|;
name|int
name|prob_pass_thru
decl_stmt|,
name|prob_pass_wont_exit
decl_stmt|,
name|prob_pass_main
decl_stmt|;
name|int
name|add_irreducible_flag
decl_stmt|;
name|basic_block
name|place_after
decl_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest
operator|==
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ndupl
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
condition|)
block|{
comment|/* Orig must be edge out of the loop.  */
name|gcc_assert
argument_list|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|orig
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|orig
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|loop
operator|->
name|num_nodes
expr_stmt|;
name|bbs
operator|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bbs
index|[
literal|0
index|]
operator|==
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bbs
index|[
name|n
operator|-
literal|1
index|]
operator|==
name|loop
operator|->
name|latch
argument_list|)
expr_stmt|;
comment|/* Check whether duplication is possible.  */
if|if
condition|(
operator|!
name|can_copy_bbs_p
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|new_bbs
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
comment|/* In case we are doing loop peeling and the loop is in the middle of      irreducible region, the peeled copies will be inside it too.  */
name|add_irreducible_flag
operator|=
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|is_latch
operator|||
operator|!
name|add_irreducible_flag
argument_list|)
expr_stmt|;
comment|/* Find edge from latch.  */
name|latch_edge
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DLTHE_FLAG_UPDATE_FREQ
condition|)
block|{
comment|/* Calculate coefficients by that we have to scale frequencies 	 of duplicated loop bodies.  */
name|freq_in
operator|=
name|header
operator|->
name|frequency
expr_stmt|;
name|freq_le
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|latch_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq_in
operator|==
literal|0
condition|)
name|freq_in
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|freq_in
operator|<
name|freq_le
condition|)
name|freq_in
operator|=
name|freq_le
expr_stmt|;
name|freq_out_orig
operator|=
name|orig
condition|?
name|EDGE_FREQUENCY
argument_list|(
name|orig
argument_list|)
else|:
name|freq_in
operator|-
name|freq_le
expr_stmt|;
if|if
condition|(
name|freq_out_orig
operator|>
name|freq_in
operator|-
name|freq_le
condition|)
name|freq_out_orig
operator|=
name|freq_in
operator|-
name|freq_le
expr_stmt|;
name|prob_pass_thru
operator|=
name|RDIV
argument_list|(
name|REG_BR_PROB_BASE
operator|*
name|freq_le
argument_list|,
name|freq_in
argument_list|)
expr_stmt|;
name|prob_pass_wont_exit
operator|=
name|RDIV
argument_list|(
name|REG_BR_PROB_BASE
operator|*
operator|(
name|freq_le
operator|+
name|freq_out_orig
operator|)
argument_list|,
name|freq_in
argument_list|)
expr_stmt|;
name|scale_step
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|ndupl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ndupl
condition|;
name|i
operator|++
control|)
name|scale_step
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
name|i
argument_list|)
condition|?
name|prob_pass_wont_exit
else|:
name|prob_pass_thru
expr_stmt|;
comment|/* Complete peeling is special as the probability of exit in last 	 copy becomes 1.  */
if|if
condition|(
name|flags
operator|&
name|DLTHE_FLAG_COMPLETTE_PEEL
condition|)
block|{
name|int
name|wanted_freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|wanted_freq
operator|>
name|freq_in
condition|)
name|wanted_freq
operator|=
name|freq_in
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|is_latch
argument_list|)
expr_stmt|;
comment|/* First copy has frequency of incoming edge.  Each subsequent 	     frequency should be reduced by prob_pass_wont_exit.  Caller 	     should've managed the flags so all except for original loop 	     has won't exist set.  */
name|scale_act
operator|=
name|RDIV
argument_list|(
name|wanted_freq
operator|*
name|REG_BR_PROB_BASE
argument_list|,
name|freq_in
argument_list|)
expr_stmt|;
comment|/* Now simulate the duplication adjustments and compute header 	     frequency of the last copy.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndupl
condition|;
name|i
operator|++
control|)
name|wanted_freq
operator|=
name|RDIV
argument_list|(
name|wanted_freq
operator|*
name|scale_step
index|[
name|i
index|]
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|scale_main
operator|=
name|RDIV
argument_list|(
name|wanted_freq
operator|*
name|REG_BR_PROB_BASE
argument_list|,
name|freq_in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_latch
condition|)
block|{
name|prob_pass_main
operator|=
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
condition|?
name|prob_pass_wont_exit
else|:
name|prob_pass_thru
expr_stmt|;
name|p
operator|=
name|prob_pass_main
expr_stmt|;
name|scale_main
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndupl
condition|;
name|i
operator|++
control|)
block|{
name|scale_main
operator|+=
name|p
expr_stmt|;
name|p
operator|=
name|RDIV
argument_list|(
name|p
operator|*
name|scale_step
index|[
name|i
index|]
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
name|scale_main
operator|=
name|RDIV
argument_list|(
name|REG_BR_PROB_BASE
operator|*
name|REG_BR_PROB_BASE
argument_list|,
name|scale_main
argument_list|)
expr_stmt|;
name|scale_act
operator|=
name|RDIV
argument_list|(
name|scale_main
operator|*
name|prob_pass_main
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scale_main
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndupl
condition|;
name|i
operator|++
control|)
name|scale_main
operator|=
name|RDIV
argument_list|(
name|scale_main
operator|*
name|scale_step
index|[
name|i
index|]
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|scale_act
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob_pass_thru
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndupl
condition|;
name|i
operator|++
control|)
name|gcc_assert
argument_list|(
name|scale_step
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|scale_step
index|[
name|i
index|]
operator|<=
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|scale_main
operator|>=
literal|0
operator|&&
name|scale_main
operator|<=
name|REG_BR_PROB_BASE
operator|&&
name|scale_act
operator|>=
literal|0
operator|&&
name|scale_act
operator|<=
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
comment|/* Loop the new bbs will belong to.  */
name|target
operator|=
name|e
operator|->
name|src
operator|->
name|loop_father
expr_stmt|;
comment|/* Original loops.  */
name|n_orig_loops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aloop
operator|=
name|loop
operator|->
name|inner
init|;
name|aloop
condition|;
name|aloop
operator|=
name|aloop
operator|->
name|next
control|)
name|n_orig_loops
operator|++
expr_stmt|;
name|orig_loops
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|loop
operator|*
argument_list|,
name|n_orig_loops
argument_list|)
expr_stmt|;
for|for
control|(
name|aloop
operator|=
name|loop
operator|->
name|inner
operator|,
name|i
operator|=
literal|0
init|;
name|aloop
condition|;
name|aloop
operator|=
name|aloop
operator|->
name|next
operator|,
name|i
operator|++
control|)
name|orig_loops
index|[
name|i
index|]
operator|=
name|aloop
expr_stmt|;
name|loop
operator|->
name|copy
operator|=
name|target
expr_stmt|;
name|first_active
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_latch
condition|)
block|{
name|memcpy
argument_list|(
name|first_active
argument_list|,
name|bbs
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|first_active_latch
operator|=
name|latch
expr_stmt|;
block|}
comment|/* Update the information about single exits.  */
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_SINGLE_EXITS
condition|)
name|update_single_exits_after_duplication
argument_list|(
name|bbs
argument_list|,
name|n
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Record exit edge in original loop body.  */
if|if
condition|(
name|orig
operator|&&
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
condition|)
name|to_remove
index|[
operator|(
operator|*
name|n_to_remove
operator|)
operator|++
index|]
operator|=
name|orig
expr_stmt|;
name|spec_edges
index|[
name|SE_ORIG
index|]
operator|=
name|orig
expr_stmt|;
name|spec_edges
index|[
name|SE_LATCH
index|]
operator|=
name|latch_edge
expr_stmt|;
name|place_after
operator|=
name|e
operator|->
name|src
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ndupl
condition|;
name|j
operator|++
control|)
block|{
comment|/* Copy loops.  */
name|copy_loops_to
argument_list|(
name|loops
argument_list|,
name|orig_loops
argument_list|,
name|n_orig_loops
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Copy bbs.  */
name|copy_bbs
argument_list|(
name|bbs
argument_list|,
name|n
argument_list|,
name|new_bbs
argument_list|,
name|spec_edges
argument_list|,
literal|2
argument_list|,
name|new_spec_edges
argument_list|,
name|loop
argument_list|,
name|place_after
argument_list|)
expr_stmt|;
name|place_after
operator|=
name|new_spec_edges
index|[
name|SE_LATCH
index|]
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DLTHE_RECORD_COPY_NUMBER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|new_bbs
index|[
name|i
index|]
operator|->
name|aux
argument_list|)
expr_stmt|;
name|new_bbs
index|[
name|i
index|]
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
call|(
name|size_t
call|)
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Note whether the blocks and edges belong to an irreducible loop.  */
if|if
condition|(
name|add_irreducible_flag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|new_bbs
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|BB_DUPLICATED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|new_bb
operator|=
name|new_bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new_bb
operator|->
name|loop_father
operator|==
name|target
condition|)
name|new_bb
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|ae
argument_list|,
argument|ei
argument_list|,
argument|new_bb->succs
argument_list|)
if|if
condition|(
operator|(
name|ae
operator|->
name|dest
operator|->
name|flags
operator|&
name|BB_DUPLICATED
operator|)
operator|&&
operator|(
name|ae
operator|->
name|src
operator|->
name|loop_father
operator|==
name|target
operator|||
name|ae
operator|->
name|dest
operator|->
name|loop_father
operator|==
name|target
operator|)
condition|)
name|ae
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|new_bbs
index|[
name|i
index|]
operator|->
name|flags
operator|&=
operator|~
name|BB_DUPLICATED
expr_stmt|;
block|}
comment|/* Redirect the special edges.  */
if|if
condition|(
name|is_latch
condition|)
block|{
name|redirect_edge_and_branch_force
argument_list|(
name|latch_edge
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|new_spec_edges
index|[
name|SE_LATCH
index|]
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|,
name|latch
argument_list|)
expr_stmt|;
name|latch
operator|=
name|loop
operator|->
name|latch
operator|=
name|new_bbs
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|e
operator|=
name|latch_edge
operator|=
name|new_spec_edges
index|[
name|SE_LATCH
index|]
expr_stmt|;
block|}
else|else
block|{
name|redirect_edge_and_branch_force
argument_list|(
name|new_spec_edges
index|[
name|SE_LATCH
index|]
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
name|e
operator|=
name|new_spec_edges
index|[
name|SE_LATCH
index|]
expr_stmt|;
block|}
comment|/* Record exit edge in this copy.  */
if|if
condition|(
name|orig
operator|&&
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
name|j
operator|+
literal|1
argument_list|)
condition|)
name|to_remove
index|[
operator|(
operator|*
name|n_to_remove
operator|)
operator|++
index|]
operator|=
name|new_spec_edges
index|[
name|SE_ORIG
index|]
expr_stmt|;
comment|/* Record the first copy in the control flow order if it is not 	 the original loop (i.e. in case of peeling).  */
if|if
condition|(
operator|!
name|first_active_latch
condition|)
block|{
name|memcpy
argument_list|(
name|first_active
argument_list|,
name|new_bbs
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|first_active_latch
operator|=
name|new_bbs
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* Set counts and frequencies.  */
if|if
condition|(
name|flags
operator|&
name|DLTHE_FLAG_UPDATE_FREQ
condition|)
block|{
name|scale_bbs_frequencies_int
argument_list|(
name|new_bbs
argument_list|,
name|n
argument_list|,
name|scale_act
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|scale_act
operator|=
name|RDIV
argument_list|(
name|scale_act
operator|*
name|scale_step
index|[
name|j
index|]
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|new_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|orig_loops
argument_list|)
expr_stmt|;
comment|/* Update the original loop.  */
if|if
condition|(
operator|!
name|is_latch
condition|)
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DLTHE_FLAG_UPDATE_FREQ
condition|)
block|{
name|scale_bbs_frequencies_int
argument_list|(
name|bbs
argument_list|,
name|n
argument_list|,
name|scale_main
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scale_step
argument_list|)
expr_stmt|;
block|}
comment|/* Update dominators of outer blocks if affected.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|dominated
decl_stmt|,
name|dom_bb
decl_stmt|,
modifier|*
name|dom_bbs
decl_stmt|;
name|int
name|n_dom_bbs
decl_stmt|,
name|j
decl_stmt|;
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
name|n_dom_bbs
operator|=
name|get_dominated_by
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
operator|&
name|dom_bbs
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_dom_bbs
condition|;
name|j
operator|++
control|)
block|{
name|dominated
operator|=
name|dom_bbs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|dominated
argument_list|)
condition|)
continue|continue;
name|dom_bb
operator|=
name|nearest_common_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|first_active
index|[
name|i
index|]
argument_list|,
name|first_active_latch
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dominated
argument_list|,
name|dom_bb
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dom_bbs
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|first_active
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A callback for make_forwarder block, to redirect all edges except for    MFB_KJ_EDGE to the entry part.  E is the edge for that we should decide    whether to redirect it.  */
end_comment

begin_decl_stmt
specifier|static
name|edge
name|mfb_kj_edge
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|mfb_keep_just
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
return|return
name|e
operator|!=
name|mfb_kj_edge
return|;
block|}
end_function

begin_comment
comment|/* A callback for make_forwarder block, to update data structures for a basic    block JUMP created by redirecting an edge (only the latch edge is being    redirected).  */
end_comment

begin_function
specifier|static
name|void
name|mfb_update_loops
parameter_list|(
name|basic_block
name|jump
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|single_succ
argument_list|(
name|jump
argument_list|)
operator|->
name|loop_father
decl_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
condition|)
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|jump
argument_list|,
name|single_pred
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|jump
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|latch
operator|=
name|jump
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates a pre-header for a LOOP.  Returns newly created block.  Unless    CP_SIMPLE_PREHEADERS is set in FLAGS, we only force LOOP to have single    entry; otherwise we also force preheader block to have only one successor.    The function also updates dominators.  */
end_comment

begin_function
specifier|static
name|basic_block
name|create_preheader
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
decl_stmt|,
name|fallthru
decl_stmt|;
name|basic_block
name|dummy
decl_stmt|;
name|struct
name|loop
modifier|*
name|cloop
decl_stmt|,
modifier|*
name|ploop
decl_stmt|;
name|int
name|nentry
init|=
literal|0
decl_stmt|;
name|bool
name|irred
init|=
name|false
decl_stmt|;
name|bool
name|latch_edge_was_fallthru
decl_stmt|;
name|edge
name|one_succ_pred
init|=
literal|0
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|cloop
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|loop->header->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
continue|continue;
name|irred
operator||=
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
operator|!=
literal|0
expr_stmt|;
name|nentry
operator|++
expr_stmt|;
if|if
condition|(
name|single_succ_p
argument_list|(
name|e
operator|->
name|src
argument_list|)
condition|)
name|one_succ_pred
operator|=
name|e
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|nentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentry
operator|==
literal|1
condition|)
block|{
comment|/* Get an edge that is different from the one from loop->latch 	 to loop->header.  */
name|e
operator|=
name|EDGE_PRED
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|EDGE_PRED
argument_list|(
name|loop
operator|->
name|header
argument_list|,
literal|0
argument_list|)
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CP_SIMPLE_PREHEADERS
operator|)
operator|||
name|single_succ_p
argument_list|(
name|e
operator|->
name|src
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|mfb_kj_edge
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|latch_edge_was_fallthru
operator|=
operator|(
name|mfb_kj_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
expr_stmt|;
name|fallthru
operator|=
name|make_forwarder_block
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|mfb_keep_just
argument_list|,
name|mfb_update_loops
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|fallthru
operator|->
name|src
expr_stmt|;
name|loop
operator|->
name|header
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
comment|/* The header could be a latch of some superloop(s); due to design of      split_block, it would now move to fallthru->dest.  */
for|for
control|(
name|ploop
operator|=
name|loop
init|;
name|ploop
condition|;
name|ploop
operator|=
name|ploop
operator|->
name|outer
control|)
if|if
condition|(
name|ploop
operator|->
name|latch
operator|==
name|dummy
condition|)
name|ploop
operator|->
name|latch
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
comment|/* Try to be clever in placing the newly created preheader.  The idea is to      avoid breaking any "fallthruness" relationship between blocks.       The preheader was created just before the header and all incoming edges      to the header were redirected to the preheader, except the latch edge.      So the only problematic case is when this latch edge was a fallthru      edge: it is not anymore after the preheader creation so we have broken      the fallthruness.  We're therefore going to look for a better place.  */
if|if
condition|(
name|latch_edge_was_fallthru
condition|)
block|{
if|if
condition|(
name|one_succ_pred
condition|)
name|e
operator|=
name|one_succ_pred
expr_stmt|;
else|else
name|e
operator|=
name|EDGE_PRED
argument_list|(
name|dummy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|move_block_after
argument_list|(
name|dummy
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
name|loop
operator|->
name|header
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|dummy
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
if|if
condition|(
name|irred
condition|)
block|{
name|dummy
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|single_succ_edge
argument_list|(
name|dummy
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Created preheader block for loop %i\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|dummy
return|;
block|}
end_function

begin_comment
comment|/* Create preheaders for each loop from loop tree stored in LOOPS; for meaning    of FLAGS see create_preheader.  */
end_comment

begin_function
name|void
name|create_preheaders
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|create_preheader
argument_list|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|loops
operator|->
name|state
operator||=
name|LOOPS_HAVE_PREHEADERS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forces all loop latches of loops from loop tree LOOPS to have only single    successor.  */
end_comment

begin_function
name|void
name|force_single_succ_latches
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|!=
name|loop
operator|->
name|header
operator|&&
name|single_succ_p
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
condition|)
continue|continue;
name|e
operator|=
name|find_edge
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|loops
operator|->
name|state
operator||=
name|LOOPS_HAVE_SIMPLE_LATCHES
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A quite stupid function to put INSNS on edge E. They are supposed to form    just one basic block.  Jumps in INSNS are not handled, so cfg do not have to    be ok after this function.  The created block is placed on correct place    in LOOPS structure and its dominator is set.  */
end_comment

begin_function
name|basic_block
name|loop_split_edge_with
parameter_list|(
name|edge
name|e
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|basic_block
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|new_bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop_c
decl_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|loop_c
operator|=
name|find_common_loop
argument_list|(
name|src
operator|->
name|loop_father
argument_list|,
name|dest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
comment|/* Create basic block for it.  */
name|new_bb
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|new_bb
argument_list|,
name|loop_c
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|flags
operator||=
operator|(
name|insns
condition|?
name|BB_SUPERBLOCK
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|insns
condition|)
name|emit_insn_after
argument_list|(
name|insns
argument_list|,
name|BB_END
argument_list|(
name|new_bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|==
name|src
condition|)
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|=
name|new_bb
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* This function is called from loop_version.  It splits the entry edge    of the loop we want to version, adds the versioning condition, and    adjust the edges to the two versions of the loop appropriately.    e is an incoming edge. Returns the basic block containing the    condition.     --- edge e ----> [second_head]     Split it and insert new conditional expression and adjust edges.      --- edge e ---> [cond expr] ---> [first_head] 			| 			+---------> [second_head] */
end_comment

begin_function
specifier|static
name|basic_block
name|lv_adjust_loop_entry_edge
parameter_list|(
name|basic_block
name|first_head
parameter_list|,
name|basic_block
name|second_head
parameter_list|,
name|edge
name|e
parameter_list|,
name|void
modifier|*
name|cond_expr
parameter_list|)
block|{
name|basic_block
name|new_head
init|=
name|NULL
decl_stmt|;
name|edge
name|e1
decl_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest
operator|==
name|second_head
argument_list|)
expr_stmt|;
comment|/* Split edge 'e'. This will create a new basic block, where we can      insert conditional expr.  */
name|new_head
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|lv_add_condition_to_bb
argument_list|(
name|first_head
argument_list|,
name|second_head
argument_list|,
name|new_head
argument_list|,
name|cond_expr
argument_list|)
expr_stmt|;
comment|/* Don't set EDGE_TRUE_VALUE in RTL mode, as it's invalid there.  */
name|e1
operator|=
name|make_edge
argument_list|(
name|new_head
argument_list|,
name|first_head
argument_list|,
name|ir_type
argument_list|()
condition|?
name|EDGE_TRUE_VALUE
else|:
literal|0
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|first_head
argument_list|,
name|new_head
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|second_head
argument_list|,
name|new_head
argument_list|)
expr_stmt|;
comment|/* Adjust loop header phi nodes.  */
name|lv_adjust_loop_header_phi
argument_list|(
name|first_head
argument_list|,
name|second_head
argument_list|,
name|new_head
argument_list|,
name|e1
argument_list|)
expr_stmt|;
return|return
name|new_head
return|;
block|}
end_function

begin_comment
comment|/* Main entry point for Loop Versioning transformation.     This transformation given a condition and a loop, creates    -if (condition) { loop_copy1 } else { loop_copy2 },    where loop_copy1 is the loop transformed in one way, and loop_copy2    is the loop transformed in another way (or unchanged). 'condition'    may be a run time test for things that were not resolved by static    analysis (overlapping ranges (anti-aliasing), alignment, etc.).     If PLACE_AFTER is true, we place the new loop after LOOP in the    instruction stream, otherwise it is placed before LOOP.  */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|loop_version
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|void
modifier|*
name|cond_expr
parameter_list|,
name|basic_block
modifier|*
name|condition_bb
parameter_list|,
name|bool
name|place_after
parameter_list|)
block|{
name|basic_block
name|first_head
decl_stmt|,
name|second_head
decl_stmt|;
name|edge
name|entry
decl_stmt|,
name|latch_edge
decl_stmt|,
name|exit
decl_stmt|,
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
name|int
name|irred_flag
decl_stmt|;
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|basic_block
name|cond_bb
decl_stmt|;
comment|/* CHECKME: Loop versioning does not handle nested loop at this point.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
return|return
name|NULL
return|;
comment|/* Record entry and latch edges for the loop */
name|entry
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|irred_flag
operator|=
name|entry
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
comment|/* Note down head of loop as first_head.  */
name|first_head
operator|=
name|entry
operator|->
name|dest
expr_stmt|;
comment|/* Duplicate loop.  */
if|if
condition|(
operator|!
name|cfg_hook_duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|entry
argument_list|,
name|loops
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* After duplication entry edge now points to new loop head block.      Note down new head as second_head.  */
name|second_head
operator|=
name|entry
operator|->
name|dest
expr_stmt|;
comment|/* Split loop entry edge and insert new block with cond expr.  */
name|cond_bb
operator|=
name|lv_adjust_loop_entry_edge
argument_list|(
name|first_head
argument_list|,
name|second_head
argument_list|,
name|entry
argument_list|,
name|cond_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|condition_bb
condition|)
operator|*
name|condition_bb
operator|=
name|cond_bb
expr_stmt|;
if|if
condition|(
operator|!
name|cond_bb
condition|)
block|{
name|entry
operator|->
name|flags
operator||=
name|irred_flag
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|latch_edge
operator|=
name|single_succ_edge
argument_list|(
name|get_bb_copy
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|extract_cond_bb_edges
argument_list|(
name|cond_bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
name|nloop
operator|=
name|loopify
argument_list|(
name|loops
argument_list|,
name|latch_edge
argument_list|,
name|single_pred_edge
argument_list|(
name|get_bb_copy
argument_list|(
name|loop
operator|->
name|header
argument_list|)
argument_list|)
argument_list|,
name|cond_bb
argument_list|,
name|true_edge
argument_list|,
name|false_edge
argument_list|,
name|false
comment|/* Do not redirect all edges.  */
argument_list|)
expr_stmt|;
name|exit
operator|=
name|loop
operator|->
name|single_exit
expr_stmt|;
if|if
condition|(
name|exit
condition|)
name|nloop
operator|->
name|single_exit
operator|=
name|find_edge
argument_list|(
name|get_bb_copy
argument_list|(
name|exit
operator|->
name|src
argument_list|)
argument_list|,
name|exit
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* loopify redirected latch_edge. Update its PENDING_STMTS.  */
name|lv_flush_pending_stmts
argument_list|(
name|latch_edge
argument_list|)
expr_stmt|;
comment|/* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */
name|extract_cond_bb_edges
argument_list|(
name|cond_bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
name|lv_flush_pending_stmts
argument_list|(
name|false_edge
argument_list|)
expr_stmt|;
comment|/* Adjust irreducible flag.  */
if|if
condition|(
name|irred_flag
condition|)
block|{
name|cond_bb
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|loop_preheader_edge
argument_list|(
name|nloop
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|single_pred_edge
argument_list|(
name|cond_bb
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
if|if
condition|(
name|place_after
condition|)
block|{
name|basic_block
modifier|*
name|bbs
init|=
name|get_loop_body_in_dom_order
argument_list|(
name|nloop
argument_list|)
decl_stmt|,
name|after
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|after
operator|=
name|loop
operator|->
name|latch
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nloop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|move_block_after
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|after
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
comment|/* At this point condition_bb is loop predheader with two successors,      first_head and second_head.   Make sure that loop predheader has only      one successor.  */
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|nloop
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|nloop
return|;
block|}
end_function

begin_comment
comment|/* The structure of LOOPS might have changed.  Some loops might get removed    (and their headers and latches were set to NULL), loop exists might get    removed (thus the loop nesting may be wrong), and some blocks and edges    were changed (so the information about bb --> loop mapping does not have    to be correct).  But still for the remaining loops the header dominates    the latch, and loops did not get new subloobs (new loops might possibly    get created, but we are not interested in them).  Fix up the mess.     If CHANGED_BBS is not NULL, basic blocks whose loop has changed are    marked in it.  */
end_comment

begin_function
name|void
name|fix_loop_structure
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|bitmap
name|changed_bbs
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|,
modifier|*
name|ploop
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* Remove the old bb -> loop mapping.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bb
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
name|bb
operator|->
name|loop_father
operator|->
name|depth
expr_stmt|;
name|bb
operator|->
name|loop_father
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
block|}
comment|/* Remove the dead loops from structures.  */
name|loops
operator|->
name|tree_root
operator|->
name|num_nodes
operator|=
name|n_basic_blocks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|loop
operator|->
name|num_nodes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|header
condition|)
continue|continue;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
name|ploop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
name|flow_loop_tree_node_remove
argument_list|(
name|ploop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|loop
operator|->
name|outer
argument_list|,
name|ploop
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the loop and free its data.  */
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
index|[
name|loop
operator|->
name|num
index|]
operator|=
name|NULL
expr_stmt|;
name|flow_loop_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
comment|/* Rescan the bodies of loops, starting from the outermost.  */
name|loop
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|!
name|loop
operator|->
name|next
operator|&&
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
name|loop
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|loop
operator|==
name|loops
operator|->
name|tree_root
condition|)
break|break;
name|loop
operator|=
name|loop
operator|->
name|next
expr_stmt|;
block|}
name|loop
operator|->
name|num_nodes
operator|=
name|flow_loop_nodes_find
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
comment|/* Now fix the loop nesting.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|bb
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|!=
name|loop
operator|->
name|outer
condition|)
block|{
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|bb
operator|->
name|loop_father
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark the blocks whose loop has changed.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|changed_bbs
operator|&&
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
name|bb
operator|->
name|loop_father
operator|->
name|depth
operator|!=
name|bb
operator|->
name|aux
condition|)
name|bitmap_set_bit
argument_list|(
name|changed_bbs
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_SINGLE_EXITS
condition|)
name|mark_single_exit_loops
argument_list|(
name|loops
argument_list|)
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
condition|)
name|mark_irreducible_loops
argument_list|(
name|loops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

