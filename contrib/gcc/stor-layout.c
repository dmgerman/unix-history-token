begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C-compiler utilities for types and variables storage layout    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1996, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* Data type for the expressions representing sizes of data types.    It is the first integer type laid out.  */
end_comment

begin_decl_stmt
name|tree
name|sizetype_tab
index|[
operator|(
name|int
operator|)
name|TYPE_KIND_LAST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, this is an upper limit on alignment of structure fields.    The value is measured in bits.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|maximum_field_alignment
init|=
name|TARGET_DEFAULT_PACK_STRUCT
operator|*
name|BITS_PER_UNIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ... and its original value in bytes, specified via -fpack-struct=<value>.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|initial_max_fld_align
init|=
name|TARGET_DEFAULT_PACK_STRUCT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if all REFERENCE_TYPEs are internal and hence should be    allocated in Pmode, not ptr_mode.   Set only by internal_reference_types    called only by a front end.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reference_types_internal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|finalize_record_size
parameter_list|(
name|record_layout_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finalize_type_size
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|place_union_field
parameter_list|(
name|record_layout_info
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PCC_BITFIELD_TYPE_MATTERS
argument_list|)
operator|||
name|defined
argument_list|(
name|BITFIELD_NBYTES_LIMITED
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|excess_unit_span
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|debug_rli
parameter_list|(
name|record_layout_info
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_sizes
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Show that REFERENCE_TYPES are internal and should be Pmode.  Called only    by front end.  */
end_comment

begin_function
name|void
name|internal_reference_types
parameter_list|(
name|void
parameter_list|)
block|{
name|reference_types_internal
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a list of all the objects put on the pending sizes list.  */
end_comment

begin_function
name|tree
name|get_pending_sizes
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|chain
init|=
name|pending_sizes
decl_stmt|;
name|pending_sizes
operator|=
literal|0
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Add EXPR to the pending sizes list.  */
end_comment

begin_function
name|void
name|put_pending_size
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
comment|/* Strip any simple arithmetic from EXPR to see if it has an underlying      SAVE_EXPR.  */
name|expr
operator|=
name|skip_simple_arithmetic
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|pending_sizes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|pending_sizes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put a chain of objects into the pending sizes list, which must be    empty.  */
end_comment

begin_function
name|void
name|put_pending_sizes
parameter_list|(
name|tree
name|chain
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|pending_sizes
argument_list|)
expr_stmt|;
name|pending_sizes
operator|=
name|chain
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a size SIZE that may not be a constant, return a SAVE_EXPR    to serve as the actual size-expression for a type or decl.  */
end_comment

begin_function
name|tree
name|variable_size
parameter_list|(
name|tree
name|size
parameter_list|)
block|{
name|tree
name|save
decl_stmt|;
comment|/* If the language-processor is to take responsibility for variable-sized      items (e.g., languages which have elaboration procedures like Ada),      just return SIZE unchanged.  Likewise for self-referential sizes and      constant sizes.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
operator|||
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
argument_list|()
operator|<
literal|0
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|size
argument_list|)
condition|)
return|return
name|size
return|;
name|size
operator|=
name|save_expr
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* If an array with a variable number of elements is declared, and      the elements require destruction, we will emit a cleanup for the      array.  That cleanup is run both on normal exit from the block      and in the exception-handler for the block.  Normally, when code      is used in both ordinary code and in an exception handler it is      `unsaved', i.e., all SAVE_EXPRs are recalculated.  However, we do      not wish to do that here; the array-size is the same in both      places.  */
name|save
operator|=
name|skip_simple_arithmetic
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|&&
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
condition|)
comment|/* The front-end doesn't want us to keep a list of the expressions        that determine sizes for variable size objects.  Trust it.  */
return|return
name|size
return|;
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
name|error
argument_list|(
literal|"type size can%'t be explicitly evaluated"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"variable-size type declared outside of any function"
argument_list|)
expr_stmt|;
return|return
name|size_one_node
return|;
block|}
name|put_pending_size
argument_list|(
name|save
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_FIXED_MODE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_FIXED_MODE_SIZE
value|GET_MODE_BITSIZE (DImode)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the machine mode to use for a nonscalar of SIZE bits.  The    mode must be in class CLASS, and have exactly that many value bits;    it may have padding as well.  If LIMIT is nonzero, modes of wider    than MAX_FIXED_MODE_SIZE will not be used.  */
end_comment

begin_function
name|enum
name|machine_mode
name|mode_for_size
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|,
name|enum
name|mode_class
name|class
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|limit
operator|&&
name|size
operator|>
name|MAX_FIXED_MODE_SIZE
condition|)
return|return
name|BLKmode
return|;
comment|/* Get the first mode which has this size, in the specified class.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|class
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
operator|==
name|size
condition|)
return|return
name|mode
return|;
return|return
name|BLKmode
return|;
block|}
end_function

begin_comment
comment|/* Similar, except passed a tree node.  */
end_comment

begin_function
name|enum
name|machine_mode
name|mode_for_size_tree
parameter_list|(
name|tree
name|size
parameter_list|,
name|enum
name|mode_class
name|class
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|uhwi
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|BLKmode
return|;
name|uhwi
operator|=
name|tree_low_cst
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ui
operator|=
name|uhwi
expr_stmt|;
if|if
condition|(
name|uhwi
operator|!=
name|ui
condition|)
return|return
name|BLKmode
return|;
return|return
name|mode_for_size
argument_list|(
name|ui
argument_list|,
name|class
argument_list|,
name|limit
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but never return BLKmode; return the narrowest mode that    contains at least the requested number of value bits.  */
end_comment

begin_function
name|enum
name|machine_mode
name|smallest_mode_for_size
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|,
name|enum
name|mode_class
name|class
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Get the first mode which has at least this size, in the      specified class.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|class
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
operator|>=
name|size
condition|)
return|return
name|mode
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find an integer mode of the exact same size, or BLKmode on failure.  */
end_comment

begin_function
name|enum
name|machine_mode
name|int_mode_for_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
break|break;
case|case
name|MODE_COMPLEX_INT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_DECIMAL_FLOAT
case|:
case|case
name|MODE_VECTOR_INT
case|:
case|case
name|MODE_VECTOR_FLOAT
case|:
name|mode
operator|=
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_RANDOM
case|:
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
break|break;
comment|/* ... fall through ...  */
case|case
name|MODE_CC
case|:
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Return the alignment of MODE. This will be bounded by 1 and    BIGGEST_ALIGNMENT.  */
end_comment

begin_function
name|unsigned
name|int
name|get_mode_alignment
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|mode_base_align
index|[
name|mode
index|]
operator|*
name|BITS_PER_UNIT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of layout_decl: Force alignment required for the data type.    But if the decl itself wants greater alignment, don't override that.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|do_type_align
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the size, mode and alignment of a ..._DECL node.    TYPE_DECL does need this for C++.    Note that LABEL_DECL and CONST_DECL nodes do not need this,    and FUNCTION_DECL nodes have them set up in a special (and simple) way.    Don't call layout_decl for them.     KNOWN_ALIGN is the amount of alignment we can assume this    decl has with no special effort.  It is relevant only for FIELD_DECLs    and depends on the previous fields.    All that matters about KNOWN_ALIGN is which powers of 2 divide it.    If KNOWN_ALIGN is 0, it means, "as much alignment as you like":    the record will be aligned to suit.  */
end_comment

begin_function
name|void
name|layout_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|unsigned
name|int
name|known_align
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|rtl
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
return|return;
name|gcc_assert
argument_list|(
name|code
operator|==
name|VAR_DECL
operator|||
name|code
operator|==
name|PARM_DECL
operator|||
name|code
operator|==
name|RESULT_DECL
operator|||
name|code
operator|==
name|TYPE_DECL
operator|||
name|code
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|rtl
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
comment|/* Usually the size and mode come from the data type without change,      however, the front-end may set the explicit width of the field, so its      size may not be the same as the size of its type.  This happens with      bitfields, of course (an `int' bitfield may be only 2 bits, say), but it      also happens with other fields.  For example, the C++ front-end creates      zero-sized fields corresponding to empty base classes, and depends on      layout_type setting DECL_FIELD_BITPOS correctly for the field.  Set the      size in bytes from the size in bits.  If we have already set the mode,      don't set it again since we can be called twice for FIELD_DECLs.  */
name|DECL_UNSIGNED
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VOIDmode
condition|)
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|FIELD_DECL
condition|)
comment|/* For non-fields, update the alignment from the type.  */
name|do_type_align
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* For fields, it's a bit more complicated...  */
block|{
name|bool
name|old_user_align
init|=
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|bool
name|zero_bitfield
init|=
name|false
decl_stmt|;
name|bool
name|packed_p
init|=
name|DECL_PACKED
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mfa
decl_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* A zero-length bit-field affects the alignment of the next 	     field.  In essence such bit-fields are not influenced by 	     any packing due to #pragma pack or attribute packed.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|zero_bitfield
operator|=
name|true
expr_stmt|;
name|packed_p
operator|=
name|false
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
condition|)
name|do_type_align
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
if|if
condition|(
name|EMPTY_FIELD_BOUNDARY
operator|>
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|EMPTY_FIELD_BOUNDARY
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* See if we can use an ordinary integer mode for a bit-field. 	     Conditions are: a fixed size that is correct for another mode 	     and occupying a complete byte or bytes on proper boundary.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
name|enum
name|machine_mode
name|xmode
init|=
name|mode_for_size_tree
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|xmode
operator|!=
name|BLKmode
operator|&&
operator|(
name|known_align
operator|==
literal|0
operator|||
name|known_align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
operator|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|xmode
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Turn off DECL_BIT_FIELD if we won't need it set.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
operator|&&
name|known_align
operator|>=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|>=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|packed_p
operator|&&
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Don't touch DECL_ALIGN.  For other packed fields, go ahead and 	   round up; we'll reduce it again below.  We want packing to 	   supersede USER_ALIGN inherited from the type, but defer to 	   alignment explicitly specified on the field decl.  */
empty_stmt|;
else|else
name|do_type_align
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If the field is of variable size, we can't misalign it since we 	 have no way to make a temporary to align the result.  But this 	 isn't an issue if the decl is not addressable.  Likewise if it 	 is of unknown size.  	 Note that do_type_align may set DECL_USER_ALIGN, so we need to 	 check old_user_align instead.  */
if|if
condition|(
name|packed_p
operator|&&
operator|!
name|old_user_align
operator|&&
operator|(
name|DECL_NONADDRESSABLE_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MIN
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|packed_p
operator|&&
operator|!
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Some targets (i.e. i386, VMS) limit struct field alignment 	     to a lower boundary than alignment of variables unless 	     it was overridden by attribute aligned.  */
ifdef|#
directive|ifdef
name|BIGGEST_FIELD_ALIGNMENT
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MIN
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|BIGGEST_FIELD_ALIGNMENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ADJUST_FIELD_ALIGN
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|ADJUST_FIELD_ALIGN
argument_list|(
name|decl
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|zero_bitfield
condition|)
name|mfa
operator|=
name|initial_max_fld_align
operator|*
name|BITS_PER_UNIT
expr_stmt|;
else|else
name|mfa
operator|=
name|maximum_field_alignment
expr_stmt|;
comment|/* Should this be controlled by DECL_USER_ALIGN, too?  */
if|if
condition|(
name|mfa
operator|!=
literal|0
condition|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MIN
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|,
name|mfa
argument_list|)
expr_stmt|;
block|}
comment|/* Evaluate nonconstant size only once, either now or as soon as safe.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|variable_size
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|variable_size
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If requested, warn about definitions of large data objects.  */
if|if
condition|(
name|warn_larger_than
operator|&&
operator|(
name|code
operator|==
name|VAR_DECL
operator|||
name|code
operator|==
name|PARM_DECL
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|size
init|=
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|size
argument_list|,
name|larger_than_size
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|size_as_int
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|size
argument_list|,
name|size_as_int
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"size of %q+D is %d bytes"
argument_list|,
name|decl
argument_list|,
name|size_as_int
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"size of %q+D is larger than %wd bytes"
argument_list|,
name|decl
argument_list|,
name|larger_than_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the RTL was already set, update its mode and mem attributes.  */
if|if
condition|(
name|rtl
condition|)
block|{
name|PUT_MODE
argument_list|(
name|rtl
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|rtl
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a VAR_DECL, PARM_DECL or RESULT_DECL, clears the results of    a previous call to layout_decl and calls it again.  */
end_comment

begin_function
name|void
name|relayout_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook for a front-end function that can modify the record layout as needed    immediately before it is finalized.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|lang_adjust_rli
function_decl|)
parameter_list|(
name|record_layout_info
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_function
name|void
name|set_lang_adjust_rli
parameter_list|(
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|record_layout_info
parameter_list|)
parameter_list|)
block|{
name|lang_adjust_rli
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin laying out type T, which may be a RECORD_TYPE, UNION_TYPE, or    QUAL_UNION_TYPE.  Return a pointer to a struct record_layout_info which    is to be passed to all other layout functions for this record.  It is the    responsibility of the caller to call `free' for the storage returned.    Note that garbage collection is not permitted until we finish laying    out the record.  */
end_comment

begin_function
name|record_layout_info
name|start_record_layout
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|record_layout_info
name|rli
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|record_layout_info_s
argument_list|)
argument_list|)
decl_stmt|;
name|rli
operator|->
name|t
operator|=
name|t
expr_stmt|;
comment|/* If the type has a minimum specified alignment (via an attribute      declaration, for example) use it -- otherwise, start with a      one-byte alignment.  */
name|rli
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|rli
operator|->
name|unpacked_align
operator|=
name|rli
operator|->
name|record_align
expr_stmt|;
name|rli
operator|->
name|offset_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|record_align
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
comment|/* Packed structures don't need to have minimum size.  */
if|if
condition|(
operator|!
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
condition|)
name|rli
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|record_align
argument_list|,
operator|(
name|unsigned
operator|)
name|STRUCTURE_SIZE_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rli
operator|->
name|offset
operator|=
name|size_zero_node
expr_stmt|;
name|rli
operator|->
name|bitpos
operator|=
name|bitsize_zero_node
expr_stmt|;
name|rli
operator|->
name|prev_field
operator|=
literal|0
expr_stmt|;
name|rli
operator|->
name|pending_statics
operator|=
literal|0
expr_stmt|;
name|rli
operator|->
name|packed_maybe_necessary
operator|=
literal|0
expr_stmt|;
name|rli
operator|->
name|remaining_in_alignment
operator|=
literal|0
expr_stmt|;
return|return
name|rli
return|;
block|}
end_function

begin_comment
comment|/* These four routines perform computations that convert between    the offset/bitpos forms and byte and bit offsets.  */
end_comment

begin_function
name|tree
name|bit_from_pos
parameter_list|(
name|tree
name|offset
parameter_list|,
name|tree
name|bitpos
parameter_list|)
block|{
return|return
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bitpos
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|bitsizetype
argument_list|,
name|offset
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|byte_from_pos
parameter_list|(
name|tree
name|offset
parameter_list|,
name|tree
name|bitpos
parameter_list|)
block|{
return|return
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|bitpos
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|pos_from_bit
parameter_list|(
name|tree
modifier|*
name|poffset
parameter_list|,
name|tree
modifier|*
name|pbitpos
parameter_list|,
name|unsigned
name|int
name|off_align
parameter_list|,
name|tree
name|pos
parameter_list|)
block|{
operator|*
name|poffset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|pos
argument_list|,
name|bitsize_int
argument_list|(
name|off_align
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|off_align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbitpos
operator|=
name|size_binop
argument_list|(
name|FLOOR_MOD_EXPR
argument_list|,
name|pos
argument_list|,
name|bitsize_int
argument_list|(
name|off_align
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to bit and byte offsets and an offset alignment,    normalize the offsets so they are within the alignment.  */
end_comment

begin_function
name|void
name|normalize_offset
parameter_list|(
name|tree
modifier|*
name|poffset
parameter_list|,
name|tree
modifier|*
name|pbitpos
parameter_list|,
name|unsigned
name|int
name|off_align
parameter_list|)
block|{
comment|/* If the bit position is now larger than it should be, adjust it      downwards.  */
if|if
condition|(
name|compare_tree_int
argument_list|(
operator|*
name|pbitpos
argument_list|,
name|off_align
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tree
name|extra_aligns
init|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
operator|*
name|pbitpos
argument_list|,
name|bitsize_int
argument_list|(
name|off_align
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|poffset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|poffset
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|extra_aligns
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|off_align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbitpos
operator|=
name|size_binop
argument_list|(
name|FLOOR_MOD_EXPR
argument_list|,
operator|*
name|pbitpos
argument_list|,
name|bitsize_int
argument_list|(
name|off_align
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print debugging information about the information in RLI.  */
end_comment

begin_function
name|void
name|debug_rli
parameter_list|(
name|record_layout_info
name|rli
parameter_list|)
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"type"
argument_list|,
name|rli
operator|->
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"\noffset"
argument_list|,
name|rli
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|" bitpos"
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\naligns: rec = %u, unpack = %u, off = %u\n"
argument_list|,
name|rli
operator|->
name|record_align
argument_list|,
name|rli
operator|->
name|unpacked_align
argument_list|,
name|rli
operator|->
name|offset_align
argument_list|)
expr_stmt|;
comment|/* The ms_struct code is the only that uses this.  */
if|if
condition|(
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|rli
operator|->
name|t
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"remaining in alignment = %u\n"
argument_list|,
name|rli
operator|->
name|remaining_in_alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|rli
operator|->
name|packed_maybe_necessary
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"packed may be necessary\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rli
operator|->
name|pending_statics
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pending statics:\n"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|rli
operator|->
name|pending_statics
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given an RLI with a possibly-incremented BITPOS, adjust OFFSET and    BITPOS if necessary to keep BITPOS below OFFSET_ALIGN.  */
end_comment

begin_function
name|void
name|normalize_rli
parameter_list|(
name|record_layout_info
name|rli
parameter_list|)
block|{
name|normalize_offset
argument_list|(
operator|&
name|rli
operator|->
name|offset
argument_list|,
operator|&
name|rli
operator|->
name|bitpos
argument_list|,
name|rli
operator|->
name|offset_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the size in bytes allocated so far.  */
end_comment

begin_function
name|tree
name|rli_size_unit_so_far
parameter_list|(
name|record_layout_info
name|rli
parameter_list|)
block|{
return|return
name|byte_from_pos
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the size in bits allocated so far.  */
end_comment

begin_function
name|tree
name|rli_size_so_far
parameter_list|(
name|record_layout_info
name|rli
parameter_list|)
block|{
return|return
name|bit_from_pos
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FIELD is about to be added to RLI->T.  The alignment (in bits) of    the next available location within the record is given by KNOWN_ALIGN.    Update the variable alignment fields in RLI, and return the alignment    to give the FIELD.  */
end_comment

begin_function
name|unsigned
name|int
name|update_alignment_for_field
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|tree
name|field
parameter_list|,
name|unsigned
name|int
name|known_align
parameter_list|)
block|{
comment|/* The alignment required for FIELD.  */
name|unsigned
name|int
name|desired_align
decl_stmt|;
comment|/* The type of this field.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* True if the field was explicitly aligned by the user.  */
name|bool
name|user_align
decl_stmt|;
name|bool
name|is_bitfield
decl_stmt|;
comment|/* Do not attempt to align an ERROR_MARK node */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
comment|/* Lay out the field so we know what alignment it needs.  */
name|layout_decl
argument_list|(
name|field
argument_list|,
name|known_align
argument_list|)
expr_stmt|;
name|desired_align
operator|=
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|user_align
operator|=
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|is_bitfield
operator|=
operator|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Record must have at least as much alignment as any field.      Otherwise, the alignment of the field within the record is      meaningless.  */
if|if
condition|(
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|rli
operator|->
name|t
argument_list|)
condition|)
block|{
comment|/* Here, the alignment of the underlying type of a bitfield can 	 affect the alignment of a record; even a zero-sized field 	 can do this.  The alignment should be to the alignment of 	 the type, except that for zero-size bitfields this only 	 applies if there was an immediately prior, nonzero-size 	 bitfield.  (That's the way it is, experimentally.) */
if|if
condition|(
operator|(
operator|!
name|is_bitfield
operator|&&
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|?
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
else|:
operator|(
name|rli
operator|->
name|prev_field
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|rli
operator|->
name|prev_field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|rli
operator|->
name|prev_field
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type_align
operator|=
name|MAX
argument_list|(
name|type_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
name|rli
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|record_align
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
name|rli
operator|->
name|unpacked_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|unpacked_align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
elseif|else
if|if
condition|(
name|is_bitfield
operator|&&
name|PCC_BITFIELD_TYPE_MATTERS
condition|)
block|{
comment|/* Named bit-fields cause the entire structure to have the 	 alignment implied by their type.  Some targets also apply the same 	 rules to unnamed bitfields.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
operator|||
name|targetm
operator|.
name|align_anon_bitfield
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_FIELD_ALIGN
if|if
condition|(
operator|!
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
name|type_align
operator|=
name|ADJUST_FIELD_ALIGN
argument_list|(
name|field
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Targets might chose to handle unnamed and hence possibly 	     zero-width bitfield.  Those are not influenced by #pragmas 	     or packed attributes.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|initial_max_fld_align
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|initial_max_fld_align
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* The alignment of the record is increased to the maximum 	     of the current alignment, the alignment indicated on the 	     field (i.e., the alignment specified by an __aligned__ 	     attribute), and the alignment indicated by the type of 	     the field.  */
name|rli
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
name|rli
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|record_align
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_packed
condition|)
name|rli
operator|->
name|unpacked_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|unpacked_align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|user_align
operator||=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
name|rli
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
name|rli
operator|->
name|unpacked_align
operator|=
name|MAX
argument_list|(
name|rli
operator|->
name|unpacked_align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_USER_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator||=
name|user_align
expr_stmt|;
return|return
name|desired_align
return|;
block|}
end_function

begin_comment
comment|/* Called from place_field to handle unions.  */
end_comment

begin_function
specifier|static
name|void
name|place_union_field
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|tree
name|field
parameter_list|)
block|{
name|update_alignment_for_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|,
comment|/*known_align=*/
literal|0
argument_list|)
expr_stmt|;
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|SET_DECL_OFFSET_ALIGN
argument_list|(
name|field
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* If this is an ERROR_MARK return *after* having set the      field at the start of the union. This helps when parsing      invalid fields. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* We assume the union's size will be a multiple of a byte so we don't      bother with BITPOS.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|rli
operator|->
name|offset
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|rli
operator|->
name|offset
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|rli
operator|->
name|offset
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|sizetype
argument_list|,
name|DECL_QUALIFIER
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
name|rli
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PCC_BITFIELD_TYPE_MATTERS
argument_list|)
operator|||
name|defined
argument_list|(
name|BITFIELD_NBYTES_LIMITED
argument_list|)
end_if

begin_comment
comment|/* A bitfield of SIZE with a required access alignment of ALIGN is allocated    at BYTE_OFFSET / BIT_OFFSET.  Return nonzero if the field would span more    units of alignment than the underlying TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|excess_unit_span
parameter_list|(
name|HOST_WIDE_INT
name|byte_offset
parameter_list|,
name|HOST_WIDE_INT
name|bit_offset
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|HOST_WIDE_INT
name|align
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Note that the calculation of OFFSET might overflow; we calculate it so      that we still get the right result as long as ALIGN is a power of two.  */
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
name|byte_offset
operator|*
name|BITS_PER_UNIT
operator|+
name|bit_offset
decl_stmt|;
name|offset
operator|=
name|offset
operator|%
name|align
expr_stmt|;
return|return
operator|(
operator|(
name|offset
operator|+
name|size
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
operator|>
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RLI contains information about the layout of a RECORD_TYPE.  FIELD    is a FIELD_DECL to be added after those fields already present in    T.  (FIELD is not actually added to the TYPE_FIELDS list here;    callers that desire that behavior must manually perform that step.)  */
end_comment

begin_function
name|void
name|place_field
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|tree
name|field
parameter_list|)
block|{
comment|/* The alignment required for FIELD.  */
name|unsigned
name|int
name|desired_align
decl_stmt|;
comment|/* The alignment FIELD would have if we just dropped it into the      record as it presently stands.  */
name|unsigned
name|int
name|known_align
decl_stmt|;
name|unsigned
name|int
name|actual_align
decl_stmt|;
comment|/* The type of this field.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|ERROR_MARK
argument_list|)
expr_stmt|;
comment|/* If FIELD is static, then treat it like a separate variable, not      really like a structure field.  If it is a FUNCTION_DECL, it's a      method.  In both cases, all we do is lay out the decl, and we do      it *after* the record is laid out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|rli
operator|->
name|pending_statics
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|rli
operator|->
name|pending_statics
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Enumerators and enum types which are local to this class need not      be laid out.  Likewise for initialized constant fields.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
return|return;
comment|/* Unions are laid out very differently than records, so split      that code off to another function.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|place_union_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
comment|/* Place this field at the current allocation position, so we 	 maintain monotonicity.  */
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|rli
operator|->
name|offset
expr_stmt|;
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|rli
operator|->
name|bitpos
expr_stmt|;
name|SET_DECL_OFFSET_ALIGN
argument_list|(
name|field
argument_list|,
name|rli
operator|->
name|offset_align
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Work out the known alignment so far.  Note that A& (-A) is the      value of the least-significant bit in A that is one.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|)
condition|)
name|known_align
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
literal|1
argument_list|)
operator|&
operator|-
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|rli
operator|->
name|offset
argument_list|)
condition|)
name|known_align
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
literal|1
argument_list|)
condition|)
name|known_align
operator|=
operator|(
name|BITS_PER_UNIT
operator|*
operator|(
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
literal|1
argument_list|)
operator|&
operator|-
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
expr_stmt|;
else|else
name|known_align
operator|=
name|rli
operator|->
name|offset_align
expr_stmt|;
name|desired_align
operator|=
name|update_alignment_for_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|,
name|known_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|known_align
operator|==
literal|0
condition|)
name|known_align
operator|=
name|MAX
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|rli
operator|->
name|record_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_packed
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|known_align
operator|>=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|desired_align
condition|)
block|{
if|if
condition|(
name|STRICT_ALIGNMENT
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"packed attribute causes "
literal|"inefficient alignment for %q+D"
argument_list|,
name|field
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"packed attribute is "
literal|"unnecessary for %q+D"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|rli
operator|->
name|packed_maybe_necessary
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Does this field automatically have alignment it needs by virtue      of the fields that precede it and the record's own alignment?      We already align ms_struct fields, so don't re-align them.  */
if|if
condition|(
name|known_align
operator|<
name|desired_align
operator|&&
operator|!
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|rli
operator|->
name|t
argument_list|)
condition|)
block|{
comment|/* No, we need to skip space before this field. 	 Bump the cumulative size to multiple of field alignment.  */
name|warning
argument_list|(
name|OPT_Wpadded
argument_list|,
literal|"padding struct to align %q+D"
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* If the alignment is still within offset_align, just align 	 the bit position.  */
if|if
condition|(
name|desired_align
operator|<
name|rli
operator|->
name|offset_align
condition|)
name|rli
operator|->
name|bitpos
operator|=
name|round_up
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* First adjust OFFSET by the partial bits, then align.  */
name|rli
operator|->
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|offset
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rli
operator|->
name|bitpos
operator|=
name|bitsize_zero_node
expr_stmt|;
name|rli
operator|->
name|offset
operator|=
name|round_up
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
name|desired_align
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|rli
operator|->
name|offset
argument_list|)
condition|)
name|rli
operator|->
name|offset_align
operator|=
name|desired_align
expr_stmt|;
block|}
comment|/* Handle compatibility with PCC.  Note that if the record has any      variable-sized fields, we need not worry about compatibility.  */
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
operator|&&
operator|!
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|type
operator|!=
name|error_mark_node
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
operator|&&
name|maximum_field_alignment
operator|==
literal|0
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|dsize
init|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|field_size
init|=
name|tree_low_cst
argument_list|(
name|dsize
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bit_offset
init|=
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_FIELD_ALIGN
if|if
condition|(
operator|!
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
name|type_align
operator|=
name|ADJUST_FIELD_ALIGN
argument_list|(
name|field
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A bit field may not span more units of alignment of its type 	 than its type itself.  Advance to next boundary if necessary.  */
if|if
condition|(
name|excess_unit_span
argument_list|(
name|offset
argument_list|,
name|bit_offset
argument_list|,
name|field_size
argument_list|,
name|type_align
argument_list|,
name|type
argument_list|)
condition|)
name|rli
operator|->
name|bitpos
operator|=
name|round_up
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator||=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BITFIELD_NBYTES_LIMITED
if|if
condition|(
name|BITFIELD_NBYTES_LIMITED
operator|&&
operator|!
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|type
operator|!=
name|error_mark_node
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|dsize
init|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|field_size
init|=
name|tree_low_cst
argument_list|(
name|dsize
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bit_offset
init|=
name|tree_low_cst
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_FIELD_ALIGN
if|if
condition|(
operator|!
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
name|type_align
operator|=
name|ADJUST_FIELD_ALIGN
argument_list|(
name|field
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
comment|/* ??? This test is opposite the test in the containing if 	 statement, so this code is unreachable currently.  */
elseif|else
if|if
condition|(
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* A bit field may not span the unit of alignment of its type. 	 Advance to next boundary if necessary.  */
if|if
condition|(
name|excess_unit_span
argument_list|(
name|offset
argument_list|,
name|bit_offset
argument_list|,
name|field_size
argument_list|,
name|type_align
argument_list|,
name|type
argument_list|)
condition|)
name|rli
operator|->
name|bitpos
operator|=
name|round_up
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator||=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* See the docs for TARGET_MS_BITFIELD_LAYOUT_P for details.      A subtlety: 	When a bit field is inserted into a packed record, the whole 	size of the underlying type is used by one or more same-size 	adjacent bitfields.  (That is, if its long:3, 32 bits is 	used in the record, and any additional adjacent long bitfields are 	packed into the same chunk of 32 bits. However, if the size 	changes, a new field of that size is allocated.)  In an unpacked 	record, this is the same as using alignment, but not equivalent 	when packing.       Note: for compatibility, we use the type size, not the type alignment      to determine alignment, since that matches the documentation */
if|if
condition|(
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|rli
operator|->
name|t
argument_list|)
condition|)
block|{
name|tree
name|prev_saved
init|=
name|rli
operator|->
name|prev_field
decl_stmt|;
name|tree
name|prev_type
init|=
name|prev_saved
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|prev_saved
argument_list|)
else|:
name|NULL
decl_stmt|;
comment|/* This is a bitfield if it exists.  */
if|if
condition|(
name|rli
operator|->
name|prev_field
condition|)
block|{
comment|/* If both are bitfields, nonzero, and the same size, this is 	     the middle of a run.  Zero declared size fields are special 	     and handled as "end of run". (Note: it's nonzero declared 	     size, but equal type sizes!) (Since we know that both 	     the current and previous fields are bitfields by the 	     time we check it, DECL_SIZE must be present for both.) */
if|if
condition|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|rli
operator|->
name|prev_field
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|rli
operator|->
name|prev_field
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|prev_type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We're in the middle of a run of equal type size fields; make 		 sure we realign if we run out of bits.  (Not decl size, 		 type size!) */
name|HOST_WIDE_INT
name|bitsize
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rli
operator|->
name|remaining_in_alignment
operator|<
name|bitsize
condition|)
block|{
name|HOST_WIDE_INT
name|typesize
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* out of bits; bump up to next 'word'.  */
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|bitsize_int
argument_list|(
name|rli
operator|->
name|remaining_in_alignment
argument_list|)
argument_list|)
expr_stmt|;
name|rli
operator|->
name|prev_field
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|typesize
operator|<
name|bitsize
condition|)
name|rli
operator|->
name|remaining_in_alignment
operator|=
literal|0
expr_stmt|;
else|else
name|rli
operator|->
name|remaining_in_alignment
operator|=
name|typesize
operator|-
name|bitsize
expr_stmt|;
block|}
else|else
name|rli
operator|->
name|remaining_in_alignment
operator|-=
name|bitsize
expr_stmt|;
block|}
else|else
block|{
comment|/* End of a run: if leaving a run of bitfields of the same type 		 size, we have to "use up" the rest of the bits of the type 		 size.  		 Compute the new position as the sum of the size for the prior 		 type and where we first started working on that type. 		 Note: since the beginning of the field was aligned then 		 of course the end will be too.  No round needed.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|rli
operator|->
name|prev_field
argument_list|)
argument_list|)
condition|)
block|{
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|bitsize_int
argument_list|(
name|rli
operator|->
name|remaining_in_alignment
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We "use up" size zero fields; the code below should behave 		   as if the prior field was not a bitfield.  */
name|prev_saved
operator|=
name|NULL
expr_stmt|;
comment|/* Cause a new bitfield to be captured, either this time (if 		 currently a bitfield) or next time we see one.  */
if|if
condition|(
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|rli
operator|->
name|prev_field
operator|=
name|NULL
expr_stmt|;
block|}
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
comment|/* If we're starting a new run of same size type bitfields 	 (or a run of non-bitfields), set up the "first of the run" 	 fields.  	 That is, if the current field is not a bitfield, or if there 	 was a prior bitfield the type sizes differ, or if there wasn't 	 a prior bitfield the size of the current field is nonzero.  	 Note: we must be sure to test ONLY the type size if there was 	 a prior bitfield and ONLY for the current field being zero if 	 there wasn't.  */
if|if
condition|(
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|||
operator|(
name|prev_saved
operator|!=
name|NULL
condition|?
operator|!
name|simple_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|prev_type
argument_list|)
argument_list|)
else|:
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Never smaller than a byte for compatibility.  */
name|unsigned
name|int
name|type_align
init|=
name|BITS_PER_UNIT
decl_stmt|;
comment|/* (When not a bitfield), we could be seeing a flex array (with 	     no DECL_SIZE).  Since we won't be using remaining_in_alignment 	     until we see a bitfield (and come by here again) we just skip 	     calculating it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|bitsize
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|typesize
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|typesize
operator|<
name|bitsize
condition|)
name|rli
operator|->
name|remaining_in_alignment
operator|=
literal|0
expr_stmt|;
else|else
name|rli
operator|->
name|remaining_in_alignment
operator|=
name|typesize
operator|-
name|bitsize
expr_stmt|;
block|}
comment|/* Now align (conventionally) for the new type.  */
name|type_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
name|rli
operator|->
name|bitpos
operator|=
name|round_up
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
comment|/* If we really aligned, don't allow subsequent bitfields 	     to undo that.  */
name|rli
operator|->
name|prev_field
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Offset so far becomes the position of this field after normalizing.  */
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|rli
operator|->
name|offset
expr_stmt|;
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|rli
operator|->
name|bitpos
expr_stmt|;
name|SET_DECL_OFFSET_ALIGN
argument_list|(
name|field
argument_list|,
name|rli
operator|->
name|offset_align
argument_list|)
expr_stmt|;
comment|/* If this field ended up more aligned than we thought it would be (we      approximate this by seeing if its position changed), lay out the field      again; perhaps we can use an integral mode for it now.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|actual_align
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&
operator|-
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|actual_align
operator|=
name|MAX
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|rli
operator|->
name|record_align
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|actual_align
operator|=
operator|(
name|BITS_PER_UNIT
operator|*
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&
operator|-
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
expr_stmt|;
else|else
name|actual_align
operator|=
name|DECL_OFFSET_ALIGN
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* ACTUAL_ALIGN is still the actual alignment *within the record* .      store / extract bit field operations will check the alignment of the      record against the mode of bit fields.  */
if|if
condition|(
name|known_align
operator|!=
name|actual_align
condition|)
name|layout_decl
argument_list|(
name|field
argument_list|,
name|actual_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|rli
operator|->
name|prev_field
operator|==
name|NULL
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
condition|)
name|rli
operator|->
name|prev_field
operator|=
name|field
expr_stmt|;
comment|/* Now add size of this field to the size of the record.  If the size is      not constant, treat the field as being a multiple of bytes and just      adjust the offset, resetting the bit position.  Otherwise, apportion the      size amongst the bit position and offset.  First handle the case of an      unspecified size, which can happen when we have an invalid nested struct      definition, such as struct j { struct j { int i; } }.  The error message      is printed in finish_struct.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
comment|/* Do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|rli
operator|->
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|offset
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rli
operator|->
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|offset
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|rli
operator|->
name|bitpos
operator|=
name|bitsize_zero_node
expr_stmt|;
name|rli
operator|->
name|offset_align
operator|=
name|MIN
argument_list|(
name|rli
operator|->
name|offset_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targetm
operator|.
name|ms_bitfield_layout_p
argument_list|(
name|rli
operator|->
name|t
argument_list|)
condition|)
block|{
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we ended a bitfield before the full length of the type then 	 pad the struct out to the full length of the last type.  */
if|if
condition|(
operator|(
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|bitsize_int
argument_list|(
name|rli
operator|->
name|remaining_in_alignment
argument_list|)
argument_list|)
expr_stmt|;
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assuming that all the fields have been laid out, this function uses    RLI to compute the final TYPE_SIZE, TYPE_ALIGN, etc. for the type    indicated by RLI.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_record_size
parameter_list|(
name|record_layout_info
name|rli
parameter_list|)
block|{
name|tree
name|unpadded_size
decl_stmt|,
name|unpadded_size_unit
decl_stmt|;
comment|/* Now we want just byte and bit offsets, so set the offset alignment      to be a byte and then normalize.  */
name|rli
operator|->
name|offset_align
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
comment|/* Determine the desired alignment.  */
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|,
name|rli
operator|->
name|record_align
argument_list|)
expr_stmt|;
else|#
directive|else
name|TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|,
name|rli
operator|->
name|record_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute the size so far.  Be sure to allow for extra bits in the      size in bytes.  We have guaranteed above that it will be no more      than a single byte.  */
name|unpadded_size
operator|=
name|rli_size_so_far
argument_list|(
name|rli
argument_list|)
expr_stmt|;
name|unpadded_size_unit
operator|=
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|)
condition|)
name|unpadded_size_unit
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|unpadded_size_unit
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
comment|/* Round the size up to be a multiple of the required alignment.  */
name|TYPE_SIZE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|=
name|round_up
argument_list|(
name|unpadded_size
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|=
name|round_up
argument_list|(
name|unpadded_size_unit
argument_list|,
name|TYPE_ALIGN_UNIT
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|unpadded_size
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|unpadded_size
argument_list|,
name|TYPE_SIZE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wpadded
argument_list|,
literal|"padding struct size to alignment boundary"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_packed
operator|&&
name|TREE_CODE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_PACKED
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|&&
operator|!
name|rli
operator|->
name|packed_maybe_necessary
operator|&&
name|TREE_CONSTANT
argument_list|(
name|unpadded_size
argument_list|)
condition|)
block|{
name|tree
name|unpacked_size
decl_stmt|;
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|rli
operator|->
name|unpacked_align
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|,
name|rli
operator|->
name|unpacked_align
argument_list|)
expr_stmt|;
else|#
directive|else
name|rli
operator|->
name|unpacked_align
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|,
name|rli
operator|->
name|unpacked_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unpacked_size
operator|=
name|round_up
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|,
name|rli
operator|->
name|unpacked_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|unpacked_size
argument_list|,
name|TYPE_SIZE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_PACKED
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|rli
operator|->
name|t
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|rli
operator|->
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STRICT_ALIGNMENT
condition|)
name|warning
argument_list|(
name|OPT_Wpacked
argument_list|,
literal|"packed attribute causes inefficient "
literal|"alignment for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wpacked
argument_list|,
literal|"packed attribute is unnecessary for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STRICT_ALIGNMENT
condition|)
name|warning
argument_list|(
name|OPT_Wpacked
argument_list|,
literal|"packed attribute causes inefficient alignment"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wpacked
argument_list|,
literal|"packed attribute is unnecessary"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the TYPE_MODE for the TYPE (which is a RECORD_TYPE).  */
end_comment

begin_function
name|void
name|compute_record_mode
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* Most RECORD_TYPEs have BLKmode, so we start off assuming that.      However, if possible, we use a mode that fits in a register      instead, in order to allow for better optimization down the      line.  */
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
comment|/* A record which has any BLKmode members must itself be      BLKmode; it can't go in a register.  Unless the member is      BLKmode only because it isn't aligned.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|TYPE_NO_FORCE_BLK
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
comment|/* If this field is the whole struct, remember its mode so 	 that, say, we can put a double in a class into a DF 	 register instead of forcing it to live in the stack.  */
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MEMBER_TYPE_FORCES_BLK
comment|/* With some targets, eg. c4x, it is sub-optimal 	 to access an aligned BLKmode structure as a scalar.  */
if|if
condition|(
name|MEMBER_TYPE_FORCES_BLK
argument_list|(
name|field
argument_list|,
name|mode
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* MEMBER_TYPE_FORCES_BLK  */
block|}
comment|/* If we only have one real field; use its mode if that mode's size      matches the type's size.  This only applies to RECORD_TYPE.  This      does not apply to unions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode
expr_stmt|;
else|else
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size_tree
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If structure's known alignment is less than what the scalar      mode would need, and it matters, then stick with BLKmode.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|STRICT_ALIGNMENT
operator|&&
operator|!
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is the only reason this type is BLKmode, then 	 don't force containing types to be BLKmode.  */
name|TYPE_NO_FORCE_BLK
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute TYPE_SIZE and TYPE_ALIGN for TYPE, once it has been laid    out.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_type_size
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* Normally, use the alignment corresponding to the mode chosen.      However, where strict alignment is not required, avoid      over-aligning structures, since most compilers do not do this      alignment.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
name|STRICT_ALIGNMENT
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|QUAL_UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
operator|)
condition|)
block|{
name|unsigned
name|mode_align
init|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Don't override a larger alignment requirement coming from a user 	 alignment of one of the fields.  */
if|if
condition|(
name|mode_align
operator|>=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|mode_align
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Do machine-dependent extra alignment.  */
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we failed to find a simple way to calculate the unit size      of the type, find it by division.  */
if|if
condition|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
comment|/* TYPE_SIZE (type) is computed in bitsizetype.  After the division, the        result will fit in sizetype.  We will get more efficient code using        sizetype, so we force a conversion.  */
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|round_up
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|round_up
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ALIGN_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Evaluate nonconstant sizes only once, either now or as soon as safe.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|variable_size
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|variable_size
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Also layout any other variants of the type.  */
if|if
condition|(
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|variant
decl_stmt|;
comment|/* Record layout info of this variant.  */
name|tree
name|size
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|size_unit
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|user_align
init|=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Copy it into all variants.  */
for|for
control|(
name|variant
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|variant
operator|!=
literal|0
condition|;
name|variant
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variant
argument_list|)
control|)
block|{
name|TYPE_SIZE
argument_list|(
name|variant
argument_list|)
operator|=
name|size
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|variant
argument_list|)
operator|=
name|size_unit
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|variant
argument_list|)
operator|=
name|align
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|variant
argument_list|)
operator|=
name|user_align
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|variant
argument_list|)
operator|=
name|mode
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do all of the work required to layout the type indicated by RLI,    once the fields have been laid out.  This function will call `free'    for RLI, unless FREE_P is false.  Passing a value other than false    for FREE_P is bad practice; this option only exists to support the    G++ 3.2 ABI.  */
end_comment

begin_function
name|void
name|finish_record_layout
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|int
name|free_p
parameter_list|)
block|{
name|tree
name|variant
decl_stmt|;
comment|/* Compute the final size.  */
name|finalize_record_size
argument_list|(
name|rli
argument_list|)
expr_stmt|;
comment|/* Compute the TYPE_MODE for the record.  */
name|compute_record_mode
argument_list|(
name|rli
operator|->
name|t
argument_list|)
expr_stmt|;
comment|/* Perform any last tweaks to the TYPE_SIZE, etc.  */
name|finalize_type_size
argument_list|(
name|rli
operator|->
name|t
argument_list|)
expr_stmt|;
comment|/* Propagate TYPE_PACKED to variants.  With C++ templates,      handle_packed_attribute is too early to do this.  */
for|for
control|(
name|variant
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|rli
operator|->
name|t
argument_list|)
init|;
name|variant
condition|;
name|variant
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variant
argument_list|)
control|)
name|TYPE_PACKED
argument_list|(
name|variant
argument_list|)
operator|=
name|TYPE_PACKED
argument_list|(
name|rli
operator|->
name|t
argument_list|)
expr_stmt|;
comment|/* Lay out any static members.  This is done now because their type      may use the record's type.  */
while|while
condition|(
name|rli
operator|->
name|pending_statics
condition|)
block|{
name|layout_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|rli
operator|->
name|pending_statics
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rli
operator|->
name|pending_statics
operator|=
name|TREE_CHAIN
argument_list|(
name|rli
operator|->
name|pending_statics
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
if|if
condition|(
name|free_p
condition|)
name|free
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish processing a builtin RECORD_TYPE type TYPE.  It's name is    NAME, its fields are chained in reverse on FIELDS.     If ALIGN_TYPE is non-null, it is given the same alignment as    ALIGN_TYPE.  */
end_comment

begin_function
name|void
name|finish_builtin_struct
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|fields
parameter_list|,
name|tree
name|align_type
parameter_list|)
block|{
name|tree
name|tail
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|NULL_TREE
init|;
name|fields
condition|;
name|tail
operator|=
name|fields
operator|,
name|fields
operator|=
name|next
control|)
block|{
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
argument_list|)
operator|=
name|type
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
operator|=
name|tail
expr_stmt|;
block|}
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|align_type
condition|)
block|{
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|align_type
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|align_type
argument_list|)
expr_stmt|;
block|}
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|TYPE_NAME (type) = make_type_decl (get_identifier (name), type);
else|#
directive|else
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate the mode, size, and alignment for TYPE.    For an array type, calculate the element separation as well.    Record TYPE on the chain of permanent or temporary types    so that dbxout will find out about it.     TYPE_SIZE of a type is nonzero if the type has been laid out already.    layout_type does nothing on such a type.     If the type is incomplete, its TYPE_SIZE remains zero.  */
end_comment

begin_function
name|void
name|layout_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Do nothing if type has been laid out before.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|LANG_TYPE
case|:
comment|/* This kind of type is the responsibility 	 of the language-specific code.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|BOOLEAN_TYPE
case|:
comment|/* Used for Java, Pascal, and Chill.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* default to one byte/boolean.  */
comment|/* ... fall through ...  */
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|smallest_mode_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|MODE_INT
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|?
name|MODE_COMPLEX_FLOAT
else|:
name|MODE_COMPLEX_INT
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
block|{
name|int
name|nunits
init|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|nunits_tree
init|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|nunits
argument_list|)
decl_stmt|;
name|tree
name|innertype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|nunits
operator|&
operator|(
name|nunits
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Find an appropriate mode for the vector type.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|innertype
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* First, look for a supported vector type.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|innermode
argument_list|)
condition|)
name|mode
operator|=
name|MIN_MODE_VECTOR_FLOAT
expr_stmt|;
else|else
name|mode
operator|=
name|MIN_MODE_VECTOR_INT
expr_stmt|;
for|for
control|(
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
name|nunits
operator|&&
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|innermode
operator|&&
name|targetm
operator|.
name|vector_mode_supported_p
argument_list|(
name|mode
argument_list|)
condition|)
break|break;
comment|/* For integers, try mapping it to a same-sized scalar mode.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|innermode
argument_list|)
operator|==
name|MODE_INT
condition|)
name|mode
operator|=
name|mode_for_size
argument_list|(
name|nunits
operator|*
name|GET_MODE_BITSIZE
argument_list|(
name|innermode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
operator|!
name|have_regs_of_mode
index|[
name|mode
index|]
condition|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
else|else
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode
expr_stmt|;
block|}
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|int_const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|innertype
argument_list|)
argument_list|,
name|nunits_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|int_const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|innertype
argument_list|)
argument_list|,
name|nunits_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Always naturally align vectors.  This prevents ABI changes 	   depending on whether or not native vector modes are supported.  */
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VOID_TYPE
case|:
comment|/* This is an incomplete type and so doesn't have a size.  */
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* A pointer might be MODE_PARTIAL_INT, 	 but ptrdiff_t must be integral.  */
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
comment|/* It's hard to see what the mode and size of a function ought to 	 be, but we do know the alignment is FUNCTION_BOUNDARY, so 	 make it consistent with that.  */
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|FUNCTION_BOUNDARY
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|FUNCTION_BOUNDARY
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* APPLE LOCAL blocks */
case|case
name|BLOCK_POINTER_TYPE
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|reference_types_internal
operator|)
condition|?
name|Pmode
else|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|int
name|nbits
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|nbits
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|nbits
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|index
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|build_pointer_type
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|/* We need to know both bounds in order to compute the size.  */
if|if
condition|(
name|index
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|index
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|index
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|tree
name|ub
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|tree
name|lb
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|tree
name|length
decl_stmt|;
name|tree
name|element_size
decl_stmt|;
comment|/* The initial subtraction should happen in the original type so 	       that (possible) negative values are handled appropriately.  */
name|length
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lb
argument_list|)
argument_list|,
name|ub
argument_list|,
name|lb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special handling for arrays of bits (for Chill).  */
name|element_size
operator|=
name|TYPE_SIZE
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|element
argument_list|)
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|element
argument_list|)
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|element
argument_list|)
argument_list|)
operator|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|element
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|maxvalue
init|=
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|element
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|minvalue
init|=
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|element
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxvalue
operator|-
name|minvalue
operator|==
literal|1
operator|&&
operator|(
name|maxvalue
operator|==
literal|1
operator|||
name|maxvalue
operator|==
literal|0
operator|)
condition|)
name|element_size
operator|=
name|integer_one_node
expr_stmt|;
block|}
comment|/* If neither bound is a constant and sizetype is signed, make 	       sure the size is never negative.  We should really do this 	       if *either* bound is non-constant, but this is the best 	       compromise between C and Ada.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|length
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|length
argument_list|,
name|size_zero_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|element_size
argument_list|,
name|fold_convert
argument_list|(
name|bitsizetype
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we know the size of the element, calculate the total 	       size directly, rather than do some division thing below. 	       This optimization helps Fortran assumed-size arrays 	       (where the size of the array is determined at runtime) 	       substantially. 	       Note that we can't do this in the case where the size of 	       the elements is one bit since TYPE_SIZE_UNIT cannot be 	       set correctly in that case.  */
if|if
condition|(
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|integer_onep
argument_list|(
name|element_size
argument_list|)
condition|)
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Now round the alignment and size, 	   using machine-dependent criteria if any.  */
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|element
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|#
directive|else
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|element
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
ifdef|#
directive|ifdef
name|MEMBER_TYPE_FORCES_BLK
operator|&&
operator|!
name|MEMBER_TYPE_FORCES_BLK
argument_list|(
name|type
argument_list|,
name|VOIDmode
argument_list|)
endif|#
directive|endif
comment|/* BLKmode elements force BLKmode aggregate; 	       else extract/store fields may lose.  */
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|||
name|TYPE_NO_FORCE_BLK
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* One-element arrays get the component type's mode.  */
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size_tree
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|STRICT_ALIGNMENT
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|<
name|BIGGEST_ALIGNMENT
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
name|TYPE_NO_FORCE_BLK
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
block|}
block|}
comment|/* When the element size is constant, check that it is at least as 	   large as the element alignment.  */
if|if
condition|(
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* If TYPE_SIZE_UNIT overflowed, then it is certainly larger than 	       TYPE_ALIGN_UNIT.  */
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
argument_list|)
operator|&&
name|compare_tree_int
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
argument_list|,
name|TYPE_ALIGN_UNIT
argument_list|(
name|element
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"alignment of array elements is greater than element size"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|field
decl_stmt|;
name|record_layout_info
name|rli
decl_stmt|;
comment|/* Initialize the layout information.  */
name|rli
operator|=
name|start_record_layout
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If this is a QUAL_UNION_TYPE, we want to process the fields 	   in the reverse order in building the COND_EXPR that denotes 	   its size.  We reverse them again later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Place all the fields.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
name|place_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang_adjust_rli
condition|)
call|(
modifier|*
name|lang_adjust_rli
call|)
argument_list|(
name|rli
argument_list|)
expr_stmt|;
comment|/* Finish laying out the record.  */
name|finish_record_layout
argument_list|(
name|rli
argument_list|,
comment|/*free_p=*/
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Compute the final TYPE_SIZE, TYPE_ALIGN, etc. for TYPE.  For      records and unions, finish_record_layout already called this      function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|QUAL_UNION_TYPE
condition|)
name|finalize_type_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If an alias set has been set for this aggregate when it was incomplete,      force it into alias set 0.      This is too conservative, but we cannot call record_component_aliases      here because some frontends still change the aggregates after      layout_type.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_ALIAS_SET_KNOWN_P
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and return a type for signed integers of PRECISION bits.  */
end_comment

begin_function
name|tree
name|make_signed_type
parameter_list|(
name|int
name|precision
parameter_list|)
block|{
name|tree
name|type
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|precision
expr_stmt|;
name|fixup_signed_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Create and return a type for unsigned integers of PRECISION bits.  */
end_comment

begin_function
name|tree
name|make_unsigned_type
parameter_list|(
name|int
name|precision
parameter_list|)
block|{
name|tree
name|type
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|precision
expr_stmt|;
name|fixup_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize sizetype and bitsizetype to a reasonable and temporary    value to enable integer types to be created.  */
end_comment

begin_function
name|void
name|initialize_sizetypes
parameter_list|(
name|bool
name|signed_p
parameter_list|)
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|int
name|precision
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|SImode
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_IS_SIZETYPE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|signed_p
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|t
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|t
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|=
name|precision
expr_stmt|;
comment|/* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE.  */
name|set_min_and_max_values_for_integral_type
argument_list|(
name|t
argument_list|,
name|precision
argument_list|,
operator|!
name|signed_p
argument_list|)
expr_stmt|;
name|sizetype
operator|=
name|t
expr_stmt|;
name|bitsizetype
operator|=
name|build_distinct_type_copy
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sizetype a version of TYPE, and initialize *sizetype    accordingly.  We do this by overwriting the stub sizetype and    bitsizetype nodes created by initialize_sizetypes.  This makes sure    that (a) anything stubby about them no longer exists, (b) any    INTEGER_CSTs created with such a type, remain valid.  */
end_comment

begin_function
name|void
name|set_sizetype
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|oprecision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* The *bitsizetype types use a precision that avoids overflows when      calculating signed sizes / offsets in bits.  However, when      cross-compiling from a 32 bit to a 64 bit host, we are limited to 64 bit      precision.  */
name|int
name|precision
init|=
name|MIN
argument_list|(
name|MIN
argument_list|(
name|oprecision
operator|+
name|BITS_PER_UNIT_LOG
operator|+
literal|1
argument_list|,
name|MAX_FIXED_MODE_SIZE
argument_list|)
argument_list|,
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_distinct_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We do want to use sizetype's cache, as we will be replacing that      type.  */
name|TYPE_CACHED_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_CACHED_VALUES
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_CACHED_VALUES_P
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_CACHED_VALUES_P
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_CACHED_VALUES
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_UID
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_UID
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_IS_SIZETYPE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Replace our original stub sizetype.  */
name|memcpy
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|,
name|tree_size
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|sizetype
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|get_identifier
argument_list|(
literal|"bit_size_type"
argument_list|)
expr_stmt|;
comment|/* We do want to use bitsizetype's cache, as we will be replacing that      type.  */
name|TYPE_CACHED_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_CACHED_VALUES
argument_list|(
name|bitsizetype
argument_list|)
expr_stmt|;
name|TYPE_CACHED_VALUES_P
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_CACHED_VALUES_P
argument_list|(
name|bitsizetype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|=
name|precision
expr_stmt|;
name|TYPE_UID
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_UID
argument_list|(
name|bitsizetype
argument_list|)
expr_stmt|;
name|TYPE_IS_SIZETYPE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Replace our original stub bitsizetype.  */
name|memcpy
argument_list|(
name|bitsizetype
argument_list|,
name|t
argument_list|,
name|tree_size
argument_list|(
name|bitsizetype
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|bitsizetype
argument_list|)
operator|=
name|bitsizetype
expr_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fixup_unsigned_type
argument_list|(
name|bitsizetype
argument_list|)
expr_stmt|;
name|ssizetype
operator|=
name|build_distinct_type_copy
argument_list|(
name|make_signed_type
argument_list|(
name|oprecision
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_IS_SIZETYPE
argument_list|(
name|ssizetype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|sbitsizetype
operator|=
name|build_distinct_type_copy
argument_list|(
name|make_signed_type
argument_list|(
name|precision
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_IS_SIZETYPE
argument_list|(
name|sbitsizetype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fixup_signed_type
argument_list|(
name|bitsizetype
argument_list|)
expr_stmt|;
name|ssizetype
operator|=
name|sizetype
expr_stmt|;
name|sbitsizetype
operator|=
name|bitsizetype
expr_stmt|;
block|}
comment|/* If SIZETYPE is unsigned, we need to fix TYPE_MAX_VALUE so that      it is sign extended in a way consistent with force_fit_type.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|orig_max
decl_stmt|,
name|new_max
decl_stmt|;
name|orig_max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
comment|/* Build a new node with the same values, but a different type.  */
name|new_max
operator|=
name|build_int_cst_wide
argument_list|(
name|sizetype
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|orig_max
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|orig_max
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now sign extend it using force_fit_type to ensure 	 consistency.  */
name|new_max
operator|=
name|force_fit_type
argument_list|(
name|new_max
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|sizetype
argument_list|)
operator|=
name|new_max
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* TYPE is an integral type, i.e., an INTEGRAL_TYPE, ENUMERAL_TYPE    or BOOLEAN_TYPE.  Set TYPE_MIN_VALUE and TYPE_MAX_VALUE    for TYPE, based on the PRECISION and whether or not the TYPE    IS_UNSIGNED.  PRECISION need not correspond to a width supported    natively by the hardware; for example, on a machine with 8-bit,    16-bit, and 32-bit register modes, PRECISION might be 7, 23, or    61.  */
end_comment

begin_function
name|void
name|set_min_and_max_values_for_integral_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|precision
parameter_list|,
name|bool
name|is_unsigned
parameter_list|)
block|{
name|tree
name|min_value
decl_stmt|;
name|tree
name|max_value
decl_stmt|;
if|if
condition|(
name|is_unsigned
condition|)
block|{
name|min_value
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max_value
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|precision
operator|)
operator|-
literal|1
argument_list|,
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|0
condition|?
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_value
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|0
condition|?
literal|0
else|:
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
argument_list|,
operator|(
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|>
literal|0
condition|?
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|max_value
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|>
literal|0
condition|?
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|)
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|min_value
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|max_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the extreme values of TYPE based on its precision in bits,    then lay it out.  Used when make_signed_type won't do    because the tree code is not INTEGER_TYPE.    E.g. for Pascal, when the -fsigned-char option is given.  */
end_comment

begin_function
name|void
name|fixup_signed_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* We can not represent properly constants greater then      2 * HOST_BITS_PER_WIDE_INT, still we need the types      as they are used by i386 vector extensions and friends.  */
if|if
condition|(
name|precision
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
name|precision
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
expr_stmt|;
name|set_min_and_max_values_for_integral_type
argument_list|(
name|type
argument_list|,
name|precision
argument_list|,
comment|/*is_unsigned=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Lay out the type: set its alignment, size, etc.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the extreme values of TYPE based on its precision in bits,    then lay it out.  This is used both in `make_unsigned_type'    and for enumeral types.  */
end_comment

begin_function
name|void
name|fixup_unsigned_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* We can not represent properly constants greater then      2 * HOST_BITS_PER_WIDE_INT, still we need the types      as they are used by i386 vector extensions and friends.  */
if|if
condition|(
name|precision
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
name|precision
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_min_and_max_values_for_integral_type
argument_list|(
name|type
argument_list|,
name|precision
argument_list|,
comment|/*is_unsigned=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Lay out the type: set its alignment, size, etc.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the best machine mode to use when referencing a bit field of length    BITSIZE bits starting at BITPOS.     The underlying object is known to be aligned to a boundary of ALIGN bits.    If LARGEST_MODE is not VOIDmode, it means that we should not use a mode    larger than LARGEST_MODE (usually SImode).     If no mode meets all these conditions, we return VOIDmode.     If VOLATILEP is false and SLOW_BYTE_ACCESS is false, we return the    smallest mode meeting these conditions.     If VOLATILEP is false and SLOW_BYTE_ACCESS is true, we return the    largest mode (but a mode no wider than UNITS_PER_WORD) that meets    all the conditions.     If VOLATILEP is true the narrow_volatile_bitfields target hook is used to    decide which of the above modes should be used.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_best_mode
parameter_list|(
name|int
name|bitsize
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|enum
name|machine_mode
name|largest_mode
parameter_list|,
name|int
name|volatilep
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|unit
init|=
literal|0
decl_stmt|;
comment|/* Find the narrowest integer mode that contains the bit field.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bitpos
operator|%
name|unit
operator|)
operator|+
name|bitsize
operator|<=
name|unit
condition|)
break|break;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
comment|/* It is tempting to omit the following line 	 if STRICT_ALIGNMENT is true. 	 But that is incorrect, since if the bitfield uses part of 3 bytes 	 and we use a 4-byte mode, we could get a spurious segv 	 if the extra 4th byte is past the end of memory. 	 (Though at least one Unix compiler ignores this problem: 	 that on the Sequent 386 machine.  */
operator|||
name|MIN
argument_list|(
name|unit
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|>
name|align
operator|||
operator|(
name|largest_mode
operator|!=
name|VOIDmode
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|largest_mode
argument_list|)
operator|)
condition|)
return|return
name|VOIDmode
return|;
if|if
condition|(
operator|(
name|SLOW_BYTE_ACCESS
operator|&&
operator|!
name|volatilep
operator|)
operator|||
operator|(
name|volatilep
operator|&&
operator|!
name|targetm
operator|.
name|narrow_volatile_bitfield
argument_list|()
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|wide_mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
block|{
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|/
name|unit
operator|==
operator|(
name|bitpos
operator|+
name|bitsize
operator|-
literal|1
operator|)
operator|/
name|unit
operator|&&
name|unit
operator|<=
name|BITS_PER_WORD
operator|&&
name|unit
operator|<=
name|MIN
argument_list|(
name|align
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|&&
operator|(
name|largest_mode
operator|==
name|VOIDmode
operator|||
name|unit
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|largest_mode
argument_list|)
operator|)
condition|)
name|wide_mode
operator|=
name|tmode
expr_stmt|;
block|}
if|if
condition|(
name|wide_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|wide_mode
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Gets minimal and maximal values for MODE (signed or unsigned depending on    SIGN).  The returned constants are made to be usable in TARGET_MODE.  */
end_comment

begin_function
name|void
name|get_mode_bounds
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|sign
parameter_list|,
name|enum
name|machine_mode
name|target_mode
parameter_list|,
name|rtx
modifier|*
name|mmin
parameter_list|,
name|rtx
modifier|*
name|mmax
parameter_list|)
block|{
name|unsigned
name|size
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|min_val
decl_stmt|,
name|max_val
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|<=
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
block|{
name|min_val
operator|=
operator|-
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|max_val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|min_val
operator|=
literal|0
expr_stmt|;
name|max_val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|mmin
operator|=
name|gen_int_mode
argument_list|(
name|min_val
argument_list|,
name|target_mode
argument_list|)
expr_stmt|;
operator|*
name|mmax
operator|=
name|gen_int_mode
argument_list|(
name|max_val
argument_list|,
name|target_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-stor-layout.h"
end_include

end_unit

