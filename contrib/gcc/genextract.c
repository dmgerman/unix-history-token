begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to extract operands from insn as rtl.    Copyright (C) 1987, 91-93, 97-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Names for patterns.  Need to allow linking with print-rtl.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure contains all the information needed to describe one    set of extractions methods.  Each method may be used by more than     one pattern if the operands are in the same place.     The string for each operand describes that path to the operand and    contains `0' through `9' when going into an expression and `a' through    `z' when going into a vector.  We assume here that only the first operand    of an rtl expression is a vector.  genrecog.c makes the same assumption    (and uses the same representation) and it is currently true.  */
end_comment

begin_struct
struct|struct
name|extraction
block|{
name|int
name|op_count
decl_stmt|;
name|char
modifier|*
name|oplocs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|dup_count
decl_stmt|;
name|char
modifier|*
name|duplocs
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
name|int
name|dupnums
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|insns
decl_stmt|;
name|struct
name|extraction
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Holds a single insn code that use an extraction method.  */
end_comment

begin_struct
struct|struct
name|code_ptr
block|{
name|int
name|insn_code
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|extraction
modifier|*
name|extractions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number instruction patterns handled, starting at 0 for first one.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the large operand number in this insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|op_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the location of any operands using the string format described    above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|oplocs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number the occurrences of MATCH_DUP in each instruction,    starting at 0 for the first occurrence.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dup_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the location of any MATCH_DUP operands.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|duplocs
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the operand number of any MATCH_DUPs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dupnums
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the list of insn_codes for peepholes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|code_ptr
modifier|*
name|peepholes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|walk_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_path
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|extraction
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|code_ptr
modifier|*
name|link
decl_stmt|;
name|op_count
operator|=
literal|0
expr_stmt|;
name|dup_count
operator|=
literal|0
expr_stmt|;
comment|/* No operands seen so far in this pattern.  */
name|memset
argument_list|(
name|oplocs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|oplocs
argument_list|)
expr_stmt|;
comment|/* Walk the insn's pattern, remembering at all times the path      down to the walking point.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|path
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|path
index|[
literal|0
index|]
operator|=
literal|'a'
operator|+
name|i
expr_stmt|;
name|path
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
operator|(
expr|struct
name|code_ptr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|code_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
comment|/* See if we find something that already had this extraction method.  */
for|for
control|(
name|p
operator|=
name|extractions
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op_count
operator|!=
name|op_count
operator|||
name|p
operator|->
name|dup_count
operator|!=
name|dup_count
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|!=
name|oplocs
index|[
name|i
index|]
operator|&&
operator|!
operator|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|oplocs
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
argument_list|,
name|oplocs
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|op_count
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dup_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dupnums
index|[
name|i
index|]
operator|!=
name|dupnums
index|[
name|i
index|]
operator|||
name|strcmp
argument_list|(
name|p
operator|->
name|duplocs
index|[
name|i
index|]
argument_list|,
name|duplocs
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|dup_count
condition|)
continue|continue;
comment|/* This extraction is the same as ours.  Just link us in.  */
name|link
operator|->
name|next
operator|=
name|p
operator|->
name|insns
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, make a new extraction method.  */
name|p
operator|=
operator|(
expr|struct
name|extraction
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extraction
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op_count
operator|=
name|op_count
expr_stmt|;
name|p
operator|->
name|dup_count
operator|=
name|dup_count
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extractions
expr_stmt|;
name|extractions
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op_count
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|=
name|oplocs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dup_count
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|dupnums
index|[
name|i
index|]
operator|=
name|dupnums
index|[
name|i
index|]
operator|,
name|p
operator|->
name|duplocs
index|[
name|i
index|]
operator|=
name|duplocs
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|walk_rtx
parameter_list|(
name|x
parameter_list|,
name|path
parameter_list|)
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|depth
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newpath
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
return|return;
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_SCRATCH
case|:
name|oplocs
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|op_count
operator|=
name|MAX
argument_list|(
name|op_count
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
name|duplocs
index|[
name|dup_count
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dupnums
index|[
name|dup_count
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup_count
operator|++
expr_stmt|;
break|break;
case|case
name|MATCH_OP_DUP
case|:
name|duplocs
index|[
name|dup_count
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dupnums
index|[
name|dup_count
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup_count
operator|++
expr_stmt|;
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MATCH_OPERATOR
case|:
name|oplocs
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|op_count
operator|=
name|MAX
argument_list|(
name|op_count
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MATCH_PARALLEL
case|:
name|oplocs
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|op_count
operator|=
name|MAX
argument_list|(
name|op_count
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'a'
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|ADDRESS
case|:
name|walk_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'a'
operator|+
name|j
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a PATH, representing a path down the instruction's    pattern from the root to a certain point, output code to    evaluate to the rtx at that point.  */
end_comment

begin_function
specifier|static
name|void
name|print_path
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Don't emit "pat", since we may try to take the address of it, 	 which isn't what is intended.  */
name|printf
argument_list|(
literal|"PATTERN (insn)"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We first write out the operations (XEXP or XVECEXP) in reverse      order, then write "insn", then the indices in forward order.  */
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|path
index|[
name|i
index|]
operator|>=
literal|'a'
operator|&&
name|path
index|[
name|i
index|]
operator|<=
literal|'z'
condition|)
name|printf
argument_list|(
literal|"XVECEXP ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|path
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
name|printf
argument_list|(
literal|"XEXP ("
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"pat"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|path
index|[
name|i
index|]
operator|>=
literal|'a'
operator|&&
name|path
index|[
name|i
index|]
operator|<=
literal|'z'
condition|)
name|printf
argument_list|(
literal|", 0, %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|path
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
name|printf
argument_list|(
literal|", %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genextract: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|input
parameter_list|)
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
block|{
specifier|register
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|extraction
modifier|*
name|p
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|link
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
comment|/* Assign sequential codes to all entries in the machine description      in parallel with the tables in insn-output.c.  */
name|insn_code_number
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genextract'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"toplev.h\"\n\n"
argument_list|)
expr_stmt|;
comment|/* This variable exists only so it can be the "location"      of any missing operand whose numbers are skipped by a given pattern.  */
name|printf
argument_list|(
literal|"static rtx junk ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"void\ninsn_extract (insn)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  register rtx *ro = recog_operand;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  register rtx **ro_loc = recog_operand_loc;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx pat = PATTERN (insn);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int i ATTRIBUTE_UNUSED;\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  memset (ro, 0, sizeof (*ro) * MAX_RECOG_OPERANDS);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  memset (ro_loc, 0, sizeof (*ro_loc) * MAX_RECOG_OPERANDS);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (INSN_CODE (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    case -1:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      fatal_insn_not_found (insn);\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
block|{
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
name|struct
name|code_ptr
modifier|*
name|link
init|=
operator|(
expr|struct
name|code_ptr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|code_ptr
argument_list|)
argument_list|)
decl_stmt|;
name|link
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|peepholes
expr_stmt|;
name|peepholes
operator|=
name|link
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
operator|++
name|insn_code_number
expr_stmt|;
block|}
comment|/* Write out code to handle peepholes and the insn_codes that it should      be called for.  */
if|if
condition|(
name|peepholes
condition|)
block|{
for|for
control|(
name|link
operator|=
name|peepholes
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|link
operator|->
name|insn_code
argument_list|)
expr_stmt|;
comment|/* The vector in the insn says how many operands it has. 	 And all it contains are operands.  In fact, the vector was 	 created just for the sake of this function.  */
name|printf
argument_list|(
literal|"      for (i = XVECLEN (pat, 0) - 1; i>= 0; i--)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"          ro[i] = XVECEXP (pat, 0, i);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Write out all the ways to extract insn operands.  */
for|for
control|(
name|p
operator|=
name|extractions
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|link
operator|=
name|p
operator|->
name|insns
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|link
operator|->
name|insn_code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|op_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"      ro[%d] = const0_rtx;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      ro_loc[%d] =&junk;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"      ro[%d] = *(ro_loc[%d] =&"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dup_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"      recog_dup_loc[%d] =&"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|p
operator|->
name|duplocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      recog_dup_num[%d] = %d;\n"
argument_list|,
name|i
argument_list|,
name|p
operator|->
name|dupnums
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* This should never be reached.  Note that we would also reach this abort    if we tried to extract something whose INSN_CODE was a DEFINE_EXPAND or    DEFINE_SPLIT, but that is correct.  */
name|printf
argument_list|(
literal|"    default:\n      abort ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n}\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

