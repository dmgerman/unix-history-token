begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to extract operands from insn as rtl.    Copyright (C) 1987, 1991, 1992, 1993, 1997, 1998, 1999, 2000, 2003,    2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_comment
comment|/* This structure contains all the information needed to describe one    set of extractions methods.  Each method may be used by more than    one pattern if the operands are in the same place.     The string for each operand describes that path to the operand and    contains `0' through `9' when going into an expression and `a' through    `z' when going into a vector.  We assume here that only the first operand    of an rtl expression is a vector.  genrecog.c makes the same assumption    (and uses the same representation) and it is currently true.  */
end_comment

begin_typedef
typedef|typedef
name|char
modifier|*
name|locstr
typedef|;
end_typedef

begin_struct
struct|struct
name|extraction
block|{
name|unsigned
name|int
name|op_count
decl_stmt|;
name|unsigned
name|int
name|dup_count
decl_stmt|;
name|locstr
modifier|*
name|oplocs
decl_stmt|;
name|locstr
modifier|*
name|duplocs
decl_stmt|;
name|int
modifier|*
name|dupnums
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|insns
decl_stmt|;
name|struct
name|extraction
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Holds a single insn code that uses an extraction method.  */
end_comment

begin_struct
struct|struct
name|code_ptr
block|{
name|int
name|insn_code
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* All extractions needed for this machine description.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|extraction
modifier|*
name|extractions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All insn codes for old-style peepholes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|code_ptr
modifier|*
name|peepholes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used by gen_insn and walk_rtx to accumulate the    data that will be used to produce an extractions structure.  */
end_comment

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|locstr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|accum_extract
block|{
name|VEC
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|)
operator|*
name|oplocs
expr_stmt|;
name|VEC
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|)
operator|*
name|duplocs
expr_stmt|;
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|dupnums
expr_stmt|;
name|VEC
argument_list|(
name|char
argument_list|,
name|heap
argument_list|)
operator|*
name|pathstr
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|walk_rtx
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|accum_extract
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|insn_code_number
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|op_count
decl_stmt|,
name|dup_count
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|extraction
modifier|*
name|p
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|link
decl_stmt|;
name|struct
name|accum_extract
name|acc
decl_stmt|;
name|acc
operator|.
name|oplocs
operator|=
name|VEC_alloc
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|acc
operator|.
name|duplocs
operator|=
name|VEC_alloc
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|acc
operator|.
name|dupnums
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|acc
operator|.
name|pathstr
operator|=
name|VEC_alloc
argument_list|(
name|char
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* Walk the insn's pattern, remembering at all times the path      down to the walking point.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|VEC_safe_push
argument_list|(
name|char
argument_list|,
name|heap
argument_list|,
name|acc
operator|.
name|pathstr
argument_list|,
literal|'a'
operator|+
name|i
argument_list|)
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|char
argument_list|,
name|acc
operator|.
name|pathstr
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
name|XNEW
argument_list|(
expr|struct
name|code_ptr
argument_list|)
expr_stmt|;
name|link
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
comment|/* See if we find something that already had this extraction method.  */
name|op_count
operator|=
name|VEC_length
argument_list|(
name|locstr
argument_list|,
name|acc
operator|.
name|oplocs
argument_list|)
expr_stmt|;
name|dup_count
operator|=
name|VEC_length
argument_list|(
name|locstr
argument_list|,
name|acc
operator|.
name|duplocs
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dup_count
operator|==
name|VEC_length
argument_list|(
name|int
argument_list|,
name|acc
operator|.
name|dupnums
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|extractions
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op_count
operator|!=
name|op_count
operator|||
name|p
operator|->
name|dup_count
operator|!=
name|dup_count
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|op_count
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|a
init|=
name|p
operator|->
name|oplocs
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|VEC_index
argument_list|(
name|locstr
argument_list|,
name|acc
operator|.
name|oplocs
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|!=
name|b
operator|&&
operator|(
operator|!
name|a
operator|||
operator|!
name|b
operator|||
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|!=
name|op_count
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dup_count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dupnums
index|[
name|j
index|]
operator|!=
name|VEC_index
argument_list|(
name|int
argument_list|,
name|acc
operator|.
name|dupnums
argument_list|,
name|j
argument_list|)
operator|||
name|strcmp
argument_list|(
name|p
operator|->
name|duplocs
index|[
name|j
index|]
argument_list|,
name|VEC_index
argument_list|(
name|locstr
argument_list|,
name|acc
operator|.
name|duplocs
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|!=
name|dup_count
condition|)
continue|continue;
comment|/* This extraction is the same as ours.  Just link us in.  */
name|link
operator|->
name|next
operator|=
name|p
operator|->
name|insns
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Otherwise, make a new extraction method.  We stash the arrays      after the extraction structure in memory.  */
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extraction
argument_list|)
operator|+
name|op_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|dup_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|dup_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op_count
operator|=
name|op_count
expr_stmt|;
name|p
operator|->
name|dup_count
operator|=
name|dup_count
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extractions
expr_stmt|;
name|extractions
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|oplocs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|extraction
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|duplocs
operator|=
name|p
operator|->
name|oplocs
operator|+
name|op_count
expr_stmt|;
name|p
operator|->
name|dupnums
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|p
operator|->
name|duplocs
operator|+
name|dup_count
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|oplocs
argument_list|,
name|VEC_address
argument_list|(
name|locstr
argument_list|,
name|acc
operator|.
name|oplocs
argument_list|)
argument_list|,
name|op_count
operator|*
sizeof|sizeof
argument_list|(
name|locstr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|duplocs
argument_list|,
name|VEC_address
argument_list|(
name|locstr
argument_list|,
name|acc
operator|.
name|duplocs
argument_list|)
argument_list|,
name|dup_count
operator|*
sizeof|sizeof
argument_list|(
name|locstr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|dupnums
argument_list|,
name|VEC_address
argument_list|(
name|int
argument_list|,
name|acc
operator|.
name|dupnums
argument_list|)
argument_list|,
name|dup_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|VEC_free
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|,
name|acc
operator|.
name|oplocs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|,
name|acc
operator|.
name|duplocs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|acc
operator|.
name|dupnums
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|char
argument_list|,
name|heap
argument_list|,
name|acc
operator|.
name|pathstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper subroutine of walk_rtx: given a VEC(locstr), an index, and a    string, insert the string at the index, which should either already    exist and be NULL, or not yet exist within the vector.  In the latter    case the vector is enlarged as appropriate.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|VEC_safe_set_locstr
argument_list|(
name|VEC
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|vp
argument_list|,
name|unsigned
name|int
name|ix
argument_list|,
name|char
operator|*
name|str
argument_list|)
block|{
if|if
condition|(
name|ix
operator|<
name|VEC_length
argument_list|(
name|locstr
argument_list|,
operator|*
name|vp
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|VEC_index
argument_list|(
name|locstr
argument_list|,
operator|*
name|vp
argument_list|,
name|ix
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|locstr
argument_list|,
operator|*
name|vp
argument_list|,
name|ix
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ix
operator|>
name|VEC_length
argument_list|(
name|locstr
argument_list|,
operator|*
name|vp
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|,
operator|*
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|,
operator|*
name|vp
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Another helper subroutine of walk_rtx: given a VEC(char), convert it    to a NUL-terminated string in malloc memory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|VEC_char_to_string
argument_list|(
name|VEC
argument_list|(
name|char
argument_list|,
name|heap
argument_list|)
operator|*
name|v
argument_list|)
block|{
name|size_t
name|n
init|=
name|VEC_length
argument_list|(
name|char
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|n
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|VEC_address
argument_list|(
name|char
argument_list|,
name|v
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|walk_rtx
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|accum_extract
modifier|*
name|acc
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|base
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
return|return;
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_SCRATCH
case|:
name|VEC_safe_set_locstr
argument_list|(
operator|&
name|acc
operator|->
name|oplocs
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VEC_char_to_string
argument_list|(
name|acc
operator|->
name|pathstr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_PARALLEL
case|:
name|VEC_safe_set_locstr
argument_list|(
operator|&
name|acc
operator|->
name|oplocs
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VEC_char_to_string
argument_list|(
name|acc
operator|->
name|pathstr
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|code
operator|==
name|MATCH_OPERATOR
condition|?
literal|'0'
else|:
literal|'a'
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|VEC_safe_push
argument_list|(
name|char
argument_list|,
name|heap
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|,
name|base
operator|+
name|i
argument_list|)
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|char
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
case|case
name|MATCH_OP_DUP
case|:
name|VEC_safe_push
argument_list|(
name|locstr
argument_list|,
name|heap
argument_list|,
name|acc
operator|->
name|duplocs
argument_list|,
name|VEC_char_to_string
argument_list|(
name|acc
operator|->
name|pathstr
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|acc
operator|->
name|dupnums
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_DUP
condition|)
break|break;
name|base
operator|=
operator|(
name|code
operator|==
name|MATCH_OP_DUP
condition|?
literal|'0'
else|:
literal|'a'
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|VEC_safe_push
argument_list|(
name|char
argument_list|,
name|heap
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|,
name|base
operator|+
name|i
argument_list|)
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|char
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|char
argument_list|,
name|heap
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|,
literal|'0'
operator|+
name|i
argument_list|)
expr_stmt|;
name|walk_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|char
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|VEC_safe_push
argument_list|(
name|char
argument_list|,
name|heap
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|,
literal|'a'
operator|+
name|j
argument_list|)
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|char
argument_list|,
name|acc
operator|->
name|pathstr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a PATH, representing a path down the instruction's    pattern from the root to a certain point, output code to    evaluate to the rtx at that point.  */
end_comment

begin_function
specifier|static
name|void
name|print_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Don't emit "pat", since we may try to take the address of it, 	 which isn't what is intended.  */
name|fputs
argument_list|(
literal|"PATTERN (insn)"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We first write out the operations (XEXP or XVECEXP) in reverse      order, then write "pat", then the indices in forward order.  */
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ISLOWER
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"XVECEXP ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"XEXP ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"pat"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISLOWER
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", 0, %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* N.B. Code below avoids putting squiggle braces in column 1 inside      a string, because this confuses some editors' syntax highlighting      engines.  */
name|puts
argument_list|(
literal|"\ /* Generated automatically by the program `genextract'\n\    from the machine description file `md'.  */\n\ \n\ #include \"config.h\"\n\ #include \"system.h\"\n\ #include \"coretypes.h\"\n\ #include \"tm.h\"\n\ #include \"rtl.h\"\n\ #include \"insn-config.h\"\n\ #include \"recog.h\"\n\ #include \"toplev.h\"\n\ \n\ /* This variable is used as the \"location\" of any missing operand\n\    whose numbers are skipped by a given pattern.  */\n\ static rtx junk ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ void\n\ insn_extract (rtx insn)\n{\n\   rtx *ro = recog_data.operand;\n\   rtx **ro_loc = recog_data.operand_loc;\n\   rtx pat = PATTERN (insn);\n\   int i ATTRIBUTE_UNUSED; /* only for peepholes */\n\ \n\ #ifdef ENABLE_CHECKING\n\   memset (ro, 0xab, sizeof (*ro) * MAX_RECOG_OPERANDS);\n\   memset (ro_loc, 0xab, sizeof (*ro_loc) * MAX_RECOG_OPERANDS);\n\ #endif\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\   switch (INSN_CODE (insn))\n\     {\n\     default:\n\       /* Control reaches here if insn_extract has been called with an\n\          unrecognizable insn (code -1), or an insn whose INSN_CODE\n\          corresponds to a DEFINE_EXPAND in the machine description;\n\          either way, a bug.  */\n\       if (INSN_CODE (insn)< 0)\n\         fatal_insn (\"unrecognizable insn:\", insn);\n\       else\n\         fatal_insn (\"insn with invalid code number:\", insn);\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|rtx
name|desc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|extraction
modifier|*
name|p
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|int
name|line_no
decl_stmt|;
name|progname
operator|=
literal|"genextract"
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
comment|/* Read the machine description.  */
while|while
condition|(
operator|(
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|line_no
argument_list|,
operator|&
name|insn_code_number
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
name|struct
name|code_ptr
modifier|*
name|link
init|=
name|XNEW
argument_list|(
expr|struct
name|code_ptr
argument_list|)
decl_stmt|;
name|link
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|peepholes
expr_stmt|;
name|peepholes
operator|=
name|link
expr_stmt|;
block|}
block|}
name|print_header
argument_list|()
expr_stmt|;
comment|/* Write out code to handle peepholes and the insn_codes that it should      be called for.  */
if|if
condition|(
name|peepholes
condition|)
block|{
for|for
control|(
name|link
operator|=
name|peepholes
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|link
operator|->
name|insn_code
argument_list|)
expr_stmt|;
comment|/* The vector in the insn says how many operands it has. 	 And all it contains are operands.  In fact, the vector was 	 created just for the sake of this function.  We need to set the 	 location of the operands for sake of simplifications after 	 extraction, like eliminating subregs.  */
name|puts
argument_list|(
literal|"      for (i = XVECLEN (pat, 0) - 1; i>= 0; i--)\n"
literal|"          ro[i] = *(ro_loc[i] =&XVECEXP (pat, 0, i));\n"
literal|"      break;\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Write out all the ways to extract insn operands.  */
for|for
control|(
name|p
operator|=
name|extractions
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|link
operator|=
name|p
operator|->
name|insns
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|i
operator|=
name|link
operator|->
name|insn_code
expr_stmt|;
name|name
operator|=
name|get_insn_name
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|printf
argument_list|(
literal|"    case %d:  /* %s */\n"
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|op_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"      ro[%d] = const0_rtx;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      ro_loc[%d] =&junk;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"      ro[%d] = *(ro_loc[%d] =&"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|");"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dup_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"      recog_data.dup_loc[%d] =&"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|p
operator|->
name|duplocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      recog_data.dup_num[%d] = %d;\n"
argument_list|,
name|i
argument_list|,
name|p
operator|->
name|dupnums
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"      break;\n"
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"    }\n}"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

