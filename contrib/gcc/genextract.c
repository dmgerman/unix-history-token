begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to extract operands from insn as rtl.    Copyright (C) 1987, 1991, 1992, 1993, 1997, 1998,    1999, 2000 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* This structure contains all the information needed to describe one    set of extractions methods.  Each method may be used by more than     one pattern if the operands are in the same place.     The string for each operand describes that path to the operand and    contains `0' through `9' when going into an expression and `a' through    `z' when going into a vector.  We assume here that only the first operand    of an rtl expression is a vector.  genrecog.c makes the same assumption    (and uses the same representation) and it is currently true.  */
end_comment

begin_struct
struct|struct
name|extraction
block|{
name|int
name|op_count
decl_stmt|;
name|char
modifier|*
name|oplocs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|dup_count
decl_stmt|;
name|char
modifier|*
name|duplocs
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
name|int
name|dupnums
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|insns
decl_stmt|;
name|struct
name|extraction
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Holds a single insn code that use an extraction method.  */
end_comment

begin_struct
struct|struct
name|code_ptr
block|{
name|int
name|insn_code
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|extraction
modifier|*
name|extractions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds an array of names indexed by insn_code_number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_name_ptr_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number instruction patterns handled, starting at 0 for first one.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the large operand number in this insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|op_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the location of any operands using the string format described    above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|oplocs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number the occurrences of MATCH_DUP in each instruction,    starting at 0 for the first occurrence.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dup_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the location of any MATCH_DUP operands.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|duplocs
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the operand number of any MATCH_DUPs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dupnums
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the list of insn_codes for peepholes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|code_ptr
modifier|*
name|peepholes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|walk_rtx
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_path
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_insn_name
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|extraction
modifier|*
name|p
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|link
decl_stmt|;
name|op_count
operator|=
literal|0
expr_stmt|;
name|dup_count
operator|=
literal|0
expr_stmt|;
comment|/* No operands seen so far in this pattern.  */
name|memset
argument_list|(
name|oplocs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|oplocs
argument_list|)
expr_stmt|;
comment|/* Walk the insn's pattern, remembering at all times the path      down to the walking point.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
name|path
index|[
literal|2
index|]
decl_stmt|;
name|path
index|[
literal|0
index|]
operator|=
literal|'a'
operator|+
name|i
expr_stmt|;
name|path
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
operator|(
expr|struct
name|code_ptr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|code_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
comment|/* See if we find something that already had this extraction method.  */
for|for
control|(
name|p
operator|=
name|extractions
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op_count
operator|!=
name|op_count
operator|||
name|p
operator|->
name|dup_count
operator|!=
name|dup_count
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|!=
name|oplocs
index|[
name|i
index|]
operator|&&
operator|!
operator|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|oplocs
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
argument_list|,
name|oplocs
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|op_count
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dup_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dupnums
index|[
name|i
index|]
operator|!=
name|dupnums
index|[
name|i
index|]
operator|||
name|strcmp
argument_list|(
name|p
operator|->
name|duplocs
index|[
name|i
index|]
argument_list|,
name|duplocs
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|dup_count
condition|)
continue|continue;
comment|/* This extraction is the same as ours.  Just link us in.  */
name|link
operator|->
name|next
operator|=
name|p
operator|->
name|insns
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, make a new extraction method.  */
name|p
operator|=
operator|(
expr|struct
name|extraction
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extraction
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op_count
operator|=
name|op_count
expr_stmt|;
name|p
operator|->
name|dup_count
operator|=
name|dup_count
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extractions
expr_stmt|;
name|extractions
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op_count
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|=
name|oplocs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dup_count
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|dupnums
index|[
name|i
index|]
operator|=
name|dupnums
index|[
name|i
index|]
operator|,
name|p
operator|->
name|duplocs
index|[
name|i
index|]
operator|=
name|duplocs
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|walk_rtx
parameter_list|(
name|x
parameter_list|,
name|path
parameter_list|)
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|depth
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newpath
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
return|return;
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_SCRATCH
case|:
name|oplocs
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|op_count
operator|=
name|MAX
argument_list|(
name|op_count
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_DUP
case|:
name|duplocs
index|[
name|dup_count
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dupnums
index|[
name|dup_count
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup_count
operator|++
expr_stmt|;
break|break;
case|case
name|MATCH_PAR_DUP
case|:
case|case
name|MATCH_OP_DUP
case|:
name|duplocs
index|[
name|dup_count
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dupnums
index|[
name|dup_count
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup_count
operator|++
expr_stmt|;
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
operator|(
name|code
operator|==
name|MATCH_OP_DUP
condition|?
literal|'0'
else|:
literal|'a'
operator|)
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
name|oplocs
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|op_count
operator|=
name|MAX
argument_list|(
name|op_count
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_PARALLEL
case|:
name|oplocs
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|op_count
operator|=
name|MAX
argument_list|(
name|op_count
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'a'
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDRESS
case|:
name|walk_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newpath
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|newpath
index|[
name|depth
index|]
operator|=
literal|'a'
operator|+
name|j
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a PATH, representing a path down the instruction's    pattern from the root to a certain point, output code to    evaluate to the rtx at that point.  */
end_comment

begin_function
specifier|static
name|void
name|print_path
parameter_list|(
name|path
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Don't emit "pat", since we may try to take the address of it, 	 which isn't what is intended.  */
name|printf
argument_list|(
literal|"PATTERN (insn)"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We first write out the operations (XEXP or XVECEXP) in reverse      order, then write "insn", then the indices in forward order.  */
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ISLOWER
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|"XVECEXP ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|"XEXP ("
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"pat"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISLOWER
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", 0, %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|extraction
modifier|*
name|p
decl_stmt|;
name|struct
name|code_ptr
modifier|*
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|progname
operator|=
literal|"genextract"
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"no input file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
comment|/* Assign sequential codes to all entries in the machine description      in parallel with the tables in insn-output.c.  */
name|insn_code_number
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genextract'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"toplev.h\"\n\n"
argument_list|)
expr_stmt|;
comment|/* This variable exists only so it can be the "location"      of any missing operand whose numbers are skipped by a given pattern.  */
name|printf
argument_list|(
literal|"static rtx junk ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"void\ninsn_extract (insn)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx *ro = recog_data.operand;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx **ro_loc = recog_data.operand_loc;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx pat = PATTERN (insn);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int i ATTRIBUTE_UNUSED;\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  memset (ro, 0, sizeof (*ro) * MAX_RECOG_OPERANDS);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  memset (ro_loc, 0, sizeof (*ro_loc) * MAX_RECOG_OPERANDS);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (INSN_CODE (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    case -1:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      fatal_insn_not_found (insn);\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|line_no
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|line_no
argument_list|,
operator|&
name|insn_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
block|{
name|record_insn_name
argument_list|(
name|insn_code_number
argument_list|,
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
name|struct
name|code_ptr
modifier|*
name|link
init|=
operator|(
expr|struct
name|code_ptr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|code_ptr
argument_list|)
argument_list|)
decl_stmt|;
name|link
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|peepholes
expr_stmt|;
name|peepholes
operator|=
name|link
expr_stmt|;
block|}
block|}
comment|/* Write out code to handle peepholes and the insn_codes that it should      be called for.  */
if|if
condition|(
name|peepholes
condition|)
block|{
for|for
control|(
name|link
operator|=
name|peepholes
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|link
operator|->
name|insn_code
argument_list|)
expr_stmt|;
comment|/* The vector in the insn says how many operands it has. 	 And all it contains are operands.  In fact, the vector was 	 created just for the sake of this function.  We need to set the 	 location of the operands for sake of simplifications after 	 extraction, like eliminating subregs.  */
name|printf
argument_list|(
literal|"      for (i = XVECLEN (pat, 0) - 1; i>= 0; i--)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"          ro[i] = *(ro_loc[i] =&XVECEXP (pat, 0, i));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Write out all the ways to extract insn operands.  */
for|for
control|(
name|p
operator|=
name|extractions
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|link
operator|=
name|p
operator|->
name|insns
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|i
operator|=
name|link
operator|->
name|insn_code
expr_stmt|;
name|name
operator|=
name|get_insn_name
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|printf
argument_list|(
literal|"    case %d:  /* %s */\n"
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|op_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"      ro[%d] = const0_rtx;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      ro_loc[%d] =&junk;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"      ro[%d] = *(ro_loc[%d] =&"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|p
operator|->
name|oplocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dup_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"      recog_data.dup_loc[%d] =&"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|p
operator|->
name|duplocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      recog_data.dup_num[%d] = %d;\n"
argument_list|,
name|i
argument_list|,
name|p
operator|->
name|dupnums
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* This should never be reached.  Note that we would also reach this abort    if we tried to extract something whose INSN_CODE was a DEFINE_EXPAND or    DEFINE_SPLIT, but that is correct.  */
name|printf
argument_list|(
literal|"    default:\n      abort ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n}\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_insn_name
parameter_list|(
name|code
parameter_list|)
name|int
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|code
operator|<
name|insn_name_ptr_size
condition|)
return|return
name|insn_name_ptr
index|[
name|code
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_insn_name
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|int
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|last_real_name
init|=
literal|"insn"
decl_stmt|;
specifier|static
name|int
name|last_real_code
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|insn_name_ptr_size
operator|<=
name|code
condition|)
block|{
name|int
name|new_size
decl_stmt|;
name|new_size
operator|=
operator|(
name|insn_name_ptr_size
condition|?
name|insn_name_ptr_size
operator|*
literal|2
else|:
literal|512
operator|)
expr_stmt|;
name|insn_name_ptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|insn_name_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|new_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|insn_name_ptr
operator|+
name|insn_name_ptr_size
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|new_size
operator|-
name|insn_name_ptr_size
operator|)
argument_list|)
expr_stmt|;
name|insn_name_ptr_size
operator|=
name|new_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|name
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|last_real_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s+%d"
argument_list|,
name|last_real_name
argument_list|,
name|code
operator|-
name|last_real_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last_real_name
operator|=
name|new
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|last_real_code
operator|=
name|code
expr_stmt|;
block|}
name|insn_name_ptr
index|[
name|code
index|]
operator|=
name|new
expr_stmt|;
block|}
end_function

end_unit

