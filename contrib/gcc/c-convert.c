begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-level data type conversion for GNU C.    Copyright (C) 1987, 1988, 1991, 1998, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains the functions for converting C expressions    to different data types.  The only entry point is `convert'.    Every language front end must have a `convert' function    but what kind of conversions it does will depend on the language.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Change of width--truncation and extension of integers or reals--    is represented with NOP_EXPR.  Proper functioning of many things    assumes that no other conversions can be NOP_EXPRs.     Conversion between integer and pointer is represented with CONVERT_EXPR.    Converting integer to real uses FLOAT_EXPR    and real to integer uses FIX_TRUNC_EXPR.     Here is a list of all the functions that assume that widening and    narrowing is always done with a NOP_EXPR:      In convert.c, convert_to_integer.      In c-typeck.c, build_binary_op (boolean ops), and 	c_common_truthvalue_conversion.      In expr.c: expand_expr, for operands of a MULT_EXPR.      In fold-const.c: fold.      In tree.c: get_narrower and get_unwidened.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `convert'.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Create an expression whose value is that of EXPR,    converted to type TYPE.  The TREE_TYPE of the value    is always TYPE.  This function implements all reasonable    conversions; callers should filter out those that are    not permitted by the language being compiled.  */
end_comment

begin_function
name|tree
name|convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|e
init|=
name|expr
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_conv_diag
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|invalid_conv_diag
operator|=
name|targetm
operator|.
name|invalid_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
name|invalid_conv_diag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|c_objc_common_truthvalue_conversion
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
comment|/* APPLE LOCAL begin blocks (C++ ck) */
if|if
condition|(
name|code
operator|==
name|BLOCK_POINTER_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_block_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
comment|/* APPLE LOCAL end blocks (C++ ck) */
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_vector
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|e
return|;
name|error
argument_list|(
literal|"conversion to non-scalar type requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

end_unit

