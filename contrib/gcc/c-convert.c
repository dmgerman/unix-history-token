begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-level data type conversion for GNU C.    Copyright (C) 1987, 1988, 1991, 1998 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains the functions for converting C expressions    to different data types.  The only entry point is `convert'.    Every language front end must have a `convert' function    but what kind of conversions it does will depend on the language.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Change of width--truncation and extension of integers or reals--    is represented with NOP_EXPR.  Proper functioning of many things    assumes that no other conversions can be NOP_EXPRs.     Conversion between integer and pointer is represented with CONVERT_EXPR.    Converting integer to real uses FLOAT_EXPR    and real to integer uses FIX_TRUNC_EXPR.     Here is a list of all the functions that assume that widening and    narrowing is always done with a NOP_EXPR:      In convert.c, convert_to_integer.      In c-typeck.c, build_binary_op (boolean ops), and truthvalue_conversion.      In expr.c: expand_expr, for operands of a MULT_EXPR.      In fold-const.c: fold.      In tree.c: get_narrower and get_unwidened.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `convert'.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Create an expression whose value is that of EXPR,    converted to type TYPE.  The TREE_TYPE of the value    is always TYPE.  This function implements all reasonable    conversions; callers should filter out those that are    not permitted by the language being compiled.  */
end_comment

begin_function
name|tree
name|convert
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|e
init|=
name|expr
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|code
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* This is incorrect.  A truncation can't be stripped this way.      Extensions will be stripped by the use of get_unwidened.  */
block|if (TREE_CODE (expr) == NOP_EXPR)     return convert (type, TREE_OPERAND (expr, 0));
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|BOOLEAN_TYPE
condition|)
block|{
name|tree
name|t
init|=
name|truthvalue_conversion
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* If truthvalue_conversion returns a NOP_EXPR, we must fold it here 	 to avoid infinite recursion between fold () and convert ().  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_vector
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
name|error
argument_list|(
literal|"conversion to non-scalar type requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

end_unit

