begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output variables, constants and external declarations, for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles generation of all the assembler code    *except* the instructions of a function.    This includes declarations of variables and their initial values.     We also output the assembler code for constants stored in memory    and are responsible for combining constants with the same value.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRAMPOLINE_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|TRAMPOLINE_ALIGNMENT
value|FUNCTION_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABS_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|"\t.stabs\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The (assembler) name of the first globally-visible object output.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|first_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|weak_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_struct_decl
struct_decl|struct
name|addr_const
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|constant_descriptor
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rtx_const
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|pool_constant
struct_decl|;
end_struct_decl

begin_define
define|#
directive|define
name|MAX_RTX_HASH_TABLE
value|61
end_define

begin_struct
struct|struct
name|varasm_status
block|{
comment|/* Hash facility for making memory-constants      from constant rtl-expressions.  It is used on RISC machines      where immediate integer arguments and constant addresses are restricted      so that such constants must be stored in memory.       This pool of constants is reinitialized for each function      so each function gets its own constants-pool that comes right before      it.  */
name|struct
name|constant_descriptor
modifier|*
modifier|*
name|x_const_rtx_hash_table
decl_stmt|;
name|struct
name|pool_constant
modifier|*
modifier|*
name|x_const_rtx_sym_hash_table
decl_stmt|;
comment|/* Pointers to first and last constant in pool.  */
name|struct
name|pool_constant
modifier|*
name|x_first_pool
decl_stmt|,
modifier|*
name|x_last_pool
decl_stmt|;
comment|/* Current offset in constant pool (does not include any machine-specific      header).  */
name|HOST_WIDE_INT
name|x_pool_offset
decl_stmt|;
comment|/* Chain of all CONST_DOUBLE rtx's constructed for the current function.      They are chained through the CONST_DOUBLE_CHAIN.  */
name|rtx
name|x_const_double_chain
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|const_rtx_hash_table
value|(cfun->varasm->x_const_rtx_hash_table)
end_define

begin_define
define|#
directive|define
name|const_rtx_sym_hash_table
value|(cfun->varasm->x_const_rtx_sym_hash_table)
end_define

begin_define
define|#
directive|define
name|first_pool
value|(cfun->varasm->x_first_pool)
end_define

begin_define
define|#
directive|define
name|last_pool
value|(cfun->varasm->x_last_pool)
end_define

begin_define
define|#
directive|define
name|pool_offset
value|(cfun->varasm->x_pool_offset)
end_define

begin_define
define|#
directive|define
name|const_double_chain
value|(cfun->varasm->x_const_double_chain)
end_define

begin_comment
comment|/* Number for making the label on the next    constant that is stored in memory.  */
end_comment

begin_decl_stmt
name|int
name|const_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number for making the label on the next    static variable internal to a function.  */
end_comment

begin_decl_stmt
name|int
name|var_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last decl for which assemble_variable was called,    if it did ASM_DECLARE_OBJECT_NAME.    If the last call to assemble_variable didn't do that,    this holds 0.  */
end_comment

begin_decl_stmt
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RTX_UNCHANGING_P in a MEM can mean it is stored into, for initialization.    So giving constant the alias set for the type will allow such    initializations to appear to conflict with the load of the constant.  We    avoid this by giving all constants an alias set for just constants.    Since there will be no stores to that alias set, nothing will ever    conflict with them.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|const_alias_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|contains_pointers_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_addr_const
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|addr_const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_hash
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_constant
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|constant_descriptor
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|compare_constant_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_constant_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_constant
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_constant_def_contents
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_rtx_const
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|struct
name|rtx_const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_hash_rtx
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_constant_rtx
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|struct
name|constant_descriptor
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant_rtx
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_constant_pool
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_constants
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_constant
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|current_rtx
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_addressed_constants
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_after_function_constants
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|array_size_for_constructor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|min_align
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_constructor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|HOST_WIDE_INT
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|remove_from_pending_weak_list
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|in_named_entry_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|in_named_entry_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|asm_output_bss
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|asm_output_aligned_bss
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mark_pool_constant
name|PARAMS
argument_list|(
operator|(
expr|struct
name|pool_constant
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_const_hash_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_const_str_htab_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_const_str_htab
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|const_str_htab_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_str_htab_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|x
operator|,
specifier|const
name|void
operator|*
name|y
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|const_str_htab_del
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asm_emit_uninitialised
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resolve_unique_section
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_enum
specifier|static
enum|enum
name|in_section
block|{
name|no_section
block|,
name|in_text
block|,
name|in_data
block|,
name|in_named
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
block|,
name|in_bss
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CTORS_SECTION_ASM_OP
block|,
name|in_ctors
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DTORS_SECTION_ASM_OP
block|,
name|in_dtors
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTRA_SECTIONS
block|,
name|EXTRA_SECTIONS
endif|#
directive|endif
block|}
name|in_section
init|=
name|no_section
enum|;
end_enum

begin_comment
comment|/* Return a non-zero value if DECL has a section attribute.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_NAMED_SECTION
end_ifndef

begin_define
define|#
directive|define
name|IN_NAMED_SECTION
parameter_list|(
name|DECL
parameter_list|)
define|\
value|((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \&& DECL_SECTION_NAME (DECL) != NULL_TREE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Text of section name when in_section == in_named.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|in_named_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table of flags that have been used for a particular named section.  */
end_comment

begin_struct
struct|struct
name|in_named_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|bool
name|declared
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|htab_t
name|in_named_htab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define functions like text_section for any extra sections.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SECTION_FUNCTIONS
end_ifdef

begin_function
name|EXTRA_SECTION_FUNCTIONS
endif|#
directive|endif
comment|/* Tell assembler to switch to text section.  */
name|void
name|text_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_text
condition|)
block|{
ifdef|#
directive|ifdef
name|TEXT_SECTION
name|TEXT_SECTION
argument_list|()
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in_section
operator|=
name|in_text
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to data section.  */
end_comment

begin_function
name|void
name|data_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_data
condition|)
block|{
if|if
condition|(
name|flag_shared_data
condition|)
block|{
ifdef|#
directive|ifdef
name|SHARED_SECTION_ASM_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|SHARED_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_data
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to ALWAYS switch to data section, in case    it's not sure where it is.  */
end_comment

begin_function
name|void
name|force_data_section
parameter_list|()
block|{
name|in_section
operator|=
name|no_section
expr_stmt|;
name|data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to read-only data section.  This is normally    the text section.  */
end_comment

begin_function
name|void
name|readonly_data_section
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION
name|READONLY_DATA_SECTION
argument_list|()
expr_stmt|;
comment|/* Note this can call data_section.  */
else|#
directive|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Determine if we're in the text section.  */
end_comment

begin_function
name|int
name|in_text_section
parameter_list|()
block|{
return|return
name|in_section
operator|==
name|in_text
return|;
block|}
end_function

begin_comment
comment|/* Determine if we're in the data section.  */
end_comment

begin_function
name|int
name|in_data_section
parameter_list|()
block|{
return|return
name|in_section
operator|==
name|in_data
return|;
block|}
end_function

begin_comment
comment|/* Helper routines for maintaining in_named_htab.  */
end_comment

begin_function
specifier|static
name|int
name|in_named_entry_eq
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|in_named_entry
modifier|*
name|old
init|=
name|p1
decl_stmt|;
specifier|const
name|char
modifier|*
name|new
init|=
name|p2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|old
operator|->
name|name
argument_list|,
name|new
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|in_named_entry_hash
parameter_list|(
name|p
parameter_list|)
specifier|const
name|PTR
name|p
decl_stmt|;
block|{
specifier|const
name|struct
name|in_named_entry
modifier|*
name|old
init|=
name|p
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|old
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If SECTION has been seen before as a named section, return the flags    that were used.  Otherwise, return 0.  Note, that 0 is a perfectly valid    set of flags for a section to have, so 0 does not mean that the section    has not been seen.  */
end_comment

begin_function
name|unsigned
name|int
name|get_named_section_flags
parameter_list|(
name|section
parameter_list|)
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
block|{
name|struct
name|in_named_entry
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|in_named_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|in_named_htab
argument_list|,
name|section
argument_list|,
name|htab_hash_string
argument_list|(
name|section
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
return|return
name|slot
condition|?
operator|(
operator|*
name|slot
operator|)
operator|->
name|flags
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the section has been declared before.   Sets internal    flag on this section in in_named_hash so subsequent calls on this     section will return false.  */
end_comment

begin_function
name|bool
name|named_section_first_declaration
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|in_named_entry
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|in_named_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|in_named_htab
argument_list|,
name|name
argument_list|,
name|htab_hash_string
argument_list|(
name|name
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|slot
operator|)
operator|->
name|declared
condition|)
block|{
operator|(
operator|*
name|slot
operator|)
operator|->
name|declared
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Record FLAGS for SECTION.  If SECTION was previously recorded with a    different set of flags, return false.  */
end_comment

begin_function
name|bool
name|set_named_section_flags
parameter_list|(
name|section
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|in_named_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|in_named_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|in_named_htab
argument_list|,
name|section
argument_list|,
name|htab_hash_string
argument_list|(
name|section
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|entry
operator|=
operator|(
expr|struct
name|in_named_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|ggc_strdup
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|entry
operator|->
name|declared
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|flags
operator|!=
name|flags
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Tell assembler to change to section NAME with attributes FLAGS.  */
end_comment

begin_function
name|void
name|named_section_flags
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_named
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|in_named_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|set_named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|named_section
call|)
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_FORGET
condition|)
name|in_section
operator|=
name|no_section
expr_stmt|;
else|else
block|{
name|in_named_name
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_named
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to change to section NAME for DECL.    If DECL is NULL, just switch to section NAME.    If NAME is NULL, get the name from DECL.    If RELOC is 1, the initializer for DECL contains relocs.  */
end_comment

begin_function
name|void
name|named_section
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
call|(
modifier|*
name|targetm
operator|.
name|section_type_flags
call|)
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
comment|/* Sanity check user variables for flag changes.  Non-user      section flag changes will abort in named_section_flags.  */
if|if
condition|(
name|decl
operator|&&
operator|!
name|set_named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"%s causes a section type conflict"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|get_named_section_flags
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If required, set DECL_SECTION_NAME to a unique name.  */
end_comment

begin_function
specifier|static
name|void
name|resolve_unique_section
parameter_list|(
name|decl
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|flag_function_sections
operator|||
operator|(
name|targetm
operator|.
name|have_named_sections
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|UNIQUE_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* Tell the assembler to switch to the bss section.  */
end_comment

begin_function
name|void
name|bss_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_bss
condition|)
block|{
ifdef|#
directive|ifdef
name|SHARED_BSS_SECTION_ASM_OP
if|if
condition|(
name|flag_shared_data
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|SHARED_BSS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|BSS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_bss
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_comment
comment|/* Utility function for ASM_OUTPUT_BSS for targets to use if    they don't support alignments in .bss.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_bss
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|rounded
decl_stmt|;
block|{
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bss_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_comment
comment|/* Utility function for targets to use in implementing    ASM_OUTPUT_ALIGNED_BSS.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_aligned_bss
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
block|{
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bss_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_comment
comment|/* Switch to the section for function DECL.     If DECL is NULL_TREE, switch to the text section.    ??? It's not clear that we will ever be passed NULL_TREE, but it's    safer to handle it.  */
end_comment

begin_function
name|void
name|function_section
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|named_section
argument_list|(
name|decl
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|text_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch to section for variable DECL.     RELOC is the `reloc' argument to SELECT_SECTION.  */
end_comment

begin_function
name|void
name|variable_section
parameter_list|(
name|decl
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
name|named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* C++ can have const variables that get initialized from constructors, 	 and thus can not be in a readonly section.  We prevent this by 	 verifying that the initial value is constant for objects put in a 	 readonly section.  	 error_mark_node is used by the C front end to indicate that the 	 initializer has not been seen yet.  In this case, we assume that 	 the initializer must be constant.  	 C++ uses error_mark_node for variables that have complicated 	 initializers, but these variables go in BSS so we won't be called 	 for them.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|DECL_READONLY_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to the section for the exception handling    table.  */
end_comment

begin_function
name|void
name|default_exception_section
parameter_list|()
block|{
if|if
condition|(
name|targetm
operator|.
name|have_named_sections
condition|)
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".gcc_except_table"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|readonly_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to the section for string merging.  */
end_comment

begin_function
name|void
name|mergeable_string_section
parameter_list|(
name|decl
parameter_list|,
name|align
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_GAS_SHF_MERGE
if|if
condition|(
name|flag_merge_constants
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|align
operator|<=
literal|256
operator|&&
name|TREE_STRING_LENGTH
argument_list|(
name|decl
argument_list|)
operator|>=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|modesize
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|,
name|unit
decl_stmt|;
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modesize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|modesize
operator|>=
literal|8
operator|&&
name|modesize
operator|<=
literal|256
operator|&&
operator|(
name|modesize
operator|&
operator|(
name|modesize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|align
operator|<
name|modesize
condition|)
name|align
operator|=
name|modesize
expr_stmt|;
name|str
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|unit
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Check for embedded NUL characters.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|unit
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|unit
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|str
index|[
name|i
operator|+
name|j
index|]
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|unit
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
operator|-
name|unit
condition|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".rodata.str%d.%d"
argument_list|,
name|modesize
operator|/
literal|8
argument_list|,
call|(
name|int
call|)
argument_list|(
name|align
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|modesize
operator|/
literal|8
operator|)
operator||
name|SECTION_MERGE
operator||
name|SECTION_STRINGS
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
name|modesize
operator|<
name|align
condition|)
block|{
comment|/* A "" string with requested alignment greater than 		     character size might cause a problem: 		     if some other string required even bigger 		     alignment than "", then linker might think the 		     "" is just part of padding after some other string 		     and not put it into the hash table initially. 		     But this means "" could have smaller alignment 		     than requested.  */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_START
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
endif|#
directive|endif
name|readonly_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to the section for constant merging.  */
end_comment

begin_function
name|void
name|mergeable_constant_section
parameter_list|(
name|mode
parameter_list|,
name|align
parameter_list|,
name|flags
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_GAS_SHF_MERGE
name|unsigned
name|int
name|modesize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_merge_constants
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|modesize
operator|<=
name|align
operator|&&
name|align
operator|>=
literal|8
operator|&&
name|align
operator|<=
literal|256
operator|&&
operator|(
name|align
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|name
index|[
literal|24
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".rodata.cst%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|align
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|align
operator|/
literal|8
operator|)
operator||
name|SECTION_MERGE
expr_stmt|;
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|readonly_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, a putative register name, discard any customary prefixes.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
argument_list|)
condition|)
name|name
operator|+=
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|name
operator|++
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode an `asm' spec for a declaration as a register name.    Return the register number, or -1 if nothing specified,    or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,    or -3 if ASMSPEC is `cc' and is not recognized,    or -4 if ASMSPEC is `memory' and is not recognized.    Accept an exact spelling or a decimal number.    Prefixes such as % are optional.  */
end_comment

begin_function
name|int
name|decode_reg_name
parameter_list|(
name|asmspec
parameter_list|)
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
block|{
if|if
condition|(
name|asmspec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Get rid of confusing prefixes.  */
name|asmspec
operator|=
name|strip_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Allow a decimal number as a "register name".  */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|asmspec
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|asmspec
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
else|else
return|return
operator|-
literal|2
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|strip_reg_name
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|i
return|;
ifdef|#
directive|ifdef
name|ADDITIONAL_REGISTER_NAMES
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|number
decl_stmt|;
block|}
name|table
index|[]
init|=
name|ADDITIONAL_REGISTER_NAMES
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|table
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|number
return|;
block|}
endif|#
directive|endif
comment|/* ADDITIONAL_REGISTER_NAMES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"memory"
argument_list|)
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"cc"
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
return|return
operator|-
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should    have static storage duration.  In other words, it should not be an    automatic variable, including PARM_DECLs.     There is, however, one exception: this function handles variables    explicitly placed in a particular register by the user.     ASMSPEC, if not 0, is the string which the user specified as the    assembler symbol name.     This is never called for PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|make_decl_rtl
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
block|{
name|int
name|top_level
init|=
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
init|=
literal|0
decl_stmt|;
name|int
name|reg_number
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Check that we are not being given an automatic variable.  */
comment|/* A weak alias has TREE_PUBLIC set but not the other bits.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* And that we were not given a type or a label.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* For a duplicate declaration, we can be called twice on the      same DECL node.  Don't discard the RTL already made.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If the old RTL had the wrong mode, fix the mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|adjust_address_nv
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Another way to do this would be to do what halfpic.c does 	 and maintain a hashed table of such critters.  */
comment|/* ??? Another way to do this would be to pass a flag bit to 	 ENCODE_SECTION_INFO saying whether this is a new decl or not.  */
comment|/* Let the target reassign the RTL if it wants. 	 This is necessary, for example, when one machine specific 	 decl attribute overrides another.  */
ifdef|#
directive|ifdef
name|REDO_SECTION_INFO_P
if|if
condition|(
name|REDO_SECTION_INFO_P
argument_list|(
name|decl
argument_list|)
condition|)
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|new_name
operator|=
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|reg_number
operator|=
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* ASMSPEC is given, and not the name of a register.  Mark the 	 name with a star so assemble_name won't munge it.  */
name|char
modifier|*
name|starred
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|starred
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|strcpy
argument_list|(
name|starred
operator|+
literal|1
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|starred
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* First detect errors in declaring global registers.  */
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name not specified for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_number
operator|<
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid register name for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"data type of `%s' isn't suitable for a register"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|reg_number
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register specified for `%s' isn't suitable for data type"
argument_list|)
expr_stmt|;
comment|/* Now handle properly declared static register variables.  */
else|else
block|{
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"global register variable has initial value"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"volatile register variables don't work as you might wish"
argument_list|)
expr_stmt|;
comment|/* If the user specified one of the eliminables registers here, 	     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable 	     confused with that register and be eliminated.  This usage is 	     somewhat suspect...  */
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_rtx_raw_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|reg_number
argument_list|)
argument_list|)
expr_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|reg_number
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Make this register global, so not usable for anything 		 else.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_REGISTER_GLOBAL
name|ASM_DECLARE_REGISTER_GLOBAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|reg_number
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|reg_number
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|>
literal|0
condition|)
name|globalize_reg
argument_list|(
name|reg_number
operator|+
operator|--
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* As a register variable, it has no section.  */
return|return;
block|}
block|}
comment|/* Now handle ordinary static variables and functions (in memory).      Also handle vars declared register invalidly.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
operator|||
name|reg_number
operator|==
operator|-
literal|3
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name given for non-register variable `%s'"
argument_list|)
expr_stmt|;
comment|/* Specifying a section attribute on a variable forces it into a      non-.bss section, and thus it cannot be common.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Can't use just the variable's own name for a variable      whose scope is less than the whole file, unless it's a member      of a local class (which will already be unambiguous).      Concatenate a distinguishing number.  */
if|if
condition|(
operator|!
name|top_level
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|asmspec
operator|==
literal|0
operator|&&
name|name
operator|==
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
name|new_name
operator|=
name|label
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
name|new_name
condition|)
block|{
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|new_name
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this variable is to be treated as volatile, show its      tree node has side effects.  */
if|if
condition|(
operator|(
name|flag_volatile_global
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|flag_volatile_static
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_REF_WEAK
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information      such as that it is a function name.      If the name is changed, the macro ASM_OUTPUT_LABELREF      will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Make the rtl for variable VAR be volatile.    Use this only for static variables.  */
end_comment

begin_function
name|void
name|make_var_volatile
parameter_list|(
name|var
parameter_list|)
name|tree
name|var
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output alignment directive to align for constant expression EXP.  */
end_comment

begin_function
name|void
name|assemble_constant_align
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a string of literal assembler code    for an `asm' keyword used between functions.  */
end_comment

begin_function
name|void
name|assemble_asm
parameter_list|(
name|string
parameter_list|)
name|tree
name|string
decl_stmt|;
block|{
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global destructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.  */
end_comment

begin_function
name|void
name|default_stabs_asm_out_destructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Tell GNU LD that this is part of the static destructor set.      This will work for any system that uses stabs, most usefully      aout systems.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\"___DTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_named_section_asm_out_destructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".dtors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* ??? This only works reliably with the GNU linker.  */
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".dtors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DTORS_SECTION_ASM_OP
end_ifdef

begin_function
name|void
name|dtors_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_dtors
condition|)
block|{
name|in_section
operator|=
name|in_dtors
expr_stmt|;
name|fputs
argument_list|(
name|DTORS_SECTION_ASM_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|default_dtor_section_asm_out_destructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|dtors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Likewise for global constructors.  */
end_comment

begin_function
name|void
name|default_stabs_asm_out_constructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Tell GNU LD that this is part of the static destructor set.      This will work for any system that uses stabs, most usefully      aout systems.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\"___CTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_named_section_asm_out_constructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".ctors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* ??? This only works reliably with the GNU linker.  */
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ctors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTORS_SECTION_ASM_OP
end_ifdef

begin_function
name|void
name|ctors_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_ctors
condition|)
block|{
name|in_section
operator|=
name|in_ctors
expr_stmt|;
name|fputs
argument_list|(
name|CTORS_SECTION_ASM_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|default_ctor_section_asm_out_constructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ctors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* CONSTANT_POOL_BEFORE_FUNCTION may be defined as an expression with    a non-zero value if the constant pool should be output before the    start of the function, or a zero value if the pool should output    after the end of the function.  The default is to put it before the    start.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONSTANT_POOL_BEFORE_FUNCTION
end_ifndef

begin_define
define|#
directive|define
name|CONSTANT_POOL_BEFORE_FUNCTION
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output assembler code for the constant pool of a function and associated    with defining the name of the function.  DECL describes the function.    NAME is the function's name.  For the constant pool, we use the current    constant pool data.  */
end_comment

begin_function
name|void
name|assemble_start_function
parameter_list|(
name|decl
parameter_list|,
name|fnname
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|function_section
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Tell assembler to move to target machine's alignment for functions.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a user-specified function alignment.      Note that we still need to align to FUNCTION_BOUNDARY, as above,      because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */
if|if
condition|(
name|align_functions_log
operator|>
name|align
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|ASM_OUTPUT_MAX_SKIP_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align_functions_log
argument_list|,
name|align_functions
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align_functions_log
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FUNCTION_PREFIX
name|ASM_OUTPUT_FUNCTION_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|debug_hooks
operator|->
name|begin_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Make function name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_global_object_name
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|p
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|name
operator|=
name|permalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|first_global_object_name
operator|=
name|name
expr_stmt|;
else|else
name|weak_global_object_name
operator|=
name|name
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
comment|/* Remove this function from the pending weak list so that 	     we do not emit multiple .weak directives for it.  */
name|remove_from_pending_weak_list
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the function name */
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_NAME
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the function.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_FUNCTION_NAME */
block|}
end_function

begin_comment
comment|/* Output assembler code associated with defining the size of the    function.  DECL describes the function.  NAME is the function's name.  */
end_comment

begin_function
name|void
name|assemble_end_function
parameter_list|(
name|decl
parameter_list|,
name|fnname
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_SIZE
name|ASM_DECLARE_FUNCTION_SIZE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
block|{
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|function_section
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* need to switch back */
block|}
comment|/* Output any constants which should appear after the function.  */
name|output_after_function_constants
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble code to leave SIZE bytes of zeros.  */
end_comment

begin_function
name|void
name|assemble_zeros
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASM_NO_SKIP_IN_TEXT
comment|/* The `space' pseudo in the text section outputs nop insns rather than 0s,      so we must output 0s explicitly in the text section.  */
if|if
condition|(
name|ASM_NO_SKIP_IN_TEXT
operator|&&
name|in_text_section
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */
end_comment

begin_function
name|void
name|assemble_align
parameter_list|(
name|align
parameter_list|)
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a string constant with the specified C string as contents.  */
end_comment

begin_function
name|void
name|assemble_string
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|maximum
init|=
literal|2000
decl_stmt|;
comment|/* If the string is very long, split it up.  */
while|while
condition|(
name|pos
operator|<
name|size
condition|)
block|{
name|int
name|thissize
init|=
name|size
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|thissize
operator|>
name|maximum
condition|)
name|thissize
operator|=
name|maximum
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|thissize
expr_stmt|;
name|p
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_LOCAL
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, decl, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_LOCAL
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_LOCAL
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASM_EMIT_LOCAL
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_BSS
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_BSS
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_BSS
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_BSS
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_BSS (asm_out_file, decl, name, size, rounded)
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|ASM_EMIT_BSS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_COMMON
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, decl, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_COMMON
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_COMMON
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASM_EMIT_COMMON
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|asm_emit_uninitialised
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|rounded
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
enum|enum
block|{
name|asm_dest_common
block|,
name|asm_dest_bss
block|,
name|asm_dest_local
block|}
name|destination
init|=
name|asm_dest_local
enum|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
name|ASM_EMIT_BSS
if|if
condition|(
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|destination
operator|=
name|asm_dest_bss
expr_stmt|;
else|else
endif|#
directive|endif
name|destination
operator|=
name|asm_dest_common
expr_stmt|;
block|}
if|if
condition|(
name|flag_shared_data
condition|)
block|{
switch|switch
condition|(
name|destination
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_BSS
case|case
name|asm_dest_bss
case|:
name|ASM_OUTPUT_SHARED_BSS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_COMMON
case|case
name|asm_dest_common
case|:
name|ASM_OUTPUT_SHARED_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_LOCAL
case|case
name|asm_dest_local
case|:
name|ASM_OUTPUT_SHARED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|destination
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_EMIT_BSS
case|case
name|asm_dest_bss
case|:
name|ASM_EMIT_BSS
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|asm_dest_common
case|:
name|ASM_EMIT_COMMON
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
break|break;
case|case
name|asm_dest_local
case|:
name|ASM_EMIT_LOCAL
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Assemble everything that is needed for a variable or function declaration.    Not used for automatic variables, and not used for function definitions.    Should not be called for variables of incomplete structure type.     TOP_LEVEL is nonzero if this variable has file scope.    AT_END is nonzero if this is the special handling, at end of compilation,    to define things that have had only tentative definitions.    DONT_OUTPUT_DATA if nonzero means don't actually output the    initial value (that will be done by the caller).  */
end_comment

begin_function
name|void
name|assemble_variable
parameter_list|(
name|decl
parameter_list|,
name|top_level
parameter_list|,
name|at_end
parameter_list|,
name|dont_output_data
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|top_level
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|at_end
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|dont_output_data
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|int
name|reloc
init|=
literal|0
decl_stmt|;
name|rtx
name|decl_rtl
decl_stmt|;
name|last_assemble_variable_decl
operator|=
literal|0
expr_stmt|;
comment|/* Normally no need to say anything here for external references,      since assemble_external is called by the language-specific code      when a declaration is first seen.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output no assembler code for a function declaration.      Only definitions of functions output anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
comment|/* Do nothing for global register variables.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If type was incomplete when the variable was declared,      see if it is complete now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Still incomplete => don't allocate it; treat the tentative defn      (which is what it must have been) as an `extern' reference.  */
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Make sure ENCODE_SECTION_INFO is invoked before we set ASM_WRITTEN.  */
name|decl_rtl
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"size of variable `%s' is too large"
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|first_global_object_name
operator|&&
operator|!
operator|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|xname
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|xname
operator|=
name|permalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|xname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|first_global_object_name
operator|=
name|xname
expr_stmt|;
block|}
comment|/* Compute the alignment of this data.  */
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* In the case for initialing an array whose length isn't specified,      where we have not yet been able to do the layout,      figure out the proper alignment now.  */
if|if
condition|(
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some object file formats have a maximum alignment which they support.      In particular, a.out format supports a maximum alignment of 4.  */
ifndef|#
directive|ifndef
name|MAX_OFILE_ALIGNMENT
define|#
directive|define
name|MAX_OFILE_ALIGNMENT
value|BIGGEST_ALIGNMENT
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|MAX_OFILE_ALIGNMENT
condition|)
block|{
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment of `%s' is greater than maximum object file alignment. Using %d"
argument_list|,
name|MAX_OFILE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|align
operator|=
name|MAX_OFILE_ALIGNMENT
expr_stmt|;
block|}
comment|/* On some machines, it is good to increase alignment sometimes.  */
if|if
condition|(
operator|!
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DATA_ALIGNMENT
name|align
operator|=
name|DATA_ALIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Reset the alignment in case we have made it tighter, so we can benefit      from it in get_pointer_alignment.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
name|set_mem_align
argument_list|(
name|decl_rtl
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Handle uninitialized definitions.  */
if|if
condition|(
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
comment|/* If the target can't output uninitialized but not common global data 	 in .bss, then we have to use .data.  */
if|#
directive|if
operator|!
name|defined
name|ASM_EMIT_BSS
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
endif|#
directive|endif
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|dont_output_data
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|size
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|rounded
init|=
name|size
decl_stmt|;
comment|/* Don't allocate zero bytes of common, 	 since that means "undefined external" in the linker.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|rounded
operator|=
literal|1
expr_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits 	 so that each uninitialized object starts on such a boundary.  */
name|rounded
operator|+=
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|rounded
operator|=
operator|(
name|rounded
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Don't continue this line--convex cc version 4.1 would lose.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_COMMON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|>
name|rounded
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"requested alignment for %s is greater than implemented alignment of %d"
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asm_emit_uninitialised
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle initialized definitions.      Also handle uninitialized global definitions if -fno-common and the      target doesn't support ASM_OUTPUT_BSS.  */
comment|/* First make the assembler name(s) global if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Remove this variable from the pending weak list so that 	      we do not emit multiple .weak directives for it.  */
name|remove_from_pending_weak_list
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Output any data that we will need to use the address of.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|reloc
operator|=
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|?
literal|3
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Switch to the appropriate section.  */
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|variable_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
comment|/* dbxout.c needs to know this.  */
if|if
condition|(
name|in_text_section
argument_list|()
condition|)
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output the alignment of this data.  */
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the object.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
if|if
condition|(
operator|!
name|dont_output_data
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Output the actual data.  */
name|output_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
comment|/* Leave space for it.  */
name|assemble_zeros
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if type TYPE contains any pointers.  */
end_comment

begin_function
specifier|static
name|int
name|contains_pointers_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* I'm not sure whether OFFSET_TYPE needs this treatment, 	 so I'll play safe and return 1.  */
case|case
name|OFFSET_TYPE
case|:
return|return
literal|1
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|fields
decl_stmt|;
comment|/* For a type that has fields, see if the fields have pointers.  */
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
comment|/* An array type contains pointers if its element type does.  */
return|return
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Output something to declare an external symbol to the assembler.    (Most assemblers don't need this, so we normally output nothing.)    Do nothing if DECL is not external.  */
end_comment

begin_function
name|void
name|assemble_external
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Because most platforms do not define ASM_OUTPUT_EXTERNAL, the      main body of this code is only rarely exercised.  To provide some      testing, on all platforms, we make sure that the ASM_OUT_FILE is      open.  If it's not, we should not be calling this function.  */
if|if
condition|(
operator|!
name|asm_out_file
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Some systems do require some output.  */
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Similar, for calling a library function FUN.  */
end_comment

begin_function
name|void
name|assemble_external_libcall
parameter_list|(
name|fun
parameter_list|)
name|rtx
name|fun
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL_LIBCALL
comment|/* Declare library function name external when first used, if nec.  */
if|if
condition|(
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL_LIBCALL
argument_list|(
name|asm_out_file
argument_list|,
name|fun
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Declare the label NAME global.  */
end_comment

begin_function
name|void
name|assemble_global
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a label named NAME.  */
end_comment

begin_function
name|void
name|assemble_label
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output to FILE a reference to the assembler name of a C-level name NAME.    If NAME starts with a *, the rest of NAME is output verbatim.    Otherwise NAME is transformed in an implementation-defined way    (usually by the addition of an underscore).    Many macros in the tm file are defined to call this function.  */
end_comment

begin_function
name|void
name|assemble_name
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|real_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|fputs
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes writable static space with a gensym name    and return an RTX to refer to its address.  */
end_comment

begin_function
name|rtx
name|assemble_static_space
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|namestring
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|#
directive|if
literal|0
block|if (flag_shared_data)     data_section ();
endif|#
directive|endif
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LF"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|namestring
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits        so that each uninitialized object starts on such a boundary.  */
comment|/* Variable `rounded' might or might not be used in ASM_OUTPUT_LOCAL.  */
name|int
name|rounded
name|ATTRIBUTE_UNUSED
init|=
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Assemble the static constant template for function entry trampolines.    This is done at most once per compilation.    Returns an RTX for the address of the template.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
end_ifdef

begin_function
name|rtx
name|assemble_trampoline_template
parameter_list|()
block|{
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* By default, put trampoline templates in read-only data section.  */
ifdef|#
directive|ifdef
name|TRAMPOLINE_SECTION
name|TRAMPOLINE_SECTION
argument_list|()
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Write the assembler code to define one.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRAMPOLINE_TEMPLATE
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Record the rtl to refer to it.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|ggc_strdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A and B are either alignments or offsets.  Return the minimum alignment    that may be assumed after adding the two together.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|min_align
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator||
name|b
operator|)
operator|&
operator|-
operator|(
name|a
operator||
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the assembler directive for creating a given kind of integer    object.  SIZE is the number of bytes in the object and ALIGNED_P    indicates whether it is known to be aligned.  Return NULL if the    assembly dialect has no such directive.     The returned string should be printed at the start of a new line and    be followed immediately by the object's initial value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|integer_asm_op
parameter_list|(
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
name|struct
name|asm_int_op
modifier|*
name|ops
decl_stmt|;
if|if
condition|(
name|aligned_p
condition|)
name|ops
operator|=
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|aligned_op
expr_stmt|;
else|else
name|ops
operator|=
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|targetm
operator|.
name|asm_out
operator|.
name|byte_op
return|;
case|case
literal|2
case|:
return|return
name|ops
operator|->
name|hi
return|;
case|case
literal|4
case|:
return|return
name|ops
operator|->
name|si
return|;
case|case
literal|8
case|:
return|return
name|ops
operator|->
name|di
return|;
case|case
literal|16
case|:
return|return
name|ops
operator|->
name|ti
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Use directive OP to assemble an integer object X.  Print OP at the    start of the line, followed immediately by the value of X.  */
end_comment

begin_function
name|void
name|assemble_integer_with_op
parameter_list|(
name|op
parameter_list|,
name|x
parameter_list|)
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|fputs
argument_list|(
name|op
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The default implementation of the asm_out.integer target hook.  */
end_comment

begin_function
name|bool
name|default_assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|aligned_p
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|op
init|=
name|integer_asm_op
argument_list|(
name|size
argument_list|,
name|aligned_p
argument_list|)
decl_stmt|;
return|return
name|op
operator|&&
operator|(
name|assemble_integer_with_op
argument_list|(
name|op
argument_list|,
name|x
argument_list|)
operator|,
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is    the alignment of the integer in bits.  Return 1 if we were able to output    the constant, otherwise 0.  If FORCE is non-zero, abort if we can't output    the constant.  */
end_comment

begin_function
name|bool
name|assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|force
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|int
name|aligned_p
decl_stmt|;
name|aligned_p
operator|=
operator|(
name|align
operator|>=
name|MIN
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|)
expr_stmt|;
comment|/* See if the target hook can handle this kind of object.  */
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|integer
call|)
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If the object is a multi-byte one, try splitting it up.  Split      it into words it if is multi-word, otherwise split it into bytes.  */
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|omode
decl_stmt|,
name|imode
decl_stmt|;
name|unsigned
name|int
name|subalign
decl_stmt|;
name|unsigned
name|int
name|subsize
decl_stmt|,
name|i
decl_stmt|;
name|subsize
operator|=
name|size
operator|>
name|UNITS_PER_WORD
condition|?
name|UNITS_PER_WORD
else|:
literal|1
expr_stmt|;
name|subalign
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|subsize
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|omode
operator|=
name|mode_for_size
argument_list|(
name|subsize
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|subsize
control|)
block|{
name|rtx
name|partial
init|=
name|simplify_subreg
argument_list|(
name|omode
argument_list|,
name|x
argument_list|,
name|imode
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|partial
operator|||
operator|!
name|assemble_integer
argument_list|(
name|partial
argument_list|,
name|subsize
argument_list|,
name|subalign
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|size
condition|)
return|return
name|true
return|;
comment|/* If we've printed some of it, but not all of it, there's no going 	 back now.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|assemble_real
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|,
name|align
parameter_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|long
name|data
index|[
literal|4
index|]
decl_stmt|;
name|long
name|l
decl_stmt|;
name|unsigned
name|int
name|nalign
init|=
name|min_align
argument_list|(
name|align
argument_list|,
literal|32
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|BITS_PER_UNIT
condition|)
block|{
case|case
literal|8
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|l
argument_list|)
argument_list|,
literal|4
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|d
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|d
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|d
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HFmode
case|:
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|l
argument_list|)
argument_list|,
literal|2
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TQFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|d
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|2
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QFmode
case|:
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|l
argument_list|)
argument_list|,
literal|1
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|d
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|nalign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here we combine duplicate floating constants to make    CONST_DOUBLE rtx's, and force those out to memory when necessary.  */
end_comment

begin_comment
comment|/* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair of ints.    For an integer, I0 is the low-order word and I1 is the high-order word.    For a real number, I0 is the word with the low address    and I1 is the word with the high address.  */
end_comment

begin_function
name|rtx
name|immed_double_const
parameter_list|(
name|i0
parameter_list|,
name|i1
parameter_list|,
name|mode
parameter_list|)
name|HOST_WIDE_INT
name|i0
decl_stmt|,
name|i1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
block|{
comment|/* We clear out all bits that don't belong in MODE, unless they and our 	 sign bit are all one.  So we get either a reasonable negative value 	 or a reasonable unsigned value for this mode.  */
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|i0
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|i0
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|,
name|i1
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|!
operator|(
name|i1
operator|==
operator|~
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
condition|)
name|i1
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* We cannot represent this value as a constant.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* If this would be an entire word for the target, but is not for 	 the host, then sign-extend on the host so that the number will look 	 the same way on the host that it would on the target.  	 For example, when building a 64 bit alpha hosted 32 bit sparc 	 targeted compiler, then we want the 32 bit unsigned value -1 to be 	 represented as a 64 bit value -1, and not as 0x00000000ffffffff. 	 The later confuses the sparc backend.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|i0
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|i0
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
comment|/* If MODE fits within HOST_BITS_PER_WIDE_INT, always use a CONST_INT.  	 ??? Strictly speaking, this is wrong if we create a CONST_INT 	 for a large unsigned constant with the size of MODE being 	 HOST_BITS_PER_WIDE_INT and later try to interpret that constant in a 	 wider mode.  In that case we will mis-interpret it as a negative 	 number.  	 Unfortunately, the only alternative is to make a CONST_DOUBLE 	 for any constant in any mode if it is an unsigned constant larger 	 than the maximum signed integer in an int on the host.  However, 	 doing this will break everyone that always expects to see a CONST_INT 	 for SImode and smaller.  	 We have always been making CONST_INTs in this case, so nothing new 	 is being broken.  */
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|i1
operator|=
operator|(
name|i0
operator|<
literal|0
operator|)
condition|?
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
comment|/* If this integer fits in one word, return a CONST_INT.  */
if|if
condition|(
operator|(
name|i1
operator|==
literal|0
operator|&&
name|i0
operator|>=
literal|0
operator|)
operator|||
operator|(
name|i1
operator|==
operator|~
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
condition|)
return|return
name|GEN_INT
argument_list|(
name|i0
argument_list|)
return|;
comment|/* We use VOIDmode for integers.  */
name|mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
if|if
condition|(
name|cfun
operator|!=
literal|0
condition|)
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
operator|==
name|i0
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|r
argument_list|)
operator|==
name|i1
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.  */
name|r
operator|=
name|gen_rtx_CONST_DOUBLE
argument_list|(
name|mode
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
comment|/* Don't touch const_double_chain if not inside any function.  */
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|r
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE for a specified `double' value    and machine mode.  */
end_comment

begin_function
name|rtx
name|immed_real_const_1
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|union
name|real_extract
name|u
decl_stmt|;
name|rtx
name|r
decl_stmt|;
comment|/* Get the desired `double' value as a sequence of ints      since that is how they are stored in a CONST_DOUBLE.  */
name|u
operator|.
name|d
operator|=
name|d
expr_stmt|;
comment|/* Detect special cases.  Check for NaN first, because some ports      (specifically the i386) do not emit correct ieee-fp code by default, and      thus will generate a core dump here if we pass a NaN to REAL_VALUES_EQUAL      and if REAL_VALUES_EQUAL does a floating point comparison.  */
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|d
argument_list|)
operator|&&
name|REAL_VALUES_IDENTICAL
argument_list|(
name|dconst0
argument_list|,
name|d
argument_list|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|d
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|dconst1
argument_list|,
name|d
argument_list|)
condition|)
return|return
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|d
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|dconst2
argument_list|,
name|d
argument_list|)
condition|)
return|return
name|CONST2_RTX
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
sizeof|sizeof
name|u
operator|==
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
return|return
name|immed_double_const
argument_list|(
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
sizeof|sizeof
name|u
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
return|return
name|immed_double_const
argument_list|(
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
return|;
comment|/* The rest of this function handles the case where      a float value requires more than 2 ints of space.      It will be deleted as dead code on machines that don't need it.  */
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
if|if
condition|(
name|cfun
operator|!=
literal|0
condition|)
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.       We may be called by an optimizer which may be discarding any memory      allocated during its processing (such as combine and loop).  However,      we will be leaving this constant on the chain, so we cannot tolerate      freed memory.  */
name|r
operator|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
comment|/* If we aren't inside a function, don't put r on the      const_double_chain.  */
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|r
expr_stmt|;
block|}
else|else
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE rtx for a value specified by EXP,    which must be a REAL_CST tree node.  */
end_comment

begin_function
name|rtx
name|immed_real_const
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
name|immed_real_const_1
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* At the end of a function, forget the memory-constants    previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.    Also clear out real_constant_chain and clear out all the chain-pointers.  */
end_comment

begin_function
name|void
name|clear_const_double_mem
parameter_list|()
block|{
name|rtx
name|r
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|next
control|)
block|{
name|next
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|const_double_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP with a constant value,    reduce it to the sum of an assembler symbol and an integer.    Store them both in the structure *VALUE.    Abort if EXP does not reduce.  */
end_comment

begin_struct
struct|struct
name|addr_const
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|exp
parameter_list|,
name|value
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|addr_const
modifier|*
name|value
decl_stmt|;
block|{
name|tree
name|target
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|host_integerp
argument_list|(
name|byte_position
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|int_byte_position
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|offset
operator|+=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|x
operator|=
name|DECL_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|INTEGER_CST
case|:
comment|/* This constant should have been output already, but we can't simply 	 use TREE_CST_RTL since INTEGER_CST doesn't have one.  */
name|x
operator|=
name|output_constant_def
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|kind
block|{
name|RTX_DOUBLE
block|,
name|RTX_INT
block|}
enum|;
end_enum

begin_struct
struct|struct
name|rtx_const
block|{
name|ENUM_BITFIELD
argument_list|(
argument|kind
argument_list|)
name|kind
label|:
literal|16
expr_stmt|;
name|ENUM_BITFIELD
argument_list|(
argument|machine_mode
argument_list|)
name|mode
label|:
literal|16
expr_stmt|;
union|union
block|{
name|union
name|real_extract
name|du
decl_stmt|;
name|struct
name|addr_const
name|addr
decl_stmt|;
struct|struct
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
block|}
name|di
struct|;
block|}
name|un
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Uniquize all constants that appear in memory.    Each constant in memory thus far output is recorded    in `const_hash_table' with a `struct constant_descriptor'    that contains a polish representation of the value of    the constant.     We cannot store the trees in the hash table    because the trees may be temporary.  */
end_comment

begin_struct
struct|struct
name|constant_descriptor
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
comment|/* Make sure the data is reasonably aligned.  */
union|union
block|{
name|unsigned
name|char
name|contents
index|[
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
name|long
name|double
name|d
decl_stmt|;
else|#
directive|else
name|double
name|d
decl_stmt|;
endif|#
directive|endif
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_define
define|#
directive|define
name|MAX_HASH_TABLE
value|1009
end_define

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|const_hash_table
index|[
name|MAX_HASH_TABLE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We maintain a hash table of STRING_CST values.  Unless we are asked to force    out a string constant, we defer output of the constants until we know    they are actually used.  This will be if something takes its address or if    there is a usage of the string in the RTL of a function.  */
end_comment

begin_define
define|#
directive|define
name|STRHASH
parameter_list|(
name|x
parameter_list|)
value|((hashval_t) ((long) (x)>> 3))
end_define

begin_struct
struct|struct
name|deferred_string
block|{
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|htab_t
name|const_str_htab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark a const_hash_table descriptor for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_const_hash_entry
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|desc
init|=
operator|*
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|*
operator|)
name|ptr
decl_stmt|;
while|while
condition|(
name|desc
condition|)
block|{
name|ggc_mark_rtx
argument_list|(
name|desc
operator|->
name|rtl
argument_list|)
expr_stmt|;
name|desc
operator|=
name|desc
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark the hash-table element X (which is really a pointer to an    struct deferred_string *).  */
end_comment

begin_function
specifier|static
name|int
name|mark_const_str_htab_1
parameter_list|(
name|x
parameter_list|,
name|data
parameter_list|)
name|void
modifier|*
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ggc_mark_tree
argument_list|(
operator|(
operator|(
expr|struct
name|deferred_string
operator|*
operator|)
operator|*
name|x
operator|)
operator|->
name|exp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark a const_str_htab for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_const_str_htab
parameter_list|(
name|htab
parameter_list|)
name|void
modifier|*
name|htab
decl_stmt|;
block|{
name|htab_traverse
argument_list|(
operator|*
operator|(
operator|(
name|htab_t
operator|*
operator|)
name|htab
operator|)
argument_list|,
name|mark_const_str_htab_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for X (which is a really a    struct deferred_string *).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_str_htab_hash
parameter_list|(
name|x
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
block|{
return|return
name|STRHASH
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|deferred_string
operator|*
operator|)
name|x
operator|)
operator|->
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value represented by X (which is really a    struct deferred_string *) is the same as that given by Y    (which is really a char *).  */
end_comment

begin_function
specifier|static
name|int
name|const_str_htab_eq
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
specifier|const
name|void
modifier|*
name|y
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
specifier|const
expr|struct
name|deferred_string
operator|*
operator|)
name|x
operator|)
operator|->
name|label
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete the hash table entry dfsp.  */
end_comment

begin_function
specifier|static
name|void
name|const_str_htab_del
parameter_list|(
name|dfsp
parameter_list|)
name|void
modifier|*
name|dfsp
decl_stmt|;
block|{
name|free
argument_list|(
name|dfsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a constant expression.  */
end_comment

begin_function
specifier|static
name|int
name|const_hash
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|,
name|hi
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Either set P and LEN to the address and len of something to hash and      exit the switch or return a value.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_INT_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|const_hash
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|*
literal|5
operator|+
name|const_hash
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tree
name|link
decl_stmt|;
comment|/* For record type, include the type in the hashing. 	     We do not do so for array types 	     because (1) the sizes of the elements are sufficient 	     and (2) distinct array types can have the same constructor. 	     Instead, we include the array size because the constructor could 	     be shorter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|hi
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
else|else
name|hi
operator|=
operator|(
operator|(
literal|5
operator|+
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
name|hi
operator|=
operator|(
name|hi
operator|*
literal|603
operator|+
name|const_hash
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* Don't hash the address of the SYMBOL_REF; 	       only use the offset and the symbol name.  */
name|hi
operator|=
name|value
operator|.
name|offset
expr_stmt|;
name|p
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|hi
operator|=
name|value
operator|.
name|offset
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|13
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
block|}
return|return
name|hi
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
operator|(
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|9
operator|+
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|7
operator|+
literal|2
return|;
default|default:
comment|/* A language specific constant. Just hash the code.  */
return|return
operator|(
name|int
operator|)
name|code
operator|%
name|MAX_HASH_TABLE
return|;
block|}
comment|/* Compute hashing function */
name|hi
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare a constant expression EXP with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as EXP.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant
parameter_list|(
name|exp
parameter_list|,
name|desc
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
return|return
literal|0
operator|!=
name|compare_constant_1
argument_list|(
name|exp
argument_list|,
name|desc
operator|->
name|u
operator|.
name|contents
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare constant expression EXP with a substring P of a constant descriptor.    If they match, return a pointer to the end of the substring matched.    If they do not match, return 0.     Since descriptors are written in polish prefix notation,    this function can be used recursively to test one operand of EXP    against a subdescriptor, and if it succeeds it returns the    address of the subdescriptor for the next operand.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|compare_constant_1
parameter_list|(
name|exp
parameter_list|,
name|p
parameter_list|)
name|tree
name|exp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|strp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
operator|(
expr|enum
name|tree_code
operator|)
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
comment|/* Either set STRP, P and LEN to pointers and length to compare and exit the      switch, or return the result of the comparison.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* Integer constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_INT_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
comment|/* Real constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
if|if
condition|(
name|flag_writable_strings
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
expr|enum
name|machine_mode
operator|)
operator|*
name|p
operator|++
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|compare_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|int
name|xlen
init|=
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmp
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xlen
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|xlen
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|xlen
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|have_purpose
init|=
literal|0
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
name|have_purpose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|length
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	     For arrays, just verify both constructors are for arrays. 	     Then insist that either both or none have any TREE_PURPOSE 	     values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mode
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|mode
expr_stmt|;
block|}
name|p
operator|+=
sizeof|sizeof
name|type
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|have_purpose
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|have_purpose
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|have_purpose
expr_stmt|;
comment|/* For arrays, insist that the size in bytes match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|size
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|zero
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|TREE_PURPOSE
operator|(
name|link
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|TREE_PURPOSE
operator|(
name|link
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|have_purpose
condition|)
block|{
name|int
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|zero
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|offset
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
operator|.
name|offset
expr_stmt|;
comment|/* Compare the offset.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
comment|/* Compare symbol name.  */
name|strp
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|strp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|RANGE_EXPR
case|:
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
return|;
default|default:
block|{
name|tree
name|new
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|exp
condition|)
return|return
name|compare_constant_1
argument_list|(
name|new
argument_list|,
name|p
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct a constant descriptor for the expression EXP.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|label
init|=
literal|0
decl_stmt|;
name|rtx
name|rtl
init|=
literal|0
decl_stmt|;
name|int
name|pad
decl_stmt|;
comment|/* Make a struct constant_descriptor.  The first three pointers will      be filled in later.  Here we just leave space for them.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|next
argument_list|,
sizeof|sizeof
name|next
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rtl
argument_list|,
sizeof|sizeof
name|rtl
argument_list|)
expr_stmt|;
comment|/* Align the descriptor for the data payload.  */
name|pad
operator|=
operator|(
name|offsetof
argument_list|(
expr|struct
name|constant_descriptor
argument_list|,
name|u
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|constant_descriptor
argument_list|,
name|rtl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|next
operator|->
name|rtl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pad
operator|>
literal|0
condition|)
name|obstack_blank
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a description of constant expression EXP    to the object growing in `permanent_obstack'.    No need to return its address; the caller will get that    from the obstack when the object is complete.  */
end_comment

begin_function
specifier|static
name|void
name|record_constant_1
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|strp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_INT_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
if|if
condition|(
name|flag_writable_strings
condition|)
return|return;
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
name|record_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|int
name|nbytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|nbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|permanent_obstack
operator|.
name|next_free
operator|-
name|nbytes
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|have_purpose
init|=
literal|0
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
name|have_purpose
operator|=
literal|1
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
sizeof|sizeof
name|length
argument_list|)
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	     For arrays, just verify both constructors are for arrays 	     of the same mode.  Then insist that either both or none 	     have any TREE_PURPOSE values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
sizeof|sizeof
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|mode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|have_purpose
argument_list|,
sizeof|sizeof
name|have_purpose
argument_list|)
expr_stmt|;
comment|/* For arrays, insist that the size in bytes match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
sizeof|sizeof
name|size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
name|record_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|zero
init|=
literal|0
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
sizeof|sizeof
name|TREE_PURPOSE
operator|(
name|link
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
name|record_constant_1
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|have_purpose
condition|)
block|{
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Record the offset.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|offset
argument_list|,
sizeof|sizeof
name|value
operator|.
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* Record the symbol name.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* Record the address of the CODE_LABEL.  It may not have 	       been emitted yet, so it's UID may be zero.  But pointer 	       identity is good enough.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|XEXP
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|RANGE_EXPR
case|:
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
block|{
name|tree
name|new
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|exp
condition|)
name|record_constant_1
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Record constant contents.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|strp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a list of constant expressions that were passed to    output_constant_def but that could not be output right away.  */
end_comment

begin_struct
struct|struct
name|deferred_constant
block|{
name|struct
name|deferred_constant
modifier|*
name|next
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|deferred_constant
modifier|*
name|deferred_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Another list of constants which should be output after the    function.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|deferred_constant
modifier|*
name|after_function_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means defer output of addressed subconstants    (i.e., those for which output_constant_def is called.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defer_addressed_constants_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start deferring output of subconstants.  */
end_comment

begin_function
name|void
name|defer_addressed_constants
parameter_list|()
block|{
name|defer_addressed_constants_flag
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop deferring output of subconstants,    and output now all those that have been deferred.  */
end_comment

begin_function
name|void
name|output_deferred_addressed_constants
parameter_list|()
block|{
name|struct
name|deferred_constant
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|defer_addressed_constants_flag
operator|--
expr_stmt|;
if|if
condition|(
name|defer_addressed_constants_flag
operator|>
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|deferred_constants
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|output_constant_def_contents
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|reloc
argument_list|,
name|p
operator|->
name|labelno
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|deferred_constants
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output any constants which should appear after a function.  */
end_comment

begin_function
specifier|static
name|void
name|output_after_function_constants
parameter_list|()
block|{
name|struct
name|deferred_constant
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|after_function_constants
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|output_constant_def_contents
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|reloc
argument_list|,
name|p
operator|->
name|labelno
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|after_function_constants
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a copy of the whole tree structure for a constant.    This handles the same types of nodes that compare_constant    and record_constant handle.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_constant
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* For ADDR_EXPR, we do not want to copy the decl whose address 	 is requested.  We do want to copy constants though.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|build_complex
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|tree
name|copy
init|=
name|copy_node
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|copy_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tail
decl_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|copy
argument_list|)
operator|=
name|list
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|copy_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|copy_constant
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx representing a reference to constant data in memory    for the constant expression EXP.     If assembler code for such a constant has already been output,    return an rtx to refer to it.    Otherwise, output such a constant in memory (or defer it for later)    and generate an rtx for it.     If DEFER is non-zero, the output of string constants can be deferred    and output only if referenced in the function after all optimizations.     The TREE_CST_RTL of EXP is set up to point to that rtx.    The const_hash_table records which constants already have label strings.  */
end_comment

begin_function
name|rtx
name|output_constant_def
parameter_list|(
name|exp
parameter_list|,
name|defer
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|defer
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|deferred_string
modifier|*
modifier|*
name|defstr
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|found
init|=
literal|1
decl_stmt|;
name|int
name|after_function
init|=
literal|0
decl_stmt|;
name|int
name|labelno
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
comment|/* We can't just use the saved RTL if this is a defererred string constant      and we are not to defer anymode.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|defer
operator|||
operator|!
name|STRING_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Make sure any other constants whose addresses appear in EXP      are assigned label numbers.  */
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Compute hash code of EXP.  Search the descriptors for that hash code      to see if any of them describes EXP.  If yes, the descriptor records      the label number already assigned.  */
name|hash
operator|=
name|const_hash
argument_list|(
name|exp
argument_list|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant
argument_list|(
name|exp
argument_list|,
name|desc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|desc
operator|==
literal|0
condition|)
block|{
comment|/* No constant equal to EXP is known to have been output. 	 Make a constant descriptor to enter EXP in the hash table. 	 Assign the label number and record it in the descriptor for 	 future calls to this function to find.  */
comment|/* Create a string containing the label name, in LABEL.  */
name|labelno
operator|=
name|const_labelno
operator|++
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|desc
operator|=
name|record_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|desc
operator|->
name|label
operator|=
name|ggc_strdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|const_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
name|rtl
operator|=
name|desc
operator|->
name|rtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|desc
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|rtl
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|rtl
argument_list|,
name|const_alias_set
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|rtl
operator|=
name|desc
operator|->
name|rtl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|rtl
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information      such as that it is a function name.  If the name is changed, the macro      ASM_OUTPUT_LABELREF will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
comment|/* A previously-processed constant would already have section info      encoded in it.  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|ENCODE_SECTION_INFO
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|rtl
operator|=
name|rtl
expr_stmt|;
name|desc
operator|->
name|label
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|desc
operator|->
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONSTANT_AFTER_FUNCTION_P
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
operator|&&
name|CONSTANT_AFTER_FUNCTION_P
argument_list|(
name|exp
argument_list|)
condition|)
name|after_function
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|found
operator|&&
name|STRING_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|defer
operator|||
name|defer_addressed_constants_flag
operator|||
name|after_function
operator|)
condition|)
block|{
name|defstr
operator|=
operator|(
expr|struct
name|deferred_string
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|const_str_htab
argument_list|,
name|desc
operator|->
name|label
argument_list|,
name|STRHASH
argument_list|(
name|desc
operator|->
name|label
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|defstr
condition|)
block|{
comment|/* If the string is currently deferred but we need to output it now, 	     remove it from deferred string hash table.  */
name|found
operator|=
literal|0
expr_stmt|;
name|labelno
operator|=
operator|(
operator|*
name|defstr
operator|)
operator|->
name|labelno
expr_stmt|;
name|STRING_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|const_str_htab
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|defstr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is the first time we've seen this particular constant,      output it (or defer its output for later).  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|defer_addressed_constants_flag
operator|||
name|after_function
condition|)
block|{
name|struct
name|deferred_constant
modifier|*
name|p
init|=
operator|(
expr|struct
name|deferred_constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deferred_constant
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|exp
operator|=
name|copy_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|labelno
operator|=
name|labelno
expr_stmt|;
if|if
condition|(
name|after_function
condition|)
block|{
name|p
operator|->
name|next
operator|=
name|after_function_constants
expr_stmt|;
name|after_function_constants
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|next
operator|=
name|deferred_constants
expr_stmt|;
name|deferred_constants
operator|=
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|STRING_CST
operator|||
operator|!
name|defer
operator|||
name|flag_writable_strings
operator|||
operator|(
name|defstr
operator|=
operator|(
expr|struct
name|deferred_string
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|const_str_htab
argument_list|,
name|desc
operator|->
name|label
argument_list|,
name|STRHASH
argument_list|(
name|desc
operator|->
name|label
argument_list|)
argument_list|,
name|INSERT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|output_constant_def_contents
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|deferred_string
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|deferred_string
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deferred_string
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|exp
operator|=
name|copy_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|p
operator|->
name|label
operator|=
name|desc
operator|->
name|label
expr_stmt|;
name|p
operator|->
name|labelno
operator|=
name|labelno
expr_stmt|;
operator|*
name|defstr
operator|=
name|p
expr_stmt|;
name|STRING_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Now output assembler code to define the label for EXP,    and follow it with the data of EXP.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_def_contents
parameter_list|(
name|exp
parameter_list|,
name|reloc
parameter_list|,
name|labelno
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|exp
argument_list|)
condition|)
name|named_section
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* First switch to text section, except for writable strings.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|&&
name|flag_writable_strings
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Output the label itself.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of EXP.  */
name|output_constant
argument_list|(
name|exp
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|?
name|MAX
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
else|:
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure to represent sufficient information about a constant so that    it can be output when the constant pool is output, so that function    integration can be done, and to simplify handling on machines that reference    constant pool as base+displacement.  */
end_comment

begin_struct
struct|struct
name|pool_constant
block|{
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|next
decl_stmt|,
modifier|*
name|next_sym
decl_stmt|;
name|rtx
name|constant
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|mark
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.    The argument is XSTR (... , 0)  */
end_comment

begin_define
define|#
directive|define
name|SYMHASH
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|((((unsigned long) (LABEL))& ((1<< HASHBITS) - 1))  % MAX_RTX_HASH_TABLE)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize constant pool hashing for a new function.  */
end_comment

begin_function
name|void
name|init_varasm_status
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|varasm_status
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|varasm_status
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|varasm_status
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|varasm
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|x_const_rtx_hash_table
operator|=
operator|(
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|MAX_RTX_HASH_TABLE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|constant_descriptor
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|x_const_rtx_sym_hash_table
operator|=
operator|(
operator|(
expr|struct
name|pool_constant
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|MAX_RTX_HASH_TABLE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pool_constant
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|x_first_pool
operator|=
name|p
operator|->
name|x_last_pool
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|x_pool_offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|x_const_double_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark PC for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_pool_constant
parameter_list|(
name|pc
parameter_list|)
name|struct
name|pool_constant
modifier|*
name|pc
decl_stmt|;
block|{
while|while
condition|(
name|pc
condition|)
block|{
name|ggc_mark
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|pc
operator|->
name|constant
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|pc
operator|->
name|desc
operator|->
name|rtl
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pc
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark P for GC.  */
end_comment

begin_function
name|void
name|mark_varasm_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|varasm_status
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|mark_pool_constant
argument_list|(
name|p
operator|->
name|x_first_pool
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|p
operator|->
name|x_const_double_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out all parts of the state in F that can safely be discarded    after the function has been compiled, to let garbage collection    reclaim the memory.  */
end_comment

begin_function
name|void
name|free_varasm_status
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|varasm_status
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|f
operator|->
name|varasm
expr_stmt|;
comment|/* Clear out the hash tables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RTX_HASH_TABLE
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|constant_descriptor
modifier|*
name|cd
decl_stmt|;
name|cd
operator|=
name|p
operator|->
name|x_const_rtx_hash_table
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|cd
condition|)
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
init|=
name|cd
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|=
name|next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|p
operator|->
name|x_const_rtx_hash_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|x_const_rtx_sym_hash_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|f
operator|->
name|varasm
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Express an rtx for a constant integer (perhaps symbolic)    as the sum of a symbol or label plus an explicit integer.    They are stored into VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|decode_rtx_const
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|value
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|rtx_const
modifier|*
name|value
decl_stmt|;
block|{
comment|/* Clear the whole structure, including any gaps.  */
name|memset
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_const
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|RTX_INT
expr_stmt|;
comment|/* Most usual kind.  */
name|value
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
name|value
operator|->
name|kind
operator|=
name|RTX_DOUBLE
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|value
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|->
name|un
operator|.
name|du
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
name|value
operator|->
name|un
operator|.
name|du
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|->
name|un
operator|.
name|di
operator|.
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|di
operator|.
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|->
name|kind
operator|==
name|RTX_INT
operator|&&
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* Use the string's address, not the SYMBOL_REF's address, 	   for the sake of addresses of library routines.  */
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
operator|(
name|rtx
operator|)
name|XSTR
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* For a LABEL_REF, compare labels.  */
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a MINUS expression, simplify it if both sides    include the same symbol.  */
end_comment

begin_function
name|rtx
name|simplify_subtraction
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|rtx_const
name|val0
decl_stmt|,
name|val1
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|val0
argument_list|)
expr_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|base
operator|==
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|base
condition|)
return|return
name|GEN_INT
argument_list|(
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
operator|-
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
argument_list|)
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a constant RTL expression.  */
end_comment

begin_function
specifier|static
name|int
name|const_hash_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|hi
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Compute hashing function */
name|hi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
name|hi
operator|+=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|value
operator|)
index|[
name|i
index|]
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_RTX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_comment
comment|/* Compare a constant rtl object X with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as X.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|desc
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|desc
operator|->
name|u
operator|.
name|contents
decl_stmt|;
name|int
modifier|*
name|strp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|value
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct a constant descriptor for the rtl-expression X.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
operator|(
name|offsetof
argument_list|(
expr|struct
name|constant_descriptor
argument_list|,
name|u
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_const
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|(
expr|struct
name|rtx_const
operator|*
operator|)
name|ptr
operator|->
name|u
operator|.
name|contents
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant rtx X, return a MEM for the location in memory at which    this constant has been placed.  Return 0 if it not has been placed yet.  */
end_comment

begin_function
name|rtx
name|mem_for_const_double
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|desc
operator|=
name|const_rtx_hash_table
index|[
name|const_hash_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|desc
argument_list|)
condition|)
return|return
name|desc
operator|->
name|rtl
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a constant rtx X, make (or find) a memory constant for its value    and return a MEM rtx to refer to it in memory.  */
end_comment

begin_function
name|rtx
name|force_const_mem
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|def
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* Compute hash code of X.  Search the descriptors for that hash code      to see if any of them describes X.  If yes, we have an rtx to use.  */
name|hash
operator|=
name|const_hash_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|desc
argument_list|)
condition|)
return|return
name|desc
operator|->
name|rtl
return|;
comment|/* No constant equal to X is known to have been output.      Make a constant descriptor to enter X in the hash table      and make a MEM for it.  */
name|desc
operator|=
name|record_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
operator|==
name|VOIDmode
condition|?
name|word_mode
else|:
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|make_tree
argument_list|(
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pool_offset
operator|+=
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|pool_offset
operator|&=
operator|~
operator|(
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|LABEL_PRESERVE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Allocate a pool constant descriptor, fill it in, and chain it in.  */
name|pool
operator|=
operator|(
expr|struct
name|pool_constant
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_constant
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|desc
operator|=
name|desc
expr_stmt|;
name|pool
operator|->
name|constant
operator|=
name|x
expr_stmt|;
name|pool
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|pool
operator|->
name|labelno
operator|=
name|const_labelno
expr_stmt|;
name|pool
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|pool
operator|->
name|offset
operator|=
name|pool_offset
expr_stmt|;
name|pool
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_pool
operator|==
literal|0
condition|)
name|first_pool
operator|=
name|pool
expr_stmt|;
else|else
name|last_pool
operator|->
name|next
operator|=
name|pool
expr_stmt|;
name|last_pool
operator|=
name|pool
expr_stmt|;
name|pool_offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
comment|/* Construct the SYMBOL_REF and the MEM.  */
name|pool
operator|->
name|desc
operator|->
name|rtl
operator|=
name|def
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|def
argument_list|,
name|const_alias_set
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|def
argument_list|,
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|def
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Add label to symbol hash table.  */
name|hash
operator|=
name|SYMHASH
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|next_sym
operator|=
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
operator|=
name|pool
expr_stmt|;
comment|/* Mark the symbol_ref as belonging to this constants pool.  */
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_function_uses_const_pool
operator|=
literal|1
expr_stmt|;
return|return
name|def
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to    the corresponding pool_constant structure.  */
end_comment

begin_function
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
parameter_list|(
name|f
parameter_list|,
name|addr
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
init|=
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|f
operator|->
name|varasm
operator|->
name|x_const_rtx_sym_hash_table
index|[
name|SYMHASH
argument_list|(
name|label
argument_list|)
index|]
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next_sym
control|)
if|if
condition|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|pool
operator|->
name|desc
operator|->
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
return|return
name|pool
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */
end_comment

begin_function
name|rtx
name|get_pool_constant
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but for the constant pool of a specific function.  */
end_comment

begin_function
name|rtx
name|get_pool_constant_for_function
parameter_list|(
name|f
parameter_list|,
name|addr
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the mode.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_pool_mode
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|mode
return|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|get_pool_mode_for_function
parameter_list|(
name|f
parameter_list|,
name|addr
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the offset in the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_offset
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_size
parameter_list|()
block|{
return|return
name|pool_offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write all the constants in the constant pool.  */
end_comment

begin_function
name|void
name|output_constant_pool
parameter_list|(
name|fnname
parameter_list|,
name|fndecl
parameter_list|)
specifier|const
name|char
modifier|*
name|fnname
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
comment|/* It is possible for gcc to call force_const_mem and then to later      discard the instructions which refer to the constant.  In such a      case we do not need to output the constant.  */
name|mark_constant_pool
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_PROLOGUE
name|ASM_OUTPUT_POOL_PROLOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|x
operator|=
name|pool
operator|->
name|constant
expr_stmt|;
if|if
condition|(
operator|!
name|pool
operator|->
name|mark
condition|)
continue|continue;
comment|/* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF) 	 whose CODE_LABEL has been deleted.  This can occur if a jump table 	 is eliminated by optimization.  If so, write a constant of zero 	 instead.  Note that this can also happen by turning the 	 CODE_LABEL into a NOTE.  */
comment|/* ??? This seems completely and utterly wrong.  Certainly it's 	 not true for NOTE_INSN_DELETED_LABEL, but I disbelieve proper 	 functioning even with INSN_DELETED_P and friends.  */
name|tmp
operator|=
name|x
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
break|break;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|LABEL_REF
case|:
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|tmp
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|const0_rtx
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* First switch to correct section.  */
ifdef|#
directive|ifdef
name|SELECT_RTX_SECTION
name|SELECT_RTX_SECTION
argument_list|(
name|pool
operator|->
name|mode
argument_list|,
name|x
argument_list|,
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|pool
operator|->
name|mode
argument_list|,
name|pool
operator|->
name|align
argument_list|,
name|pool
operator|->
name|labelno
argument_list|,
name|done
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assemble_align
argument_list|(
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
comment|/* Output the label.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|pool
operator|->
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of the constant itself.  */
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|pool
operator|->
name|mode
argument_list|,
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
name|assemble_integer
argument_list|(
name|x
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
argument_list|,
name|pool
operator|->
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|done
label|:
empty_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_EPILOGUE
name|ASM_OUTPUT_POOL_EPILOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Done with this pool.  */
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the instructions for this function, and mark all the    entries in the constant pool which are actually being used.    Emit used deferred strings.  */
end_comment

begin_function
specifier|static
name|void
name|mark_constant_pool
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
if|if
condition|(
name|first_pool
operator|==
literal|0
operator|&&
name|htab_elements
argument_list|(
name|const_str_htab
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
name|pool
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through appropriate parts of X, marking all entries in the    constant pool which are actually being used.  Entries that are only    referenced by other constants are also marked as used.  Emit    deferred strings that are used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_constants
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|mark_constant
argument_list|(
operator|&
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Insns may appear inside a SEQUENCE.  Only check the patterns of      insns, not any notes that may be attached.  We don't want to mark      a constant just because it happens to appear in a REG_EQUIV note.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|mark_constants
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_constants
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
case|case
literal|'0'
case|:
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'n'
case|:
case|case
literal|'u'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers    to as used.  Emit referenced deferred strings.  This function can    be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */
end_comment

begin_function
specifier|static
name|int
name|mark_constant
parameter_list|(
name|current_rtx
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|current_rtx
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|current_rtx
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|struct
name|pool_constant
modifier|*
name|pool
init|=
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|->
name|mark
operator|==
literal|0
condition|)
block|{
name|pool
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
operator|(
name|pool
operator|->
name|constant
operator|)
argument_list|,
operator|&
name|mark_constant
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|STRING_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|struct
name|deferred_string
modifier|*
modifier|*
name|defstr
decl_stmt|;
name|defstr
operator|=
operator|(
expr|struct
name|deferred_string
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|const_str_htab
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|STRHASH
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|defstr
condition|)
block|{
name|struct
name|deferred_string
modifier|*
name|p
init|=
operator|*
name|defstr
decl_stmt|;
name|STRING_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|output_constant_def_contents
argument_list|(
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|labelno
argument_list|)
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|const_str_htab
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|defstr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the constants whose addresses are referenced inside of EXP,    and make sure assembler code with a label has been output for each one.    Indicate whether an ADDR_EXPR has been encountered.  */
end_comment

begin_function
specifier|static
name|int
name|output_addressed_constants
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|reloc
init|=
literal|0
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|exp
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* Go inside any operations that get_inner_reference can handle and see 	 if what's inside is a constant: no need to do anything here for 	 addresses of variables or functions.  */
for|for
control|(
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constant_def
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
condition|)
name|reloc
operator||=
literal|2
expr_stmt|;
else|else
name|reloc
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator||=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
for|for
control|(
name|tem
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|reloc
operator||=
name|output_addressed_constants
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if VALUE is a valid constant-valued expression    for use in initializing a static variable; one that can be an    element of a "constant" initializer.     Return null_pointer_node if the value is absolute;    if it is relocatable, return the variable that determines the relocation.    We assume that VALUE has been folded as much as possible;    therefore, we do not need to check for such things as    arithmetic-combinations of integers.  */
end_comment

begin_function
name|tree
name|initializer_constant_valid_p
parameter_list|(
name|value
parameter_list|,
name|endtype
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|endtype
decl_stmt|;
block|{
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|value
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
return|return
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|?
name|null_pointer_node
else|:
literal|0
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
return|return
name|null_pointer_node
return|;
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
return|return
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
else|:
literal|0
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Allow conversions between pointer types.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between real types.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow length-preserving conversions between integer types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between other integer types only if 	 explicit value.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|null_pointer_node
condition|)
return|return
name|null_pointer_node
return|;
break|break;
block|}
comment|/* Allow (int)&foo provided int is as wide as a pointer.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Likewise conversions from int to pointers, but also allow 	 conversions from 0.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
block|}
comment|/* Allow conversions to union types if the value inside is okay.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|>=
name|POINTER_SIZE
condition|)
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* If either term is absolute, use the other terms relocation.  */
if|if
condition|(
name|valid0
operator|==
name|null_pointer_node
condition|)
return|return
name|valid1
return|;
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
block|}
break|break;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|>=
name|POINTER_SIZE
condition|)
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* Win if second argument is absolute.  */
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
comment|/* Win if both arguments have the same relocation. 	     Then the value is absolute.  */
if|if
condition|(
name|valid0
operator|==
name|valid1
operator|&&
name|valid0
operator|!=
literal|0
condition|)
return|return
name|null_pointer_node
return|;
comment|/* Since GCC guarantees that string constants are unique in the 	     generated code, a subtraction between two copies of the same 	     constant string is absolute.  */
if|if
condition|(
name|valid0
operator|&&
name|TREE_CODE
argument_list|(
name|valid0
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|valid1
operator|&&
name|TREE_CODE
argument_list|(
name|valid1
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_STRING_POINTER
argument_list|(
name|valid0
argument_list|)
operator|==
name|TREE_STRING_POINTER
argument_list|(
name|valid1
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
block|}
comment|/* Support differences between labels.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
condition|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
return|return
name|null_pointer_node
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for constant EXP to FILE, with no label.    This includes the pseudo-op such as ".int" or ".byte", and a newline.    Assumes output_addressed_constants has been done on EXP already.     Generate exactly SIZE bytes of assembler data, padding at the end    with zeros if necessary.  SIZE must always be specified.     SIZE is important for structure constructors,    since trailing members may have been omitted from the constructor.    It is also important for initialization of arrays from string constants    since the full length of the string constant might not be wanted.    It is also needed for initialization of unions, where the initializer's    type is just one member, and that may not be as long as the union.     There a case in which we would fail to output exactly SIZE bytes:    for a structure constructor that wants to produce more than SIZE bytes.    But such constructors will never be generated for any possible input.     ALIGN is the alignment of the data in bits.  */
end_comment

begin_function
name|void
name|output_constant
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|HOST_WIDE_INT
name|thissize
decl_stmt|;
comment|/* Some front-ends use constants other than the standard language-indepdent      varieties, but which may still be output directly.  Give the front-end a      chance to convert EXP to a language-independent representation.  */
name|exp
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|flag_syntax_only
condition|)
return|return;
comment|/* Eliminate any conversions since we'll be outputting the underlying      constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|thissize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow a constructor with no elements for any data type.      This means to fill the space with zeros.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FDESC_EXPR
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FDESC
name|HOST_WIDE_INT
name|part
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_FDESC
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|part
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Now output the underlying data.  If we've handling the padding, return.      Otherwise, break and ensure THISSIZE is the size written.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
operator|!
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"initializer for integer value is too complicated"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|REAL_CST
condition|)
name|error
argument_list|(
literal|"initializer for floating value is not a floating constant"
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|output_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
operator|/
literal|2
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
operator|/
literal|2
argument_list|,
name|min_align
argument_list|(
name|align
argument_list|,
name|BITS_PER_UNIT
operator|*
operator|(
name|thissize
operator|/
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|thissize
operator|=
name|MIN
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
name|SET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|thissize
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|thissize
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
name|buffer
argument_list|,
name|thissize
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|assemble_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"unknown set constructor type"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR_MARK
case|:
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|size
operator|-=
name|thissize
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_constructor, used for computing the size of    arrays of unspecified length.  VAL must be a CONSTRUCTOR of an array    type with an unspecified upper bound.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|array_size_for_constructor
parameter_list|(
name|val
parameter_list|)
name|tree
name|val
decl_stmt|;
block|{
name|tree
name|max_index
decl_stmt|,
name|i
decl_stmt|;
comment|/* This code used to attempt to handle string constants that are not      arrays of single-bytes, but nothing else does, so there's no point in      doing it here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|val
argument_list|)
return|;
name|max_index
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|val
argument_list|)
init|;
name|i
condition|;
name|i
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
control|)
block|{
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
name|index
operator|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_index
operator|==
name|NULL_TREE
operator|||
name|tree_int_cst_lt
argument_list|(
name|max_index
argument_list|,
name|index
argument_list|)
condition|)
name|max_index
operator|=
name|index
expr_stmt|;
block|}
if|if
condition|(
name|max_index
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Compute the total number of array elements.  */
name|i
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|max_index
argument_list|)
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Multiply by the array element unit size to find number of bytes.  */
name|i
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tree_low_cst
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).    Generate at least SIZE bytes, padding if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|output_constructor
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|link
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|;
name|tree
name|min_index
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes output or skipped so far.      In other words, current position within the constructor.  */
name|HOST_WIDE_INT
name|total_bytes
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means BYTE contains part of a byte, to be output.  */
name|int
name|byte_buffer_in_use
init|=
literal|0
decl_stmt|;
name|int
name|byte
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|min_index
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As LINK goes through the elements of the constant,      FIELD goes through the structure fields, if the constant is a structure.      if the constant is a union, then we override this,      by getting the field from the TREE_LIST element.      But the constant could also be an array.  Then FIELD is zero.       There is always a maximum of one element in the chain LINK for unions      (even if the initializer in a source program incorrectly contains      more one).  */
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|field
operator|=
name|field
condition|?
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
else|:
literal|0
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
literal|0
decl_stmt|;
comment|/* The element in a union constructor specifies the proper field 	 or index.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|index
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* Eliminate the marker that makes a cast not be an lvalue.  */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|STRIP_NOPS
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lo_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|hi_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|index
decl_stmt|;
name|unsigned
name|int
name|align2
init|=
name|min_align
argument_list|(
name|align
argument_list|,
name|fieldsize
operator|*
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
for|for
control|(
name|index
operator|=
name|lo_index
init|;
name|index
operator|<=
name|hi_index
condition|;
name|index
operator|++
control|)
block|{
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|,
name|align2
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|==
literal|0
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* An element that is not a bit-field.  */
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
decl_stmt|;
comment|/* Since this structure is static, 	     we know the positions are constant.  */
name|HOST_WIDE_INT
name|pos
init|=
name|field
condition|?
name|int_byte_position
argument_list|(
name|field
argument_list|)
else|:
literal|0
decl_stmt|;
name|unsigned
name|int
name|align2
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|pos
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
operator|(
name|tree_low_cst
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|min_index
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Output any buffered-up bit-fields preceding this element.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Advance to offset of this element. 	     Note no alignment needed in an array, since that is guaranteed 	     if each element has the proper size.  */
if|if
condition|(
operator|(
name|field
operator|!=
literal|0
operator|||
name|index
operator|!=
literal|0
operator|)
operator|&&
name|pos
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_zeros
argument_list|(
name|pos
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|pos
expr_stmt|;
block|}
comment|/* Find the alignment of this element.  */
name|align2
operator|=
name|min_align
argument_list|(
name|align
argument_list|,
name|BITS_PER_UNIT
operator|*
name|pos
argument_list|)
expr_stmt|;
comment|/* Determine size this element should occupy.  */
if|if
condition|(
name|field
condition|)
block|{
name|fieldsize
operator|=
literal|0
expr_stmt|;
comment|/* If this is an array with an unspecified upper bound, 		 the initializer determines the size.  */
comment|/* ??? This ought to only checked if DECL_SIZE_UNIT is NULL, 		 but we cannot do this until the deprecated support for 		 initializing zero-length array members is removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|fieldsize
operator|=
name|array_size_for_constructor
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Given a non-empty initialization, this field had 		     better be last.  */
if|if
condition|(
name|fieldsize
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* ??? This can't be right.  If the decl size overflows 		     a host integer we will silently emit no data.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|fieldsize
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fieldsize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|,
name|align2
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid initial value for member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Element that is a bit-field.  */
name|HOST_WIDE_INT
name|next_offset
init|=
name|int_bit_position
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|end_offset
init|=
operator|(
name|next_offset
operator|+
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* If this field does not start in this (or, next) byte, 	     skip some bytes.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
comment|/* Output remnant of any bit field in previous bytes.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still not at proper byte, advance to there.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_zeros
argument_list|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|next_offset
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|byte_buffer_in_use
condition|)
name|byte
operator|=
literal|0
expr_stmt|;
comment|/* We must split the element into pieces that fall within 	     separate bytes, and combine each byte with previous or 	     following bit-fields.  */
comment|/* next_offset is the offset n fbits from the beginning of 	     the structure to the next bit of this element to be processed. 	     end_offset is the offset of the first bit past the end of 	     this element.  */
while|while
condition|(
name|next_offset
operator|<
name|end_offset
condition|)
block|{
name|int
name|this_time
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|HOST_WIDE_INT
name|next_byte
init|=
name|next_offset
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|next_bit
init|=
name|next_offset
operator|%
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Advance from byte to byte 		 within this element when necessary.  */
while|while
condition|(
name|next_byte
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Number of bits we can process at once 		 (all part of the same byte).  */
name|this_time
operator|=
name|MIN
argument_list|(
name|end_offset
operator|-
name|next_offset
argument_list|,
name|BITS_PER_UNIT
operator|-
name|next_bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* On big-endian machine, take the most significant bits 		     first (of the bits that are significant) 		     and put them into bytes from the most significant end.  */
name|shift
operator|=
name|end_offset
operator|-
name|next_offset
operator|-
name|this_time
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST. We can 		     only select bits from the LOW or HIGH part 		     not from both.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|this_time
operator|=
name|shift
operator|+
name|this_time
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the result. This works only when: 		     1<= this_time<= HOST_BITS_PER_WIDE_INT.  */
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|this_time
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|BITS_PER_UNIT
operator|-
name|this_time
operator|-
name|next_bit
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* On little-endian machines, 		     take first the least significant bits of the value 		     and pack them starting at the least significant 		     bits of the bytes.  */
name|shift
operator|=
name|next_offset
operator|-
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST. We can 		     only select bits from the LOW or HIGH part 		     not from both.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|this_time
operator|=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|shift
operator|)
expr_stmt|;
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the result. This works only when: 		     1<= this_time<= HOST_BITS_PER_WIDE_INT.  */
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|this_time
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|next_bit
operator|)
expr_stmt|;
block|}
name|next_offset
operator|+=
name|this_time
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|total_bytes
operator|<
name|size
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This structure contains any weak symbol declarations waiting    to be emitted.  */
end_comment

begin_struct
struct|struct
name|weak_syms
block|{
name|struct
name|weak_syms
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|weak_syms
modifier|*
name|weak_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add function NAME to the weak symbols list.  VALUE is a weak alias    associated with NAME.  */
end_comment

begin_function
name|int
name|add_weak
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|weak_syms
modifier|*
name|weak
decl_stmt|;
name|weak
operator|=
operator|(
expr|struct
name|weak_syms
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|weak_syms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|weak
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|weak
operator|->
name|next
operator|=
name|weak_decls
expr_stmt|;
name|weak
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|weak
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|weak_decls
operator|=
name|weak
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Declare DECL to be a weak symbol.  */
end_comment

begin_function
name|void
name|declare_weak
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"weak declaration of `%s' must be public"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"weak declaration of `%s' must precede definition"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
name|add_weak
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"weak declaration of `%s' not supported"
argument_list|)
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit any pending weak declarations.  */
end_comment

begin_function
name|void
name|weak_finish
parameter_list|()
block|{
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
block|{
name|struct
name|weak_syms
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|weak_decls
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_WEAK_ALIAS
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|(
name|asm_out_file
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|t
operator|->
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
if|if
condition|(
name|t
operator|->
name|value
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove NAME from the pending list of weak symbols.  This prevents    the compiler from emitting multiple .weak directives which confuses    some assemblers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
end_ifdef

begin_function
specifier|static
name|void
name|remove_from_pending_weak_list
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|weak_syms
modifier|*
name|t
decl_stmt|;
name|struct
name|weak_syms
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|weak_decls
init|;
operator|*
name|p
condition|;
control|)
block|{
name|t
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|&
operator|(
name|t
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASM_WEAKEN_LABEL */
end_comment

begin_comment
comment|/* Emit an assembler directive to make the symbol for DECL an alias to    the symbol for TARGET.  */
end_comment

begin_function
name|void
name|assemble_alias
parameter_list|(
name|decl
parameter_list|,
name|target
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|target
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* We must force creation of DECL_RTL for debug info generation, even though      we don't use it here.  */
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
comment|/* Make name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Remove this function from the pending weak list so that 	     we do not emit multiple .weak directives for it.  */
name|remove_from_pending_weak_list
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF_FROM_DECLS
name|ASM_OUTPUT_DEF_FROM_DECLS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_WEAK_ALIAS
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"only weak aliases are supported in this configuration"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"alias definitions not supported in this configuration; ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Returns 1 if the target configuration supports defining public symbols    so that one of them will be chosen at link time instead of generating a    multiply-defined symbol error, whether through the use of weak symbols or    a target-specific mechanism for having duplicates discarded.  */
end_comment

begin_function
name|int
name|supports_one_only
parameter_list|()
block|{
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
return|return
literal|1
return|;
return|return
name|SUPPORTS_WEAK
return|;
block|}
end_function

begin_comment
comment|/* Set up DECL as a public symbol that can be defined in multiple    translation units without generating a linker error.  */
end_comment

begin_function
name|void
name|make_decl_one_only
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
block|{
ifdef|#
directive|ifdef
name|MAKE_DECL_ONE_ONLY
name|MAKE_DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_varasm_once
parameter_list|()
block|{
name|const_str_htab
operator|=
name|htab_create
argument_list|(
literal|128
argument_list|,
name|const_str_htab_hash
argument_list|,
name|const_str_htab_eq
argument_list|,
name|const_str_htab_del
argument_list|)
expr_stmt|;
name|in_named_htab
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|in_named_entry_hash
argument_list|,
name|in_named_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
name|const_hash_table
argument_list|,
name|MAX_HASH_TABLE
argument_list|,
sizeof|sizeof
name|const_hash_table
index|[
literal|0
index|]
argument_list|,
name|mark_const_hash_entry
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|const_str_htab
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|const_str_htab
argument_list|,
name|mark_const_str_htab
argument_list|)
expr_stmt|;
name|const_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select a set of attributes for section NAME based on the properties    of DECL and whether or not RELOC indicates that DECL's initializer    might contain runtime relocations.     We make the section read-only and executable for a function decl,    read-only for a const data decl, and writable for a non-const data decl.  */
end_comment

begin_function
name|unsigned
name|int
name|default_section_type_flags
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|&&
name|DECL_READONLY_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_LINKONCE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".bss."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.b."
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.sb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SECTION_BSS
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Output assembly to switch to section NAME with attribute FLAGS.    Four variants for common object file formats.  */
end_comment

begin_function
name|void
name|default_no_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Some object formats don't support named sections at all.  The      front-end should already have flagged this as an error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_elf_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|char
name|flagchars
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|named_section_first_declaration
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_DEBUG
operator|)
condition|)
operator|*
name|f
operator|++
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_SMALL
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_MERGE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_STRINGS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_BSS
condition|)
name|type
operator|=
literal|"nobits"
expr_stmt|;
else|else
name|type
operator|=
literal|"progbits"
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_ENTSIZE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\",@%s,%d\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|,
name|type
argument_list|,
name|flags
operator|&
name|SECTION_ENTSIZE
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\",@%s\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_coff_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|char
name|flagchars
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\"\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_pe_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|default_coff_asm_named_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_LINKONCE
condition|)
block|{
comment|/* Functions may have been compiled at various levels of          optimization so we can't use `same_size' here.          Instead, have the linker pick one.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.linkonce %s\n"
argument_list|,
operator|(
name|flags
operator|&
name|SECTION_CODE
condition|?
literal|"discard"
else|:
literal|"same_size"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for vtable gc in GNU binutils.  Record that the pointer at OFFSET    from SYMBOL is used in all classes derived from SYMBOL.  */
end_comment

begin_function
name|void
name|assemble_vtable_entry
parameter_list|(
name|symbol
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"\t.vtable_entry "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used for vtable gc in GNU binutils.  Record the class hierarchy by noting    that the vtable symbol CHILD is derived from the vtable symbol PARENT.  */
end_comment

begin_function
name|void
name|assemble_vtable_inherit
parameter_list|(
name|child
parameter_list|,
name|parent
parameter_list|)
name|rtx
name|child
decl_stmt|,
name|parent
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"\t.vtable_inherit "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

