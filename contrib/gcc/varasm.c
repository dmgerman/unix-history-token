begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output variables, constants and external declarations, for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles generation of all the assembler code    *except* the instructions of a function.    This includes declarations of variables and their initial values.     We also output the assembler code for constants stored in memory    and are responsible for combining constants with the same value.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* #include<stab.h> */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRAMPOLINE_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|TRAMPOLINE_ALIGNMENT
value|FUNCTION_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABS_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|".stabs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the prefix to use when check_memory_usage_flag is enable.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DOLLAR_IN_LABEL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DOT_IN_LABEL
end_ifdef

begin_define
define|#
directive|define
name|CHKR_PREFIX
value|"chkr_prefix_"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !NO_DOT_IN_LABEL */
end_comment

begin_define
define|#
directive|define
name|CHKR_PREFIX
value|"chkr."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !NO_DOLLAR_IN_LABEL */
end_comment

begin_define
define|#
directive|define
name|CHKR_PREFIX
value|"chkr$"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CHKR_PREFIX_SIZE
value|(sizeof (CHKR_PREFIX) - 1)
end_define

begin_comment
comment|/* File in which assembler code is being written.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The (assembler) name of the first globally-visible object output.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|first_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|weak_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_comment
comment|/* Number for making the label on the next    constant that is stored in memory.  */
end_comment

begin_decl_stmt
name|int
name|const_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number for making the label on the next    static variable internal to a function.  */
end_comment

begin_decl_stmt
name|int
name|var_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last decl for which assemble_variable was called,    if it did ASM_DECLARE_OBJECT_NAME.    If the last call to assemble_variable didn't do that,    this holds 0.  */
end_comment

begin_decl_stmt
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if at least one function definition has been seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|function_defined
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|addr_const
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|constant_descriptor
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rtx_const
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|pool_constant
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|contains_pointers_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_addr_const
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|addr_const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_hash
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_constant
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|constant_descriptor
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|compare_constant_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_constant_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_constant
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_constant_def_contents
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_rtx_const
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|struct
name|rtx_const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_hash_rtx
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_constant_rtx
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|struct
name|constant_descriptor
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant_rtx
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_constant_pool
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_constants
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_addressed_constants
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_after_function_constants
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_constructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_from_pending_weak_list
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|asm_output_bss
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|asm_output_aligned_bss
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_escape
end_escape

begin_enum
specifier|static
enum|enum
name|in_section
block|{
name|no_section
block|,
name|in_text
block|,
name|in_data
block|,
name|in_named
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
block|,
name|in_bss
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_ASM_OP
block|,
name|in_eh_frame
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTRA_SECTIONS
block|,
name|EXTRA_SECTIONS
endif|#
directive|endif
block|}
name|in_section
init|=
name|no_section
enum|;
end_enum

begin_comment
comment|/* Return a non-zero value if DECL has a section attribute.  */
end_comment

begin_define
define|#
directive|define
name|IN_NAMED_SECTION
parameter_list|(
name|DECL
parameter_list|)
define|\
value|((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \&& DECL_SECTION_NAME (DECL) != NULL_TREE)
end_define

begin_comment
comment|/* Text of section name when in_section == in_named.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|in_named_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define functions like text_section for any extra sections.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SECTION_FUNCTIONS
end_ifdef

begin_function
name|EXTRA_SECTION_FUNCTIONS
endif|#
directive|endif
comment|/* Tell assembler to switch to text section.  */
name|void
name|text_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_text
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_text
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to data section.  */
end_comment

begin_function
name|void
name|data_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_data
condition|)
block|{
if|if
condition|(
name|flag_shared_data
condition|)
block|{
ifdef|#
directive|ifdef
name|SHARED_SECTION_ASM_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|SHARED_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_data
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to ALWAYS switch to data section, in case    it's not sure where it it.  */
end_comment

begin_function
name|void
name|force_data_section
parameter_list|()
block|{
name|in_section
operator|=
name|no_section
expr_stmt|;
name|data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to read-only data section.  This is normally    the text section.  */
end_comment

begin_function
name|void
name|readonly_data_section
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION
name|READONLY_DATA_SECTION
argument_list|()
expr_stmt|;
comment|/* Note this can call data_section.  */
else|#
directive|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Determine if we're in the text section.  */
end_comment

begin_function
name|int
name|in_text_section
parameter_list|()
block|{
return|return
name|in_section
operator|==
name|in_text
return|;
block|}
end_function

begin_comment
comment|/* Determine if we're in the data section.  */
end_comment

begin_function
name|int
name|in_data_section
parameter_list|()
block|{
return|return
name|in_section
operator|==
name|in_data
return|;
block|}
end_function

begin_comment
comment|/* Tell assembler to change to section NAME for DECL.    If DECL is NULL, just switch to section NAME.    If NAME is NULL, get the name from DECL.    If RELOC is 1, the initializer for DECL contains relocs.  */
end_comment

begin_function
name|void
name|named_section
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|'d'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_section
operator|!=
name|in_named
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|in_named_name
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
name|ASM_OUTPUT_SECTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Section attributes are not supported if this macro isn't provided - 	 some host formats don't support them at all.  The front-end should 	 already have flagged this as an error.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|in_named_name
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|in_named_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_named
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|UNIQUE_SECTION
end_ifndef

begin_define
define|#
directive|define
name|UNIQUE_SECTION
parameter_list|(
name|DECL
parameter_list|,
name|RELOC
parameter_list|)
define|\
value|do {								\   int len;							\   char *name, *string;						\ 								\   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));	\
comment|/* Strip off any encoding in name.  */
value|\   STRIP_NAME_ENCODING (name, name);				\ 								\   len = strlen (name) + 1;					\   string = alloca (len + 1);					\   sprintf (string, ".%s", name);				\ 								\   DECL_SECTION_NAME (DECL) = build_string (len, string);	\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNIQUE_SECTION_P
end_ifndef

begin_define
define|#
directive|define
name|UNIQUE_SECTION_P
parameter_list|(
name|DECL
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* Tell the assembler to switch to the bss section.  */
end_comment

begin_function
name|void
name|bss_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_bss
condition|)
block|{
ifdef|#
directive|ifdef
name|SHARED_BSS_SECTION_ASM_OP
if|if
condition|(
name|flag_shared_data
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|SHARED_BSS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|BSS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_bss
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_comment
comment|/* Utility function for ASM_OUTPUT_BSS for targets to use if    they don't support alignments in .bss.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_bss
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rounded
decl_stmt|;
block|{
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bss_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_comment
comment|/* Utility function for targets to use in implementing    ASM_OUTPUT_ALIGNED_BSS.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_aligned_bss
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
block|{
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bss_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_ASM_OP
end_ifdef

begin_function
name|void
name|eh_frame_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_eh_frame
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|EH_FRAME_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_eh_frame
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Switch to the section for function DECL.     If DECL is NULL_TREE, switch to the text section.    ??? It's not clear that we will ever be passed NULL_TREE, but it's    safer to handle it.  */
end_comment

begin_function
name|void
name|function_section
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|named_section
argument_list|(
name|decl
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|text_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch to section for variable DECL.     RELOC is the `reloc' argument to SELECT_SECTION.  */
end_comment

begin_function
name|void
name|variable_section
parameter_list|(
name|decl
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
name|named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* C++ can have const variables that get initialized from constructors, 	 and thus can not be in a readonly section.  We prevent this by 	 verifying that the initial value is constant for objects put in a 	 readonly section.  	 error_mark_node is used by the C front end to indicate that the 	 initializer has not been seen yet.  In this case, we assume that 	 the initializer must be constant.  	 C++ uses error_mark_node for variables that have complicated 	 initializers, but these variables go in BSS so we won't be called 	 for them.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|DECL_READONLY_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to the section for the exception handling    table.  */
end_comment

begin_function
name|void
name|exception_section
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|EXCEPTION_SECTION
argument_list|)
name|EXCEPTION_SECTION
argument_list|()
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".gcc_except_table"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_pic
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the rtl to represent a function, for a function definition.    DECL is a FUNCTION_DECL node which describes which function.    The rtl is stored into DECL.  */
end_comment

begin_function
name|void
name|make_function_rtl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_name
init|=
name|name
decl_stmt|;
comment|/* Rename a nested function to avoid conflicts.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* When -fprefix-function-name is used, every function name is          prefixed.  Even static functions are prefixed because they          could be declared latter.  Note that a nested function name          is not prefixed.  */
if|if
condition|(
name|flag_prefix_function_name
condition|)
block|{
name|new_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|CHKR_PREFIX_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|CHKR_PREFIX
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
operator|+
name|CHKR_PREFIX_SIZE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|new_name
argument_list|,
name|strlen
argument_list|(
name|new_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information 	 such as that it is a function name.  If the name is changed, the macro 	 ASM_OUTPUT_LABELREF will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* ??? Another way to do this would be to do what halfpic.c does 	 and maintain a hashed table of such critters.  */
comment|/* ??? Another way to do this would be to pass a flag bit to 	 ENCODE_SECTION_INFO saying whether this is a new decl or not.  */
comment|/* Let the target reassign the RTL if it wants. 	 This is necessary, for example, when one machine specific 	 decl attribute overrides another.  */
ifdef|#
directive|ifdef
name|REDO_SECTION_INFO_P
if|if
condition|(
name|REDO_SECTION_INFO_P
argument_list|(
name|decl
argument_list|)
condition|)
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Record at least one function has been defined.  */
name|function_defined
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given NAME, a putative register name, discard any customary prefixes.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
argument_list|)
condition|)
name|name
operator|+=
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|name
operator|++
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode an `asm' spec for a declaration as a register name.    Return the register number, or -1 if nothing specified,    or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,    or -3 if ASMSPEC is `cc' and is not recognized,    or -4 if ASMSPEC is `memory' and is not recognized.    Accept an exact spelling or a decimal number.    Prefixes such as % are optional.  */
end_comment

begin_function
name|int
name|decode_reg_name
parameter_list|(
name|asmspec
parameter_list|)
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
block|{
if|if
condition|(
name|asmspec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Get rid of confusing prefixes.  */
name|asmspec
operator|=
name|strip_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Allow a decimal number as a "register name".  */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|asmspec
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|asmspec
index|[
name|i
index|]
operator|<=
literal|'9'
operator|)
condition|)
break|break;
if|if
condition|(
name|asmspec
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
else|else
return|return
operator|-
literal|2
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|strip_reg_name
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|i
return|;
ifdef|#
directive|ifdef
name|ADDITIONAL_REGISTER_NAMES
block|{
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|table
index|[]
init|=
name|ADDITIONAL_REGISTER_NAMES
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|number
return|;
block|}
endif|#
directive|endif
comment|/* ADDITIONAL_REGISTER_NAMES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"memory"
argument_list|)
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"cc"
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
return|return
operator|-
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the DECL_RTL for a declaration for a static or external variable    or static or external function.    ASMSPEC, if not 0, is the string which the user specified    as the assembler symbol name.    TOP_LEVEL is nonzero if this is a file-scope variable.     This is never called for PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|make_decl_rtl
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|int
name|reg_number
decl_stmt|;
name|reg_number
operator|=
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* ASMSPEC is given, and not the name of a register.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
comment|/* For a duplicate declaration, we can be called twice on the      same DECL node.  Don't discard the RTL already made.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* First detect errors in declaring global registers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|reg_number
operator|==
operator|-
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name not specified for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|reg_number
operator|<
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid register name for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|reg_number
operator|>=
literal|0
operator|||
name|reg_number
operator|==
operator|-
literal|3
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name given for non-register variable `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"data type of `%s' isn't suitable for a register"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|reg_number
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register number for `%s' isn't suitable for data type"
argument_list|)
expr_stmt|;
comment|/* Now handle properly declared static register variables.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|top_level
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"global register variable has initial value"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixed_regs
index|[
name|reg_number
index|]
operator|==
literal|0
operator|&&
name|function_defined
operator|&&
name|top_level
condition|)
name|error
argument_list|(
literal|"global register variable follows a function definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"volatile register variables don't work as you might wish"
argument_list|)
expr_stmt|;
comment|/* If the user specified one of the eliminables registers here, 	     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable 	     confused with that register and be eliminated.  Although this 	     usage is somewhat suspect, we nevertheless use the following 	     kludge to avoid setting DECL_RTL to frame_pointer_rtx.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|reg_number
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|top_level
condition|)
block|{
comment|/* Make this register global, so not usable for anything 		 else.  */
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|reg_number
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|>
literal|0
condition|)
name|globalize_reg
argument_list|(
name|reg_number
operator|+
operator|--
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Specifying a section attribute on a variable forces it into a          non-.bss section, and thus it cannot be common. */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now handle ordinary static variables and functions (in memory). 	 Also handle vars declared register invalidly.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't use just the variable's own name for a variable 	     whose scope is less than the whole file. 	     Concatenate a distinguishing number.  */
if|if
condition|(
operator|!
name|top_level
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* When -fprefix-function-name is used, the functions 	     names are prefixed.  Only nested function names are not 	     prefixed.  */
if|if
condition|(
name|flag_prefix_function_name
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|new_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|CHKR_PREFIX_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|CHKR_PREFIX
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
operator|+
name|CHKR_PREFIX_SIZE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|new_name
argument_list|,
name|strlen
argument_list|(
name|new_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|get_alias_set
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If this variable is to be treated as volatile, show its 	     tree node has side effects.  If it has side effects, either 	     because of this test or from TREE_THIS_VOLATILE also 	     being set, show the MEM is volatile.  */
if|if
condition|(
name|flag_volatile_global
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_volatile_static
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information 	     such as that it is a function name. 	     If the name is changed, the macro ASM_OUTPUT_LABELREF 	     will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* If the old RTL had the wrong mode, fix the mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|rtl
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ??? Another way to do this would be to do what halfpic.c does 	 and maintain a hashed table of such critters.  */
comment|/* ??? Another way to do this would be to pass a flag bit to 	 ENCODE_SECTION_INFO saying whether this is a new decl or not.  */
comment|/* Let the target reassign the RTL if it wants. 	 This is necessary, for example, when one machine specific 	 decl attribute overrides another.  */
ifdef|#
directive|ifdef
name|REDO_SECTION_INFO_P
if|if
condition|(
name|REDO_SECTION_INFO_P
argument_list|(
name|decl
argument_list|)
condition|)
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Make the rtl for variable VAR be volatile.    Use this only for static variables.  */
end_comment

begin_function
name|void
name|make_var_volatile
parameter_list|(
name|var
parameter_list|)
name|tree
name|var
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output alignment directive to align for constant expression EXP.  */
end_comment

begin_function
name|void
name|assemble_constant_align
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a string of literal assembler code    for an `asm' keyword used between functions.  */
end_comment

begin_function
name|void
name|assemble_asm
parameter_list|(
name|string
parameter_list|)
name|tree
name|string
decl_stmt|;
block|{
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This should no longer be needed, because 	 flag_gnu_linker should be 0 on these systems, 	 which should prevent any output 	 if ASM_OUTPUT_CONSTRUCTOR and ASM_OUTPUT_DESTRUCTOR are absent.  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FASCIST_ASSEMBLER
argument_list|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_CONSTRUCTOR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_CONSTRUCTOR
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DESTRUCTOR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DESTRUCTOR
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Record an element in the table of global destructors.    How this is done depends on what sort of assembler and linker    are in use.     NAME should be the name of a global function to be called    at exit time.  This name is output using assemble_name.  */
end_comment

begin_function
name|void
name|assemble_destructor
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DESTRUCTOR
name|ASM_OUTPUT_DESTRUCTOR
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_gnu_linker
condition|)
block|{
comment|/* Now tell GNU LD that this is part of the static destructor set.  */
comment|/* This code works for any machine provided you use GNU as/ld.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s \"___DTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Likewise for global constructors.  */
end_comment

begin_function
name|void
name|assemble_constructor
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CONSTRUCTOR
name|ASM_OUTPUT_CONSTRUCTOR
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_gnu_linker
condition|)
block|{
comment|/* Now tell GNU LD that this is part of the static constructor set.  */
comment|/* This code works for any machine provided you use GNU as/ld.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s \"___CTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Likewise for entries we want to record for garbage collection.    Garbage collection is still under development.  */
end_comment

begin_function
name|void
name|assemble_gc_entry
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_GC_ENTRY
name|ASM_OUTPUT_GC_ENTRY
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_gnu_linker
condition|)
block|{
comment|/* Now tell GNU LD that this is part of the static constructor set.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s \"___PTR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* CONSTANT_POOL_BEFORE_FUNCTION may be defined as an expression with    a non-zero value if the constant pool should be output before the    start of the function, or a zero value if the pool should output    after the end of the function.  The default is to put it before the    start.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONSTANT_POOL_BEFORE_FUNCTION
end_ifndef

begin_define
define|#
directive|define
name|CONSTANT_POOL_BEFORE_FUNCTION
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output assembler code for the constant pool of a function and associated    with defining the name of the function.  DECL describes the function.    NAME is the function's name.  For the constant pool, we use the current    constant pool data.  */
end_comment

begin_function
name|void
name|assemble_start_function
parameter_list|(
name|decl
parameter_list|,
name|fnname
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
comment|/* If the function is to be put in its own section and it's not in a section      already, indicate so.  */
if|if
condition|(
operator|(
name|flag_function_sections
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|||
name|UNIQUE_SECTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|UNIQUE_SECTION
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|function_section
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Tell assembler to move to target machine's alignment for functions.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FUNCTION_PREFIX
name|ASM_OUTPUT_FUNCTION_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
comment|/* Output SDB definition of the function.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_mark_begin_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
comment|/* Output DBX definition of the function.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|dbxout_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make function name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_global_object_name
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|name
operator|=
operator|&
name|first_global_object_name
expr_stmt|;
else|else
name|name
operator|=
operator|&
name|weak_global_object_name
expr_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|p
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|permalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
comment|/* Remove this function from the pending weak list so that 	     we do not emit multiple .weak directives for it.  */
name|remove_from_pending_weak_list
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the function name */
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_NAME
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the function.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_FUNCTION_NAME */
block|}
end_function

begin_comment
comment|/* Output assembler code associated with defining the size of the    function.  DECL describes the function.  NAME is the function's name.  */
end_comment

begin_function
name|void
name|assemble_end_function
parameter_list|(
name|decl
parameter_list|,
name|fnname
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_SIZE
name|ASM_DECLARE_FUNCTION_SIZE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
block|{
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|function_section
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* need to switch back */
block|}
comment|/* Output any constants which should appear after the function.  */
name|output_after_function_constants
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble code to leave SIZE bytes of zeros.  */
end_comment

begin_function
name|void
name|assemble_zeros
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASM_NO_SKIP_IN_TEXT
comment|/* The `space' pseudo in the text section outputs nop insns rather than 0s,      so we must output 0s explicitly in the text section.  */
if|if
condition|(
name|ASM_NO_SKIP_IN_TEXT
operator|&&
name|in_text_section
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
literal|20
condition|;
name|i
operator|+=
literal|20
control|)
block|{
ifdef|#
directive|ifdef
name|ASM_BYTE_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tbyte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|<
name|size
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_BYTE_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s 0"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tbyte 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */
end_comment

begin_function
name|void
name|assemble_align
parameter_list|(
name|align
parameter_list|)
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a string constant with the specified C string as contents.  */
end_comment

begin_function
name|void
name|assemble_string
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|maximum
init|=
literal|2000
decl_stmt|;
comment|/* If the string is very long, split it up.  */
while|while
condition|(
name|pos
operator|<
name|size
condition|)
block|{
name|int
name|thissize
init|=
name|size
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|thissize
operator|>
name|maximum
condition|)
name|thissize
operator|=
name|maximum
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|thissize
expr_stmt|;
name|p
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble everything that is needed for a variable or function declaration.    Not used for automatic variables, and not used for function definitions.    Should not be called for variables of incomplete structure type.     TOP_LEVEL is nonzero if this variable has file scope.    AT_END is nonzero if this is the special handling, at end of compilation,    to define things that have had only tentative definitions.    DONT_OUTPUT_DATA if nonzero means don't actually output the    initial value (that will be done by the caller).  */
end_comment

begin_function
name|void
name|assemble_variable
parameter_list|(
name|decl
parameter_list|,
name|top_level
parameter_list|,
name|at_end
parameter_list|,
name|dont_output_data
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|top_level
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|at_end
decl_stmt|;
name|int
name|dont_output_data
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|tree
name|size_tree
decl_stmt|;
name|int
name|reloc
init|=
literal|0
decl_stmt|;
name|enum
name|in_section
name|saved_in_section
decl_stmt|;
name|last_assemble_variable_decl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Do output symbol info for global register variables, but do nothing 	 else for them.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
comment|/* File-scope global variables are output here.  */
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|)
operator|&&
name|top_level
condition|)
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
comment|/* Leave initialized global vars for end of compilation; 	     see comment in compile_file.  */
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't output any DWARF debugging information for variables here. 	 In the case of local variables, the information for them is output 	 when we do our recursive traversal of the tree representation for 	 the entire containing function.  In the case of file-scope variables, 	 we output information for all of them at the very end of compilation 	 while we are doing our final traversal of the chain of file-scope 	 declarations.  */
return|return;
block|}
comment|/* Normally no need to say anything here for external references,      since assemble_external is called by the language-specific code      when a declaration is first seen.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output no assembler code for a function declaration.      Only definitions of functions output anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
comment|/* If type was incomplete when the variable was declared,      see if it is complete now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Still incomplete => don't allocate it; treat the tentative defn      (which is what it must have been) as an `extern' reference.  */
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dont_output_data
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
goto|goto
name|finish
goto|;
comment|/* This is better than explicit arithmetic, since it avoids overflow.  */
name|size_tree
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|size_tree
argument_list|)
operator|!=
literal|0
operator|||
name|size
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"size of variable `%s' is too large"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|first_global_object_name
operator|&&
operator|!
operator|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|first_global_object_name
operator|=
name|permalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|first_global_object_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the alignment of this data.  */
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* In the case for initialing an array whose length isn't specified,      where we have not yet been able to do the layout,      figure out the proper alignment now.  */
if|if
condition|(
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some object file formats have a maximum alignment which they support.      In particular, a.out format supports a maximum alignment of 4.  */
ifndef|#
directive|ifndef
name|MAX_OFILE_ALIGNMENT
define|#
directive|define
name|MAX_OFILE_ALIGNMENT
value|BIGGEST_ALIGNMENT
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|MAX_OFILE_ALIGNMENT
condition|)
block|{
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment of `%s' is greater than maximum object file alignment. Using %d."
argument_list|,
name|MAX_OFILE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|align
operator|=
name|MAX_OFILE_ALIGNMENT
expr_stmt|;
block|}
comment|/* On some machines, it is good to increase alignment sometimes.  */
ifdef|#
directive|ifdef
name|DATA_ALIGNMENT
name|align
operator|=
name|DATA_ALIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset the alignment in case we have made it tighter, so we can benefit      from it in get_pointer_alignment.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
comment|/* Handle uninitialized definitions.  */
if|if
condition|(
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
comment|/* If the target can't output uninitialized but not common global data 	 in .bss, then we have to use .data.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_BSS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
endif|#
directive|endif
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|dont_output_data
condition|)
block|{
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
decl_stmt|;
name|int
name|rounded
init|=
name|size
decl_stmt|;
comment|/* Don't allocate zero bytes of common, 	 since that means "undefined external" in the linker.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|rounded
operator|=
literal|1
expr_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits 	 so that each uninitialized object starts on such a boundary.  */
name|rounded
operator|+=
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|rounded
operator|=
operator|(
name|rounded
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_COMMON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
if|if
condition|(
operator|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
operator|>
name|rounded
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"requested alignment for %s is greater than implemented alignment of %d."
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
comment|/* File-scope global variables are output here.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|top_level
condition|)
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
comment|/* Leave initialized global vars for end of compilation; 	     see comment in compile_file.  */
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't output any DWARF debugging information for variables here. 	 In the case of local variables, the information for them is output 	 when we do our recursive traversal of the tree representation for 	 the entire containing function.  In the case of file-scope variables, 	 we output information for all of them at the very end of compilation 	 while we are doing our final traversal of the chain of file-scope 	 declarations.  */
if|#
directive|if
literal|0
comment|/* ??? We should either delete this or add a comment describing what 	 it was intended to do and why we shouldn't delete it.  */
block|if (flag_shared_data) 	data_section ();
endif|#
directive|endif
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_BSS
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_COMMON
if|if
condition|(
name|flag_shared_data
condition|)
name|ASM_OUTPUT_SHARED_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_COMMON
name|ASM_OUTPUT_ALIGNED_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_BSS
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_BSS
if|if
condition|(
name|flag_shared_data
condition|)
name|ASM_OUTPUT_SHARED_BSS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_BSS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* ASM_OUTPUT_BSS || ASM_OUTPUT_ALIGNED_BSS */
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_LOCAL
if|if
condition|(
name|flag_shared_data
condition|)
name|ASM_OUTPUT_SHARED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
goto|goto
name|finish
goto|;
block|}
comment|/* Handle initialized definitions.      Also handle uninitialized global definitions if -fno-common and the      target doesn't support ASM_OUTPUT_BSS.  */
comment|/* First make the assembler name(s) global if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Remove this variable from the pending weak list so that 	      we do not emit multiple .weak directives for it.  */
name|remove_from_pending_weak_list
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|for (d = equivalents; d; d = TREE_CHAIN (d))     {       tree e = TREE_VALUE (d);       if (TREE_PUBLIC (e)&& DECL_NAME (e)) 	ASM_GLOBALIZE_LABEL (asm_out_file, 			     XSTR (XEXP (DECL_RTL (e), 0), 0));     }
endif|#
directive|endif
comment|/* Output any data that we will need to use the address of.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|reloc
operator|=
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
if|if
condition|(
operator|(
name|flag_data_sections
operator|!=
literal|0
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|||
name|UNIQUE_SECTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|UNIQUE_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Switch to the appropriate section.  */
name|variable_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
comment|/* dbxout.c needs to know this.  */
if|if
condition|(
name|in_text_section
argument_list|()
condition|)
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record current section so we can restore it if dbxout.c clobbers it.  */
name|saved_in_section
operator|=
name|in_section
expr_stmt|;
comment|/* Output the dbx info now that we have chosen the section.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
comment|/* File-scope global variables are output here.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|top_level
condition|)
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
comment|/* Leave initialized global vars for end of compilation; 	 see comment in compile_file.  */
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't output any DWARF debugging information for variables here.      In the case of local variables, the information for them is output      when we do our recursive traversal of the tree representation for      the entire containing function.  In the case of file-scope variables,      we output information for all of them at the very end of compilation      while we are doing our final traversal of the chain of file-scope      declarations.  */
comment|/* If the debugging output changed sections, reselect the section      that's supposed to be selected.  */
if|if
condition|(
name|in_section
operator|!=
name|saved_in_section
condition|)
name|variable_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
comment|/* Output the alignment of this data.  */
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do any machine/system dependent processing of the object.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
if|if
condition|(
operator|!
name|dont_output_data
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Output the actual data.  */
name|output_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Leave space for it.  */
name|assemble_zeros
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
comment|/* Unfortunately, the IBM assembler cannot handle stabx before the actual      declaration.  When something like ".stabx  "aa:S-2",aa,133,0" is emitted       and `aa' hasn't been output yet, the assembler generates a stab entry with      a value of zero, in addition to creating an unnecessary external entry      for `aa'.  Hence, we must postpone dbxout_symbol to here at the end.  */
comment|/* File-scope global variables are output here.  */
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|&&
name|top_level
condition|)
block|{
name|saved_in_section
operator|=
name|in_section
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_section
operator|!=
name|saved_in_section
condition|)
name|variable_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* There must be a statement after a label.  */
empty_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return 1 if type TYPE contains any pointers.  */
end_comment

begin_function
specifier|static
name|int
name|contains_pointers_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* I'm not sure whether OFFSET_TYPE needs this treatment, 	 so I'll play safe and return 1.  */
case|case
name|OFFSET_TYPE
case|:
return|return
literal|1
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|fields
decl_stmt|;
comment|/* For a type that has fields, see if the fields have pointers.  */
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
comment|/* An array type contains pointers if its element type does.  */
return|return
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Output something to declare an external symbol to the assembler.    (Most assemblers don't need this, so we normally output nothing.)    Do nothing if DECL is not external.  */
end_comment

begin_function
name|void
name|assemble_external
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Some systems do require some output.  */
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Similar, for calling a library function FUN.  */
end_comment

begin_function
name|void
name|assemble_external_libcall
parameter_list|(
name|fun
parameter_list|)
name|rtx
name|fun
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL_LIBCALL
comment|/* Declare library function name external when first used, if nec.  */
if|if
condition|(
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL_LIBCALL
argument_list|(
name|asm_out_file
argument_list|,
name|fun
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Declare the label NAME global.  */
end_comment

begin_function
name|void
name|assemble_global
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a label named NAME.  */
end_comment

begin_function
name|void
name|assemble_label
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output to FILE a reference to the assembler name of a C-level name NAME.    If NAME starts with a *, the rest of NAME is output verbatim.    Otherwise NAME is transformed in an implementation-defined way    (usually by the addition of an underscore).    Many macros in the tm file are defined to call this function.  */
end_comment

begin_function
name|void
name|assemble_name
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|real_name
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|real_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_prefix_function_name
operator|&&
operator|!
name|bcmp
argument_list|(
name|real_name
argument_list|,
name|CHKR_PREFIX
argument_list|,
name|CHKR_PREFIX_SIZE
argument_list|)
condition|)
name|real_name
operator|=
name|real_name
operator|+
name|CHKR_PREFIX_SIZE
expr_stmt|;
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|fputs
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes writable static space with a gensym name    and return an RTX to refer to its address.  */
end_comment

begin_function
name|rtx
name|assemble_static_space
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
name|char
modifier|*
name|namestring
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|#
directive|if
literal|0
block|if (flag_shared_data)     data_section ();
endif|#
directive|endif
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LF"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|namestring
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|namestring
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits        so that each uninitialized object starts on such a boundary.  */
comment|/* Variable `rounded' might or might not be used in ASM_OUTPUT_LOCAL. */
name|int
name|rounded
name|ATTRIBUTE_UNUSED
init|=
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Assemble the static constant template for function entry trampolines.    This is done at most once per compilation.    Returns an RTX for the address of the template.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
end_ifdef

begin_function
name|rtx
name|assemble_trampoline_template
parameter_list|()
block|{
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* By default, put trampoline templates in read-only data section.  */
ifdef|#
directive|ifdef
name|TRAMPOLINE_SECTION
name|TRAMPOLINE_SECTION
argument_list|()
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Write the assembler code to define one.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRAMPOLINE_TEMPLATE
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Record the rtl to refer to it.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Assemble the integer constant X into an object of SIZE bytes.    X must be either a CONST_INT or CONST_DOUBLE.     Return 1 if we were able to output the constant, otherwise 0.  If FORCE is    non-zero, abort if we can't output the constant.  */
end_comment

begin_function
name|int
name|assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|force
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
comment|/* First try to use the standard 1, 2, 4, 8, and 16 byte      ASM_OUTPUT... macros.  */
switch|switch
condition|(
name|size
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CHAR
case|case
literal|1
case|:
name|ASM_OUTPUT_CHAR
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHORT
case|case
literal|2
case|:
name|ASM_OUTPUT_SHORT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_INT
case|case
literal|4
case|:
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DOUBLE_INT
case|case
literal|8
case|:
name|ASM_OUTPUT_DOUBLE_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_QUADRUPLE_INT
case|case
literal|16
case|:
name|ASM_OUTPUT_QUADRUPLE_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
comment|/* If we couldn't do it that way, there are two other possibilities: First,      if the machine can output an explicit byte and this is a 1 byte constant,      we can use ASM_OUTPUT_BYTE.  */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BYTE
if|if
condition|(
name|size
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Finally, if SIZE is larger than a single word, try to output the constant      one word at a time.  */
if|if
condition|(
name|size
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|word
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
name|UNITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|word
operator|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|assemble_integer
argument_list|(
name|word
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|size
operator|/
name|UNITS_PER_WORD
condition|)
return|return
literal|1
return|;
comment|/* If we output at least one word and then could not finish, 	 there is no valid way to continue.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble the floating-point constant D into an object of size MODE.  */
end_comment

begin_function
name|void
name|assemble_real
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|jmp_buf
name|output_constant_handler
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|output_constant_handler
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"floating point trap outputting a constant"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_IS_NOT_DOUBLE
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|d
argument_list|,
sizeof|sizeof
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|dconst0
expr_stmt|;
else|#
directive|else
name|d
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|set_float_handler
argument_list|(
name|output_constant_handler
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BYTE_FLOAT
case|case
name|QFmode
case|:
name|ASM_OUTPUT_BYTE_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHORT_FLOAT
case|case
name|HFmode
case|:
name|ASM_OUTPUT_SHORT_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_THREE_QUARTER_FLOAT
case|case
name|TQFmode
case|:
name|ASM_OUTPUT_THREE_QUARTER_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FLOAT
case|case
name|SFmode
case|:
name|ASM_OUTPUT_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DOUBLE
case|case
name|DFmode
case|:
name|ASM_OUTPUT_DOUBLE
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_LONG_DOUBLE
case|case
name|XFmode
case|:
case|case
name|TFmode
case|:
name|ASM_OUTPUT_LONG_DOUBLE
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here we combine duplicate floating constants to make    CONST_DOUBLE rtx's, and force those out to memory when necessary.  */
end_comment

begin_comment
comment|/* Chain of all CONST_DOUBLE rtx's constructed for the current function.    They are chained through the CONST_DOUBLE_CHAIN.    A CONST_DOUBLE rtx has CONST_DOUBLE_MEM != cc0_rtx iff it is on this chain.    In that case, CONST_DOUBLE_MEM is either a MEM,    or const0_rtx if no MEM has been made for this CONST_DOUBLE yet.     (CONST_DOUBLE_MEM is used only for top-level functions.    See force_const_mem for explanation.)  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|const_double_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair of ints.    For an integer, I0 is the low-order word and I1 is the high-order word.    For a real number, I0 is the word with the low address    and I1 is the word with the high address.  */
end_comment

begin_function
name|rtx
name|immed_double_const
parameter_list|(
name|i0
parameter_list|,
name|i1
parameter_list|,
name|mode
parameter_list|)
name|HOST_WIDE_INT
name|i0
decl_stmt|,
name|i1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
block|{
comment|/* We clear out all bits that don't belong in MODE, unless they and our 	 sign bit are all one.  So we get either a reasonable negative value 	 or a reasonable unsigned value for this mode.  */
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|i0
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|i0
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|,
name|i1
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|!
operator|(
name|i1
operator|==
operator|~
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
condition|)
name|i1
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* We cannot represent this value as a constant.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* If this would be an entire word for the target, but is not for 	 the host, then sign-extend on the host so that the number will look 	 the same way on the host that it would on the target.  	 For example, when building a 64 bit alpha hosted 32 bit sparc 	 targeted compiler, then we want the 32 bit unsigned value -1 to be 	 represented as a 64 bit value -1, and not as 0x00000000ffffffff. 	 The later confuses the sparc backend.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|BITS_PER_WORD
operator|==
name|width
operator|&&
operator|(
name|i0
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|i0
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
comment|/* If MODE fits within HOST_BITS_PER_WIDE_INT, always use a CONST_INT.  	 ??? Strictly speaking, this is wrong if we create a CONST_INT 	 for a large unsigned constant with the size of MODE being 	 HOST_BITS_PER_WIDE_INT and later try to interpret that constant in a 	 wider mode.  In that case we will mis-interpret it as a negative 	 number.  	 Unfortunately, the only alternative is to make a CONST_DOUBLE 	 for any constant in any mode if it is an unsigned constant larger 	 than the maximum signed integer in an int on the host.  However, 	 doing this will break everyone that always expects to see a CONST_INT 	 for SImode and smaller.  	 We have always been making CONST_INTs in this case, so nothing new 	 is being broken.  */
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|i1
operator|=
operator|(
name|i0
operator|<
literal|0
operator|)
condition|?
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
comment|/* If this integer fits in one word, return a CONST_INT.  */
if|if
condition|(
operator|(
name|i1
operator|==
literal|0
operator|&&
name|i0
operator|>=
literal|0
operator|)
operator|||
operator|(
name|i1
operator|==
operator|~
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
condition|)
return|return
name|GEN_INT
argument_list|(
name|i0
argument_list|)
return|;
comment|/* We use VOIDmode for integers.  */
name|mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
operator|==
name|i0
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|r
argument_list|)
operator|==
name|i1
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.       We may be called by an optimizer which may be discarding any memory      allocated during its processing (such as combine and loop).  However,      we will be leaving this constant on the chain, so we cannot tolerate      freed memory.  So switch to saveable_obstack for this allocation      and then switch back if we were in current_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
name|r
operator|=
name|gen_rtx_CONST_DOUBLE
argument_list|(
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Don't touch const_double_chain in nested function; see force_const_mem.      Also, don't touch it if not inside any function.  */
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
operator|&&
name|current_function_decl
operator|!=
literal|0
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|r
expr_stmt|;
block|}
comment|/* Store const0_rtx in mem-slot since this CONST_DOUBLE is on the chain.      Actual use of mem-slot is only through force_const_mem.  */
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE for a specified `double' value    and machine mode.  */
end_comment

begin_function
name|rtx
name|immed_real_const_1
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|union
name|real_extract
name|u
decl_stmt|;
specifier|register
name|rtx
name|r
decl_stmt|;
comment|/* Get the desired `double' value as a sequence of ints      since that is how they are stored in a CONST_DOUBLE.  */
name|u
operator|.
name|d
operator|=
name|d
expr_stmt|;
comment|/* Detect special cases.  */
if|if
condition|(
name|REAL_VALUES_IDENTICAL
argument_list|(
name|dconst0
argument_list|,
name|d
argument_list|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Check for NaN first, because some ports (specifically the i386) do not      emit correct ieee-fp code by default, and thus will generate a core      dump here if we pass a NaN to REAL_VALUES_EQUAL and if REAL_VALUES_EQUAL      does a floating point comparison.  */
elseif|else
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|d
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|dconst1
argument_list|,
name|d
argument_list|)
condition|)
return|return
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
sizeof|sizeof
name|u
operator|==
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
return|return
name|immed_double_const
argument_list|(
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
sizeof|sizeof
name|u
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
return|return
name|immed_double_const
argument_list|(
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
return|;
comment|/* The rest of this function handles the case where      a float value requires more than 2 ints of space.      It will be deleted as dead code on machines that don't need it.  */
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.       We may be called by an optimizer which may be discarding any memory      allocated during its processing (such as combine and loop).  However,      we will be leaving this constant on the chain, so we cannot tolerate      freed memory.  So switch to saveable_obstack for this allocation      and then switch back if we were in current_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
name|r
operator|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Don't touch const_double_chain in nested function; see force_const_mem.      Also, don't touch it if not inside any function.  */
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
operator|&&
name|current_function_decl
operator|!=
literal|0
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|r
expr_stmt|;
block|}
comment|/* Store const0_rtx in CONST_DOUBLE_MEM since this CONST_DOUBLE is on the      chain, but has not been allocated memory.  Actual use of CONST_DOUBLE_MEM      is only through force_const_mem.  */
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE rtx for a value specified by EXP,    which must be a REAL_CST tree node.  */
end_comment

begin_function
name|rtx
name|immed_real_const
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
name|immed_real_const_1
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* At the end of a function, forget the memory-constants    previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.    Also clear out real_constant_chain and clear out all the chain-pointers.  */
end_comment

begin_function
name|void
name|clear_const_double_mem
parameter_list|()
block|{
specifier|register
name|rtx
name|r
decl_stmt|,
name|next
decl_stmt|;
comment|/* Don't touch CONST_DOUBLE_MEM for nested functions.      See force_const_mem for explanation.  */
if|if
condition|(
name|outer_function_chain
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|next
control|)
block|{
name|next
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|cc0_rtx
expr_stmt|;
block|}
name|const_double_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP with a constant value,    reduce it to the sum of an assembler symbol and an integer.    Store them both in the structure *VALUE.    Abort if EXP does not reduce.  */
end_comment

begin_struct
struct|struct
name|addr_const
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|exp
parameter_list|,
name|value
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|addr_const
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|tree
name|target
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|offset
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|+=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|x
operator|=
name|DECL_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|INTEGER_CST
case|:
name|x
operator|=
name|TREE_CST_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Uniquize all constants that appear in memory.    Each constant in memory thus far output is recorded    in `const_hash_table' with a `struct constant_descriptor'    that contains a polish representation of the value of    the constant.     We cannot store the trees in the hash table    because the trees may be temporary.  */
end_comment

begin_struct
struct|struct
name|constant_descriptor
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|char
name|contents
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_define
define|#
directive|define
name|MAX_HASH_TABLE
value|1009
end_define

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|const_hash_table
index|[
name|MAX_HASH_TABLE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a hash code for a constant expression.  */
end_comment

begin_function
specifier|static
name|int
name|const_hash
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|hi
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Either set P and LEN to the address and len of something to hash and      exit the switch or return a value.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|const_hash
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|*
literal|5
operator|+
name|const_hash
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* For record type, include the type in the hashing. 	     We do not do so for array types 	     because (1) the sizes of the elements are sufficient 	     and (2) distinct array types can have the same constructor. 	     Instead, we include the array size because the constructor could 	     be shorter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|hi
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
else|else
name|hi
operator|=
operator|(
operator|(
literal|5
operator|+
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
name|hi
operator|=
operator|(
name|hi
operator|*
literal|603
operator|+
name|const_hash
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* Don't hash the address of the SYMBOL_REF; 	       only use the offset and the symbol name.  */
name|hi
operator|=
name|value
operator|.
name|offset
expr_stmt|;
name|p
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|hi
operator|=
name|value
operator|.
name|offset
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|13
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
block|}
return|return
name|hi
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
operator|(
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|9
operator|+
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|7
operator|+
literal|2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Compute hashing function */
name|hi
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare a constant expression EXP with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as EXP.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant
parameter_list|(
name|exp
parameter_list|,
name|desc
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
return|return
literal|0
operator|!=
name|compare_constant_1
argument_list|(
name|exp
argument_list|,
name|desc
operator|->
name|contents
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare constant expression EXP with a substring P of a constant descriptor.    If they match, return a pointer to the end of the substring matched.    If they do not match, return 0.     Since descriptors are written in polish prefix notation,    this function can be used recursively to test one operand of EXP    against a subdescriptor, and if it succeeds it returns the    address of the subdescriptor for the next operand.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|compare_constant_1
parameter_list|(
name|exp
parameter_list|,
name|p
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
operator|(
expr|enum
name|tree_code
operator|)
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
comment|/* Either set STRP, P and LEN to pointers and length to compare and exit the      switch, or return the result of the comparison.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* Integer constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
comment|/* Real constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
if|if
condition|(
name|flag_writable_strings
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|compare_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|int
name|xlen
init|=
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xlen
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|xlen
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|xlen
expr_stmt|;
break|break;
block|}
else|else
block|{
specifier|register
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|have_purpose
init|=
literal|0
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
name|have_purpose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|length
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	     For arrays, just verify both constructors are for arrays.  	     Then insist that either both or none have any TREE_PURPOSE 	     values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|type
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|have_purpose
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|have_purpose
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|have_purpose
expr_stmt|;
comment|/* For arrays, insist that the size in bytes match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|size
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|zero
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|TREE_PURPOSE
operator|(
name|link
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|TREE_PURPOSE
operator|(
name|link
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|have_purpose
condition|)
block|{
name|int
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|zero
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|offset
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
operator|.
name|offset
expr_stmt|;
comment|/* Compare the offset.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
comment|/* Compare symbol name.  */
name|strp
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|strp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|RANGE_EXPR
case|:
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct a constant descriptor for the expression EXP.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|label
init|=
literal|0
decl_stmt|;
comment|/* Make a struct constant_descriptor.  The first two pointers will      be filled in later.  Here we just leave space for them.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|next
argument_list|,
sizeof|sizeof
name|next
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a description of constant expression EXP    to the object growing in `permanent_obstack'.    No need to return its address; the caller will get that    from the obstack when the object is complete.  */
end_comment

begin_function
specifier|static
name|void
name|record_constant_1
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
if|if
condition|(
name|flag_writable_strings
condition|)
return|return;
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
name|record_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|int
name|nbytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|nbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|permanent_obstack
operator|.
name|next_free
operator|-
name|nbytes
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
specifier|register
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|have_purpose
init|=
literal|0
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
name|have_purpose
operator|=
literal|1
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
sizeof|sizeof
name|length
argument_list|)
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	     For arrays, just verify both constructors are for arrays.  	     Then insist that either both or none have any TREE_PURPOSE 	     values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
sizeof|sizeof
name|type
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|have_purpose
argument_list|,
sizeof|sizeof
name|have_purpose
argument_list|)
expr_stmt|;
comment|/* For arrays, insist that the size in bytes match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
sizeof|sizeof
name|size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
name|record_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|zero
init|=
literal|0
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
sizeof|sizeof
name|TREE_PURPOSE
operator|(
name|link
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
condition|)
name|record_constant_1
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|have_purpose
condition|)
block|{
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Record the offset.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|offset
argument_list|,
sizeof|sizeof
name|value
operator|.
name|offset
argument_list|)
expr_stmt|;
comment|/* Record the symbol name.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|RANGE_EXPR
case|:
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Record constant contents.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|strp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a list of constant expressions that were passed to    output_constant_def but that could not be output right away.  */
end_comment

begin_struct
struct|struct
name|deferred_constant
block|{
name|struct
name|deferred_constant
modifier|*
name|next
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|deferred_constant
modifier|*
name|deferred_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Another list of constants which should be output after the    function.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|deferred_constant
modifier|*
name|after_function_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means defer output of addressed subconstants    (i.e., those for which output_constant_def is called.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defer_addressed_constants_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start deferring output of subconstants.  */
end_comment

begin_function
name|void
name|defer_addressed_constants
parameter_list|()
block|{
name|defer_addressed_constants_flag
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop deferring output of subconstants,    and output now all those that have been deferred.  */
end_comment

begin_function
name|void
name|output_deferred_addressed_constants
parameter_list|()
block|{
name|struct
name|deferred_constant
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|defer_addressed_constants_flag
operator|--
expr_stmt|;
if|if
condition|(
name|defer_addressed_constants_flag
operator|>
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|deferred_constants
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|output_constant_def_contents
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|reloc
argument_list|,
name|p
operator|->
name|labelno
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|deferred_constants
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output any constants which should appear after a function.  */
end_comment

begin_function
specifier|static
name|void
name|output_after_function_constants
parameter_list|()
block|{
name|struct
name|deferred_constant
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|after_function_constants
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|output_constant_def_contents
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|reloc
argument_list|,
name|p
operator|->
name|labelno
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|after_function_constants
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a copy of the whole tree structure for a constant.    This handles the same types of nodes that compare_constant    and record_constant handle.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_constant
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* For ADDR_EXPR, we do not want to copy the decl whose address 	 is requested.  We do want to copy constants though.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|build_complex
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|tree
name|copy
init|=
name|copy_node
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|copy_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tail
decl_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|copy
argument_list|)
operator|=
name|list
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|copy_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|copy_constant
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx representing a reference to constant data in memory    for the constant expression EXP.     If assembler code for such a constant has already been output,    return an rtx to refer to it.    Otherwise, output such a constant in memory (or defer it for later)    and generate an rtx for it.     The TREE_CST_RTL of EXP is set up to point to that rtx.    The const_hash_table records which constants already have label strings.  */
end_comment

begin_function
name|rtx
name|output_constant_def
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|found
init|=
literal|0
decl_stmt|;
name|int
name|reloc
decl_stmt|;
specifier|register
name|rtx
name|def
decl_stmt|;
if|if
condition|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Make sure any other constants whose addresses appear in EXP      are assigned label numbers.  */
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Compute hash code of EXP.  Search the descriptors for that hash code      to see if any of them describes EXP.  If yes, the descriptor records      the label number already assigned.  */
name|hash
operator|=
name|const_hash
argument_list|(
name|exp
argument_list|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant
argument_list|(
name|exp
argument_list|,
name|desc
argument_list|)
condition|)
block|{
name|found
operator|=
name|desc
operator|->
name|label
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
comment|/* No constant equal to EXP is known to have been output. 	 Make a constant descriptor to enter EXP in the hash table. 	 Assign the label number and record it in the descriptor for 	 future calls to this function to find.  */
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
name|desc
operator|=
name|record_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|desc
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|const_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
block|}
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|exp
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|def
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|desc
operator|->
name|label
argument_list|)
expr_stmt|;
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information      such as that it is a function name.  If the name is changed, the macro      ASM_OUTPUT_LABELREF will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
name|ENCODE_SECTION_INFO
argument_list|(
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is the first time we've seen this particular constant,      output it (or defer its output for later).  */
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|int
name|after_function
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_AFTER_FUNCTION_P
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
operator|&&
name|CONSTANT_AFTER_FUNCTION_P
argument_list|(
name|exp
argument_list|)
condition|)
name|after_function
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|defer_addressed_constants_flag
operator|||
name|after_function
condition|)
block|{
name|struct
name|deferred_constant
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|deferred_constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deferred_constant
argument_list|)
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|suspend_momentary
argument_list|()
expr_stmt|;
name|p
operator|->
name|exp
operator|=
name|copy_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|labelno
operator|=
name|const_labelno
operator|++
expr_stmt|;
if|if
condition|(
name|after_function
condition|)
block|{
name|p
operator|->
name|next
operator|=
name|after_function_constants
expr_stmt|;
name|after_function_constants
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|next
operator|=
name|deferred_constants
expr_stmt|;
name|deferred_constants
operator|=
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
name|output_constant_def_contents
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
block|}
block|}
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Now output assembler code to define the label for EXP,    and follow it with the data of EXP.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_def_contents
parameter_list|(
name|exp
parameter_list|,
name|reloc
parameter_list|,
name|labelno
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|exp
argument_list|)
condition|)
name|named_section
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* First switch to text section, except for writable strings.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|&&
name|flag_writable_strings
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the label itself.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of EXP.  */
name|output_constant
argument_list|(
name|exp
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|?
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
else|:
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar hash facility for making memory-constants    from constant rtl-expressions.  It is used on RISC machines    where immediate integer arguments and constant addresses are restricted    so that such constants must be stored in memory.     This pool of constants is reinitialized for each function    so each function gets its own constants-pool that comes right before it.     All structures allocated here are discarded when functions are saved for    inlining, so they do not need to be allocated permanently.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RTX_HASH_TABLE
value|61
end_define

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
modifier|*
name|const_rtx_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to represent sufficient information about a constant so that    it can be output when the constant pool is output, so that function    integration can be done, and to simplify handling on machines that reference    constant pool as base+displacement.  */
end_comment

begin_struct
struct|struct
name|pool_constant
block|{
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|next
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|constant
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|mark
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pointers to first and last constant in pool.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pool_constant
modifier|*
name|first_pool
decl_stmt|,
modifier|*
name|last_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current offset in constant pool (does not include any machine-specific    header.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pool_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to maintain hash table mapping symbols used to their    corresponding constants.  */
end_comment

begin_struct
struct|struct
name|pool_sym
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|struct
name|pool_sym
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pool_sym
modifier|*
modifier|*
name|const_rtx_sym_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.    The argument is XSTR (... , 0)  */
end_comment

begin_define
define|#
directive|define
name|SYMHASH
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|((((unsigned long) (LABEL))& ((1<< HASHBITS) - 1))  % MAX_RTX_HASH_TABLE)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize constant pool hashing for next function.  */
end_comment

begin_function
name|void
name|init_const_rtx_hash_table
parameter_list|()
block|{
name|const_rtx_hash_table
operator|=
operator|(
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|constant_descriptor
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|const_rtx_sym_hash_table
operator|=
operator|(
operator|(
expr|struct
name|pool_sym
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pool_sym
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|const_rtx_hash_table
argument_list|,
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|constant_descriptor
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|const_rtx_sym_hash_table
argument_list|,
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pool_sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
name|pool_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save and restore status for a nested function.  */
end_comment

begin_function
name|void
name|save_varasm_status
parameter_list|(
name|p
parameter_list|,
name|context
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
name|tree
name|context
decl_stmt|;
block|{
name|p
operator|->
name|const_rtx_hash_table
operator|=
name|const_rtx_hash_table
expr_stmt|;
name|p
operator|->
name|const_rtx_sym_hash_table
operator|=
name|const_rtx_sym_hash_table
expr_stmt|;
name|p
operator|->
name|first_pool
operator|=
name|first_pool
expr_stmt|;
name|p
operator|->
name|last_pool
operator|=
name|last_pool
expr_stmt|;
name|p
operator|->
name|pool_offset
operator|=
name|pool_offset
expr_stmt|;
name|p
operator|->
name|const_double_chain
operator|=
name|const_double_chain
expr_stmt|;
comment|/* If we are pushing to toplevel, we can't reuse const_double_chain.  */
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
name|const_double_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_varasm_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|const_rtx_hash_table
operator|=
name|p
operator|->
name|const_rtx_hash_table
expr_stmt|;
name|const_rtx_sym_hash_table
operator|=
name|p
operator|->
name|const_rtx_sym_hash_table
expr_stmt|;
name|first_pool
operator|=
name|p
operator|->
name|first_pool
expr_stmt|;
name|last_pool
operator|=
name|p
operator|->
name|last_pool
expr_stmt|;
name|pool_offset
operator|=
name|p
operator|->
name|pool_offset
expr_stmt|;
name|const_double_chain
operator|=
name|p
operator|->
name|const_double_chain
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|kind
block|{
name|RTX_DOUBLE
block|,
name|RTX_INT
block|}
enum|;
end_enum

begin_struct
struct|struct
name|rtx_const
block|{
ifdef|#
directive|ifdef
name|ONLY_INT_FIELDS
name|unsigned
name|int
name|kind
range|:
literal|16
decl_stmt|;
name|unsigned
name|int
name|mode
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|enum
name|kind
name|kind
range|:
literal|16
decl_stmt|;
name|enum
name|machine_mode
name|mode
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
union|union
block|{
name|union
name|real_extract
name|du
decl_stmt|;
name|struct
name|addr_const
name|addr
decl_stmt|;
struct|struct
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
block|}
name|di
struct|;
block|}
name|un
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Express an rtx for a constant integer (perhaps symbolic)    as the sum of a symbol or label plus an explicit integer.    They are stored into VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|decode_rtx_const
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|value
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|rtx_const
modifier|*
name|value
decl_stmt|;
block|{
comment|/* Clear the whole structure, including any gaps.  */
block|{
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|value
decl_stmt|;
name|int
modifier|*
name|end
init|=
operator|(
name|int
operator|*
operator|)
operator|(
name|value
operator|+
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|->
name|kind
operator|=
name|RTX_INT
expr_stmt|;
comment|/* Most usual kind.  */
name|value
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
name|value
operator|->
name|kind
operator|=
name|RTX_DOUBLE
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|value
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|->
name|un
operator|.
name|du
argument_list|,
sizeof|sizeof
name|value
operator|->
name|un
operator|.
name|du
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|->
name|un
operator|.
name|di
operator|.
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|di
operator|.
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|->
name|kind
operator|==
name|RTX_INT
operator|&&
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
comment|/* Use the string's address, not the SYMBOL_REF's address, 	   for the sake of addresses of library routines. 	   For a LABEL_REF, compare labels.  */
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a MINUS expression, simplify it if both sides    include the same symbol.  */
end_comment

begin_function
name|rtx
name|simplify_subtraction
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|rtx_const
name|val0
decl_stmt|,
name|val1
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|val0
argument_list|)
expr_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|base
operator|==
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|base
condition|)
return|return
name|GEN_INT
argument_list|(
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
operator|-
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
argument_list|)
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a constant RTL expression.  */
end_comment

begin_function
specifier|static
name|int
name|const_hash_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|hi
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Compute hashing function */
name|hi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
name|hi
operator|+=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|value
operator|)
index|[
name|i
index|]
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_RTX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_comment
comment|/* Compare a constant rtl object X with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as X.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|desc
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|desc
operator|->
name|contents
decl_stmt|;
specifier|register
name|int
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|value
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct a constant descriptor for the rtl-expression X.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Put these things in the saveable obstack so we can ensure it won't      be freed if we are called from combine or some other phase that discards      memory allocated from function_obstack (current_obstack).  */
name|obstack_grow
argument_list|(
name|saveable_obstack
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|saveable_obstack
argument_list|,
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
comment|/* Record constant contents.  */
name|obstack_grow
argument_list|(
name|saveable_obstack
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|obstack_finish
argument_list|(
name|saveable_obstack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant rtx X, make (or find) a memory constant for its value    and return a MEM rtx to refer to it in memory.  */
end_comment

begin_function
name|rtx
name|force_const_mem
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|found
init|=
literal|0
decl_stmt|;
name|rtx
name|def
decl_stmt|;
comment|/* If we want this CONST_DOUBLE in the same mode as it is in memory      (this will always be true for floating CONST_DOUBLEs that have been      placed in memory, but not for VOIDmode (integer) CONST_DOUBLEs),      use the previous copy.  Otherwise, make a new one.  Note that in      the unlikely event that this same CONST_DOUBLE is used in two different      modes in an alternating fashion, we will allocate a lot of different      memory locations, but this should be extremely rare.  */
comment|/* Don't use CONST_DOUBLE_MEM in a nested function.      Nested functions have their own constant pools,      so they can't share the same values in CONST_DOUBLE_MEM      with the containing function.  */
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
return|;
comment|/* Compute hash code of X.  Search the descriptors for that hash code      to see if any of them describes X.  If yes, the descriptor records      the label number already assigned.  */
name|hash
operator|=
name|const_hash_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|desc
argument_list|)
condition|)
block|{
name|found
operator|=
name|desc
operator|->
name|label
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
specifier|register
name|struct
name|pool_sym
modifier|*
name|sym
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* No constant equal to X is known to have been output. 	 Make a constant descriptor to enter X in the hash table. 	 Assign the label number and record it in the descriptor for 	 future calls to this function to find.  */
name|desc
operator|=
name|record_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
operator|(
name|mode
operator|==
name|VOIDmode
operator|)
condition|?
name|UNITS_PER_WORD
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|make_tree
argument_list|(
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
endif|#
directive|endif
name|pool_offset
operator|+=
name|align
operator|-
literal|1
expr_stmt|;
name|pool_offset
operator|&=
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If RTL is not being placed into the saveable obstack, make a 	 copy of X that is in the saveable obstack in case we are 	 being called from combine or some other phase that discards 	 memory it allocates.  We used to only do this if it is a 	 CONST; however, reload can allocate a CONST_INT when 	 eliminating registers.  */
if|if
condition|(
name|rtl_obstack
operator|!=
name|saveable_obstack
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|gen_rtx_CONST
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
name|forced_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|forced_labels
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Allocate a pool constant descriptor, fill it in, and chain it in.  */
name|pool
operator|=
operator|(
expr|struct
name|pool_constant
operator|*
operator|)
name|savealloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_constant
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|desc
operator|=
name|desc
expr_stmt|;
name|pool
operator|->
name|constant
operator|=
name|x
expr_stmt|;
name|pool
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|pool
operator|->
name|labelno
operator|=
name|const_labelno
expr_stmt|;
name|pool
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|pool
operator|->
name|offset
operator|=
name|pool_offset
expr_stmt|;
name|pool
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_pool
operator|==
literal|0
condition|)
name|first_pool
operator|=
name|pool
expr_stmt|;
else|else
name|last_pool
operator|->
name|next
operator|=
name|pool
expr_stmt|;
name|last_pool
operator|=
name|pool
expr_stmt|;
name|pool_offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|desc
operator|->
name|label
operator|=
name|found
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add label to symbol hash table.  */
name|hash
operator|=
name|SYMHASH
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|pool_sym
operator|*
operator|)
name|savealloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|label
operator|=
name|found
expr_stmt|;
name|sym
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|sym
operator|->
name|next
operator|=
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
operator|=
name|sym
expr_stmt|;
block|}
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
name|def
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|found
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|def
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark the symbol_ref as belonging to this constants pool.  */
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_function_uses_const_pool
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|x
expr_stmt|;
block|}
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
operator|=
name|def
expr_stmt|;
block|}
return|return
name|def
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to    the corresponding pool_constant structure.  */
end_comment

begin_function
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|pool_sym
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|label
init|=
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|const_rtx_sym_hash_table
index|[
name|SYMHASH
argument_list|(
name|label
argument_list|)
index|]
init|;
name|sym
condition|;
name|sym
operator|=
name|sym
operator|->
name|next
control|)
if|if
condition|(
name|sym
operator|->
name|label
operator|==
name|label
condition|)
return|return
name|sym
operator|->
name|pool
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */
end_comment

begin_function
name|rtx
name|get_pool_constant
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the mode.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_pool_mode
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the offset in the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_offset
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_size
parameter_list|()
block|{
return|return
name|pool_offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write all the constants in the constant pool.  */
end_comment

begin_function
name|void
name|output_constant_pool
parameter_list|(
name|fnname
parameter_list|,
name|fndecl
parameter_list|)
name|char
modifier|*
name|fnname
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
comment|/* It is possible for gcc to call force_const_mem and then to later      discard the instructions which refer to the constant.  In such a      case we do not need to output the constant.  */
name|mark_constant_pool
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_PROLOGUE
name|ASM_OUTPUT_POOL_PROLOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
name|x
operator|=
name|pool
operator|->
name|constant
expr_stmt|;
if|if
condition|(
operator|!
name|pool
operator|->
name|mark
condition|)
continue|continue;
comment|/* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF) 	 whose CODE_LABEL has been deleted.  This can occur if a jump table 	 is eliminated by optimization.  If so, write a constant of zero 	 instead.  Note that this can also happen by turning the 	 CODE_LABEL into a NOTE.  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|)
operator|)
condition|)
name|x
operator|=
name|const0_rtx
expr_stmt|;
comment|/* First switch to correct section.  */
ifdef|#
directive|ifdef
name|SELECT_RTX_SECTION
name|SELECT_RTX_SECTION
argument_list|(
name|pool
operator|->
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|pool
operator|->
name|mode
argument_list|,
name|pool
operator|->
name|align
argument_list|,
name|pool
operator|->
name|labelno
argument_list|,
name|done
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pool
operator|->
name|align
operator|>
literal|1
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|pool
operator|->
name|align
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the label.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|pool
operator|->
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of the constant itself.  */
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|pool
operator|->
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
name|assemble_integer
argument_list|(
name|x
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|done
label|:
empty_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_EPILOGUE
name|ASM_OUTPUT_POOL_EPILOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Done with this pool.  */
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the instructions for this function, and mark all the    entries in the constant pool which are actually being used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_constant_pool
parameter_list|()
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
if|if
condition|(
name|first_pool
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
name|pool
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It's possible that the only reference to a symbol is in a symbol      that's in the constant pool.  This happens in Fortran under some      situations.  (When the constant contains the address of another      constant, and only the first is used directly in an insn.)       This is potentially suboptimal if there's ever a possibility of      backwards (in pool order) 2'd level references.  However, it's      not clear that 2'd level references can happen. */
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
name|struct
name|pool_sym
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
comment|/* skip unmarked entries; no insn refers to them. */
if|if
condition|(
operator|!
name|pool
operator|->
name|mark
condition|)
continue|continue;
name|label
operator|=
name|XSTR
argument_list|(
name|pool
operator|->
name|constant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Be sure the symbol's value is marked. */
for|for
control|(
name|sym
operator|=
name|const_rtx_sym_hash_table
index|[
name|SYMHASH
argument_list|(
name|label
argument_list|)
index|]
init|;
name|sym
condition|;
name|sym
operator|=
name|sym
operator|->
name|next
control|)
if|if
condition|(
name|sym
operator|->
name|label
operator|==
name|label
condition|)
name|sym
operator|->
name|pool
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
comment|/* If we didn't find it, there's something truly wrong here, but it 	 will be announced by the assembler. */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mark_constants
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|find_pool_constant
argument_list|(
name|x
argument_list|)
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Never search inside a CONST_DOUBLE, because CONST_DOUBLE_MEM may be      a MEM, but does not constitute a use of that MEM.  This is particularly      important inside a nested function, because CONST_DOUBLE_MEM may be      a reference to a MEM in the parent's constant pool.  See the comment      in force_const_mem.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return;
comment|/* Insns may appear inside a SEQUENCE.  Only check the patterns of      insns, not any notes that may be attached.  We don't want to mark      a constant just because it happens to appear in a REG_EQUIV note.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|mark_constants
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_constants
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
case|case
literal|'0'
case|:
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'n'
case|:
case|case
literal|'u'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the constants whose addresses are referenced inside of EXP,    and make sure assembler code with a label has been output for each one.    Indicate whether an ADDR_EXPR has been encountered.  */
end_comment

begin_function
specifier|static
name|int
name|output_addressed_constants
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|reloc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
block|{
specifier|register
name|tree
name|constant
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|constant
operator|=
name|TREE_OPERAND
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|constant
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|TREE_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
comment|/* No need to do anything here 	     for addresses of variables or functions.  */
name|output_constant_def
argument_list|(
name|constant
argument_list|)
expr_stmt|;
block|}
name|reloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator||=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|reloc
operator||=
name|output_addressed_constants
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for constant EXP to FILE, with no label.    This includes the pseudo-op such as ".int" or ".byte", and a newline.    Assumes output_addressed_constants has been done on EXP already.     Generate exactly SIZE bytes of assembler data, padding at the end    with zeros if necessary.  SIZE must always be specified.     SIZE is important for structure constructors,    since trailing members may have been omitted from the constructor.    It is also important for initialization of arrays from string constants    since the full length of the string constant might not be wanted.    It is also needed for initialization of unions, where the initializer's    type is just one member, and that may not be as long as the union.     There a case in which we would fail to output exactly SIZE bytes:    for a structure constructor that wants to produce more than SIZE bytes.    But such constructors will never be generated for any possible input.  */
end_comment

begin_function
name|void
name|output_constant
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Some front-ends use constants other than the standard      language-indepdent varieties, but which may still be output      directly.  Give the front-end a chance to convert EXP to a      language-independent representation.  */
if|if
condition|(
name|lang_expand_constant
condition|)
name|exp
operator|=
call|(
modifier|*
name|lang_expand_constant
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|flag_syntax_only
condition|)
return|return;
comment|/* Eliminate the NON_LVALUE_EXPR_EXPR that makes a cast not be an lvalue.      That way we get the constant (we hope) inside it.  Also, strip off any      NOP_EXPR that converts between two record, union, array, or set types.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow a constructor with no elements for any data type.      This means to fill the space with zeros.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* ??? What about       (int)((float)(int)&foo + 4)    */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"initializer for integer value is too complicated"
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|REAL_CST
condition|)
name|error
argument_list|(
literal|"initializer for floating value is not a floating constant"
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|output_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|size
operator|-=
operator|(
name|size
operator|/
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|excess
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|excess
operator|=
name|size
operator|-
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
name|assemble_string
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|excess
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
name|SET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|assemble_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"unknown set constructor type"
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
comment|/* ??? */
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_constant, used for CONSTRUCTORs    (aggregate constants).    Generate at least SIZE bytes, padding if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|output_constructor
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|min_index
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes output or skipped so far.      In other words, current position within the constructor.  */
name|int
name|total_bytes
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means BYTE contains part of a byte, to be output.  */
name|int
name|byte_buffer_in_use
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|byte
decl_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|min_index
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As LINK goes through the elements of the constant,      FIELD goes through the structure fields, if the constant is a structure.      if the constant is a union, then we override this,      by getting the field from the TREE_LIST element.      But the constant could also be an array.  Then FIELD is zero.       There is always a maximum of one element in the chain LINK for unions      (even if the initializer in a source program incorrectly contains      more one). */
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|field
operator|=
name|field
condition|?
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
else|:
literal|0
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
literal|0
decl_stmt|;
comment|/* the element in a union constructor specifies the proper field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* if available, use the type given by link */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|index
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* Eliminate the marker that makes a cast not be an lvalue.  */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|STRIP_NOPS
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
specifier|register
name|int
name|fieldsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lo_index
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|hi_index
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
name|lo_index
init|;
name|index
operator|<=
name|hi_index
condition|;
name|index
operator|++
control|)
block|{
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|==
literal|0
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* An element that is not a bit-field.  */
specifier|register
name|int
name|fieldsize
decl_stmt|;
comment|/* Since this structure is static, 	     we know the positions are constant.  */
name|int
name|bitpos
init|=
operator|(
name|field
condition|?
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|bitpos
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|*
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|-
name|min_index
operator|)
operator|)
expr_stmt|;
comment|/* Output any buffered-up bit-fields preceding this element.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Advance to offset of this element. 	     Note no alignment needed in an array, since that is guaranteed 	     if each element has the proper size.  */
if|if
condition|(
operator|(
name|field
operator|!=
literal|0
operator|||
name|index
operator|!=
literal|0
operator|)
operator|&&
name|bitpos
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_zeros
argument_list|(
name|bitpos
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|bitpos
expr_stmt|;
block|}
comment|/* Determine size this element should occupy.  */
if|if
condition|(
name|field
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|>
literal|100000
condition|)
block|{
comment|/* This avoids overflow trouble.  */
name|tree
name|size_tree
init|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|fieldsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fieldsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|fieldsize
operator|=
operator|(
name|fieldsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
else|else
name|fieldsize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid initial value for member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Element that is a bit-field.  */
name|int
name|next_offset
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|end_offset
init|=
operator|(
name|next_offset
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* If this field does not start in this (or, next) byte, 	     skip some bytes.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
comment|/* Output remnant of any bit field in previous bytes.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still not at proper byte, advance to there.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_zeros
argument_list|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|next_offset
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|byte_buffer_in_use
condition|)
name|byte
operator|=
literal|0
expr_stmt|;
comment|/* We must split the element into pieces that fall within 	     separate bytes, and combine each byte with previous or 	     following bit-fields.  */
comment|/* next_offset is the offset n fbits from the beginning of 	     the structure to the next bit of this element to be processed. 	     end_offset is the offset of the first bit past the end of 	     this element.  */
while|while
condition|(
name|next_offset
operator|<
name|end_offset
condition|)
block|{
name|int
name|this_time
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|next_byte
init|=
name|next_offset
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|next_bit
init|=
name|next_offset
operator|%
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Advance from byte to byte 		 within this element when necessary.  */
while|while
condition|(
name|next_byte
operator|!=
name|total_bytes
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Number of bits we can process at once 		 (all part of the same byte).  */
name|this_time
operator|=
name|MIN
argument_list|(
name|end_offset
operator|-
name|next_offset
argument_list|,
name|BITS_PER_UNIT
operator|-
name|next_bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* On big-endian machine, take the most significant bits 		     first (of the bits that are significant) 		     and put them into bytes from the most significant end.  */
name|shift
operator|=
name|end_offset
operator|-
name|next_offset
operator|-
name|this_time
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|this_time
operator|-=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|shift
operator|)
expr_stmt|;
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|this_time
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|BITS_PER_UNIT
operator|-
name|this_time
operator|-
name|next_bit
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* On little-endian machines, 		     take first the least significant bits of the value 		     and pack them starting at the least significant 		     bits of the bytes.  */
name|shift
operator|=
operator|(
name|next_offset
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|this_time
operator|-=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|shift
operator|)
expr_stmt|;
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|this_time
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|next_bit
operator|)
expr_stmt|;
block|}
name|next_offset
operator|+=
name|this_time
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|total_bytes
operator|<
name|size
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
end_ifdef

begin_comment
comment|/* Add function NAME to the weak symbols list.  VALUE is a weak alias    associatd with NAME.  */
end_comment

begin_function
name|int
name|add_weak
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|weak_syms
modifier|*
name|weak
decl_stmt|;
name|weak
operator|=
operator|(
expr|struct
name|weak_syms
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|weak_syms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|weak
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|weak
operator|->
name|next
operator|=
name|weak_decls
expr_stmt|;
name|weak
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|weak
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|weak_decls
operator|=
name|weak
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_WEAK */
end_comment

begin_comment
comment|/* Declare DECL to be a weak symbol.  */
end_comment

begin_function
name|void
name|declare_weak
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"weak declaration of `%s' must be public"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"weak declaration of `%s' must precede definition"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
name|add_weak
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit any pending weak declarations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
end_ifdef

begin_decl_stmt
name|struct
name|weak_syms
modifier|*
name|weak_decls
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|weak_finish
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
if|if
condition|(
name|HANDLE_PRAGMA_WEAK
condition|)
block|{
name|struct
name|weak_syms
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|weak_decls
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|name
condition|)
block|{
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|value
condition|)
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|t
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Remove NAME from the pending list of weak symbols.  This prevents    the compiler from emitting multiple .weak directives which confuses    some assemblers.  */
end_comment

begin_function
specifier|static
name|void
name|remove_from_pending_weak_list
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
if|if
condition|(
name|HANDLE_PRAGMA_WEAK
condition|)
block|{
name|struct
name|weak_syms
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|weak_decls
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|assemble_alias
parameter_list|(
name|decl
parameter_list|,
name|target
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|target
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
comment|/* Make name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Remove this function from the pending weak list so that 	     we do not emit multiple .weak directives for it.  */
name|remove_from_pending_weak_list
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_WEAK_ALIAS
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"only weak aliases are supported in this configuration"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"alias definitions not supported in this configuration; ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This determines whether or not we support link-once semantics.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SUPPORTS_ONE_ONLY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAKE_DECL_ONE_ONLY
end_ifdef

begin_define
define|#
directive|define
name|SUPPORTS_ONE_ONLY
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SUPPORTS_ONE_ONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Returns 1 if the target configuration supports defining public symbols    so that one of them will be chosen at link time instead of generating a    multiply-defined symbol error, whether through the use of weak symbols or    a target-specific mechanism for having duplicates discarded.  */
end_comment

begin_function
name|int
name|supports_one_only
parameter_list|()
block|{
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
return|return
literal|1
return|;
return|return
name|SUPPORTS_WEAK
return|;
block|}
end_function

begin_comment
comment|/* Set up DECL as a public symbol that can be defined in multiple    translation units without generating a linker error.  */
end_comment

begin_function
name|void
name|make_decl_one_only
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
block|{
ifdef|#
directive|ifdef
name|MAKE_DECL_ONE_ONLY
name|MAKE_DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

