begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output variables, constants and external declarations, for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles generation of all the assembler code    *except* the instructions of a function.    This includes declarations of variables and their initial values.     We also output the assembler code for constants stored in memory    and are responsible for combining constants with the same value.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRAMPOLINE_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|TRAMPOLINE_ALIGNMENT
value|FUNCTION_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABS_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|"\t.stabs\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The (assembler) name of the first globally-visible object output.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|first_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|weak_global_object_name
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|addr_const
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|constant_descriptor_rtx
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rtx_const
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|pool_constant
struct_decl|;
end_struct_decl

begin_define
define|#
directive|define
name|MAX_RTX_HASH_TABLE
value|61
end_define

begin_decl_stmt
name|struct
name|varasm_status
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Hash facility for making memory-constants      from constant rtl-expressions.  It is used on RISC machines      where immediate integer arguments and constant addresses are restricted      so that such constants must be stored in memory.       This pool of constants is reinitialized for each function      so each function gets its own constants-pool that comes right before      it.  */
name|struct
name|constant_descriptor_rtx
modifier|*
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"MAX_RTX_HASH_TABLE"
argument_list|)
operator|)
argument_list|)
name|x_const_rtx_hash_table
decl_stmt|;
name|struct
name|pool_constant
modifier|*
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"MAX_RTX_HASH_TABLE"
argument_list|)
operator|)
argument_list|)
name|x_const_rtx_sym_hash_table
decl_stmt|;
comment|/* Pointers to first and last constant in pool.  */
name|struct
name|pool_constant
modifier|*
name|x_first_pool
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|x_last_pool
decl_stmt|;
comment|/* Current offset in constant pool (does not include any machine-specific      header).  */
name|HOST_WIDE_INT
name|x_pool_offset
decl_stmt|;
comment|/* Number of tree-constants deferred during the expansion of this      function.  */
name|unsigned
name|int
name|deferred_constants
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|const_rtx_hash_table
value|(cfun->varasm->x_const_rtx_hash_table)
end_define

begin_define
define|#
directive|define
name|const_rtx_sym_hash_table
value|(cfun->varasm->x_const_rtx_sym_hash_table)
end_define

begin_define
define|#
directive|define
name|first_pool
value|(cfun->varasm->x_first_pool)
end_define

begin_define
define|#
directive|define
name|last_pool
value|(cfun->varasm->x_last_pool)
end_define

begin_define
define|#
directive|define
name|pool_offset
value|(cfun->varasm->x_pool_offset)
end_define

begin_define
define|#
directive|define
name|n_deferred_constants
value|(cfun->varasm->deferred_constants)
end_define

begin_comment
comment|/* Number for making the label on the next    constant that is stored in memory.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|const_labelno
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last decl for which assemble_variable was called,    if it did ASM_DECLARE_OBJECT_NAME.    If the last call to assemble_variable didn't do that,    this holds 0.  */
end_comment

begin_decl_stmt
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RTX_UNCHANGING_P in a MEM can mean it is stored into, for initialization.    So giving constant the alias set for the type will allow such    initializations to appear to conflict with the load of the constant.  We    avoid this by giving all constants an alias set for just constants.    Since there will be no stores to that alias set, nothing will ever    conflict with them.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|const_alias_set
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contains_pointers_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
end_ifdef

begin_function_decl
specifier|static
name|bool
name|incorporeal_function_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|tree
parameter_list|,
name|struct
name|addr_const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|const_desc_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|const_desc_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|const_hash_1
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_constant
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_constant
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_constant_def_contents
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_rtx_const
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|rtx_const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|const_hash_rtx
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_constant_rtx
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|constant_descriptor_rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|constant_descriptor_rtx
modifier|*
name|record_constant_rtx
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_constant_pool
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_constants
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mark_constant
parameter_list|(
name|rtx
modifier|*
name|current_rtx
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_addressed_constants
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|array_size_for_constructor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|min_align
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_constructor
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|globalize_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_assemble_visibility
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in_named_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|in_named_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_function_decl
specifier|static
name|void
name|asm_output_bss
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|asm_output_aligned_bss
argument_list|(
name|FILE
operator|*
argument_list|,
name|tree
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|unsigned
name|HOST_WIDE_INT
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_function_decl
specifier|static
name|bool
name|asm_emit_uninitialised
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_weak
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_enum
enum|enum
name|in_section
block|{
name|no_section
block|,
name|in_text
block|,
name|in_data
block|,
name|in_named
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
block|,
name|in_bss
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CTORS_SECTION_ASM_OP
block|,
name|in_ctors
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DTORS_SECTION_ASM_OP
block|,
name|in_dtors
endif|#
directive|endif
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION_ASM_OP
block|,
name|in_readonly_data
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTRA_SECTIONS
block|,
name|EXTRA_SECTIONS
endif|#
directive|endif
block|}
enum|;
end_enum

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
expr|enum
name|in_section
name|in_section
operator|=
name|no_section
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return a nonzero value if DECL has a section attribute.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_NAMED_SECTION
end_ifndef

begin_define
define|#
directive|define
name|IN_NAMED_SECTION
parameter_list|(
name|DECL
parameter_list|)
define|\
value|((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \&& DECL_SECTION_NAME (DECL) != NULL_TREE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Text of section name when in_section == in_named.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
specifier|const
name|char
operator|*
name|in_named_name
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hash table of flags that have been used for a particular named section.  */
end_comment

begin_decl_stmt
name|struct
name|in_named_entry
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|bool
name|declared
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct in_named_entry))
argument_list|)
name|htab_t
name|in_named_htab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Define functions like text_section for any extra sections.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SECTION_FUNCTIONS
end_ifdef

begin_function
name|EXTRA_SECTION_FUNCTIONS
endif|#
directive|endif
comment|/* Tell assembler to switch to text section.  */
name|void
name|text_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_text
condition|)
block|{
name|in_section
operator|=
name|in_text
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to data section.  */
end_comment

begin_function
name|void
name|data_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_data
condition|)
block|{
name|in_section
operator|=
name|in_data
expr_stmt|;
if|if
condition|(
name|flag_shared_data
condition|)
block|{
ifdef|#
directive|ifdef
name|SHARED_SECTION_ASM_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|SHARED_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to read-only data section.  This is normally    the text section.  */
end_comment

begin_function
name|void
name|readonly_data_section
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION
name|READONLY_DATA_SECTION
argument_list|()
expr_stmt|;
comment|/* Note this can call data_section.  */
else|#
directive|else
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION_ASM_OP
if|if
condition|(
name|in_section
operator|!=
name|in_readonly_data
condition|)
block|{
name|in_section
operator|=
name|in_readonly_data
expr_stmt|;
name|fputs
argument_list|(
name|READONLY_DATA_SECTION_ASM_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Determine if we're in the text section.  */
end_comment

begin_function
name|int
name|in_text_section
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|in_section
operator|==
name|in_text
return|;
block|}
end_function

begin_comment
comment|/* Determine if we're in the data section.  */
end_comment

begin_function
name|int
name|in_data_section
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|in_section
operator|==
name|in_data
return|;
block|}
end_function

begin_comment
comment|/* Helper routines for maintaining in_named_htab.  */
end_comment

begin_function
specifier|static
name|int
name|in_named_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|in_named_entry
modifier|*
name|old
init|=
name|p1
decl_stmt|;
specifier|const
name|char
modifier|*
name|new
init|=
name|p2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|old
operator|->
name|name
argument_list|,
name|new
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|in_named_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|in_named_entry
modifier|*
name|old
init|=
name|p
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|old
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If SECTION has been seen before as a named section, return the flags    that were used.  Otherwise, return 0.  Note, that 0 is a perfectly valid    set of flags for a section to have, so 0 does not mean that the section    has not been seen.  */
end_comment

begin_function
name|unsigned
name|int
name|get_named_section_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|in_named_entry
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|in_named_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|in_named_htab
argument_list|,
name|section
argument_list|,
name|htab_hash_string
argument_list|(
name|section
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
return|return
name|slot
condition|?
operator|(
operator|*
name|slot
operator|)
operator|->
name|flags
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the section has been declared before.   Sets internal    flag on this section in in_named_hash so subsequent calls on this    section will return false.  */
end_comment

begin_function
name|bool
name|named_section_first_declaration
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|in_named_entry
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|in_named_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|in_named_htab
argument_list|,
name|name
argument_list|,
name|htab_hash_string
argument_list|(
name|name
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|slot
operator|)
operator|->
name|declared
condition|)
block|{
operator|(
operator|*
name|slot
operator|)
operator|->
name|declared
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Record FLAGS for SECTION.  If SECTION was previously recorded with a    different set of flags, return false.  */
end_comment

begin_function
name|bool
name|set_named_section_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|struct
name|in_named_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|in_named_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|in_named_htab
argument_list|,
name|section
argument_list|,
name|htab_hash_string
argument_list|(
name|section
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|entry
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|ggc_strdup
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|entry
operator|->
name|declared
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|flags
operator|!=
name|flags
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Tell assembler to change to section NAME with attributes FLAGS.  */
end_comment

begin_function
name|void
name|named_section_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_named
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|in_named_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|set_named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|named_section
call|)
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_FORGET
condition|)
name|in_section
operator|=
name|no_section
expr_stmt|;
else|else
block|{
name|in_named_name
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_named
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to change to section NAME for DECL.    If DECL is NULL, just switch to section NAME.    If NAME is NULL, get the name from DECL.    If RELOC is 1, the initializer for DECL contains relocs.  */
end_comment

begin_function
name|void
name|named_section
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
call|(
modifier|*
name|targetm
operator|.
name|section_type_flags
call|)
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
comment|/* Sanity check user variables for flag changes.  Non-user      section flag changes will abort in named_section_flags.      However, don't complain if SECTION_OVERRIDE is set.      We trust that the setter knows that it is safe to ignore      the default flags for this decl.  */
if|if
condition|(
name|decl
operator|&&
operator|!
name|set_named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|flags
operator|=
name|get_named_section_flags
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SECTION_OVERRIDE
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"%J%D causes a section type conflict"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If required, set DECL_SECTION_NAME to a unique name.  */
end_comment

begin_function
name|void
name|resolve_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flag_function_or_data_sections
parameter_list|)
block|{
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|targetm
operator|.
name|have_named_sections
operator|&&
operator|(
name|flag_function_or_data_sections
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|unique_section
call|)
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* Tell the assembler to switch to the bss section.  */
end_comment

begin_function
name|void
name|bss_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_bss
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|BSS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_bss
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_comment
comment|/* Utility function for ASM_OUTPUT_BSS for targets to use if    they don't support alignments in .bss.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_bss
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|rounded
parameter_list|)
block|{
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bss_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|rounded
condition|?
name|rounded
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_comment
comment|/* Utility function for targets to use in implementing    ASM_OUTPUT_ALIGNED_BSS.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_aligned_bss
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|bss_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_comment
comment|/* Switch to the section for function DECL.     If DECL is NULL_TREE, switch to the text section.    ??? It's not clear that we will ever be passed NULL_TREE, but it's    safer to handle it.  */
end_comment

begin_function
name|void
name|function_section
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|named_section
argument_list|(
name|decl
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|text_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch to section for variable DECL.  RELOC is the same as the    argument to SELECT_SECTION.  */
end_comment

begin_function
name|void
name|variable_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
name|named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|select_section
call|)
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to the section for string merging.  */
end_comment

begin_function
name|void
name|mergeable_string_section
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|HAVE_GAS_SHF_MERGE
operator|&&
name|flag_merge_constants
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|align
operator|<=
literal|256
operator|&&
name|TREE_STRING_LENGTH
argument_list|(
name|decl
argument_list|)
operator|>=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|modesize
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|,
name|unit
decl_stmt|;
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modesize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|modesize
operator|>=
literal|8
operator|&&
name|modesize
operator|<=
literal|256
operator|&&
operator|(
name|modesize
operator|&
operator|(
name|modesize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|align
operator|<
name|modesize
condition|)
name|align
operator|=
name|modesize
expr_stmt|;
name|str
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|unit
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Check for embedded NUL characters.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|unit
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|unit
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|str
index|[
name|i
operator|+
name|j
index|]
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|unit
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
operator|-
name|unit
condition|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".rodata.str%d.%d"
argument_list|,
name|modesize
operator|/
literal|8
argument_list|,
call|(
name|int
call|)
argument_list|(
name|align
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|modesize
operator|/
literal|8
operator|)
operator||
name|SECTION_MERGE
operator||
name|SECTION_STRINGS
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
name|modesize
operator|<
name|align
condition|)
block|{
comment|/* A "" string with requested alignment greater than 		     character size might cause a problem: 		     if some other string required even bigger 		     alignment than "", then linker might think the 		     "" is just part of padding after some other string 		     and not put it into the hash table initially. 		     But this means "" could have smaller alignment 		     than requested.  */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_START
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|readonly_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to the section for constant merging.  */
end_comment

begin_function
name|void
name|mergeable_constant_section
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|modesize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAVE_GAS_SHF_MERGE
operator|&&
name|flag_merge_constants
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|modesize
operator|<=
name|align
operator|&&
name|align
operator|>=
literal|8
operator|&&
name|align
operator|<=
literal|256
operator|&&
operator|(
name|align
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|name
index|[
literal|24
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".rodata.cst%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|align
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|align
operator|/
literal|8
operator|)
operator||
name|SECTION_MERGE
expr_stmt|;
name|named_section_flags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|readonly_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, a putative register name, discard any customary prefixes.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
argument_list|)
condition|)
name|name
operator|+=
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|name
operator|++
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode an `asm' spec for a declaration as a register name.    Return the register number, or -1 if nothing specified,    or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,    or -3 if ASMSPEC is `cc' and is not recognized,    or -4 if ASMSPEC is `memory' and is not recognized.    Accept an exact spelling or a decimal number.    Prefixes such as % are optional.  */
end_comment

begin_function
name|int
name|decode_reg_name
parameter_list|(
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|)
block|{
if|if
condition|(
name|asmspec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Get rid of confusing prefixes.  */
name|asmspec
operator|=
name|strip_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Allow a decimal number as a "register name".  */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|asmspec
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|asmspec
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
else|else
return|return
operator|-
literal|2
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|strip_reg_name
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|i
return|;
ifdef|#
directive|ifdef
name|ADDITIONAL_REGISTER_NAMES
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|number
decl_stmt|;
block|}
name|table
index|[]
init|=
name|ADDITIONAL_REGISTER_NAMES
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|table
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|number
return|;
block|}
endif|#
directive|endif
comment|/* ADDITIONAL_REGISTER_NAMES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"memory"
argument_list|)
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"cc"
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
return|return
operator|-
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should    have static storage duration.  In other words, it should not be an    automatic variable, including PARM_DECLs.     There is, however, one exception: this function handles variables    explicitly placed in a particular register by the user.     ASMSPEC, if not 0, is the string which the user specified as the    assembler symbol name.     This is never called for PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|make_decl_rtl
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|int
name|reg_number
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Check that we are not being given an automatic variable.  */
comment|/* A weak alias has TREE_PUBLIC set but not the other bits.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* And that we were not given a type or a label.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* For a duplicate declaration, we can be called twice on the      same DECL node.  Don't discard the RTL already made.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If the old RTL had the wrong mode, fix the mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|adjust_address_nv
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Another way to do this would be to maintain a hashed 	 table of such critters.  Instead of adding stuff to a DECL 	 to give certain attributes to it, we could use an external 	 hash map from DECL to set of attributes.  */
comment|/* Let the target reassign the RTL if it wants. 	 This is necessary, for example, when one machine specific 	 decl attribute overrides another.  */
call|(
modifier|*
name|targetm
operator|.
name|encode_section_info
call|)
argument_list|(
name|decl
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg_number
operator|=
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* ASMSPEC is given, and not the name of a register.  Mark the 	 name with a star so assemble_name won't munge it.  */
name|char
modifier|*
name|starred
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|starred
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|strcpy
argument_list|(
name|starred
operator|+
literal|1
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|change_decl_assembler_name
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|starred
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* First detect errors in declaring global registers.  */
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"%Jregister name not specified for '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_number
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"%Jinvalid register name for '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|error
argument_list|(
literal|"%Jdata type of '%D' isn't suitable for a register"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|reg_number
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jregister specified for '%D' isn't suitable for data type"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Now handle properly declared static register variables.  */
else|else
block|{
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"global register variable has initial value"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"volatile register variables don't work as you might wish"
argument_list|)
expr_stmt|;
comment|/* If the user specified one of the eliminables registers here, 	     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable 	     confused with that register and be eliminated.  This usage is 	     somewhat suspect...  */
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_rtx_raw_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|reg_number
argument_list|)
argument_list|)
expr_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|reg_number
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Make this register global, so not usable for anything 		 else.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_REGISTER_GLOBAL
name|ASM_DECLARE_REGISTER_GLOBAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|reg_number
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|reg_number
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|>
literal|0
condition|)
name|globalize_reg
argument_list|(
name|reg_number
operator|+
operator|--
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* As a register variable, it has no section.  */
return|return;
block|}
block|}
comment|/* Now handle ordinary static variables and functions (in memory).      Also handle vars declared register invalidly.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
operator|||
name|reg_number
operator|==
operator|-
literal|3
condition|)
name|error
argument_list|(
literal|"%Jregister name given for non-register variable '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Specifying a section attribute on a variable forces it into a      non-.bss section, and thus it cannot be common.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Variables can't be both common and weak.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
operator|=
name|decl
expr_stmt|;
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information      such as that it is a function name.      If the name is changed, the macro ASM_OUTPUT_LABELREF      will have to know how to strip this information.  */
call|(
modifier|*
name|targetm
operator|.
name|encode_section_info
call|)
argument_list|(
name|decl
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the rtl for variable VAR be volatile.    Use this only for static variables.  */
end_comment

begin_function
name|void
name|make_var_volatile
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a string of literal assembler code    for an `asm' keyword used between functions.  */
end_comment

begin_function
name|void
name|assemble_asm
parameter_list|(
name|tree
name|string
parameter_list|)
block|{
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global destructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.  */
end_comment

begin_function
name|void
name|default_stabs_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Tell GNU LD that this is part of the static destructor set.      This will work for any system that uses stabs, most usefully      aout systems.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\"___DTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_named_section_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".dtors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* ??? This only works reliably with the GNU linker.  */
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".dtors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DTORS_SECTION_ASM_OP
end_ifdef

begin_function
name|void
name|dtors_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_dtors
condition|)
block|{
name|in_section
operator|=
name|in_dtors
expr_stmt|;
name|fputs
argument_list|(
name|DTORS_SECTION_ASM_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|default_dtor_section_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|dtors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Likewise for global constructors.  */
end_comment

begin_function
name|void
name|default_stabs_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Tell GNU LD that this is part of the static destructor set.      This will work for any system that uses stabs, most usefully      aout systems.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\"___CTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_named_section_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".ctors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* ??? This only works reliably with the GNU linker.  */
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ctors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTORS_SECTION_ASM_OP
end_ifdef

begin_function
name|void
name|ctors_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_ctors
condition|)
block|{
name|in_section
operator|=
name|in_ctors
expr_stmt|;
name|fputs
argument_list|(
name|CTORS_SECTION_ASM_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|default_ctor_section_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|ctors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* CONSTANT_POOL_BEFORE_FUNCTION may be defined as an expression with    a nonzero value if the constant pool should be output before the    start of the function, or a zero value if the pool should output    after the end of the function.  The default is to put it before the    start.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONSTANT_POOL_BEFORE_FUNCTION
end_ifndef

begin_define
define|#
directive|define
name|CONSTANT_POOL_BEFORE_FUNCTION
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DECL is an object (either VAR_DECL or FUNCTION_DECL) which is going    to be output to assembler.    Set first_global_object_name and weak_global_object_name as appropriate.  */
end_comment

begin_function
name|void
name|notice_global_symbol
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|type
init|=
operator|&
name|first_global_object_name
decl_stmt|;
if|if
condition|(
name|first_global_object_name
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
comment|/* We win when global object is found, but it is usefull to know about weak      symbol as well so we can produce nicer unique names.  */
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|type
operator|=
operator|&
name|weak_global_object_name
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|type
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|p
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|name
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output assembler code for the constant pool of a function and associated    with defining the name of the function.  DECL describes the function.    NAME is the function's name.  For the constant pool, we use the current    constant pool data.  */
end_comment

begin_function
name|void
name|assemble_start_function
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
parameter_list|)
block|{
name|int
name|align
decl_stmt|;
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|flag_function_sections
argument_list|)
expr_stmt|;
name|function_section
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Tell assembler to move to target machine's alignment for functions.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<
name|force_align_functions_log
condition|)
name|align
operator|=
name|force_align_functions_log
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a user-specified function alignment.      Note that we still need to align to FUNCTION_BOUNDARY, as above,      because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */
if|if
condition|(
name|align_functions_log
operator|>
name|align
operator|&&
name|cfun
operator|->
name|function_frequency
operator|!=
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|ASM_OUTPUT_MAX_SKIP_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align_functions_log
argument_list|,
name|align_functions
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align_functions_log
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FUNCTION_PREFIX
name|ASM_OUTPUT_FUNCTION_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|debug_hooks
operator|->
name|begin_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Make function name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|notice_global_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|globalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|maybe_assemble_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the function name.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_NAME
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the function.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_FUNCTION_NAME */
block|}
end_function

begin_comment
comment|/* Output assembler code associated with defining the size of the    function.  DECL describes the function.  NAME is the function's name.  */
end_comment

begin_function
name|void
name|assemble_end_function
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_SIZE
name|ASM_DECLARE_FUNCTION_SIZE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
block|{
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|function_section
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* need to switch back */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble code to leave SIZE bytes of zeros.  */
end_comment

begin_function
name|void
name|assemble_zeros
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASM_NO_SKIP_IN_TEXT
comment|/* The `space' pseudo in the text section outputs nop insns rather than 0s,      so we must output 0s explicitly in the text section.  */
if|if
condition|(
name|ASM_NO_SKIP_IN_TEXT
operator|&&
name|in_text_section
argument_list|()
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */
end_comment

begin_function
name|void
name|assemble_align
parameter_list|(
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a string constant with the specified C string as contents.  */
end_comment

begin_function
name|void
name|assemble_string
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|maximum
init|=
literal|2000
decl_stmt|;
comment|/* If the string is very long, split it up.  */
while|while
condition|(
name|pos
operator|<
name|size
condition|)
block|{
name|int
name|thissize
init|=
name|size
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|thissize
operator|>
name|maximum
condition|)
name|thissize
operator|=
name|maximum
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|thissize
expr_stmt|;
name|p
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_LOCAL
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, decl, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_LOCAL
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_LOCAL
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASM_EMIT_LOCAL
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_BSS
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_BSS
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_BSS
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_BSS
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_BSS (asm_out_file, decl, name, size, rounded)
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|ASM_EMIT_BSS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_COMMON
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, decl, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_COMMON
end_if

begin_define
define|#
directive|define
name|ASM_EMIT_COMMON
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size, DECL_ALIGN (decl))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASM_EMIT_COMMON
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
define|\
value|ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|asm_emit_uninitialised
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|rounded
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
enum|enum
block|{
name|asm_dest_common
block|,
name|asm_dest_bss
block|,
name|asm_dest_local
block|}
name|destination
init|=
name|asm_dest_local
enum|;
comment|/* ??? We should handle .bss via select_section mechanisms rather than      via special target hooks.  That would eliminate this special case.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|ASM_EMIT_BSS
name|destination
operator|=
name|asm_dest_bss
expr_stmt|;
else|#
directive|else
return|return
name|false
return|;
endif|#
directive|endif
else|else
name|destination
operator|=
name|asm_dest_common
expr_stmt|;
block|}
if|if
condition|(
name|destination
operator|==
name|asm_dest_bss
condition|)
name|globalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|flag_data_sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_shared_data
condition|)
block|{
switch|switch
condition|(
name|destination
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_BSS
case|case
name|asm_dest_bss
case|:
name|ASM_OUTPUT_SHARED_BSS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_COMMON
case|case
name|asm_dest_common
case|:
name|ASM_OUTPUT_SHARED_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_LOCAL
case|case
name|asm_dest_local
case|:
name|ASM_OUTPUT_SHARED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|destination
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_EMIT_BSS
case|case
name|asm_dest_bss
case|:
name|ASM_EMIT_BSS
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|asm_dest_common
case|:
name|ASM_EMIT_COMMON
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
break|break;
case|case
name|asm_dest_local
case|:
name|ASM_EMIT_LOCAL
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Assemble everything that is needed for a variable or function declaration.    Not used for automatic variables, and not used for function definitions.    Should not be called for variables of incomplete structure type.     TOP_LEVEL is nonzero if this variable has file scope.    AT_END is nonzero if this is the special handling, at end of compilation,    to define things that have had only tentative definitions.    DONT_OUTPUT_DATA if nonzero means don't actually output the    initial value (that will be done by the caller).  */
end_comment

begin_function
name|void
name|assemble_variable
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|top_level
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|at_end
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|dont_output_data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|int
name|reloc
init|=
literal|0
decl_stmt|;
name|rtx
name|decl_rtl
decl_stmt|;
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|prepare_assemble_variable
condition|)
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|prepare_assemble_variable
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|last_assemble_variable_decl
operator|=
literal|0
expr_stmt|;
comment|/* Normally no need to say anything here for external references,      since assemble_external is called by the language-specific code      when a declaration is first seen.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output no assembler code for a function declaration.      Only definitions of functions output anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
comment|/* Do nothing for global register variables.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If type was incomplete when the variable was declared,      see if it is complete now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Still incomplete => don't allocate it; treat the tentative defn      (which is what it must have been) as an `extern' reference.  */
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%Jstorage size of `%D' isn't known"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Make sure targetm.encode_section_info is invoked before we set      ASM_WRITTEN.  */
name|decl_rtl
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jsize of variable '%D' is too large"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|notice_global_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Compute the alignment of this data.  */
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* In the case for initialing an array whose length isn't specified,      where we have not yet been able to do the layout,      figure out the proper alignment now.  */
if|if
condition|(
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some object file formats have a maximum alignment which they support.      In particular, a.out format supports a maximum alignment of 4.  */
ifndef|#
directive|ifndef
name|MAX_OFILE_ALIGNMENT
define|#
directive|define
name|MAX_OFILE_ALIGNMENT
value|BIGGEST_ALIGNMENT
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|MAX_OFILE_ALIGNMENT
condition|)
block|{
name|warning
argument_list|(
literal|"%Jalignment of '%D' is greater than maximum object "
literal|"file alignment.  Using %d"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|,
name|MAX_OFILE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|align
operator|=
name|MAX_OFILE_ALIGNMENT
expr_stmt|;
block|}
comment|/* On some machines, it is good to increase alignment sometimes.  */
if|if
condition|(
operator|!
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DATA_ALIGNMENT
name|align
operator|=
name|DATA_ALIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Reset the alignment in case we have made it tighter, so we can benefit      from it in get_pointer_alignment.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
name|set_mem_align
argument_list|(
name|decl_rtl
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|maybe_assemble_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output any data that we will need to use the address of.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|reloc
operator|=
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|?
literal|3
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|output_addressed_constants
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|flag_data_sections
argument_list|)
expr_stmt|;
comment|/* Handle uninitialized definitions.  */
comment|/* If the decl has been given an explicit section name, then it      isn't common, and shouldn't be handled as such.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|||
name|dont_output_data
condition|)
empty_stmt|;
comment|/* We don't implement common thread-local data at present.  */
elseif|else
if|if
condition|(
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"thread-local COMMON data not implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|(
name|flag_zero_initialized_in_bss
comment|/* Leave constant zeroes in .rodata so they can be shared.  */
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|initializer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|size
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|rounded
init|=
name|size
decl_stmt|;
comment|/* Don't allocate zero bytes of common, 	 since that means "undefined external" in the linker.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|rounded
operator|=
literal|1
expr_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits 	 so that each uninitialized object starts on such a boundary.  */
name|rounded
operator|+=
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|rounded
operator|=
operator|(
name|rounded
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_COMMON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|>
name|rounded
condition|)
name|warning
argument_list|(
literal|"%Jrequested alignment for '%D' is greater than "
literal|"implemented alignment of %d"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the target cannot output uninitialized but not common global data 	 in .bss, then we have to use .data, so fall through.  */
if|if
condition|(
name|asm_emit_uninitialised
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
condition|)
return|return;
block|}
comment|/* Handle initialized definitions.      Also handle uninitialized global definitions if -fno-common and the      target doesn't support ASM_OUTPUT_BSS.  */
comment|/* First make the assembler name(s) global if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|globalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Switch to the appropriate section.  */
name|variable_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
comment|/* dbxout.c needs to know this.  */
if|if
condition|(
name|in_text_section
argument_list|()
condition|)
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output the alignment of this data.  */
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the object.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
if|if
condition|(
operator|!
name|dont_output_data
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
comment|/* Output the actual data.  */
name|output_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
comment|/* Leave space for it.  */
name|assemble_zeros
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if type TYPE contains any pointers.  */
end_comment

begin_function
specifier|static
name|int
name|contains_pointers_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* I'm not sure whether OFFSET_TYPE needs this treatment, 	 so I'll play safe and return 1.  */
case|case
name|OFFSET_TYPE
case|:
return|return
literal|1
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|fields
decl_stmt|;
comment|/* For a type that has fields, see if the fields have pointers.  */
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
comment|/* An array type contains pointers if its element type does.  */
return|return
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
end_ifdef

begin_comment
comment|/* True if DECL is a function decl for which no out-of-line copy exists.    It is assumed that DECL's assembler name has been set.  */
end_comment

begin_function
specifier|static
name|bool
name|incorporeal_function_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_ALLOCA
condition|)
return|return
name|true
return|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|,
name|strlen
argument_list|(
literal|"__builtin_"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output something to declare an external symbol to the assembler.    (Most assemblers don't need this, so we normally output nothing.)    Do nothing if DECL is not external.  */
end_comment

begin_function
name|void
name|assemble_external
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Because most platforms do not define ASM_OUTPUT_EXTERNAL, the      main body of this code is only rarely exercised.  To provide some      testing, on all platforms, we make sure that the ASM_OUT_FILE is      open.  If it's not, we should not be calling this function.  */
if|if
condition|(
operator|!
name|asm_out_file
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|incorporeal_function_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Some systems do require some output.  */
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Similar, for calling a library function FUN.  */
end_comment

begin_function
name|void
name|assemble_external_libcall
parameter_list|(
name|rtx
name|fun
parameter_list|)
block|{
comment|/* Declare library function name external when first used, if nec.  */
if|if
condition|(
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|external_libcall
call|)
argument_list|(
name|fun
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a label named NAME.  */
end_comment

begin_function
name|void
name|assemble_label
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the symbol_referenced flag for ID and notify callgraph code.  */
end_comment

begin_function
name|void
name|mark_referenced
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
decl_stmt|;
if|if
condition|(
operator|!
name|cgraph_global_info_ready
condition|)
block|{
name|node
operator|=
name|cgraph_node_for_identifier
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|vnode
operator|=
name|cgraph_varpool_node_for_identifier
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnode
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|vnode
argument_list|)
expr_stmt|;
block|}
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output to FILE a reference to the assembler name of a C-level name NAME.    If NAME starts with a *, the rest of NAME is output verbatim.    Otherwise NAME is transformed in an implementation-defined way    (usually by the addition of an underscore).    Many macros in the tm file are defined to call this function.  */
end_comment

begin_function
name|void
name|assemble_name
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|real_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|mark_referenced
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|fputs
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes writable static space with a gensym name    and return an RTX to refer to its address.  */
end_comment

begin_function
name|rtx
name|assemble_static_space
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|namestring
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|#
directive|if
literal|0
block|if (flag_shared_data)     data_section ();
endif|#
directive|endif
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LF"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|namestring
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|x
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits        so that each uninitialized object starts on such a boundary.  */
comment|/* Variable `rounded' might or might not be used in ASM_OUTPUT_LOCAL.  */
name|unsigned
name|HOST_WIDE_INT
name|rounded
name|ATTRIBUTE_UNUSED
init|=
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Assemble the static constant template for function entry trampolines.    This is done at most once per compilation.    Returns an RTX for the address of the template.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
end_ifdef

begin_function
name|rtx
name|assemble_trampoline_template
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|align
decl_stmt|;
name|rtx
name|symbol
decl_stmt|;
comment|/* By default, put trampoline templates in read-only data section.  */
ifdef|#
directive|ifdef
name|TRAMPOLINE_SECTION
name|TRAMPOLINE_SECTION
argument_list|()
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Write the assembler code to define one.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRAMPOLINE_TEMPLATE
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Record the rtl to refer to it.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|ggc_strdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
return|return
name|symbol
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A and B are either alignments or offsets.  Return the minimum alignment    that may be assumed after adding the two together.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|min_align
parameter_list|(
name|unsigned
name|int
name|a
parameter_list|,
name|unsigned
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator||
name|b
operator|)
operator|&
operator|-
operator|(
name|a
operator||
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the assembler directive for creating a given kind of integer    object.  SIZE is the number of bytes in the object and ALIGNED_P    indicates whether it is known to be aligned.  Return NULL if the    assembly dialect has no such directive.     The returned string should be printed at the start of a new line and    be followed immediately by the object's initial value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|integer_asm_op
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
name|struct
name|asm_int_op
modifier|*
name|ops
decl_stmt|;
if|if
condition|(
name|aligned_p
condition|)
name|ops
operator|=
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|aligned_op
expr_stmt|;
else|else
name|ops
operator|=
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|targetm
operator|.
name|asm_out
operator|.
name|byte_op
return|;
case|case
literal|2
case|:
return|return
name|ops
operator|->
name|hi
return|;
case|case
literal|4
case|:
return|return
name|ops
operator|->
name|si
return|;
case|case
literal|8
case|:
return|return
name|ops
operator|->
name|di
return|;
case|case
literal|16
case|:
return|return
name|ops
operator|->
name|ti
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Use directive OP to assemble an integer object X.  Print OP at the    start of the line, followed immediately by the value of X.  */
end_comment

begin_function
name|void
name|assemble_integer_with_op
parameter_list|(
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|fputs
argument_list|(
name|op
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The default implementation of the asm_out.integer target hook.  */
end_comment

begin_function
name|bool
name|default_assemble_integer
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|aligned_p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|op
init|=
name|integer_asm_op
argument_list|(
name|size
argument_list|,
name|aligned_p
argument_list|)
decl_stmt|;
return|return
name|op
operator|&&
operator|(
name|assemble_integer_with_op
argument_list|(
name|op
argument_list|,
name|x
argument_list|)
operator|,
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is    the alignment of the integer in bits.  Return 1 if we were able to output    the constant, otherwise 0.  If FORCE is nonzero, abort if we can't output    the constant.  */
end_comment

begin_function
name|bool
name|assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|int
name|aligned_p
decl_stmt|;
name|aligned_p
operator|=
operator|(
name|align
operator|>=
name|MIN
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|)
expr_stmt|;
comment|/* See if the target hook can handle this kind of object.  */
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|integer
call|)
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If the object is a multi-byte one, try splitting it up.  Split      it into words it if is multi-word, otherwise split it into bytes.  */
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|omode
decl_stmt|,
name|imode
decl_stmt|;
name|unsigned
name|int
name|subalign
decl_stmt|;
name|unsigned
name|int
name|subsize
decl_stmt|,
name|i
decl_stmt|;
name|subsize
operator|=
name|size
operator|>
name|UNITS_PER_WORD
condition|?
name|UNITS_PER_WORD
else|:
literal|1
expr_stmt|;
name|subalign
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|subsize
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|omode
operator|=
name|mode_for_size
argument_list|(
name|subsize
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|subsize
control|)
block|{
name|rtx
name|partial
init|=
name|simplify_subreg
argument_list|(
name|omode
argument_list|,
name|x
argument_list|,
name|imode
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|partial
operator|||
operator|!
name|assemble_integer
argument_list|(
name|partial
argument_list|,
name|subsize
argument_list|,
name|subalign
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|size
condition|)
return|return
name|true
return|;
comment|/* If we've printed some of it, but not all of it, there's no going 	 back now.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|assemble_real
parameter_list|(
name|REAL_VALUE_TYPE
name|d
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|long
name|data
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|nelts
decl_stmt|,
name|nunits
decl_stmt|,
name|units_per
decl_stmt|;
comment|/* This is hairy.  We have a quantity of known size.  real_to_target      will put it into an array of *host* longs, 32 bits per element      (even if long is more than 32 bits).  We need to determine the      number of array elements that are occupied (nelts) and the number      of *target* min-addressable units that will be occupied in the      object file (nunits).  We cannot assume that 32 divides the      mode's bitsize (size * BITS_PER_UNIT) evenly.       size * BITS_PER_UNIT is used here to make sure that padding bits      (which might appear at either end of the value; real_to_target      will include the padding bits in its output array) are included.  */
name|nunits
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|nunits
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|nelts
operator|=
name|CEIL
argument_list|(
name|bitsize
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|units_per
operator|=
literal|32
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|real_to_target
argument_list|(
name|data
argument_list|,
operator|&
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Put out the first word with the specified alignment.  */
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|nunits
argument_list|,
name|units_per
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nunits
operator|-=
name|units_per
expr_stmt|;
comment|/* Subsequent words need only 32-bit alignment.  */
name|align
operator|=
name|min_align
argument_list|(
name|align
argument_list|,
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|nunits
argument_list|,
name|units_per
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nunits
operator|-=
name|units_per
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP with a constant value,    reduce it to the sum of an assembler symbol and an integer.    Store them both in the structure *VALUE.    Abort if EXP does not reduce.  */
end_comment

begin_decl_stmt
name|struct
name|addr_const
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|tree
name|exp
parameter_list|,
name|struct
name|addr_const
modifier|*
name|value
parameter_list|)
block|{
name|tree
name|target
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|host_integerp
argument_list|(
name|byte_position
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|int_byte_position
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|offset
operator|+=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|x
operator|=
name|DECL_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|force_label_rtx
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|INTEGER_CST
case|:
name|x
operator|=
name|output_constant_def
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We do RTX_UNSPEC + XINT (blah), so nothing can go after RTX_UNSPEC.  */
end_comment

begin_enum
enum|enum
name|kind
block|{
name|RTX_UNKNOWN
block|,
name|RTX_DOUBLE
block|,
name|RTX_VECTOR
block|,
name|RTX_INT
block|,
name|RTX_UNSPEC
block|}
enum|;
end_enum

begin_decl_stmt
name|struct
name|rtx_const
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|ENUM_BITFIELD
argument_list|(
argument|kind
argument_list|)
name|kind
label|:
literal|16
expr_stmt|;
name|ENUM_BITFIELD
argument_list|(
argument|machine_mode
argument_list|)
name|mode
label|:
literal|16
expr_stmt|;
union|union
name|rtx_const_un
block|{
name|REAL_VALUE_TYPE
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"4"
argument_list|)
operator|)
argument_list|)
name|du
decl_stmt|;
struct|struct
name|rtx_const_u_addr
block|{
name|rtx
name|base
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"1"
argument_list|)
operator|)
argument_list|)
name|addr
struct|;
struct|struct
name|rtx_const_u_di
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"0"
argument_list|)
operator|)
argument_list|)
name|di
struct|;
comment|/* The max vector size we have is 16 wide; two variants for        integral and floating point vectors.  */
struct|struct
name|rtx_const_int_vec
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"2"
argument_list|)
operator|)
argument_list|)
name|int_vec
index|[
literal|16
index|]
struct|;
name|REAL_VALUE_TYPE
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"3"
argument_list|)
operator|)
argument_list|)
name|fp_vec
index|[
literal|8
index|]
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|desc
argument_list|(
literal|"%1.kind>= RTX_INT"
argument_list|)
operator|,
name|descbits
argument_list|(
literal|"1"
argument_list|)
operator|)
argument_list|)
name|un
union|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Uniquize all constants that appear in memory.    Each constant in memory thus far output is recorded    in `const_desc_table'.  */
end_comment

begin_decl_stmt
name|struct
name|constant_descriptor_tree
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* A MEM for the constant.  */
name|rtx
name|rtl
decl_stmt|;
comment|/* The value of the constant.  */
name|tree
name|value
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct constant_descriptor_tree))
argument_list|)
name|htab_t
name|const_desc_htab
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|constant_descriptor_tree
modifier|*
name|build_constant_desc
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_output_constant_def_contents
parameter_list|(
name|struct
name|constant_descriptor_tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Compute a hash code for a constant expression.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_desc_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|const_hash_1
argument_list|(
operator|(
operator|(
expr|struct
name|constant_descriptor_tree
operator|*
operator|)
name|ptr
operator|)
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|const_hash_1
parameter_list|(
specifier|const
name|tree
name|exp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|hashval_t
name|hi
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Either set P and LEN to the address and len of something to hash and      exit the switch or return a value.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_INT_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
return|return
name|real_hash
argument_list|(
name|TREE_REAL_CST_PTR
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
if|if
condition|(
name|flag_writable_strings
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|exp
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|exp
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|const_hash_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|*
literal|5
operator|+
name|const_hash_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tree
name|link
decl_stmt|;
name|hi
operator|=
literal|5
operator|+
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
name|hi
operator|=
name|hi
operator|*
literal|603
operator|+
name|const_hash_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hi
return|;
block|}
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* Don't hash the address of the SYMBOL_REF; 	       only use the offset and the symbol name.  */
name|hi
operator|=
name|value
operator|.
name|offset
expr_stmt|;
name|p
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|hi
operator|=
name|value
operator|.
name|offset
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|13
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|hi
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
operator|(
name|const_hash_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|9
operator|+
name|const_hash_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|const_hash_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|7
operator|+
literal|2
return|;
default|default:
comment|/* A language specific constant. Just hash the code.  */
return|return
name|code
return|;
block|}
comment|/* Compute hashing function.  */
name|hi
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_comment
comment|/* Wrapper of compare_constant, for the htab interface.  */
end_comment

begin_function
specifier|static
name|int
name|const_desc_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
name|compare_constant
argument_list|(
operator|(
operator|(
expr|struct
name|constant_descriptor_tree
operator|*
operator|)
name|p1
operator|)
operator|->
name|value
argument_list|,
operator|(
operator|(
expr|struct
name|constant_descriptor_tree
operator|*
operator|)
name|p2
operator|)
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare t1 and t2, and return 1 only if they are known to result in    the same bit pattern on output.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant
parameter_list|(
specifier|const
name|tree
name|t1
parameter_list|,
specifier|const
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|typecode
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t2
operator|==
name|NULL_TREE
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* Integer constants are the same only if the same width of type.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|tree_int_cst_equal
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* Real constants are the same only if the same width of type.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
if|if
condition|(
name|flag_writable_strings
condition|)
return|return
name|t1
operator|==
name|t2
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|compare_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REALPART
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
name|compare_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typecode
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|typecode
operator|==
name|SET_TYPE
condition|)
block|{
name|int
name|len
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|len
condition|)
return|return
literal|0
return|;
name|tmp1
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_set_constructor_bytes
argument_list|(
name|t1
argument_list|,
name|tmp1
argument_list|,
name|len
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_set_constructor_bytes
argument_list|(
name|t2
argument_list|,
name|tmp2
argument_list|,
name|len
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
literal|0
return|;
return|return
name|memcmp
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|,
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
block|{
name|tree
name|l1
decl_stmt|,
name|l2
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size_1
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For arrays, check that the sizes all match.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|||
name|size_1
operator|==
operator|-
literal|1
operator|||
name|size_1
operator|!=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* For record and union constructors, require exact type                  equality.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|l1
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|t1
argument_list|)
operator|,
name|l2
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|t2
argument_list|)
init|;
name|l1
operator|&&
name|l2
condition|;
name|l1
operator|=
name|TREE_CHAIN
argument_list|(
name|l1
argument_list|)
operator|,
name|l2
operator|=
name|TREE_CHAIN
argument_list|(
name|l2
argument_list|)
control|)
block|{
comment|/* Check that each value is the same...  */
if|if
condition|(
operator|!
name|compare_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|l1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|l2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... and that they apply to the same fields!  */
if|if
condition|(
name|typecode
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|compare_constant
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|l1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|l2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|l1
argument_list|)
operator|!=
name|TREE_PURPOSE
argument_list|(
name|l2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
name|l1
operator|==
name|NULL_TREE
operator|&&
name|l2
operator|==
name|NULL_TREE
return|;
block|}
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
block|{
name|struct
name|addr_const
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|decode_addr_const
argument_list|(
name|t1
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
name|decode_addr_const
argument_list|(
name|t2
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
return|return
operator|(
name|value1
operator|.
name|offset
operator|==
name|value2
operator|.
name|offset
operator|&&
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|value1
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|value2
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|RANGE_EXPR
case|:
return|return
operator|(
name|compare_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|compare_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|compare_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
block|{
name|tree
name|nt1
decl_stmt|,
name|nt2
decl_stmt|;
name|nt1
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|nt2
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt1
operator|!=
name|t1
operator|||
name|nt2
operator|!=
name|t2
condition|)
return|return
name|compare_constant
argument_list|(
name|nt1
argument_list|,
name|nt2
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
comment|/* Should not get here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of the whole tree structure for a constant.  This    handles the same types of nodes that compare_constant handles.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_constant
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* For ADDR_EXPR, we do not want to copy the decl whose address 	 is requested.  We do want to copy constants though.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|build_complex
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|tree
name|copy
init|=
name|copy_node
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|copy_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tail
decl_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|copy
argument_list|)
operator|=
name|list
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|copy_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|copy_constant
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
default|default:
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|exp
condition|)
return|return
name|copy_constant
argument_list|(
name|t
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_constant_def:    No constant equal to EXP is known to have been output.    Make a constant descriptor to enter EXP in the hash table.    Assign the label number and construct RTL to refer to the    constant's location in memory.    Caller is responsible for updating the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor_tree
modifier|*
name|build_constant_desc
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|rtx
name|symbol
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_writable_strings
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
name|desc
operator|->
name|value
operator|=
name|exp
expr_stmt|;
else|else
name|desc
operator|->
name|value
operator|=
name|copy_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|labelno
operator|=
name|const_labelno
operator|++
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
name|symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
operator|=
name|desc
operator|->
name|value
expr_stmt|;
name|TREE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|rtl
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|rtl
argument_list|,
name|const_alias_set
argument_list|)
expr_stmt|;
comment|/* Set flags or add text to the name to record information, such as      that it is a local symbol.  If the name is changed, the macro      ASM_OUTPUT_LABELREF will have to know how to strip this      information.  This call might invalidate our local variable      SYMBOL; we can't use it afterward.  */
call|(
modifier|*
name|targetm
operator|.
name|encode_section_info
call|)
argument_list|(
name|exp
argument_list|,
name|rtl
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|desc
operator|->
name|rtl
operator|=
name|rtl
expr_stmt|;
return|return
name|desc
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing a reference to constant data in memory    for the constant expression EXP.     If assembler code for such a constant has already been output,    return an rtx to refer to it.    Otherwise, output such a constant in memory    and generate an rtx for it.     If DEFER is nonzero, this constant can be deferred and output only    if referenced in the function after all optimizations.     `const_desc_table' records which constants already have label strings.  */
end_comment

begin_function
name|rtx
name|output_constant_def
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|defer
parameter_list|)
block|{
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
decl_stmt|;
name|struct
name|constant_descriptor_tree
name|key
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Look up EXP in the table of constant descriptors.  If we didn't find      it, create a new one.  */
name|key
operator|.
name|value
operator|=
name|exp
expr_stmt|;
name|loc
operator|=
name|htab_find_slot
argument_list|(
name|const_desc_htab
argument_list|,
operator|&
name|key
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
name|desc
operator|==
literal|0
condition|)
block|{
name|desc
operator|=
name|build_constant_desc
argument_list|(
name|exp
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|desc
expr_stmt|;
block|}
name|maybe_output_constant_def_contents
argument_list|(
name|desc
argument_list|,
name|defer
argument_list|)
expr_stmt|;
return|return
name|desc
operator|->
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_constant_def: Decide whether or not we need to    output the constant DESC now, and if so, do it.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_output_constant_def_contents
parameter_list|(
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
parameter_list|,
name|int
name|defer
parameter_list|)
block|{
name|rtx
name|symbol
init|=
name|XEXP
argument_list|(
name|desc
operator|->
name|rtl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|exp
init|=
name|desc
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* Already output; don't do it again.  */
return|return;
comment|/* The only constants that cannot safely be deferred, assuming the      context allows it, are strings under flag_writable_strings.  */
if|if
condition|(
name|defer
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|STRING_CST
operator|||
operator|!
name|flag_writable_strings
operator|)
condition|)
block|{
comment|/* Increment n_deferred_constants if it exists.  It needs to be at 	 least as large as the number of constants actually referred to 	 by the function.  If it's too small we'll stop looking too early 	 and fail to emit constants; if it's too large we'll only look 	 through the entire function when we could have stopped earlier.  */
if|if
condition|(
name|cfun
condition|)
name|n_deferred_constants
operator|++
expr_stmt|;
return|return;
block|}
name|output_constant_def_contents
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We must output the constant data referred to by SYMBOL; do so.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_def_contents
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
name|tree
name|exp
init|=
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
init|=
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* Make sure any other constants whose addresses appear in EXP      are assigned label numbers.  */
name|int
name|reloc
init|=
name|compute_reloc_for_constant
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|int
name|align
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|output_addressed_constants
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We are no longer deferring this constant.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|exp
argument_list|)
condition|)
name|named_section
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|select_section
call|)
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
name|size
operator|=
name|MAX
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Do any machine/system dependent processing of the constant.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_CONSTANT_NAME
name|ASM_DECLARE_CONSTANT_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the constant.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_CONSTANT_NAME */
comment|/* Output the value of EXP.  */
name|output_constant
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A constant which was deferred in its original location has been    inserted by the RTL inliner into a different function.  The    current function's deferred constant count must be incremented.  */
end_comment

begin_function
name|void
name|notice_rtl_inlining_of_deferred_constant
parameter_list|(
name|void
parameter_list|)
block|{
name|n_deferred_constants
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up EXP in the table of constant descriptors.  Return the rtl    if it has been emitted, else null.  */
end_comment

begin_function
name|rtx
name|lookup_constant_def
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
decl_stmt|;
name|struct
name|constant_descriptor_tree
name|key
decl_stmt|;
name|key
operator|.
name|value
operator|=
name|exp
expr_stmt|;
name|desc
operator|=
name|htab_find
argument_list|(
name|const_desc_htab
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
condition|?
name|desc
operator|->
name|rtl
else|:
name|NULL_RTX
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used in the hash tables to avoid outputting the same constant    twice.  Unlike 'struct constant_descriptor_tree', RTX constants    are output once per function, not once per file; there seems    to be no reason for the difference.  */
end_comment

begin_decl_stmt
name|struct
name|constant_descriptor_rtx
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* More constant_descriptors with the same hash code.  */
name|struct
name|constant_descriptor_rtx
modifier|*
name|next
decl_stmt|;
comment|/* A MEM for the constant.  */
name|rtx
name|rtl
decl_stmt|;
comment|/* The value of the constant.  */
name|struct
name|rtx_const
name|value
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Structure to represent sufficient information about a constant so that    it can be output when the constant pool is output, so that function    integration can be done, and to simplify handling on machines that reference    constant pool as base+displacement.  */
end_comment

begin_decl_stmt
name|struct
name|pool_constant
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|next
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|next_sym
decl_stmt|;
name|rtx
name|constant
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|mark
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.    The argument is XSTR (... , 0)  */
end_comment

begin_define
define|#
directive|define
name|SYMHASH
parameter_list|(
name|LABEL
parameter_list|)
value|(((unsigned long) (LABEL)) % MAX_RTX_HASH_TABLE)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize constant pool hashing for a new function.  */
end_comment

begin_function
name|void
name|init_varasm_status
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|varasm_status
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|varasm_status
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|varasm
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|x_const_rtx_hash_table
operator|=
name|ggc_alloc_cleared
argument_list|(
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|constant_descriptor_rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|x_const_rtx_sym_hash_table
operator|=
name|ggc_alloc_cleared
argument_list|(
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pool_constant
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|x_first_pool
operator|=
name|p
operator|->
name|x_last_pool
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|x_pool_offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|deferred_constants
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Express an rtx for a constant integer (perhaps symbolic)    as the sum of a symbol or label plus an explicit integer.    They are stored into VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|decode_rtx_const
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|struct
name|rtx_const
modifier|*
name|value
parameter_list|)
block|{
comment|/* Clear the whole structure, including any gaps.  */
name|memset
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_const
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|RTX_INT
expr_stmt|;
comment|/* Most usual kind.  */
name|value
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
name|value
operator|->
name|kind
operator|=
name|RTX_DOUBLE
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
init|=
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|value
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Copy the REAL_VALUE_TYPE by members so that we don't 	     copy garbage from the original structure into our 	     carefully cleaned hashing structure.  */
name|value
operator|->
name|un
operator|.
name|du
operator|.
name|class
operator|=
name|r
operator|->
name|class
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|du
operator|.
name|sign
operator|=
name|r
operator|->
name|sign
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
case|case
name|rvc_inf
case|:
break|break;
case|case
name|rvc_normal
case|:
name|value
operator|->
name|un
operator|.
name|du
operator|.
name|exp
operator|=
name|r
operator|->
name|exp
expr_stmt|;
comment|/* Fall through.  */
case|case
name|rvc_nan
case|:
name|memcpy
argument_list|(
name|value
operator|->
name|un
operator|.
name|du
operator|.
name|sig
argument_list|,
name|r
operator|->
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|r
operator|->
name|sig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|->
name|un
operator|.
name|di
operator|.
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|di
operator|.
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_VECTOR
case|:
block|{
name|int
name|units
decl_stmt|,
name|i
decl_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|RTX_VECTOR
expr_stmt|;
name|value
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|elt
init|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|int_vec
index|[
name|i
index|]
operator|.
name|low
operator|=
name|INTVAL
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|int_vec
index|[
name|i
index|]
operator|.
name|high
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|value
operator|->
name|un
operator|.
name|int_vec
index|[
name|i
index|]
operator|.
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|int_vec
index|[
name|i
index|]
operator|.
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
init|=
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|d
init|=
operator|&
name|value
operator|->
name|un
operator|.
name|fp_vec
index|[
name|i
index|]
decl_stmt|;
comment|/* Copy the REAL_VALUE_TYPE by members so that we don't 	           copy garbage from the original structure into our 	           carefully cleaned hashing structure.  */
name|d
operator|->
name|class
operator|=
name|r
operator|->
name|class
expr_stmt|;
name|d
operator|->
name|sign
operator|=
name|r
operator|->
name|sign
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
case|case
name|rvc_inf
case|:
break|break;
case|case
name|rvc_normal
case|:
name|d
operator|->
name|exp
operator|=
name|r
operator|->
name|exp
expr_stmt|;
comment|/* Fall through.  */
case|case
name|rvc_nan
case|:
name|memcpy
argument_list|(
name|d
operator|->
name|sig
argument_list|,
name|r
operator|->
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|r
operator|->
name|sig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|value
operator|->
name|kind
operator|=
name|RTX_UNKNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|->
name|kind
operator|==
name|RTX_INT
operator|&&
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
comment|/* For a simple UNSPEC, the base is set to the 	 operand, the kind field is set to the index of 	 the unspec expression. 	 Together with the code below, in case that 	 the operand is a SYMBOL_REF or LABEL_REF, 	 the address of the string or the code_label 	 is taken as base.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|value
operator|->
name|kind
operator|=
name|RTX_UNSPEC
operator|+
name|XINT
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XVECEXP
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|->
name|kind
operator|>=
name|RTX_INT
operator|&&
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* Use the string's address, not the SYMBOL_REF's address, 	   for the sake of addresses of library routines.  */
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|symbol
operator|=
name|XSTR
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* For a LABEL_REF, compare labels.  */
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a MINUS expression, simplify it if both sides    include the same symbol.  */
end_comment

begin_function
name|rtx
name|simplify_subtraction
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|rtx_const
name|val0
decl_stmt|,
name|val1
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|val0
argument_list|)
expr_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val0
operator|.
name|kind
operator|>=
name|RTX_INT
operator|&&
name|val0
operator|.
name|kind
operator|==
name|val1
operator|.
name|kind
operator|&&
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|base
operator|==
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|base
operator|&&
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|symbol
operator|==
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|symbol
condition|)
return|return
name|GEN_INT
argument_list|(
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
operator|-
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
argument_list|)
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a constant RTL expression.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|const_hash_rtx
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
union|union
block|{
name|struct
name|rtx_const
name|value
decl_stmt|;
name|unsigned
name|int
name|data
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_const
argument_list|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr|]
expr_stmt|;
block|}
name|u
union|;
name|unsigned
name|int
name|hi
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* Compute hashing function.  */
name|hi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|u
operator|.
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
name|hi
operator|=
name|hi
operator|*
literal|613
operator|+
name|u
operator|.
name|data
index|[
name|i
index|]
expr_stmt|;
return|return
name|hi
operator|%
name|MAX_RTX_HASH_TABLE
return|;
block|}
end_function

begin_comment
comment|/* Compare a constant rtl object X with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as X.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant_rtx
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Compare constant contents.  */
return|return
name|memcmp
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|desc
operator|->
name|value
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_const
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Construct a constant descriptor for the rtl-expression X.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor_rtx
modifier|*
name|record_constant_rtx
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|ptr
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant rtx X, make (or find) a memory constant for its value    and return a MEM rtx to refer to it in memory.  */
end_comment

begin_function
name|rtx
name|force_const_mem
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|def
decl_stmt|,
name|symbol
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* If we're not allowed to drop X into the constant pool, don't.  */
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|cannot_force_const_mem
call|)
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Compute hash code of X.  Search the descriptors for that hash code      to see if any of them describes X.  If yes, we have an rtx to use.  */
name|hash
operator|=
name|const_hash_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|desc
argument_list|)
condition|)
return|return
name|copy_rtx
argument_list|(
name|desc
operator|->
name|rtl
argument_list|)
return|;
comment|/* No constant equal to X is known to have been output.      Make a constant descriptor to enter X in the hash table      and make a MEM for it.  */
name|desc
operator|=
name|record_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
operator|==
name|VOIDmode
condition|?
name|word_mode
else|:
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
block|{
name|tree
name|type
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|make_tree
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pool_offset
operator|+=
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|pool_offset
operator|&=
operator|~
operator|(
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|LABEL_PRESERVE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Allocate a pool constant descriptor, fill it in, and chain it in.  */
name|pool
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_constant
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|desc
operator|=
name|desc
expr_stmt|;
name|pool
operator|->
name|constant
operator|=
name|x
expr_stmt|;
name|pool
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|pool
operator|->
name|labelno
operator|=
name|const_labelno
expr_stmt|;
name|pool
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|pool
operator|->
name|offset
operator|=
name|pool_offset
expr_stmt|;
name|pool
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_pool
operator|==
literal|0
condition|)
name|first_pool
operator|=
name|pool
expr_stmt|;
else|else
name|last_pool
operator|->
name|next
operator|=
name|pool
expr_stmt|;
name|last_pool
operator|=
name|pool
expr_stmt|;
name|pool_offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
comment|/* Construct the SYMBOL_REF and the MEM.  */
name|symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|pool
operator|->
name|desc
operator|->
name|rtl
operator|=
name|def
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|def
argument_list|,
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|def
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Add label to symbol hash table.  */
name|hash
operator|=
name|SYMHASH
argument_list|(
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|next_sym
operator|=
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
operator|=
name|pool
expr_stmt|;
comment|/* Mark the symbol_ref as belonging to this constants pool.  */
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|current_function_uses_const_pool
operator|=
literal|1
expr_stmt|;
return|return
name|copy_rtx
argument_list|(
name|def
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to    the corresponding pool_constant structure.  */
end_comment

begin_function
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
init|=
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|f
operator|->
name|varasm
operator|->
name|x_const_rtx_sym_hash_table
index|[
name|SYMHASH
argument_list|(
name|label
argument_list|)
index|]
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next_sym
control|)
if|if
condition|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|pool
operator|->
name|desc
operator|->
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
return|return
name|pool
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */
end_comment

begin_function
name|rtx
name|get_pool_constant
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant    and whether it has been output or not.  */
end_comment

begin_function
name|rtx
name|get_pool_constant_mark
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|bool
modifier|*
name|pmarked
parameter_list|)
block|{
name|struct
name|pool_constant
modifier|*
name|pool
init|=
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|addr
argument_list|)
decl_stmt|;
operator|*
name|pmarked
operator|=
operator|(
name|pool
operator|->
name|mark
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|pool
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but for the constant pool of a specific function.  */
end_comment

begin_function
name|rtx
name|get_pool_constant_for_function
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the mode.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_pool_mode
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|mode
return|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|get_pool_mode_for_function
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the offset in the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_offset
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|addr
argument_list|)
operator|)
operator|->
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|pool_offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write all the constants in the constant pool.  */
end_comment

begin_function
name|void
name|output_constant_pool
parameter_list|(
specifier|const
name|char
modifier|*
name|fnname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
comment|/* It is possible for gcc to call force_const_mem and then to later      discard the instructions which refer to the constant.  In such a      case we do not need to output the constant.  */
name|mark_constant_pool
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_PROLOGUE
name|ASM_OUTPUT_POOL_PROLOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|x
operator|=
name|pool
operator|->
name|constant
expr_stmt|;
if|if
condition|(
operator|!
name|pool
operator|->
name|mark
condition|)
continue|continue;
comment|/* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF) 	 whose CODE_LABEL has been deleted.  This can occur if a jump table 	 is eliminated by optimization.  If so, write a constant of zero 	 instead.  Note that this can also happen by turning the 	 CODE_LABEL into a NOTE.  */
comment|/* ??? This seems completely and utterly wrong.  Certainly it's 	 not true for NOTE_INSN_DELETED_LABEL, but I disbelieve proper 	 functioning even with INSN_DELETED_P and friends.  */
name|tmp
operator|=
name|x
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
break|break;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|LABEL_REF
case|:
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|tmp
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|const0_rtx
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* First switch to correct section.  */
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|select_rtx_section
call|)
argument_list|(
name|pool
operator|->
name|mode
argument_list|,
name|x
argument_list|,
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|pool
operator|->
name|mode
argument_list|,
name|pool
operator|->
name|align
argument_list|,
name|pool
operator|->
name|labelno
argument_list|,
name|done
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assemble_align
argument_list|(
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
comment|/* Output the label.  */
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|pool
operator|->
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of the constant itself.  */
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|r
argument_list|,
name|pool
operator|->
name|mode
argument_list|,
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
name|assemble_integer
argument_list|(
name|x
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
argument_list|,
name|pool
operator|->
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_VECTOR_FLOAT
case|:
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|r
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
argument_list|,
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MODE_VECTOR_INT
case|:
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|elt
argument_list|,
name|GET_MODE_UNIT_SIZE
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
argument_list|,
name|pool
operator|->
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Make sure all constants in SECTION_MERGE and not SECTION_STRINGS 	 sections have proper size.  */
if|if
condition|(
name|pool
operator|->
name|align
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
operator|&&
name|in_section
operator|==
name|in_named
operator|&&
name|get_named_section_flags
argument_list|(
name|in_named_name
argument_list|)
operator|&
name|SECTION_MERGE
condition|)
name|assemble_align
argument_list|(
name|pool
operator|->
name|align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|done
label|:
empty_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_EPILOGUE
name|ASM_OUTPUT_POOL_EPILOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Done with this pool.  */
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the instructions for this function, and mark all the    entries in the constant pool which are actually being used.  Emit    deferred constants which have indeed been used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_constant_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
if|if
condition|(
name|first_pool
operator|==
literal|0
operator|&&
name|n_deferred_constants
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
name|pool
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_function_epilogue_delay_list
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look through appropriate parts of X, marking all entries in the    constant pool which are actually being used.  Entries that are only    referenced by other constants are also marked as used.  Emit    deferred strings that are used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_constants
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|mark_constant
argument_list|(
operator|&
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Insns may appear inside a SEQUENCE.  Only check the patterns of      insns, not any notes that may be attached.  We don't want to mark      a constant just because it happens to appear in a REG_EQUIV note.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|mark_constants
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|mark_constants
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_constants
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
case|case
literal|'0'
case|:
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'n'
case|:
case|case
literal|'u'
case|:
case|case
literal|'B'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers    to as used.  Emit referenced deferred strings.  This function can    be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */
end_comment

begin_function
specifier|static
name|int
name|mark_constant
parameter_list|(
name|rtx
modifier|*
name|current_rtx
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|current_rtx
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|struct
name|pool_constant
modifier|*
name|pool
init|=
name|find_pool_constant
argument_list|(
name|cfun
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|->
name|mark
operator|==
literal|0
condition|)
block|{
name|pool
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
operator|(
name|pool
operator|->
name|constant
operator|)
argument_list|,
operator|&
name|mark_constant
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tree
name|exp
init|=
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|n_deferred_constants
operator|--
expr_stmt|;
name|output_constant_def_contents
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine what kind of relocations EXP may need.  */
end_comment

begin_function
name|int
name|compute_reloc_for_constant
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|int
name|reloc
init|=
literal|0
decl_stmt|,
name|reloc2
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|exp
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
comment|/* Go inside any operations that get_inner_reference can handle and see 	 if what's inside is a constant: no need to do anything here for 	 addresses of variables or functions.  */
for|for
control|(
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
condition|)
name|reloc
operator||=
literal|2
expr_stmt|;
else|else
name|reloc
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator||=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reloc2
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The difference of two local labels is computable at link time.  */
if|if
condition|(
name|reloc
operator|==
literal|1
operator|&&
name|reloc2
operator|==
literal|1
condition|)
name|reloc
operator|=
literal|0
expr_stmt|;
else|else
name|reloc
operator||=
name|reloc2
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
for|for
control|(
name|tem
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|reloc
operator||=
name|compute_reloc_for_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Find all the constants whose addresses are referenced inside of EXP,    and make sure assembler code with a label has been output for each one.    Indicate whether an ADDR_EXPR has been encountered.  */
end_comment

begin_function
specifier|static
name|void
name|output_addressed_constants
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|exp
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
comment|/* Go inside any operations that get_inner_reference can handle and see 	 if what's inside is a constant: no need to do anything here for 	 addresses of variables or functions.  */
for|for
control|(
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constant_def
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
for|for
control|(
name|tem
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|output_addressed_constants
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if VALUE is a valid constant-valued expression    for use in initializing a static variable; one that can be an    element of a "constant" initializer.     Return null_pointer_node if the value is absolute;    if it is relocatable, return the variable that determines the relocation.    We assume that VALUE has been folded as much as possible;    therefore, we do not need to check for such things as    arithmetic-combinations of integers.  */
end_comment

begin_function
name|tree
name|initializer_constant_valid_p
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|endtype
parameter_list|)
block|{
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|value
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|tree
name|elt
decl_stmt|;
name|bool
name|absolute
init|=
name|true
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|tree
name|reloc
decl_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|reloc
operator|!=
name|null_pointer_node
condition|)
name|absolute
operator|=
name|false
expr_stmt|;
block|}
comment|/* For a non-absolute relocation, there is no single 	     variable that can be "the variable that determines the 	     relocation."  */
return|return
name|absolute
condition|?
name|null_pointer_node
else|:
name|error_mark_node
return|;
block|}
return|return
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|?
name|null_pointer_node
else|:
name|NULL_TREE
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
return|return
name|null_pointer_node
return|;
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
return|return
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
else|:
literal|0
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Allow conversions between pointer types.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between real types.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow length-preserving conversions between integer types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between other integer types only if 	 explicit value.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|null_pointer_node
condition|)
return|return
name|null_pointer_node
return|;
break|break;
block|}
comment|/* Allow (int)&foo provided int is as wide as a pointer.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Likewise conversions from int to pointers, but also allow 	 conversions from 0.  */
if|if
condition|(
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
block|}
comment|/* Allow conversions to struct or union types if the value 	 inside is okay.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|>=
name|POINTER_SIZE
condition|)
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* If either term is absolute, use the other terms relocation.  */
if|if
condition|(
name|valid0
operator|==
name|null_pointer_node
condition|)
return|return
name|valid1
return|;
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
block|}
break|break;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|>=
name|POINTER_SIZE
condition|)
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* Win if second argument is absolute.  */
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
comment|/* Win if both arguments have the same relocation. 	     Then the value is absolute.  */
if|if
condition|(
name|valid0
operator|==
name|valid1
operator|&&
name|valid0
operator|!=
literal|0
condition|)
return|return
name|null_pointer_node
return|;
comment|/* Since GCC guarantees that string constants are unique in the 	     generated code, a subtraction between two copies of the same 	     constant string is absolute.  */
if|if
condition|(
name|valid0
operator|&&
name|TREE_CODE
argument_list|(
name|valid0
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|valid1
operator|&&
name|TREE_CODE
argument_list|(
name|valid1
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_STRING_POINTER
argument_list|(
name|valid0
argument_list|)
operator|==
name|TREE_STRING_POINTER
argument_list|(
name|valid1
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
block|}
comment|/* Support differences between labels.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
condition|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Like STRIP_NOPS except allow the operand mode to widen. 	     This works around a feature of fold that simplifies 	     (int)(p1 - p2) to ((int)p1 - (int)p2) under the theory 	     that the narrower operation is cheaper.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|error_mark_node
operator|||
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|op0
operator|=
name|inner
expr_stmt|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|error_mark_node
operator|||
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|op1
operator|=
name|inner
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
return|return
name|null_pointer_node
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for constant EXP to FILE, with no label.    This includes the pseudo-op such as ".int" or ".byte", and a newline.    Assumes output_addressed_constants has been done on EXP already.     Generate exactly SIZE bytes of assembler data, padding at the end    with zeros if necessary.  SIZE must always be specified.     SIZE is important for structure constructors,    since trailing members may have been omitted from the constructor.    It is also important for initialization of arrays from string constants    since the full length of the string constant might not be wanted.    It is also needed for initialization of unions, where the initializer's    type is just one member, and that may not be as long as the union.     There a case in which we would fail to output exactly SIZE bytes:    for a structure constructor that wants to produce more than SIZE bytes.    But such constructors will never be generated for any possible input.     ALIGN is the alignment of the data in bits.  */
end_comment

begin_function
name|void
name|output_constant
parameter_list|(
name|tree
name|exp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|thissize
decl_stmt|;
comment|/* Some front-ends use constants other than the standard language-independent      varieties, but which may still be output directly.  Give the front-end a      chance to convert EXP to a language-independent representation.  */
name|exp
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|expand_constant
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|flag_syntax_only
condition|)
return|return;
comment|/* Eliminate any conversions since we'll be outputting the underlying      constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|thissize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow a constructor with no elements for any data type.      This means to fill the space with zeros.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FDESC_EXPR
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FDESC
name|HOST_WIDE_INT
name|part
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_FDESC
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|part
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Now output the underlying data.  If we've handling the padding, return.      Otherwise, break and ensure THISSIZE is the size written.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
operator|!
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"initializer for integer value is too complicated"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|REAL_CST
condition|)
name|error
argument_list|(
literal|"initializer for floating value is not a floating constant"
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|output_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
operator|/
literal|2
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
operator|/
literal|2
argument_list|,
name|min_align
argument_list|(
name|align
argument_list|,
name|BITS_PER_UNIT
operator|*
operator|(
name|thissize
operator|/
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|thissize
operator|=
name|MIN
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VECTOR_CST
condition|)
block|{
name|int
name|elt_size
decl_stmt|;
name|tree
name|link
decl_stmt|;
name|unsigned
name|int
name|nalign
decl_stmt|;
name|enum
name|machine_mode
name|inner
decl_stmt|;
name|inner
operator|=
name|GET_MODE_INNER
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nalign
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|elt_size
operator|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|elt_size
argument_list|,
name|align
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|output_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|elt_size
argument_list|,
name|nalign
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
name|SET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|thissize
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
name|alloca
argument_list|(
name|thissize
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_set_constructor_bytes
argument_list|(
name|exp
argument_list|,
name|buffer
argument_list|,
name|thissize
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|assemble_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"unknown set constructor type"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR_MARK
case|:
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|thissize
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|thissize
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_constructor, used for computing the size of    arrays of unspecified length.  VAL must be a CONSTRUCTOR of an array    type with an unspecified upper bound.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|array_size_for_constructor
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
name|tree
name|max_index
decl_stmt|,
name|i
decl_stmt|;
comment|/* This code used to attempt to handle string constants that are not      arrays of single-bytes, but nothing else does, so there's no point in      doing it here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|val
argument_list|)
return|;
name|max_index
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|val
argument_list|)
init|;
name|i
condition|;
name|i
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
control|)
block|{
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
name|index
operator|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_index
operator|==
name|NULL_TREE
operator|||
name|tree_int_cst_lt
argument_list|(
name|max_index
argument_list|,
name|index
argument_list|)
condition|)
name|max_index
operator|=
name|index
expr_stmt|;
block|}
if|if
condition|(
name|max_index
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Compute the total number of array elements.  */
name|i
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|max_index
argument_list|)
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Multiply by the array element unit size to find number of bytes.  */
name|i
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tree_low_cst
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).    Generate at least SIZE bytes, padding if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|output_constructor
parameter_list|(
name|tree
name|exp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|link
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|;
name|tree
name|min_index
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes output or skipped so far.      In other words, current position within the constructor.  */
name|HOST_WIDE_INT
name|total_bytes
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means BYTE contains part of a byte, to be output.  */
name|int
name|byte_buffer_in_use
init|=
literal|0
decl_stmt|;
name|int
name|byte
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|min_index
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As LINK goes through the elements of the constant,      FIELD goes through the structure fields, if the constant is a structure.      if the constant is a union, then we override this,      by getting the field from the TREE_LIST element.      But the constant could also be an array.  Then FIELD is zero.       There is always a maximum of one element in the chain LINK for unions      (even if the initializer in a source program incorrectly contains      more one).  */
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|field
operator|=
name|field
condition|?
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
else|:
literal|0
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
literal|0
decl_stmt|;
comment|/* The element in a union constructor specifies the proper field 	 or index.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|index
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_COMMENT_START
if|if
condition|(
name|field
operator|&&
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s %s:\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
else|:
literal|"<anonymous>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Eliminate the marker that makes a cast not be an lvalue.  */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|STRIP_NOPS
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lo_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|hi_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|index
decl_stmt|;
name|unsigned
name|int
name|align2
init|=
name|min_align
argument_list|(
name|align
argument_list|,
name|fieldsize
operator|*
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
for|for
control|(
name|index
operator|=
name|lo_index
init|;
name|index
operator|<=
name|hi_index
condition|;
name|index
operator|++
control|)
block|{
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|,
name|align2
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|==
literal|0
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* An element that is not a bit-field.  */
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
decl_stmt|;
comment|/* Since this structure is static, 	     we know the positions are constant.  */
name|HOST_WIDE_INT
name|pos
init|=
name|field
condition|?
name|int_byte_position
argument_list|(
name|field
argument_list|)
else|:
literal|0
decl_stmt|;
name|unsigned
name|int
name|align2
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|pos
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
operator|(
name|tree_low_cst
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|min_index
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Output any buffered-up bit-fields preceding this element.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Advance to offset of this element. 	     Note no alignment needed in an array, since that is guaranteed 	     if each element has the proper size.  */
if|if
condition|(
operator|(
name|field
operator|!=
literal|0
operator|||
name|index
operator|!=
literal|0
operator|)
operator|&&
name|pos
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_zeros
argument_list|(
name|pos
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|pos
expr_stmt|;
block|}
comment|/* Find the alignment of this element.  */
name|align2
operator|=
name|min_align
argument_list|(
name|align
argument_list|,
name|BITS_PER_UNIT
operator|*
name|pos
argument_list|)
expr_stmt|;
comment|/* Determine size this element should occupy.  */
if|if
condition|(
name|field
condition|)
block|{
name|fieldsize
operator|=
literal|0
expr_stmt|;
comment|/* If this is an array with an unspecified upper bound, 		 the initializer determines the size.  */
comment|/* ??? This ought to only checked if DECL_SIZE_UNIT is NULL, 		 but we cannot do this until the deprecated support for 		 initializing zero-length array members is removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|fieldsize
operator|=
name|array_size_for_constructor
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Given a non-empty initialization, this field had 		     better be last.  */
if|if
condition|(
name|fieldsize
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* ??? This can't be right.  If the decl size overflows 		     a host integer we will silently emit no data.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|fieldsize
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fieldsize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|,
name|align2
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid initial value for member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Element that is a bit-field.  */
name|HOST_WIDE_INT
name|next_offset
init|=
name|int_bit_position
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|end_offset
init|=
operator|(
name|next_offset
operator|+
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* If this field does not start in this (or, next) byte, 	     skip some bytes.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
comment|/* Output remnant of any bit field in previous bytes.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still not at proper byte, advance to there.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_zeros
argument_list|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|next_offset
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|byte_buffer_in_use
condition|)
name|byte
operator|=
literal|0
expr_stmt|;
comment|/* We must split the element into pieces that fall within 	     separate bytes, and combine each byte with previous or 	     following bit-fields.  */
comment|/* next_offset is the offset n fbits from the beginning of 	     the structure to the next bit of this element to be processed. 	     end_offset is the offset of the first bit past the end of 	     this element.  */
while|while
condition|(
name|next_offset
operator|<
name|end_offset
condition|)
block|{
name|int
name|this_time
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|HOST_WIDE_INT
name|next_byte
init|=
name|next_offset
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|next_bit
init|=
name|next_offset
operator|%
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Advance from byte to byte 		 within this element when necessary.  */
while|while
condition|(
name|next_byte
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Number of bits we can process at once 		 (all part of the same byte).  */
name|this_time
operator|=
name|MIN
argument_list|(
name|end_offset
operator|-
name|next_offset
argument_list|,
name|BITS_PER_UNIT
operator|-
name|next_bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* On big-endian machine, take the most significant bits 		     first (of the bits that are significant) 		     and put them into bytes from the most significant end.  */
name|shift
operator|=
name|end_offset
operator|-
name|next_offset
operator|-
name|this_time
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST. We can 		     only select bits from the LOW or HIGH part 		     not from both.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|this_time
operator|=
name|shift
operator|+
name|this_time
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the result. This works only when: 		     1<= this_time<= HOST_BITS_PER_WIDE_INT.  */
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|this_time
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|BITS_PER_UNIT
operator|-
name|this_time
operator|-
name|next_bit
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* On little-endian machines, 		     take first the least significant bits of the value 		     and pack them starting at the least significant 		     bits of the bytes.  */
name|shift
operator|=
name|next_offset
operator|-
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST. We can 		     only select bits from the LOW or HIGH part 		     not from both.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|this_time
operator|=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|shift
operator|)
expr_stmt|;
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the result. This works only when: 		     1<= this_time<= HOST_BITS_PER_WIDE_INT.  */
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|this_time
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|next_bit
operator|)
expr_stmt|;
block|}
name|next_offset
operator|+=
name|this_time
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|total_bytes
operator|<
name|size
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This TREE_LIST contains any weak symbol declarations waiting    to be emitted.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|weak_decls
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Mark DECL as weak.  */
end_comment

begin_function
specifier|static
name|void
name|mark_weak
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|SYMBOL_REF_WEAK
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge weak status between NEWDECL and OLDDECL.  */
end_comment

begin_function
name|void
name|merge_weak
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_WEAK
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|tree
name|wd
decl_stmt|;
comment|/* NEWDECL is weak, but OLDDECL is not.  */
comment|/* If we already output the OLDDECL, we're in trouble; we can't 	 go back and make it weak.  This error cannot caught in 	 declare_weak because the NEWDECL and OLDDECL was not yet 	 been merged; therefore, TREE_ASM_WRITTEN was not set.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jweak declaration of '%D' must precede definition"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If we've already generated rtl referencing OLDDECL, we may 	 have done so in a way that will not function properly with 	 a weak symbol.  */
elseif|else
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jweak declaration of '%D' after first use results "
literal|"in unspecified behavior"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
block|{
comment|/* We put the NEWDECL on the weak_decls list at some point. 	     Replace it with the OLDDECL.  */
for|for
control|(
name|wd
operator|=
name|weak_decls
init|;
name|wd
condition|;
name|wd
operator|=
name|TREE_CHAIN
argument_list|(
name|wd
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|wd
argument_list|)
operator|==
name|newdecl
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|wd
argument_list|)
operator|=
name|olddecl
expr_stmt|;
break|break;
block|}
comment|/* We may not find the entry on the list.  If NEWDECL is a 	     weak alias, then we will have already called 	     globalize_decl to remove the entry; in that case, we do 	     not need to do anything.  */
block|}
comment|/* Make the OLDDECL weak; it's OLDDECL that we'll be keeping.  */
name|mark_weak
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* OLDDECL was weak, but NEWDECL was not explicitly marked as        weak.  Just update NEWDECL to indicate that it's weak too.  */
name|mark_weak
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declare DECL to be a weak symbol.  */
end_comment

begin_function
name|void
name|declare_weak
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jweak declaration of '%D' must be public"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jweak declaration of '%D' must precede definition"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|weak_decls
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|decl
argument_list|,
name|weak_decls
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"%Jweak declaration of '%D' not supported"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|mark_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit any pending weak declarations.  */
end_comment

begin_function
name|void
name|weak_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|weak_decls
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ASM_WEAKEN_DECL
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_WEAKEN_LABEL
argument_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|ASM_WEAKEN_DECL
name|ASM_WEAKEN_DECL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_WEAK_ALIAS
name|warning
argument_list|(
literal|"only weak aliases are supported in this configuration"
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Emit the assembly bits to indicate that DECL is globally visible.  */
end_comment

begin_function
specifier|static
name|void
name|globalize_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ASM_WEAKEN_LABEL
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_WEAKEN_DECL
argument_list|)
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_WEAKEN_DECL
name|ASM_WEAKEN_DECL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove this function from the pending weak list so that 	 we do not emit multiple .weak directives for it.  */
for|for
control|(
name|p
operator|=
operator|&
name|weak_decls
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an assembler directive to make the symbol for DECL an alias to    the symbol for TARGET.  */
end_comment

begin_function
name|void
name|assemble_alias
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|target
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* We must force creation of DECL_RTL for debug info generation, even though      we don't use it here.  */
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
comment|/* Make name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|globalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|maybe_assemble_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF_FROM_DECLS
name|ASM_OUTPUT_DEF_FROM_DECLS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !ASM_OUTPUT_DEF */
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_WEAKEN_DECL
argument_list|)
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_WEAKEN_DECL
name|ASM_WEAKEN_DECL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove this function from the pending weak list so that 	 we do not emit multiple .weak directives for it.  */
for|for
control|(
name|p
operator|=
operator|&
name|weak_decls
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
control|)
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"only weak aliases are supported in this configuration"
argument_list|)
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"alias definitions not supported in this configuration; ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an assembler directive to set symbol for DECL visibility to    the visibility type VIS, which must not be VISIBILITY_DEFAULT.  */
end_comment

begin_function
name|void
name|default_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|vis
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|visibility_types
index|[]
init|=
block|{
name|NULL
block|,
literal|"internal"
block|,
literal|"hidden"
block|,
literal|"protected"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|name
operator|=
operator|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|visibility_types
index|[
name|vis
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.%s\t"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"visibility attribute not supported in this configuration; ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A helper function to call assemble_visibility when needed for a decl.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|enum
name|symbol_visibility
name|vis
init|=
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|vis
operator|!=
name|VISIBILITY_DEFAULT
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|visibility
call|)
argument_list|(
name|decl
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the target configuration supports defining public symbols    so that one of them will be chosen at link time instead of generating a    multiply-defined symbol error, whether through the use of weak symbols or    a target-specific mechanism for having duplicates discarded.  */
end_comment

begin_function
name|int
name|supports_one_only
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
return|return
literal|1
return|;
return|return
name|SUPPORTS_WEAK
return|;
block|}
end_function

begin_comment
comment|/* Set up DECL as a public symbol that can be defined in multiple    translation units without generating a linker error.  */
end_comment

begin_function
name|void
name|make_decl_one_only
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
block|{
ifdef|#
directive|ifdef
name|MAKE_DECL_ONE_ONLY
name|MAKE_DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_varasm_once
parameter_list|(
name|void
parameter_list|)
block|{
name|in_named_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|in_named_entry_hash
argument_list|,
name|in_named_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|const_desc_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|1009
argument_list|,
name|const_desc_hash
argument_list|,
name|const_desc_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|const_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|tls_model
name|decl_tls_model
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|enum
name|tls_model
name|kind
decl_stmt|;
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"tls_model"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|is_local
decl_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|attr
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|attr
argument_list|)
operator|!=
name|STRING_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|attr
argument_list|)
argument_list|,
literal|"local-exec"
argument_list|)
condition|)
name|kind
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|attr
argument_list|)
argument_list|,
literal|"initial-exec"
argument_list|)
condition|)
name|kind
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|attr
argument_list|)
argument_list|,
literal|"local-dynamic"
argument_list|)
condition|)
name|kind
operator|=
name|optimize
condition|?
name|TLS_MODEL_LOCAL_DYNAMIC
else|:
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|attr
argument_list|)
argument_list|,
literal|"global-dynamic"
argument_list|)
condition|)
name|kind
operator|=
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|kind
return|;
block|}
name|is_local
operator|=
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
if|if
condition|(
name|is_local
condition|)
name|kind
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
else|else
name|kind
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
block|}
comment|/* Local dynamic is inefficient when we're not combining the      parts of the address.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|is_local
condition|)
name|kind
operator|=
name|TLS_MODEL_LOCAL_DYNAMIC
expr_stmt|;
else|else
name|kind
operator|=
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
if|if
condition|(
name|kind
operator|<
name|flag_tls_default
condition|)
name|kind
operator|=
name|flag_tls_default
expr_stmt|;
return|return
name|kind
return|;
block|}
end_function

begin_comment
comment|/* Select a set of attributes for section NAME based on the properties    of DECL and whether or not RELOC indicates that DECL's initializer    might contain runtime relocations.     We make the section read-only and executable for a function decl,    read-only for a const data decl, and writable for a non-const data decl.  */
end_comment

begin_function
name|unsigned
name|int
name|default_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
return|return
name|default_section_type_flags_1
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|,
name|flag_pic
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|default_section_type_flags_1
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|,
name|int
name|shlib
parameter_list|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|&&
name|decl_readonly_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|shlib
argument_list|)
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_LINKONCE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_TLS
operator||
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".bss."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.b."
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.sb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.tb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SECTION_BSS
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.td."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.tb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SECTION_TLS
expr_stmt|;
comment|/* These three sections have special ELF types.  They are neither      SHT_PROGBITS nor SHT_NOBITS, so when changing sections we don't      want to print a section type (@progbits or @nobits).  If someone      is silly enough to emit code or TLS variables to one of these      sections, then don't handle them specially.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|SECTION_CODE
operator||
name|SECTION_BSS
operator||
name|SECTION_TLS
operator|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init_array"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini_array"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".preinit_array"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|flags
operator||=
name|SECTION_NOTYPE
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Output assembly to switch to section NAME with attribute FLAGS.    Four variants for common object file formats.  */
end_comment

begin_function
name|void
name|default_no_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Some object formats don't support named sections at all.  The      front-end should already have flagged this as an error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_elf_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|char
name|flagchars
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
operator|!
name|named_section_first_declaration
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_DEBUG
operator|)
condition|)
operator|*
name|f
operator|++
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_SMALL
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_MERGE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_STRINGS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_TLS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\""
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_NOTYPE
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_BSS
condition|)
name|type
operator|=
literal|"nobits"
expr_stmt|;
else|else
name|type
operator|=
literal|"progbits"
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",@%s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_ENTSIZE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",%d"
argument_list|,
name|flags
operator|&
name|SECTION_ENTSIZE
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_coff_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|char
name|flagchars
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\"\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_pe_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|default_coff_asm_named_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_LINKONCE
condition|)
block|{
comment|/* Functions may have been compiled at various levels of          optimization so we can't use `same_size' here.          Instead, have the linker pick one.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.linkonce %s\n"
argument_list|,
operator|(
name|flags
operator|&
name|SECTION_CODE
condition|?
literal|"discard"
else|:
literal|"same_size"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The lame default section selector.  */
end_comment

begin_function
name|void
name|default_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bool
name|readonly
init|=
name|false
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|readonly
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
operator|||
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|readonly
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|readonly
operator|=
operator|!
name|flag_writable_strings
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
name|readonly
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|readonly
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A helper function for default_elf_select_section and    default_elf_unique_section.  Categorizes the DECL.  */
end_comment

begin_enum
enum|enum
name|section_category
block|{
name|SECCAT_TEXT
block|,
name|SECCAT_RODATA
block|,
name|SECCAT_RODATA_MERGE_STR
block|,
name|SECCAT_RODATA_MERGE_STR_INIT
block|,
name|SECCAT_RODATA_MERGE_CONST
block|,
name|SECCAT_SRODATA
block|,
name|SECCAT_DATA
block|,
comment|/* To optimize loading of shared programs, define following subsections      of data section: 	_REL	Contains data that has relocations, so they get grouped 		together and dynamic linker will visit fewer pages in memory. 	_RO	Contains data that is otherwise read-only.  This is useful 		with prelinking as most relocations won't be dynamically 		linked and thus stay read only. 	_LOCAL	Marks data containing relocations only to local objects. 		These relocations will get fully resolved by prelinking.  */
name|SECCAT_DATA_REL
block|,
name|SECCAT_DATA_REL_LOCAL
block|,
name|SECCAT_DATA_REL_RO
block|,
name|SECCAT_DATA_REL_RO_LOCAL
block|,
name|SECCAT_SDATA
block|,
name|SECCAT_TDATA
block|,
name|SECCAT_BSS
block|,
name|SECCAT_SBSS
block|,
name|SECCAT_TBSS
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|enum
name|section_category
name|categorize_decl_for_section
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|enum
name|section_category
name|categorize_decl_for_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|int
name|shlib
parameter_list|)
block|{
name|enum
name|section_category
name|ret
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|SECCAT_TEXT
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|flag_writable_strings
condition|)
return|return
name|SECCAT_DATA
return|;
else|else
return|return
name|SECCAT_RODATA_MERGE_STR
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|ret
operator|=
name|SECCAT_BSS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|shlib
operator|&&
operator|(
name|reloc
operator|&
literal|2
operator|)
condition|)
name|ret
operator|=
name|SECCAT_DATA_REL
expr_stmt|;
elseif|else
if|if
condition|(
name|shlib
operator|&&
name|reloc
condition|)
name|ret
operator|=
name|SECCAT_DATA_REL_LOCAL
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shlib
operator|&&
operator|(
name|reloc
operator|&
literal|2
operator|)
condition|)
name|ret
operator|=
name|SECCAT_DATA_REL_RO
expr_stmt|;
elseif|else
if|if
condition|(
name|shlib
operator|&&
name|reloc
condition|)
name|ret
operator|=
name|SECCAT_DATA_REL_RO_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc
operator|||
name|flag_merge_constants
operator|<
literal|2
condition|)
comment|/* C and C++ don't allow different variables to share the same 	   location.  -fmerge-all-constants allows even that (at the 	   expense of not conforming).  */
name|ret
operator|=
name|SECCAT_RODATA
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
name|ret
operator|=
name|SECCAT_RODATA_MERGE_STR_INIT
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_RODATA_MERGE_CONST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
operator|(
name|shlib
operator|&&
name|reloc
operator|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
condition|)
name|ret
operator|=
name|SECCAT_DATA
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_RODATA
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|SECCAT_RODATA
expr_stmt|;
comment|/* There are no read-only thread-local sections.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|SECCAT_BSS
condition|)
name|ret
operator|=
name|SECCAT_TBSS
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_TDATA
expr_stmt|;
block|}
comment|/* If the target uses small data sections, select it.  */
elseif|else
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|in_small_data_p
call|)
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|SECCAT_BSS
condition|)
name|ret
operator|=
name|SECCAT_SBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|targetm
operator|.
name|have_srodata_section
operator|&&
name|ret
operator|==
name|SECCAT_RODATA
condition|)
name|ret
operator|=
name|SECCAT_SRODATA
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_SDATA
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|decl_readonly_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
return|return
name|decl_readonly_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|flag_pic
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|decl_readonly_section_1
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|int
name|shlib
parameter_list|)
block|{
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|shlib
argument_list|)
condition|)
block|{
case|case
name|SECCAT_RODATA
case|:
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
case|case
name|SECCAT_SRODATA
case|:
return|return
name|true
return|;
break|break;
default|default:
return|return
name|false
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Select a section based on the above categorization.  */
end_comment

begin_function
name|void
name|default_elf_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
name|default_elf_select_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|align
argument_list|,
name|flag_pic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_elf_select_section_1
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|,
name|int
name|shlib
parameter_list|)
block|{
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|shlib
argument_list|)
condition|)
block|{
case|case
name|SECCAT_TEXT
case|:
comment|/* We're not supposed to be called on FUNCTION_DECLs.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|SECCAT_RODATA
case|:
name|readonly_data_section
argument_list|()
expr_stmt|;
break|break;
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
name|mergeable_string_section
argument_list|(
name|decl
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
name|mergeable_string_section
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
name|mergeable_constant_section
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_SRODATA
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".sdata2"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA
case|:
name|data_section
argument_list|()
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".data.rel"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_LOCAL
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".data.rel.local"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".data.rel.ro"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO_LOCAL
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".data.rel.ro.local"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_SDATA
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".sdata"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_TDATA
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".tdata"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_BSS
case|:
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
name|bss_section
argument_list|()
expr_stmt|;
else|#
directive|else
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".bss"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SECCAT_SBSS
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".sbss"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECCAT_TBSS
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".tbss"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Construct a unique section name based on the decl name and the    categorization performed above.  */
end_comment

begin_function
name|void
name|default_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|default_unique_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|flag_pic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_unique_section_1
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|int
name|shlib
parameter_list|)
block|{
name|bool
name|one_only
init|=
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|size_t
name|nlen
decl_stmt|,
name|plen
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|shlib
argument_list|)
condition|)
block|{
case|case
name|SECCAT_TEXT
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.t."
else|:
literal|".text."
expr_stmt|;
break|break;
case|case
name|SECCAT_RODATA
case|:
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.r."
else|:
literal|".rodata."
expr_stmt|;
break|break;
case|case
name|SECCAT_SRODATA
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.s2."
else|:
literal|".sdata2."
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA
case|:
case|case
name|SECCAT_DATA_REL
case|:
case|case
name|SECCAT_DATA_REL_LOCAL
case|:
case|case
name|SECCAT_DATA_REL_RO
case|:
case|case
name|SECCAT_DATA_REL_RO_LOCAL
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.d."
else|:
literal|".data."
expr_stmt|;
break|break;
case|case
name|SECCAT_SDATA
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.s."
else|:
literal|".sdata."
expr_stmt|;
break|break;
case|case
name|SECCAT_BSS
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.b."
else|:
literal|".bss."
expr_stmt|;
break|break;
case|case
name|SECCAT_SBSS
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.sb."
else|:
literal|".sbss."
expr_stmt|;
break|break;
case|case
name|SECCAT_TDATA
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.td."
else|:
literal|".tdata."
expr_stmt|;
break|break;
case|case
name|SECCAT_TBSS
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.tb."
else|:
literal|".tbss."
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|plen
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|nlen
operator|+
name|plen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|string
argument_list|,
name|prefix
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|string
operator|+
name|plen
argument_list|,
name|name
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|nlen
operator|+
name|plen
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|flag_pic
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
name|data_section
argument_list|()
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|readonly_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_elf_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
comment|/* ??? Handle small data here somehow.  */
if|if
condition|(
name|flag_pic
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".data.rel.ro"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".data.rel.ro.local"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|mergeable_constant_section
argument_list|(
name|mode
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the generally applicable flags on the SYMBOL_REF for EXP.  */
end_comment

begin_function
name|void
name|default_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|symbol
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Careful not to prod global register variables.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|symbol
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|symbol
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_FUNCTION
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|in_small_data_p
call|)
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_SMALL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|decl_tls_model
argument_list|(
name|decl
argument_list|)
operator|<<
name|SYMBOL_FLAG_TLS_SHIFT
expr_stmt|;
comment|/* ??? Why is DECL_EXTERNAL ever set for non-PUBLIC names?  Without      being PUBLIC, the thing *must* be defined in this translation unit.      Prevent this buglet from being propagated into rtl code as well.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_EXTERNAL
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/* By default, we do nothing for encode_section_info, so we need not    do anything but discard the '*' marker.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|default_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|str
operator|+
operator|(
operator|*
name|str
operator|==
literal|'*'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assume ELF-ish defaults, since that's pretty much the most liberal    wrt cross-module name binding.  */
end_comment

begin_function
name|bool
name|default_binds_local_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
return|return
name|default_binds_local_p_1
argument_list|(
name|exp
argument_list|,
name|flag_shlib
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|default_binds_local_p_1
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|shlib
parameter_list|)
block|{
name|bool
name|local_p
decl_stmt|;
comment|/* A non-decl is an entry in the constant pool.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* Static variables are always local.  */
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* A variable is local if the user tells us so.  */
elseif|else
if|if
condition|(
name|DECL_VISIBILITY
argument_list|(
name|exp
argument_list|)
operator|!=
name|VISIBILITY_DEFAULT
condition|)
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* Otherwise, variables defined outside this object may not be local.  */
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* Linkonce and weak data are never local.  */
elseif|else
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_WEAK
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* If PIC, then assume that any global name can be overridden by      symbols resolved from other modules.  */
elseif|else
if|if
condition|(
name|shlib
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* Uninitialized COMMON variable may be unified with symbols      resolved from other modules.  */
elseif|else
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL
operator|||
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* Otherwise we're left with initialized (or non-common) global data      which is of necessity defined locally.  */
else|else
name|local_p
operator|=
name|true
expr_stmt|;
return|return
name|local_p
return|;
block|}
end_function

begin_comment
comment|/* Determine whether or not a pointer mode is valid. Assume defaults    of ptr_mode or Pmode - can be overridden.  */
end_comment

begin_function
name|bool
name|default_valid_pointer_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|mode
operator|==
name|ptr_mode
operator|||
name|mode
operator|==
name|Pmode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Default function to output code that will globalize a label.  A    target must define GLOBAL_ASM_OP or provide it's own function to    globalize a label.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GLOBAL_ASM_OP
end_ifdef

begin_function
name|void
name|default_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fputs
argument_list|(
name|GLOBAL_ASM_OP
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GLOBAL_ASM_OP */
end_comment

begin_comment
comment|/* This is how to output an internal numbered label where PREFIX is    the class of label and LABELNO is the number within the class.  */
end_comment

begin_function
name|void
name|default_internal_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|unsigned
name|long
name|labelno
parameter_list|)
block|{
name|char
modifier|*
specifier|const
name|buf
init|=
name|alloca
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
name|prefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the default behavior at the beginning of a file.  It's    controlled by two other target-hook toggles.  */
end_comment

begin_function
name|void
name|default_file_start
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|targetm
operator|.
name|file_start_app_off
operator|&&
operator|!
name|flag_verbose_asm
condition|)
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|file_start_file_directive
condition|)
name|output_file_directive
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a generic routine suitable for use as TARGET_ASM_FILE_END    which emits a special section directive used to indicate whether or    not this object file needs an executable stack.  This is primarily    a GNU extension to ELF but could be used on other targets.  */
end_comment

begin_function
name|void
name|file_end_indicate_exec_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
name|SECTION_DEBUG
decl_stmt|;
if|if
condition|(
name|trampolines_created
condition|)
name|flags
operator||=
name|SECTION_CODE
expr_stmt|;
name|named_section_flags
argument_list|(
literal|".note.GNU-stack"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-varasm.h"
end_include

end_unit

