begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output variables, constants and external declarations, for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file handles generation of all the assembler code    *except* the instructions of a function.    This includes declarations of variables and their initial values.     We also output the assembler code for constants stored in memory    and are responsible for combining constants with the same value.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The (assembler) name of the first globally-visible object output.  */
end_comment

begin_extern
extern|extern GTY((
end_extern

begin_decl_stmt
unit|))
specifier|const
name|char
modifier|*
name|first_global_object_name
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern GTY((
end_extern

begin_decl_stmt
unit|))
specifier|const
name|char
modifier|*
name|weak_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|first_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|weak_global_object_name
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|addr_const
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|constant_descriptor_rtx
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rtx_constant_pool
struct_decl|;
end_struct_decl

begin_decl_stmt
name|struct
name|varasm_status
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* If we're using a per-function constant pool, this is it.  */
name|struct
name|rtx_constant_pool
modifier|*
name|pool
decl_stmt|;
comment|/* Number of tree-constants deferred during the expansion of this      function.  */
name|unsigned
name|int
name|deferred_constants
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|n_deferred_constants
value|(cfun->varasm->deferred_constants)
end_define

begin_comment
comment|/* Number for making the label on the next    constant that is stored in memory.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|const_labelno
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last decl for which assemble_variable was called,    if it did ASM_DECLARE_OBJECT_NAME.    If the last call to assemble_variable didn't do that,    this holds 0.  */
end_comment

begin_decl_stmt
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following global variable indicates if the first basic block    in a function belongs to the cold partition or not.  */
end_comment

begin_decl_stmt
name|bool
name|first_function_block_is_cold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We give all constants their own alias set.  Perhaps redundant with    MEM_READONLY_P, but pre-dates it.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|const_alias_set
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contains_pointers_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
end_ifdef

begin_function_decl
specifier|static
name|bool
name|incorporeal_function_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|tree
parameter_list|,
name|struct
name|addr_const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|const_desc_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|const_desc_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|const_hash_1
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_constant
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_constant
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_constant_def_contents
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_addressed_constants
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|array_size_for_constructor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|min_align
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_constructor
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|globalize_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_assemble_visibility
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_function_decl
specifier|static
name|void
name|asm_output_bss
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|asm_output_aligned_bss
argument_list|(
name|FILE
operator|*
argument_list|,
name|tree
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|unsigned
name|HOST_WIDE_INT
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_function_decl
specifier|static
name|void
name|mark_weak
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_constant_pool
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Well-known sections, each one associated with some sort of *_ASM_OP.  */
end_comment

begin_decl_stmt
name|section
modifier|*
name|text_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|data_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|readonly_data_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|sdata_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|ctors_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|dtors_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|bss_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|sbss_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various forms of common section.  All are guaranteed to be nonnull.  */
end_comment

begin_decl_stmt
name|section
modifier|*
name|tls_comm_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|comm_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|section
modifier|*
name|lcomm_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A SECTION_NOSWITCH section used for declaring global BSS variables.    May be null.  */
end_comment

begin_decl_stmt
name|section
modifier|*
name|bss_noswitch_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The section that holds the main exception table, when known.  The section    is set either by the target's init_sections hook or by the first call to    switch_to_exception_section.  */
end_comment

begin_decl_stmt
name|section
modifier|*
name|exception_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The section that holds the DWARF2 frame unwind information, when known.    The section is set either by the target's init_sections hook or by the    first call to switch_to_eh_frame_section.  */
end_comment

begin_decl_stmt
name|section
modifier|*
name|eh_frame_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* asm_out_file's current section.  This is NULL if no section has yet    been selected or if we lose track of what the current section is.  */
end_comment

begin_decl_stmt
name|section
modifier|*
name|in_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if code for the current function is currently being directed    at the cold section.  */
end_comment

begin_decl_stmt
name|bool
name|in_cold_section_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A linked list of all the unnamed sections.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|unnamed_sections
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return a nonzero value if DECL has a section attribute.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_NAMED_SECTION
end_ifndef

begin_define
define|#
directive|define
name|IN_NAMED_SECTION
parameter_list|(
name|DECL
parameter_list|)
define|\
value|((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \&& DECL_SECTION_NAME (DECL) != NULL_TREE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hash table of named sections.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (section))
argument_list|)
name|htab_t
name|section_htab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A table of object_blocks, indexed by section.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct object_block))
argument_list|)
name|htab_t
name|object_block_htab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The next number to use for internal anchor labels.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|anchor_labelno
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A pool of constants that can be shared between functions.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|rtx_constant_pool
operator|*
name|shared_constant_pool
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Helper routines for maintaining section_htab.  */
end_comment

begin_function
specifier|static
name|int
name|section_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|section
modifier|*
name|old
init|=
name|p1
decl_stmt|;
specifier|const
name|char
modifier|*
name|new
init|=
name|p2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|old
operator|->
name|named
operator|.
name|name
argument_list|,
name|new
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|section_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|section
modifier|*
name|old
init|=
name|p
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|old
operator|->
name|named
operator|.
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a hash value for section SECT.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_section
parameter_list|(
name|section
modifier|*
name|sect
parameter_list|)
block|{
if|if
condition|(
name|sect
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_NAMED
condition|)
return|return
name|htab_hash_string
argument_list|(
name|sect
operator|->
name|named
operator|.
name|name
argument_list|)
return|;
return|return
name|sect
operator|->
name|common
operator|.
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Helper routines for maintaining object_block_htab.  */
end_comment

begin_function
specifier|static
name|int
name|object_block_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|object_block
modifier|*
name|old
init|=
name|p1
decl_stmt|;
specifier|const
name|section
modifier|*
name|new
init|=
name|p2
decl_stmt|;
return|return
name|old
operator|->
name|sect
operator|==
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|object_block_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|object_block
modifier|*
name|old
init|=
name|p
decl_stmt|;
return|return
name|hash_section
argument_list|(
name|old
operator|->
name|sect
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new unnamed section with the given fields.  */
end_comment

begin_function
name|section
modifier|*
name|get_unnamed_section
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
name|section
modifier|*
name|sect
decl_stmt|;
name|sect
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unnamed_section
argument_list|)
argument_list|)
expr_stmt|;
name|sect
operator|->
name|unnamed
operator|.
name|common
operator|.
name|flags
operator|=
name|flags
operator||
name|SECTION_UNNAMED
expr_stmt|;
name|sect
operator|->
name|unnamed
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|sect
operator|->
name|unnamed
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|sect
operator|->
name|unnamed
operator|.
name|next
operator|=
name|unnamed_sections
expr_stmt|;
name|unnamed_sections
operator|=
name|sect
expr_stmt|;
return|return
name|sect
return|;
block|}
end_function

begin_comment
comment|/* Return a SECTION_NOSWITCH section with the given fields.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|get_noswitch_section
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|,
name|noswitch_section_callback
name|callback
parameter_list|)
block|{
name|section
modifier|*
name|sect
decl_stmt|;
name|sect
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unnamed_section
argument_list|)
argument_list|)
expr_stmt|;
name|sect
operator|->
name|noswitch
operator|.
name|common
operator|.
name|flags
operator|=
name|flags
operator||
name|SECTION_NOSWITCH
expr_stmt|;
name|sect
operator|->
name|noswitch
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
return|return
name|sect
return|;
block|}
end_function

begin_comment
comment|/* Return the named section structure associated with NAME.  Create    a new section with the given fields if no such structure exists.  */
end_comment

begin_function
name|section
modifier|*
name|get_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|section
modifier|*
name|sect
decl_stmt|,
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
name|section
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|section_htab
argument_list|,
name|name
argument_list|,
name|htab_hash_string
argument_list|(
name|name
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|flags
operator||=
name|SECTION_NAMED
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|sect
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|named_section
argument_list|)
argument_list|)
expr_stmt|;
name|sect
operator|->
name|named
operator|.
name|common
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|sect
operator|->
name|named
operator|.
name|name
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sect
operator|->
name|named
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
operator|*
name|slot
operator|=
name|sect
expr_stmt|;
block|}
else|else
block|{
name|sect
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|(
name|sect
operator|->
name|common
operator|.
name|flags
operator|&
operator|~
name|SECTION_DECLARED
operator|)
operator|!=
name|flags
operator|&&
operator|(
operator|(
name|sect
operator|->
name|common
operator|.
name|flags
operator||
name|flags
operator|)
operator|&
name|SECTION_OVERRIDE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Sanity check user variables for flag changes.  */
if|if
condition|(
name|decl
operator|==
literal|0
condition|)
name|decl
operator|=
name|sect
operator|->
name|named
operator|.
name|decl
expr_stmt|;
name|gcc_assert
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%+D causes a section type conflict"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sect
return|;
block|}
end_function

begin_comment
comment|/* Return true if the current compilation mode benefits from having    objects grouped into blocks.  */
end_comment

begin_function
specifier|static
name|bool
name|use_object_blocks_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_section_anchors
return|;
block|}
end_function

begin_comment
comment|/* Return the object_block structure for section SECT.  Create a new    structure if we haven't created one already.  Return null if SECT    itself is null.  */
end_comment

begin_function
specifier|static
name|struct
name|object_block
modifier|*
name|get_block_for_section
parameter_list|(
name|section
modifier|*
name|sect
parameter_list|)
block|{
name|struct
name|object_block
modifier|*
name|block
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|object_block_htab
argument_list|,
name|sect
argument_list|,
name|hash_section
argument_list|(
name|sect
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|block
operator|=
operator|(
expr|struct
name|object_block
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
name|block
operator|=
operator|(
expr|struct
name|object_block
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object_block
argument_list|)
argument_list|)
expr_stmt|;
name|block
operator|->
name|sect
operator|=
name|sect
expr_stmt|;
operator|*
name|slot
operator|=
name|block
expr_stmt|;
block|}
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Create a symbol with label LABEL and place it at byte offset    OFFSET in BLOCK.  OFFSET can be negative if the symbol's offset    is not yet known.  LABEL must be a garbage-collected string.  */
end_comment

begin_function
specifier|static
name|rtx
name|create_block_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|struct
name|object_block
modifier|*
name|block
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|rtx
name|symbol
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* Create the extended SYMBOL_REF.  */
name|size
operator|=
name|RTX_HDR_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_symbol
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|ggc_alloc_zone
argument_list|(
name|size
argument_list|,
operator|&
name|rtl_zone
argument_list|)
expr_stmt|;
comment|/* Initialize the normal SYMBOL_REF fields.  */
name|memset
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|symbol
argument_list|,
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|symbol
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
operator|=
name|label
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_HAS_BLOCK_INFO
expr_stmt|;
comment|/* Initialize the block_symbol stuff.  */
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
operator|=
name|block
expr_stmt|;
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
operator|=
name|offset
expr_stmt|;
return|return
name|symbol
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_cold_section_name
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|stripped_name
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|tree
name|dsn
decl_stmt|;
name|gcc_assert
argument_list|(
name|cfun
operator|&&
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|unlikely_text_section_name
condition|)
return|return;
name|dsn
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_function_sections
operator|&&
name|dsn
condition|)
block|{
name|name
operator|=
name|alloca
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|dsn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|dsn
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|dsn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stripped_name
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ACONCAT
argument_list|(
operator|(
name|stripped_name
operator|,
literal|"_unlikely"
operator|,
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|unlikely_text_section_name
operator|=
name|ggc_strdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|cfun
operator|->
name|unlikely_text_section_name
operator|=
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to unlikely-to-be-executed text section.  */
end_comment

begin_function
name|section
modifier|*
name|unlikely_text_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cfun
condition|)
block|{
if|if
condition|(
operator|!
name|cfun
operator|->
name|unlikely_text_section_name
condition|)
name|initialize_cold_section_name
argument_list|()
expr_stmt|;
return|return
name|get_named_section
argument_list|(
name|NULL
argument_list|,
name|cfun
operator|->
name|unlikely_text_section_name
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
return|return
name|get_named_section
argument_list|(
name|NULL
argument_list|,
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* When called within a function context, return true if the function    has been assigned a cold text section and if SECT is that section.    When called outside a function context, return true if SECT is the    default cold section.  */
end_comment

begin_function
name|bool
name|unlikely_text_section_p
parameter_list|(
name|section
modifier|*
name|sect
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|cfun
condition|)
name|name
operator|=
name|cfun
operator|->
name|unlikely_text_section_name
expr_stmt|;
else|else
name|name
operator|=
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
expr_stmt|;
return|return
operator|(
name|name
operator|&&
name|sect
operator|&&
name|SECTION_STYLE
argument_list|(
name|sect
argument_list|)
operator|==
name|SECTION_NAMED
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|sect
operator|->
name|named
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a section with a particular name and with whatever SECTION_*    flags section_type_flags deems appropriate.  The name of the section    is taken from NAME if nonnull, otherwise it is taken from DECL's    DECL_SECTION_NAME.  DECL is the decl associated with the section    (see the section comment for details) and RELOC is as for    section_type_flags.  */
end_comment

begin_function
name|section
modifier|*
name|get_named_section
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|decl
operator|||
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|targetm
operator|.
name|section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
return|return
name|get_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If required, set DECL_SECTION_NAME to a unique name.  */
end_comment

begin_function
name|void
name|resolve_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flag_function_or_data_sections
parameter_list|)
block|{
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|targetm
operator|.
name|have_named_sections
operator|&&
operator|(
name|flag_function_or_data_sections
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|unique_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BSS
end_ifdef

begin_comment
comment|/* Utility function for ASM_OUTPUT_BSS for targets to use if    they don't support alignments in .bss.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_bss
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|rounded
parameter_list|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|bss_section
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|rounded
condition|?
name|rounded
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_BSS
end_ifdef

begin_comment
comment|/* Utility function for targets to use in implementing    ASM_OUTPUT_ALIGNED_BSS.    ??? It is believed that this function will work in most cases so such    support is localized here.  */
end_comment

begin_function
specifier|static
name|void
name|asm_output_aligned_bss
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|switch_to_section
argument_list|(
name|bss_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSS_SECTION_ASM_OP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_SELECT_SECTION_FOR_FUNCTIONS
end_ifndef

begin_comment
comment|/* Return the hot section for function DECL.  Return text_section for    null DECLs.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|hot_function_section
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|targetm
operator|.
name|have_named_sections
condition|)
return|return
name|get_named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|text_section
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the section for function DECL.     If DECL is NULL_TREE, return the text section.  We can be passed    NULL_TREE under some circumstances by dbxout.c at least.  */
end_comment

begin_function
name|section
modifier|*
name|function_section
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|int
name|reloc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first_function_block_is_cold
condition|)
name|reloc
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SELECT_SECTION_FOR_FUNCTIONS
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|reloc
condition|?
name|unlikely_text_section
argument_list|()
else|:
name|get_named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|targetm
operator|.
name|asm_out
operator|.
name|select_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|reloc
condition|?
name|unlikely_text_section
argument_list|()
else|:
name|hot_function_section
argument_list|(
name|decl
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|section
modifier|*
name|current_function_section
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_SELECT_SECTION_FOR_FUNCTIONS
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|in_cold_section_p
condition|?
name|unlikely_text_section
argument_list|()
else|:
name|get_named_section
argument_list|(
name|current_function_decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|targetm
operator|.
name|asm_out
operator|.
name|select_section
argument_list|(
name|current_function_decl
argument_list|,
name|in_cold_section_p
argument_list|,
name|DECL_ALIGN
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
name|in_cold_section_p
condition|?
name|unlikely_text_section
argument_list|()
else|:
name|hot_function_section
argument_list|(
name|current_function_decl
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return the read-only data section associated with function DECL.  */
end_comment

begin_function
name|section
modifier|*
name|default_function_rodata_section
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|HAVE_COMDAT_GROUP
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
decl_stmt|;
name|char
modifier|*
name|rname
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|rname
argument_list|,
literal|".rodata"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rname
argument_list|,
name|name
operator|+
literal|5
argument_list|)
expr_stmt|;
return|return
name|get_section
argument_list|(
name|rname
argument_list|,
name|SECTION_LINKONCE
argument_list|,
name|decl
argument_list|)
return|;
block|}
comment|/* For .gnu.linkonce.t.foo we want to use .gnu.linkonce.r.foo.  */
elseif|else
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|rname
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|rname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rname
index|[
literal|14
index|]
operator|=
literal|'r'
expr_stmt|;
return|return
name|get_section
argument_list|(
name|rname
argument_list|,
name|SECTION_LINKONCE
argument_list|,
name|decl
argument_list|)
return|;
block|}
comment|/* For .text.foo we want to use .rodata.foo.  */
elseif|else
if|if
condition|(
name|flag_function_sections
operator|&&
name|flag_data_sections
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".text."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|rname
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|rname
argument_list|,
literal|".rodata"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rname
operator|+
literal|7
argument_list|,
name|name
operator|+
literal|5
argument_list|,
name|len
operator|-
literal|5
argument_list|)
expr_stmt|;
return|return
name|get_section
argument_list|(
name|rname
argument_list|,
literal|0
argument_list|,
name|decl
argument_list|)
return|;
block|}
block|}
return|return
name|readonly_data_section
return|;
block|}
end_function

begin_comment
comment|/* Return the read-only data section associated with function DECL    for targets where that section should be always the single    readonly data section.  */
end_comment

begin_function
name|section
modifier|*
name|default_no_function_rodata_section
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|readonly_data_section
return|;
block|}
end_function

begin_comment
comment|/* Return the section to use for string merging.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|mergeable_string_section
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|len
decl_stmt|;
if|if
condition|(
name|HAVE_GAS_SHF_MERGE
operator|&&
name|flag_merge_constants
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|align
operator|<=
literal|256
operator|&&
operator|(
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|TREE_STRING_LENGTH
argument_list|(
name|decl
argument_list|)
operator|>=
name|len
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|modesize
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|unit
decl_stmt|;
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modesize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|modesize
operator|>=
literal|8
operator|&&
name|modesize
operator|<=
literal|256
operator|&&
operator|(
name|modesize
operator|&
operator|(
name|modesize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|align
operator|<
name|modesize
condition|)
name|align
operator|=
name|modesize
expr_stmt|;
name|str
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|unit
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Check for embedded NUL characters.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|unit
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|unit
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|str
index|[
name|i
operator|+
name|j
index|]
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|unit
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
operator|-
name|unit
condition|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".rodata.str%d.%d"
argument_list|,
name|modesize
operator|/
literal|8
argument_list|,
call|(
name|int
call|)
argument_list|(
name|align
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|modesize
operator|/
literal|8
operator|)
operator||
name|SECTION_MERGE
operator||
name|SECTION_STRINGS
expr_stmt|;
return|return
name|get_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|readonly_data_section
return|;
block|}
end_function

begin_comment
comment|/* Return the section to use for constant merging.  */
end_comment

begin_function
name|section
modifier|*
name|mergeable_constant_section
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|modesize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAVE_GAS_SHF_MERGE
operator|&&
name|flag_merge_constants
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|modesize
operator|<=
name|align
operator|&&
name|align
operator|>=
literal|8
operator|&&
name|align
operator|<=
literal|256
operator|&&
operator|(
name|align
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|name
index|[
literal|24
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".rodata.cst%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|align
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|align
operator|/
literal|8
operator|)
operator||
name|SECTION_MERGE
expr_stmt|;
return|return
name|get_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|readonly_data_section
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, a putative register name, discard any customary prefixes.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|strip_reg_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
argument_list|)
condition|)
name|name
operator|+=
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|name
operator|++
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The user has asked for a DECL to have a particular name.  Set (or    change) it in such a way that we don't prefix an underscore to    it.  */
end_comment

begin_function
name|void
name|set_user_assembler_name
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|starred
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|starred
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|strcpy
argument_list|(
name|starred
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|change_decl_assembler_name
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|starred
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode an `asm' spec for a declaration as a register name.    Return the register number, or -1 if nothing specified,    or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,    or -3 if ASMSPEC is `cc' and is not recognized,    or -4 if ASMSPEC is `memory' and is not recognized.    Accept an exact spelling or a decimal number.    Prefixes such as % are optional.  */
end_comment

begin_function
name|int
name|decode_reg_name
parameter_list|(
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|)
block|{
if|if
condition|(
name|asmspec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Get rid of confusing prefixes.  */
name|asmspec
operator|=
name|strip_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Allow a decimal number as a "register name".  */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|asmspec
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|asmspec
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
else|else
return|return
operator|-
literal|2
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|strip_reg_name
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|i
return|;
ifdef|#
directive|ifdef
name|ADDITIONAL_REGISTER_NAMES
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|number
decl_stmt|;
block|}
name|table
index|[]
init|=
name|ADDITIONAL_REGISTER_NAMES
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|table
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|number
return|;
block|}
endif|#
directive|endif
comment|/* ADDITIONAL_REGISTER_NAMES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"memory"
argument_list|)
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"cc"
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
return|return
operator|-
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if DECL's initializer is suitable for a BSS section.  */
end_comment

begin_function
specifier|static
name|bool
name|bss_initializer_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|(
name|flag_zero_initialized_in_bss
comment|/* Leave constant zeroes in .rodata so they 		 can be shared.  */
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|initializer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment of variable specified by DECL.    DONT_OUTPUT_DATA is from assemble_variable.  */
end_comment

begin_function
name|void
name|align_variable
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|dont_output_data
parameter_list|)
block|{
name|unsigned
name|int
name|align
init|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* In the case for initialing an array whose length isn't specified,      where we have not yet been able to do the layout,      figure out the proper alignment now.  */
if|if
condition|(
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some object file formats have a maximum alignment which they support.      In particular, a.out format supports a maximum alignment of 4.  */
if|if
condition|(
name|align
operator|>
name|MAX_OFILE_ALIGNMENT
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"alignment of %q+D is greater than maximum object "
literal|"file alignment.  Using %d"
argument_list|,
name|decl
argument_list|,
name|MAX_OFILE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|align
operator|=
name|MAX_OFILE_ALIGNMENT
expr_stmt|;
block|}
comment|/* On some machines, it is good to increase alignment sometimes.  */
if|if
condition|(
operator|!
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DATA_ALIGNMENT
name|align
operator|=
name|DATA_ALIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Reset the alignment in case we have made it tighter, so we can benefit      from it in get_pointer_alignment.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the section into which the given VAR_DECL or CONST_DECL    should be placed.  PREFER_NOSWITCH_P is true if a noswitch    section should be used wherever possible.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|get_variable_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|prefer_noswitch_p
parameter_list|)
block|{
name|int
name|reloc
decl_stmt|;
comment|/* If the decl has been given an explicit section name, then it      isn't common, and shouldn't be handled as such.  */
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|tls_comm_section
return|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|bss_initializer_p
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|comm_section
return|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|reloc
operator|=
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|?
literal|3
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|reloc
operator|=
literal|0
expr_stmt|;
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|flag_data_sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|get_named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|reloc
argument_list|)
return|;
if|if
condition|(
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|prefer_noswitch_p
operator|&&
name|targetm
operator|.
name|have_switchable_bss_sections
operator|)
operator|&&
name|bss_initializer_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lcomm_section
return|;
if|if
condition|(
name|bss_noswitch_section
condition|)
return|return
name|bss_noswitch_section
return|;
block|}
return|return
name|targetm
operator|.
name|asm_out
operator|.
name|select_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the block into which object_block DECL should be placed.  */
end_comment

begin_function
specifier|static
name|struct
name|object_block
modifier|*
name|get_block_for_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|section
modifier|*
name|sect
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* The object must be defined in this translation unit.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* There's no point using object blocks for something that is 	 isolated by definition.  */
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
comment|/* We can only calculate block offsets if the decl has a known      constant size.  */
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Find out which section should contain DECL.  We cannot put it into      an object block if it requires a standalone definition.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|align_variable
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sect
operator|=
name|get_variable_section
argument_list|(
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|SECTION_STYLE
argument_list|(
name|sect
argument_list|)
operator|==
name|SECTION_NOSWITCH
condition|)
return|return
name|NULL
return|;
return|return
name|get_block_for_section
argument_list|(
name|sect
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make sure block symbol SYMBOL is in block BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|change_symbol_block
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|struct
name|object_block
modifier|*
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|!=
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if it is possible to put DECL in an object_block.  */
end_comment

begin_function
specifier|static
name|bool
name|use_blocks_for_decl_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Only data DECLs can be placed into object blocks.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
return|return
name|false
return|;
comment|/* Detect decls created by dw2_force_const_mem.  Such decls are      special because DECL_INITIAL doesn't specify the decl's true value.      dw2_output_indirect_constants will instead call assemble_variable      with dont_output_data set to 1 and then print the contents itself.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|decl
condition|)
return|return
name|false
return|;
comment|/* If this decl is an alias, then we don't want to emit a definition.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"alias"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should    have static storage duration.  In other words, it should not be an    automatic variable, including PARM_DECLs.     There is, however, one exception: this function handles variables    explicitly placed in a particular register by the user.     This is never called for PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|make_decl_rtl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|int
name|reg_number
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Check that we are not being given an automatic variable.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|RESULT_DECL
argument_list|)
expr_stmt|;
comment|/* A weak alias has TREE_PUBLIC set but not the other bits.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And that we were not given a type or a label.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|LABEL_DECL
argument_list|)
expr_stmt|;
comment|/* For a duplicate declaration, we can be called twice on the      same DECL node.  Don't discard the RTL already made.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If the old RTL had the wrong mode, fix the mode.  */
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* ??? Another way to do this would be to maintain a hashed 	 table of such critters.  Instead of adding stuff to a DECL 	 to give certain attributes to it, we could use an external 	 hash map from DECL to set of attributes.  */
comment|/* Let the target reassign the RTL if it wants. 	 This is necessary, for example, when one machine specific 	 decl attribute overrides another.  */
name|targetm
operator|.
name|encode_section_info
argument_list|(
name|decl
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If the symbol has a SYMBOL_REF_BLOCK field, update it based 	 on the new decl information.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_HAS_BLOCK_INFO_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|change_symbol_block
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|get_block_for_decl
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make this function static known to the mudflap runtime.  */
if|if
condition|(
name|flag_mudflap
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|mudflap_enqueue_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"register name not specified for %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|asmspec
init|=
name|name
operator|+
literal|1
decl_stmt|;
name|reg_number
operator|=
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
comment|/* First detect errors in declaring global registers.  */
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"register name not specified for %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_number
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"invalid register name for %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|error
argument_list|(
literal|"data type of %q+D isn%'t suitable for a register"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|reg_number
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"register specified for %q+D isn%'t suitable for data type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Now handle properly declared static register variables.  */
else|else
block|{
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"global register variable has initial value"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wvolatile_register_var
argument_list|,
literal|"optimization may eliminate reads and/or "
literal|"writes to register variables"
argument_list|)
expr_stmt|;
comment|/* If the user specified one of the eliminables registers here, 	     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable 	     confused with that register and be eliminated.  This usage is 	     somewhat suspect...  */
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_rtx_raw_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|reg_number
argument_list|)
argument_list|)
expr_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|reg_number
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Make this register global, so not usable for anything 		 else.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_REGISTER_GLOBAL
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_DECLARE_REGISTER_GLOBAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|reg_number
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nregs
operator|=
name|hard_regno_nregs
index|[
name|reg_number
index|]
index|[
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|nregs
operator|>
literal|0
condition|)
name|globalize_reg
argument_list|(
name|reg_number
operator|+
operator|--
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* As a register variable, it has no section.  */
return|return;
block|}
block|}
comment|/* Now handle ordinary static variables and functions (in memory).      Also handle vars declared register invalidly.  */
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|reg_number
operator|=
name|decode_reg_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|>=
literal|0
operator|||
name|reg_number
operator|==
operator|-
literal|3
condition|)
name|error
argument_list|(
literal|"register name given for non-register variable %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Specifying a section attribute on a variable forces it into a      non-.bss section, and thus it cannot be common.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Variables can't be both common and weak.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|use_object_blocks_p
argument_list|()
operator|&&
name|use_blocks_for_decl_p
argument_list|(
name|decl
argument_list|)
condition|)
name|x
operator|=
name|create_block_symbol
argument_list|(
name|name
argument_list|,
name|get_block_for_decl
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|SET_SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information      such as that it is a function name.      If the name is changed, the macro ASM_OUTPUT_LABELREF      will have to know how to strip this information.  */
name|targetm
operator|.
name|encode_section_info
argument_list|(
name|decl
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Make this function static known to the mudflap runtime.  */
if|if
condition|(
name|flag_mudflap
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|mudflap_enqueue_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a string of literal assembler code    for an `asm' keyword used between functions.  */
end_comment

begin_function
name|void
name|assemble_asm
parameter_list|(
name|tree
name|string
parameter_list|)
block|{
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global destructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.  */
end_comment

begin_function
name|void
name|default_stabs_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
name|DBX_DEBUGGING_INFO
operator|||
name|defined
name|XCOFF_DEBUGGING_INFO
comment|/* Tell GNU LD that this is part of the static destructor set.      This will work for any system that uses stabs, most usefully      aout systems.  */
name|dbxout_begin_simple_stabs
argument_list|(
literal|"___DTOR_LIST__"
argument_list|,
literal|22
comment|/* N_SETT */
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label
argument_list|(
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sorry
argument_list|(
literal|"global destructors not supported on this target"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|default_named_section_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".dtors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* ??? This only works reliably with the GNU linker.  */
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".dtors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|get_section
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DTORS_SECTION_ASM_OP
end_ifdef

begin_function
name|void
name|default_dtor_section_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|switch_to_section
argument_list|(
name|dtors_section
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Likewise for global constructors.  */
end_comment

begin_function
name|void
name|default_stabs_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
name|DBX_DEBUGGING_INFO
operator|||
name|defined
name|XCOFF_DEBUGGING_INFO
comment|/* Tell GNU LD that this is part of the static destructor set.      This will work for any system that uses stabs, most usefully      aout systems.  */
name|dbxout_begin_simple_stabs
argument_list|(
literal|"___CTOR_LIST__"
argument_list|,
literal|22
comment|/* N_SETT */
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label
argument_list|(
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sorry
argument_list|(
literal|"global constructors not supported on this target"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|default_named_section_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".ctors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* ??? This only works reliably with the GNU linker.  */
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ctors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|get_section
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTORS_SECTION_ASM_OP
end_ifdef

begin_function
name|void
name|default_ctor_section_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|switch_to_section
argument_list|(
name|ctors_section
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* CONSTANT_POOL_BEFORE_FUNCTION may be defined as an expression with    a nonzero value if the constant pool should be output before the    start of the function, or a zero value if the pool should output    after the end of the function.  The default is to put it before the    start.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONSTANT_POOL_BEFORE_FUNCTION
end_ifndef

begin_define
define|#
directive|define
name|CONSTANT_POOL_BEFORE_FUNCTION
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DECL is an object (either VAR_DECL or FUNCTION_DECL) which is going    to be output to assembler.    Set first_global_object_name and weak_global_object_name as appropriate.  */
end_comment

begin_function
name|void
name|notice_global_symbol
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|type
init|=
operator|&
name|first_global_object_name
decl_stmt|;
if|if
condition|(
name|first_global_object_name
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
operator|)
operator|)
operator|||
operator|!
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* We win when global object is found, but it is useful to know about weak      symbol as well so we can produce nicer unique names.  */
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|type
operator|=
operator|&
name|weak_global_object_name
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|type
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|p
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|ggc_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|name
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output assembler code for the constant pool of a function and associated    with defining the name of the function.  DECL describes the function.    NAME is the function's name.  For the constant pool, we use the current    constant pool data.  */
end_comment

begin_function
name|void
name|assemble_start_function
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
parameter_list|)
block|{
name|int
name|align
decl_stmt|;
name|char
name|tmp_label
index|[
literal|100
index|]
decl_stmt|;
name|bool
name|hot_label_written
init|=
name|false
decl_stmt|;
name|cfun
operator|->
name|unlikely_text_section_name
operator|=
name|NULL
expr_stmt|;
name|first_function_block_is_cold
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|tmp_label
argument_list|,
literal|"LHOTB"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|hot_section_label
operator|=
name|ggc_strdup
argument_list|(
name|tmp_label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|tmp_label
argument_list|,
literal|"LCOLDB"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|cold_section_label
operator|=
name|ggc_strdup
argument_list|(
name|tmp_label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|tmp_label
argument_list|,
literal|"LHOTE"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|hot_section_end_label
operator|=
name|ggc_strdup
argument_list|(
name|tmp_label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|tmp_label
argument_list|,
literal|"LCOLDE"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|cold_section_end_label
operator|=
name|ggc_strdup
argument_list|(
name|tmp_label
argument_list|)
expr_stmt|;
name|const_labelno
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cfun
operator|->
name|hot_section_label
operator|=
name|NULL
expr_stmt|;
name|cfun
operator|->
name|cold_section_label
operator|=
name|NULL
expr_stmt|;
name|cfun
operator|->
name|hot_section_end_label
operator|=
name|NULL
expr_stmt|;
name|cfun
operator|->
name|cold_section_end_label
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|resolve_unique_section
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|flag_function_sections
argument_list|)
expr_stmt|;
comment|/* Make sure the not and cold text (code) sections are properly      aligned.  This is necessary here in the case where the function      has both hot and cold sections, because we don't want to re-set      the alignment when the section switch happens mid-function.  */
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|switch_to_section
argument_list|(
name|unlikely_text_section
argument_list|()
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cfun
operator|->
name|cold_section_label
argument_list|)
expr_stmt|;
comment|/* When the function starts with a cold section, we need to explicitly 	 align the hot section and write out the hot section label. 	 But if the current function is a thunk, we do not have a CFG.  */
if|if
condition|(
operator|!
name|current_function_is_thunk
operator|&&
name|BB_PARTITION
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
argument_list|)
operator|==
name|BB_COLD_PARTITION
condition|)
block|{
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cfun
operator|->
name|hot_section_label
argument_list|)
expr_stmt|;
name|hot_label_written
operator|=
name|true
expr_stmt|;
name|first_function_block_is_cold
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Calls to function_section rely on first_function_block_is_cold 	 being accurate.  The first block may be cold even if we aren't 	 doing partitioning, if the entire function was decided by 	 choose_function_section (predict.c) to be cold.  */
name|initialize_cold_section_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|unlikely_text_section_name
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|cfun
operator|->
name|unlikely_text_section_name
argument_list|)
operator|==
literal|0
condition|)
name|first_function_block_is_cold
operator|=
name|true
expr_stmt|;
block|}
name|in_cold_section_p
operator|=
name|first_function_block_is_cold
expr_stmt|;
comment|/* Switch to the correct text section for the start of the function.  */
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
operator|&&
operator|!
name|hot_label_written
condition|)
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cfun
operator|->
name|hot_section_label
argument_list|)
expr_stmt|;
comment|/* Tell assembler to move to target machine's alignment for functions.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a user-specified function alignment.      Note that we still need to align to DECL_ALIGN, as above,      because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */
if|if
condition|(
operator|!
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|&&
name|align_functions_log
operator|>
name|align
operator|&&
name|cfun
operator|->
name|function_frequency
operator|!=
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|ASM_OUTPUT_MAX_SKIP_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align_functions_log
argument_list|,
name|align_functions
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align_functions_log
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FUNCTION_PREFIX
name|ASM_OUTPUT_FUNCTION_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|debug_hooks
operator|->
name|begin_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Make function name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|notice_global_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|globalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|maybe_assemble_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_PRESERVE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|mark_decl_preserved
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
comment|/* Do any machine/system dependent processing of the function name.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_NAME
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the function.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_FUNCTION_NAME */
block|}
end_function

begin_comment
comment|/* Output assembler code associated with defining the size of the    function.  DECL describes the function.  NAME is the function's name.  */
end_comment

begin_function
name|void
name|assemble_end_function
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_SIZE
comment|/* We could have switched section in the middle of the function.  */
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_DECLARE_FUNCTION_SIZE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|CONSTANT_POOL_BEFORE_FUNCTION
condition|)
block|{
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* need to switch back */
block|}
comment|/* Output labels for end of hot/cold text sections (to be used by      debug info.)  */
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|section
modifier|*
name|save_text_section
decl_stmt|;
name|save_text_section
operator|=
name|in_section
expr_stmt|;
name|switch_to_section
argument_list|(
name|unlikely_text_section
argument_list|()
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cfun
operator|->
name|cold_section_end_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_function_block_is_cold
condition|)
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cfun
operator|->
name|hot_section_end_label
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|save_text_section
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble code to leave SIZE bytes of zeros.  */
end_comment

begin_function
name|void
name|assemble_zeros
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASM_NO_SKIP_IN_TEXT
comment|/* The `space' pseudo in the text section outputs nop insns rather than 0s,      so we must output 0s explicitly in the text section.  */
if|if
condition|(
name|ASM_NO_SKIP_IN_TEXT
operator|&&
operator|(
name|in_section
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_CODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */
end_comment

begin_function
name|void
name|assemble_align
parameter_list|(
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a string constant with the specified C string as contents.  */
end_comment

begin_function
name|void
name|assemble_string
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|maximum
init|=
literal|2000
decl_stmt|;
comment|/* If the string is very long, split it up.  */
while|while
condition|(
name|pos
operator|<
name|size
condition|)
block|{
name|int
name|thissize
init|=
name|size
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|thissize
operator|>
name|maximum
condition|)
name|thissize
operator|=
name|maximum
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|thissize
expr_stmt|;
name|p
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A noswitch_section_callback for lcomm_section.  */
end_comment

begin_function
specifier|static
name|bool
name|emit_local
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|rounded
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
elif|#
directive|elif
name|defined
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
else|#
directive|else
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A noswitch_section_callback for bss_noswitch_section.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_BSS
operator|||
name|defined
name|ASM_OUTPUT_BSS
end_if

begin_function
specifier|static
name|bool
name|emit_bss
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|rounded
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_BSS
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
else|#
directive|else
name|ASM_OUTPUT_BSS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A noswitch_section_callback for comm_section.  */
end_comment

begin_function
specifier|static
name|bool
name|emit_common
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|rounded
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
name|ASM_OUTPUT_ALIGNED_DECL_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
elif|#
directive|elif
name|defined
name|ASM_OUTPUT_ALIGNED_COMMON
name|ASM_OUTPUT_ALIGNED_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
else|#
directive|else
name|ASM_OUTPUT_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A noswitch_section_callback for tls_comm_section.  */
end_comment

begin_function
specifier|static
name|bool
name|emit_tls_common
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|rounded
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_TLS_COMMON
name|ASM_OUTPUT_TLS_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|true
return|;
else|#
directive|else
name|sorry
argument_list|(
literal|"thread-local COMMON data not implemented"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Assemble DECL given that it belongs in SECTION_NOSWITCH section SECT.    NAME is the name of DECL's SYMBOL_REF.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_noswitch_variable
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|section
modifier|*
name|sect
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|rounded
decl_stmt|;
name|size
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rounded
operator|=
name|size
expr_stmt|;
comment|/* Don't allocate zero bytes of common,      since that means "undefined external" in the linker.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|rounded
operator|=
literal|1
expr_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits      so that each uninitialized object starts on such a boundary.  */
name|rounded
operator|+=
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|rounded
operator|=
operator|(
name|rounded
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|sect
operator|->
name|noswitch
operator|.
name|callback
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|DECL_ALIGN_UNIT
argument_list|(
name|decl
argument_list|)
operator|>
name|rounded
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"requested alignment for %q+D is greater than "
literal|"implemented alignment of %wu"
argument_list|,
name|decl
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assemble_variable.  Output the label and contents of    DECL, whose address is a SYMBOL_REF with name NAME.  DONT_OUTPUT_DATA    is as for assemble_variable.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_variable_contents
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|dont_output_data
parameter_list|)
block|{
comment|/* Do any machine/system dependent processing of the object.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
if|if
condition|(
operator|!
name|dont_output_data
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|initializer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* Output the actual data.  */
name|output_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Leave space for it.  */
name|assemble_zeros
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble everything that is needed for a variable or function declaration.    Not used for automatic variables, and not used for function definitions.    Should not be called for variables of incomplete structure type.     TOP_LEVEL is nonzero if this variable has file scope.    AT_END is nonzero if this is the special handling, at end of compilation,    to define things that have had only tentative definitions.    DONT_OUTPUT_DATA if nonzero means don't actually output the    initial value (that will be done by the caller).  */
end_comment

begin_function
name|void
name|assemble_variable
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|top_level
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|at_end
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|dont_output_data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|rtx
name|decl_rtl
decl_stmt|,
name|symbol
decl_stmt|;
name|section
modifier|*
name|sect
decl_stmt|;
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|prepare_assemble_variable
condition|)
name|lang_hooks
operator|.
name|decls
operator|.
name|prepare_assemble_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|last_assemble_variable_decl
operator|=
literal|0
expr_stmt|;
comment|/* Normally no need to say anything here for external references,      since assemble_external is called by the language-specific code      when a declaration is first seen.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output no assembler code for a function declaration.      Only definitions of functions output anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
comment|/* Do nothing for global register variables.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If type was incomplete when the variable was declared,      see if it is complete now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Still incomplete => don't allocate it; treat the tentative defn      (which is what it must have been) as an `extern' reference.  */
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"storage size of %q+D isn%'t known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Make sure targetm.encode_section_info is invoked before we set      ASM_WRITTEN.  */
name|decl_rtl
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do no output if -fsyntax-only.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
name|app_disable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of variable %q+D is too large"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|decl_rtl
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|notice_global_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Compute the alignment of this data.  */
name|align_variable
argument_list|(
name|decl
argument_list|,
name|dont_output_data
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|decl_rtl
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|maybe_assemble_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PRESERVE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|mark_decl_preserved
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* First make the assembler name(s) global if appropriate.  */
name|sect
operator|=
name|get_variable_section
argument_list|(
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|sect
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_COMMON
operator|)
operator|==
literal|0
condition|)
name|globalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output any data that we will need to use the address of.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|output_addressed_constants
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dbxout.c needs to know this.  */
if|if
condition|(
name|sect
operator|&&
operator|(
name|sect
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_CODE
operator|)
operator|!=
literal|0
condition|)
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If the decl is part of an object_block, make sure that the decl      has been positioned within its block, but do not write out its      definition yet.  output_object_blocks will do that later.  */
if|if
condition|(
name|SYMBOL_REF_HAS_BLOCK_INFO_P
argument_list|(
name|symbol
argument_list|)
operator|&&
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|dont_output_data
argument_list|)
expr_stmt|;
name|place_block_symbol
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SECTION_STYLE
argument_list|(
name|sect
argument_list|)
operator|==
name|SECTION_NOSWITCH
condition|)
name|assemble_noswitch_variable
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|sect
argument_list|)
expr_stmt|;
else|else
block|{
name|switch_to_section
argument_list|(
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|DECL_ALIGN_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_variable_contents
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|dont_output_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if type TYPE contains any pointers.  */
end_comment

begin_function
specifier|static
name|int
name|contains_pointers_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* I'm not sure whether OFFSET_TYPE needs this treatment, 	 so I'll play safe and return 1.  */
case|case
name|OFFSET_TYPE
case|:
return|return
literal|1
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|fields
decl_stmt|;
comment|/* For a type that has fields, see if the fields have pointers.  */
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
comment|/* An array type contains pointers if its element type does.  */
return|return
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* In unit-at-a-time mode, we delay assemble_external processing until    the compilation unit is finalized.  This is the best we can do for    right now (i.e. stage 3 of GCC 4.0) - the right thing is to delay    it all the way to final.  See PR 17982 for further discussion.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_assemble_externals
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
end_ifdef

begin_comment
comment|/* True if DECL is a function decl for which no out-of-line copy exists.    It is assumed that DECL's assembler name has been set.  */
end_comment

begin_function
specifier|static
name|bool
name|incorporeal_function_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_ALLOCA
condition|)
return|return
name|true
return|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|,
name|strlen
argument_list|(
literal|"__builtin_"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Actually do the tests to determine if this is necessary, and invoke    ASM_OUTPUT_EXTERNAL.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_external_real
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|rtl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|incorporeal_function_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Some systems do require some output.  */
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|process_pending_assemble_externals
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
name|tree
name|list
decl_stmt|;
for|for
control|(
name|list
operator|=
name|pending_assemble_externals
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
name|assemble_external_real
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|pending_assemble_externals
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output something to declare an external symbol to the assembler.    (Most assemblers don't need this, so we normally output nothing.)    Do nothing if DECL is not external.  */
end_comment

begin_function
name|void
name|assemble_external
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Because most platforms do not define ASM_OUTPUT_EXTERNAL, the      main body of this code is only rarely exercised.  To provide some      testing, on all platforms, we make sure that the ASM_OUT_FILE is      open.  If it's not, we should not be calling this function.  */
name|gcc_assert
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
name|pending_assemble_externals
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|decl
argument_list|,
name|pending_assemble_externals
argument_list|)
expr_stmt|;
else|else
name|assemble_external_real
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Similar, for calling a library function FUN.  */
end_comment

begin_function
name|void
name|assemble_external_libcall
parameter_list|(
name|rtx
name|fun
parameter_list|)
block|{
comment|/* Declare library function name external when first used, if nec.  */
if|if
condition|(
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
operator|=
literal|1
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|external_libcall
argument_list|(
name|fun
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a label named NAME.  */
end_comment

begin_function
name|void
name|assemble_label
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the symbol_referenced flag for ID.  */
end_comment

begin_function
name|void
name|mark_referenced
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the symbol_referenced flag for DECL and notify callgraph.  */
end_comment

begin_function
name|void
name|mark_decl_referenced
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Extern inline functions don't become needed when referenced. 	 If we know a method will be emitted in other TU and no new 	 functions can be marked reachable, just use the external 	 definition.  */
name|struct
name|cgraph_node
modifier|*
name|node
init|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|node
operator|->
name|local
operator|.
name|vtable_method
operator|||
operator|!
name|cgraph_global_info_ready
operator|||
operator|!
name|node
operator|->
name|local
operator|.
name|finalized
operator|)
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
init|=
name|cgraph_varpool_node
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|cgraph_varpool_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* C++ frontend use mark_decl_references to force COMDAT variables          to be output that might appear dead otherwise.  */
name|node
operator|->
name|force_output
operator|=
name|true
expr_stmt|;
block|}
comment|/* else do nothing - we can get various sorts of CST nodes here,      which do not need to be marked.  */
block|}
end_function

begin_comment
comment|/* Follow the IDENTIFIER_TRANSPARENT_ALIAS chain starting at *ALIAS    until we find an identifier that is not itself a transparent alias.    Modify the alias passed to it by reference (and all aliases on the    way to the ultimate target), such that they do not have to be    followed again, and return the ultimate target of the alias    chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|ultimate_transparent_alias_target
parameter_list|(
name|tree
modifier|*
name|alias
parameter_list|)
block|{
name|tree
name|target
init|=
operator|*
name|alias
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_TRANSPARENT_ALIAS
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|TREE_CHAIN
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|IDENTIFIER_TRANSPARENT_ALIAS
argument_list|(
name|target
argument_list|)
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|alias
operator|=
name|target
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Output to FILE (an assembly file) a reference to NAME.  If NAME    starts with a *, the rest of NAME is output verbatim.  Otherwise    NAME is transformed in a target-specific way (usually by the    addition of an underscore).  */
end_comment

begin_function
name|void
name|assemble_name_raw
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|fputs
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like assemble_name_raw, but should be used when NAME might refer to    an entity that is also represented as a tree (like a function or    variable).  If NAME does refer to such an entity, that entity will    be marked as referenced.  */
end_comment

begin_function
name|void
name|assemble_name
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|real_name
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|tree
name|id_orig
init|=
name|id
decl_stmt|;
name|mark_referenced
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|id_orig
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TREE_CHAIN
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assemble_name_raw
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes writable static space with a gensym name    and return an RTX to refer to its address.  */
end_comment

begin_function
name|rtx
name|assemble_static_space
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|namestring
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LF"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|namestring
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|x
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits        so that each uninitialized object starts on such a boundary.  */
comment|/* Variable `rounded' might or might not be used in ASM_OUTPUT_LOCAL.  */
name|unsigned
name|HOST_WIDE_INT
name|rounded
name|ATTRIBUTE_UNUSED
init|=
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Assemble the static constant template for function entry trampolines.    This is done at most once per compilation.    Returns an RTX for the address of the template.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|initial_trampoline
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
end_ifdef

begin_function
name|rtx
name|assemble_trampoline_template
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|align
decl_stmt|;
name|rtx
name|symbol
decl_stmt|;
if|if
condition|(
name|initial_trampoline
condition|)
return|return
name|initial_trampoline
return|;
comment|/* By default, put trampoline templates in read-only data section.  */
ifdef|#
directive|ifdef
name|TRAMPOLINE_SECTION
name|switch_to_section
argument_list|(
name|TRAMPOLINE_SECTION
argument_list|)
expr_stmt|;
else|#
directive|else
name|switch_to_section
argument_list|(
name|readonly_data_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write the assembler code to define one.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRAMPOLINE_TEMPLATE
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Record the rtl to refer to it.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|ggc_strdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|initial_trampoline
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|initial_trampoline
argument_list|,
name|TRAMPOLINE_ALIGNMENT
argument_list|)
expr_stmt|;
return|return
name|initial_trampoline
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A and B are either alignments or offsets.  Return the minimum alignment    that may be assumed after adding the two together.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|min_align
parameter_list|(
name|unsigned
name|int
name|a
parameter_list|,
name|unsigned
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator||
name|b
operator|)
operator|&
operator|-
operator|(
name|a
operator||
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the assembler directive for creating a given kind of integer    object.  SIZE is the number of bytes in the object and ALIGNED_P    indicates whether it is known to be aligned.  Return NULL if the    assembly dialect has no such directive.     The returned string should be printed at the start of a new line and    be followed immediately by the object's initial value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|integer_asm_op
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
name|struct
name|asm_int_op
modifier|*
name|ops
decl_stmt|;
if|if
condition|(
name|aligned_p
condition|)
name|ops
operator|=
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|aligned_op
expr_stmt|;
else|else
name|ops
operator|=
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|targetm
operator|.
name|asm_out
operator|.
name|byte_op
return|;
case|case
literal|2
case|:
return|return
name|ops
operator|->
name|hi
return|;
case|case
literal|4
case|:
return|return
name|ops
operator|->
name|si
return|;
case|case
literal|8
case|:
return|return
name|ops
operator|->
name|di
return|;
case|case
literal|16
case|:
return|return
name|ops
operator|->
name|ti
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Use directive OP to assemble an integer object X.  Print OP at the    start of the line, followed immediately by the value of X.  */
end_comment

begin_function
name|void
name|assemble_integer_with_op
parameter_list|(
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|fputs
argument_list|(
name|op
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The default implementation of the asm_out.integer target hook.  */
end_comment

begin_function
name|bool
name|default_assemble_integer
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|aligned_p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|op
init|=
name|integer_asm_op
argument_list|(
name|size
argument_list|,
name|aligned_p
argument_list|)
decl_stmt|;
comment|/* Avoid GAS bugs for large values.  Specifically negative values whose      absolute value fits in a bfd_vma, but not in a bfd_signed_vma.  */
if|if
condition|(
name|size
operator|>
name|UNITS_PER_WORD
operator|&&
name|size
operator|>
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
condition|)
return|return
name|false
return|;
return|return
name|op
operator|&&
operator|(
name|assemble_integer_with_op
argument_list|(
name|op
argument_list|,
name|x
argument_list|)
operator|,
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is    the alignment of the integer in bits.  Return 1 if we were able to output    the constant, otherwise 0.  We must be able to output the constant,    if FORCE is nonzero.  */
end_comment

begin_function
name|bool
name|assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|int
name|aligned_p
decl_stmt|;
name|aligned_p
operator|=
operator|(
name|align
operator|>=
name|MIN
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|)
expr_stmt|;
comment|/* See if the target hook can handle this kind of object.  */
if|if
condition|(
name|targetm
operator|.
name|asm_out
operator|.
name|integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If the object is a multi-byte one, try splitting it up.  Split      it into words it if is multi-word, otherwise split it into bytes.  */
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|omode
decl_stmt|,
name|imode
decl_stmt|;
name|unsigned
name|int
name|subalign
decl_stmt|;
name|unsigned
name|int
name|subsize
decl_stmt|,
name|i
decl_stmt|;
name|subsize
operator|=
name|size
operator|>
name|UNITS_PER_WORD
condition|?
name|UNITS_PER_WORD
else|:
literal|1
expr_stmt|;
name|subalign
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|subsize
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|omode
operator|=
name|mode_for_size
argument_list|(
name|subsize
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|subsize
control|)
block|{
name|rtx
name|partial
init|=
name|simplify_subreg
argument_list|(
name|omode
argument_list|,
name|x
argument_list|,
name|imode
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|partial
operator|||
operator|!
name|assemble_integer
argument_list|(
name|partial
argument_list|,
name|subsize
argument_list|,
name|subalign
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|size
condition|)
return|return
name|true
return|;
comment|/* If we've printed some of it, but not all of it, there's no going 	 back now.  */
name|gcc_assert
argument_list|(
operator|!
name|i
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|force
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|assemble_real
parameter_list|(
name|REAL_VALUE_TYPE
name|d
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|long
name|data
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|nelts
decl_stmt|,
name|nunits
decl_stmt|,
name|units_per
decl_stmt|;
comment|/* This is hairy.  We have a quantity of known size.  real_to_target      will put it into an array of *host* longs, 32 bits per element      (even if long is more than 32 bits).  We need to determine the      number of array elements that are occupied (nelts) and the number      of *target* min-addressable units that will be occupied in the      object file (nunits).  We cannot assume that 32 divides the      mode's bitsize (size * BITS_PER_UNIT) evenly.       size * BITS_PER_UNIT is used here to make sure that padding bits      (which might appear at either end of the value; real_to_target      will include the padding bits in its output array) are included.  */
name|nunits
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|nunits
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|nelts
operator|=
name|CEIL
argument_list|(
name|bitsize
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|units_per
operator|=
literal|32
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|real_to_target
argument_list|(
name|data
argument_list|,
operator|&
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Put out the first word with the specified alignment.  */
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|nunits
argument_list|,
name|units_per
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nunits
operator|-=
name|units_per
expr_stmt|;
comment|/* Subsequent words need only 32-bit alignment.  */
name|align
operator|=
name|min_align
argument_list|(
name|align
argument_list|,
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|nunits
argument_list|,
name|units_per
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nunits
operator|-=
name|units_per
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP with a constant value,    reduce it to the sum of an assembler symbol and an integer.    Store them both in the structure *VALUE.    EXP must be reducible.  */
end_comment

begin_decl_stmt
name|struct
name|addr_const
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|tree
name|exp
parameter_list|,
name|struct
name|addr_const
modifier|*
name|value
parameter_list|)
block|{
name|tree
name|target
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|host_integerp
argument_list|(
name|byte_position
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|int_byte_position
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|offset
operator|+=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|x
operator|=
name|DECL_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|force_label_rtx
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|INTEGER_CST
case|:
name|x
operator|=
name|output_constant_def
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Uniquize all constants that appear in memory.    Each constant in memory thus far output is recorded    in `const_desc_table'.  */
end_comment

begin_decl_stmt
name|struct
name|constant_descriptor_tree
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* A MEM for the constant.  */
name|rtx
name|rtl
decl_stmt|;
comment|/* The value of the constant.  */
name|tree
name|value
decl_stmt|;
comment|/* Hash of value.  Computing the hash from value each time      hashfn is called can't work properly, as that means recursive      use of the hash table during hash table expansion.  */
name|hashval_t
name|hash
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct constant_descriptor_tree))
argument_list|)
name|htab_t
name|const_desc_htab
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|constant_descriptor_tree
modifier|*
name|build_constant_desc
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_output_constant_def_contents
parameter_list|(
name|struct
name|constant_descriptor_tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Compute a hash code for a constant expression.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_desc_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|constant_descriptor_tree
operator|*
operator|)
name|ptr
operator|)
operator|->
name|hash
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|const_hash_1
parameter_list|(
specifier|const
name|tree
name|exp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|hashval_t
name|hi
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Either set P and LEN to the address and len of something to hash and      exit the switch or return a value.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_INT_CST
operator|(
name|exp
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
return|return
name|real_hash
argument_list|(
name|TREE_REAL_CST_PTR
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|const_hash_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|*
literal|5
operator|+
name|const_hash_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|hi
operator|=
literal|5
operator|+
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|value
argument_list|)
if|if
condition|(
name|value
condition|)
name|hi
operator|=
name|hi
operator|*
literal|603
operator|+
name|const_hash_1
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|hi
return|;
block|}
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* Don't hash the address of the SYMBOL_REF; 	       only use the offset and the symbol name.  */
name|hi
operator|=
name|value
operator|.
name|offset
expr_stmt|;
name|p
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|hi
operator|=
name|value
operator|.
name|offset
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|13
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|hi
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
operator|(
name|const_hash_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|9
operator|+
name|const_hash_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|const_hash_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|7
operator|+
literal|2
return|;
default|default:
comment|/* A language specific constant. Just hash the code.  */
return|return
name|code
return|;
block|}
comment|/* Compute hashing function.  */
name|hi
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_comment
comment|/* Wrapper of compare_constant, for the htab interface.  */
end_comment

begin_function
specifier|static
name|int
name|const_desc_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|constant_descriptor_tree
modifier|*
name|c1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|constant_descriptor_tree
modifier|*
name|c2
init|=
name|p2
decl_stmt|;
if|if
condition|(
name|c1
operator|->
name|hash
operator|!=
name|c2
operator|->
name|hash
condition|)
return|return
literal|0
return|;
return|return
name|compare_constant
argument_list|(
name|c1
operator|->
name|value
argument_list|,
name|c2
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare t1 and t2, and return 1 only if they are known to result in    the same bit pattern on output.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant
parameter_list|(
specifier|const
name|tree
name|t1
parameter_list|,
specifier|const
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|typecode
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t2
operator|==
name|NULL_TREE
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* Integer constants are the same only if the same width of type.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|tree_int_cst_equal
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* Real constants are the same only if the same width of type.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|compare_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REALPART
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
name|compare_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v1
operator|,
operator|*
name|v2
expr_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typecode
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|typecode
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size_1
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For arrays, check that the sizes all match.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|||
name|size_1
operator|==
operator|-
literal|1
operator|||
name|size_1
operator|!=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* For record and union constructors, require exact type                equality.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|v1
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v1
argument_list|)
operator|!=
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v2
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v1
argument_list|)
condition|;
operator|++
name|idx
control|)
block|{
name|constructor_elt
modifier|*
name|c1
init|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v1
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|constructor_elt
modifier|*
name|c2
init|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v2
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|/* Check that each value is the same...  */
if|if
condition|(
operator|!
name|compare_constant
argument_list|(
name|c1
operator|->
name|value
argument_list|,
name|c2
operator|->
name|value
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... and that they apply to the same fields!  */
if|if
condition|(
name|typecode
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|compare_constant
argument_list|(
name|c1
operator|->
name|index
argument_list|,
name|c2
operator|->
name|index
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|c1
operator|->
name|index
operator|!=
name|c2
operator|->
name|index
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
block|{
name|struct
name|addr_const
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|decode_addr_const
argument_list|(
name|t1
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
name|decode_addr_const
argument_list|(
name|t2
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
return|return
operator|(
name|value1
operator|.
name|offset
operator|==
name|value2
operator|.
name|offset
operator|&&
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|value1
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|value2
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|RANGE_EXPR
case|:
return|return
operator|(
name|compare_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|compare_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
return|return
name|compare_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
block|{
name|tree
name|nt1
decl_stmt|,
name|nt2
decl_stmt|;
name|nt1
operator|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|nt2
operator|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt1
operator|!=
name|t1
operator|||
name|nt2
operator|!=
name|t2
condition|)
return|return
name|compare_constant
argument_list|(
name|nt1
argument_list|,
name|nt2
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of the whole tree structure for a constant.  This    handles the same types of nodes that compare_constant handles.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_constant
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* For ADDR_EXPR, we do not want to copy the decl whose address 	 is requested.  We do want to copy constants though.  */
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|build_complex
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|tree
name|copy
init|=
name|copy_node
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
expr_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|;
name|v
operator|=
name|VEC_alloc
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|purpose
argument_list|,
argument|value
argument_list|)
block|{
name|constructor_elt
modifier|*
name|ce
init|=
name|VEC_quick_push
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|ce
operator|->
name|index
operator|=
name|purpose
expr_stmt|;
name|ce
operator|->
name|value
operator|=
name|copy_constant
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|CONSTRUCTOR_ELTS
argument_list|(
name|copy
argument_list|)
operator|=
name|v
expr_stmt|;
return|return
name|copy
return|;
block|}
default|default:
block|{
name|tree
name|t
init|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|t
operator|!=
name|exp
argument_list|)
expr_stmt|;
return|return
name|copy_constant
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the alignment of constant EXP in bits.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_constant_alignment
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Return the section into which constant EXP should be placed.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|get_constant_section
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|get_named_section
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|,
name|compute_reloc_for_constant
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
else|else
return|return
name|targetm
operator|.
name|asm_out
operator|.
name|select_section
argument_list|(
name|exp
argument_list|,
name|compute_reloc_for_constant
argument_list|(
name|exp
argument_list|)
argument_list|,
name|get_constant_alignment
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of constant EXP in bytes.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|get_constant_size
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
name|size
operator|=
name|MAX
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_constant_def:    No constant equal to EXP is known to have been output.    Make a constant descriptor to enter EXP in the hash table.    Assign the label number and construct RTL to refer to the    constant's location in memory.    Caller is responsible for updating the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor_tree
modifier|*
name|build_constant_desc
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|rtx
name|symbol
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|value
operator|=
name|copy_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Propagate marked-ness to copied constant.  */
if|if
condition|(
name|flag_mudflap
operator|&&
name|mf_marked_p
argument_list|(
name|exp
argument_list|)
condition|)
name|mf_mark
argument_list|(
name|desc
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|labelno
operator|=
name|const_labelno
operator|++
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
if|if
condition|(
name|use_object_blocks_p
argument_list|()
condition|)
block|{
name|section
modifier|*
name|sect
init|=
name|get_constant_section
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|symbol
operator|=
name|create_block_symbol
argument_list|(
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|,
name|get_block_for_section
argument_list|(
name|sect
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|SET_SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|,
name|desc
operator|->
name|value
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|rtl
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|rtl
argument_list|,
name|const_alias_set
argument_list|)
expr_stmt|;
comment|/* Set flags or add text to the name to record information, such as      that it is a local symbol.  If the name is changed, the macro      ASM_OUTPUT_LABELREF will have to know how to strip this      information.  This call might invalidate our local variable      SYMBOL; we can't use it afterward.  */
name|targetm
operator|.
name|encode_section_info
argument_list|(
name|exp
argument_list|,
name|rtl
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|desc
operator|->
name|rtl
operator|=
name|rtl
expr_stmt|;
return|return
name|desc
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing a reference to constant data in memory    for the constant expression EXP.     If assembler code for such a constant has already been output,    return an rtx to refer to it.    Otherwise, output such a constant in memory    and generate an rtx for it.     If DEFER is nonzero, this constant can be deferred and output only    if referenced in the function after all optimizations.     `const_desc_table' records which constants already have label strings.  */
end_comment

begin_function
name|rtx
name|output_constant_def
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|defer
parameter_list|)
block|{
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
decl_stmt|;
name|struct
name|constant_descriptor_tree
name|key
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Look up EXP in the table of constant descriptors.  If we didn't find      it, create a new one.  */
name|key
operator|.
name|value
operator|=
name|exp
expr_stmt|;
name|key
operator|.
name|hash
operator|=
name|const_hash_1
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|const_desc_htab
argument_list|,
operator|&
name|key
argument_list|,
name|key
operator|.
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
name|desc
operator|==
literal|0
condition|)
block|{
name|desc
operator|=
name|build_constant_desc
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|hash
operator|=
name|key
operator|.
name|hash
expr_stmt|;
operator|*
name|loc
operator|=
name|desc
expr_stmt|;
block|}
name|maybe_output_constant_def_contents
argument_list|(
name|desc
argument_list|,
name|defer
argument_list|)
expr_stmt|;
return|return
name|desc
operator|->
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_constant_def: Decide whether or not we need to    output the constant DESC now, and if so, do it.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_output_constant_def_contents
parameter_list|(
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
parameter_list|,
name|int
name|defer
parameter_list|)
block|{
name|rtx
name|symbol
init|=
name|XEXP
argument_list|(
name|desc
operator|->
name|rtl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|exp
init|=
name|desc
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* Already output; don't do it again.  */
return|return;
comment|/* We can always defer constants as long as the context allows      doing so.  */
if|if
condition|(
name|defer
condition|)
block|{
comment|/* Increment n_deferred_constants if it exists.  It needs to be at 	 least as large as the number of constants actually referred to 	 by the function.  If it's too small we'll stop looking too early 	 and fail to emit constants; if it's too large we'll only look 	 through the entire function when we could have stopped earlier.  */
if|if
condition|(
name|cfun
condition|)
name|n_deferred_constants
operator|++
expr_stmt|;
return|return;
block|}
name|output_constant_def_contents
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_constant_def_contents.  Output the definition    of constant EXP, which is pointed to by label LABEL.  ALIGN is the    constant's alignment in bits.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_constant_contents
parameter_list|(
name|tree
name|exp
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|size
operator|=
name|get_constant_size
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Do any machine/system dependent processing of the constant.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_CONSTANT_NAME
name|ASM_DECLARE_CONSTANT_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the constant.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_CONSTANT_NAME */
comment|/* Output the value of EXP.  */
name|output_constant
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We must output the constant data referred to by SYMBOL; do so.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_def_contents
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
name|tree
name|exp
init|=
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* Make sure any other constants whose addresses appear in EXP      are assigned label numbers.  */
name|output_addressed_constants
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We are no longer deferring this constant.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If the constant is part of an object block, make sure that the      decl has been positioned within its block, but do not write out      its definition yet.  output_object_blocks will do that later.  */
if|if
condition|(
name|SYMBOL_REF_HAS_BLOCK_INFO_P
argument_list|(
name|symbol
argument_list|)
operator|&&
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
condition|)
name|place_block_symbol
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
else|else
block|{
name|switch_to_section
argument_list|(
name|get_constant_section
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|get_constant_alignment
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_constant_contents
argument_list|(
name|exp
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_mudflap
condition|)
name|mudflap_enqueue_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up EXP in the table of constant descriptors.  Return the rtl    if it has been emitted, else null.  */
end_comment

begin_function
name|rtx
name|lookup_constant_def
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|struct
name|constant_descriptor_tree
modifier|*
name|desc
decl_stmt|;
name|struct
name|constant_descriptor_tree
name|key
decl_stmt|;
name|key
operator|.
name|value
operator|=
name|exp
expr_stmt|;
name|key
operator|.
name|hash
operator|=
name|const_hash_1
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|desc
operator|=
name|htab_find_with_hash
argument_list|(
name|const_desc_htab
argument_list|,
operator|&
name|key
argument_list|,
name|key
operator|.
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
condition|?
name|desc
operator|->
name|rtl
else|:
name|NULL_RTX
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used in the hash tables to avoid outputting the same constant    twice.  Unlike 'struct constant_descriptor_tree', RTX constants    are output once per function, not once per file.  */
end_comment

begin_comment
comment|/* ??? Only a few targets need per-function constant pools.  Most    can use one per-file pool.  Should add a targetm bit to tell the    difference.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_constant_pool
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Pointers to first and last constant in pool, as ordered by offset.  */
name|struct
name|constant_descriptor_rtx
modifier|*
name|first
decl_stmt|;
name|struct
name|constant_descriptor_rtx
modifier|*
name|last
decl_stmt|;
comment|/* Hash facility for making memory-constants from constant rtl-expressions.      It is used on RISC machines where immediate integer arguments and      constant addresses are restricted so that such constants must be stored      in memory.  */
name|htab_t
name|GTY
argument_list|(
operator|(
name|param_is
argument_list|(
expr|struct
name|constant_descriptor_rtx
argument_list|)
operator|)
argument_list|)
name|const_rtx_htab
decl_stmt|;
comment|/* Current offset in constant pool (does not include any      machine-specific header).  */
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|constant_descriptor_rtx
name|GTY
argument_list|(
operator|(
name|chain_next
argument_list|(
literal|"%h.next"
argument_list|)
operator|)
argument_list|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|next
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|sym
decl_stmt|;
name|rtx
name|constant
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|int
name|mark
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Hash and compare functions for const_rtx_htab.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_desc_rtx_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
init|=
name|ptr
decl_stmt|;
return|return
name|desc
operator|->
name|hash
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|const_desc_rtx_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|constant_descriptor_rtx
modifier|*
name|x
init|=
name|a
decl_stmt|;
specifier|const
name|struct
name|constant_descriptor_rtx
modifier|*
name|y
init|=
name|b
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|mode
operator|!=
name|y
operator|->
name|mode
condition|)
return|return
literal|0
return|;
return|return
name|rtx_equal_p
argument_list|(
name|x
operator|->
name|constant
argument_list|,
name|y
operator|->
name|constant
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is the worker function for const_rtx_hash, called via for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|const_rtx_hash_1
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|hwi
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|hashval_t
name|h
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|x
operator|=
operator|*
name|xp
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|hashval_t
operator|)
name|code
operator|*
literal|1048573
operator|+
name|mode
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
name|hwi
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fold_hwi
label|:
block|{
specifier|const
name|int
name|shift
init|=
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
operator|*
name|CHAR_BIT
decl_stmt|;
specifier|const
name|int
name|n
init|=
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|h
operator|^=
operator|(
name|hashval_t
operator|)
name|hwi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|hwi
operator|>>=
name|shift
expr_stmt|;
name|h
operator|^=
operator|(
name|hashval_t
operator|)
name|hwi
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|hwi
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|^
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|fold_hwi
goto|;
block|}
else|else
name|h
operator|^=
name|real_hash
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_VECTOR
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
name|h
operator|=
name|h
operator|*
literal|251
operator|+
name|const_rtx_hash_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SYMBOL_REF
case|:
name|h
operator|^=
name|htab_hash_string
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|h
operator|=
name|h
operator|*
literal|251
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
name|h
operator|=
name|h
operator|*
literal|251
operator|+
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|hp
operator|=
name|data
expr_stmt|;
operator|*
name|hp
operator|=
operator|*
name|hp
operator|*
literal|509
operator|+
name|h
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash value for X, which should be a constant.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|const_rtx_hash
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|hashval_t
name|h
init|=
literal|0
decl_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|const_rtx_hash_1
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and return a new rtx constant pool.  */
end_comment

begin_function
specifier|static
name|struct
name|rtx_constant_pool
modifier|*
name|create_constant_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|rtx_constant_pool
modifier|*
name|pool
decl_stmt|;
name|pool
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_constant_pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|const_rtx_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|const_desc_rtx_hash
argument_list|,
name|const_desc_rtx_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Initialize constant pool hashing for a new function.  */
end_comment

begin_function
name|void
name|init_varasm_status
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|varasm_status
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|varasm_status
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|varasm
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|pool
operator|=
name|create_constant_pool
argument_list|()
expr_stmt|;
name|p
operator|->
name|deferred_constants
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a MINUS expression, simplify it if both sides    include the same symbol.  */
end_comment

begin_function
name|rtx
name|simplify_subtraction
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|r
init|=
name|simplify_rtx
argument_list|(
name|x
argument_list|)
decl_stmt|;
return|return
name|r
condition|?
name|r
else|:
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant rtx X, make (or find) a memory constant for its value    and return a MEM rtx to refer to it in memory.  */
end_comment

begin_function
name|rtx
name|force_const_mem
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|rtx_constant_pool
modifier|*
name|pool
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|def
decl_stmt|,
name|symbol
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* If we're not allowed to drop X into the constant pool, don't.  */
if|if
condition|(
name|targetm
operator|.
name|cannot_force_const_mem
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Record that this function has used a constant pool entry.  */
name|current_function_uses_const_pool
operator|=
literal|1
expr_stmt|;
comment|/* Decide which pool to use.  */
name|pool
operator|=
operator|(
name|targetm
operator|.
name|use_blocks_for_constant_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|?
name|shared_constant_pool
else|:
name|cfun
operator|->
name|varasm
operator|->
name|pool
operator|)
expr_stmt|;
comment|/* Lookup the value in the hashtable.  */
name|tmp
operator|.
name|constant
operator|=
name|x
expr_stmt|;
name|tmp
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|hash
operator|=
name|const_rtx_hash
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|pool
operator|->
name|const_rtx_htab
argument_list|,
operator|&
name|tmp
argument_list|,
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|*
name|slot
expr_stmt|;
comment|/* If the constant was already present, return its memory.  */
if|if
condition|(
name|desc
condition|)
return|return
name|copy_rtx
argument_list|(
name|desc
operator|->
name|mem
argument_list|)
return|;
comment|/* Otherwise, create a new descriptor.  */
name|desc
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|desc
expr_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
operator|==
name|VOIDmode
condition|?
name|word_mode
else|:
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
block|{
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|make_tree
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pool
operator|->
name|offset
operator|+=
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|pool
operator|->
name|offset
operator|&=
operator|~
operator|(
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|constant
operator|=
name|tmp
operator|.
name|constant
expr_stmt|;
name|desc
operator|->
name|offset
operator|=
name|pool
operator|->
name|offset
expr_stmt|;
name|desc
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|desc
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|desc
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|desc
operator|->
name|labelno
operator|=
name|const_labelno
expr_stmt|;
name|desc
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|last
condition|)
name|pool
operator|->
name|last
operator|->
name|next
operator|=
name|desc
expr_stmt|;
else|else
name|pool
operator|->
name|first
operator|=
name|pool
operator|->
name|last
operator|=
name|desc
expr_stmt|;
name|pool
operator|->
name|last
operator|=
name|desc
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
comment|/* Construct the SYMBOL_REF.  Make sure to mark it as belonging to      the constants pool.  */
if|if
condition|(
name|use_object_blocks_p
argument_list|()
operator|&&
name|targetm
operator|.
name|use_blocks_for_constant_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|section
modifier|*
name|sect
init|=
name|targetm
operator|.
name|asm_out
operator|.
name|select_rtx_section
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
decl_stmt|;
name|symbol
operator|=
name|create_block_symbol
argument_list|(
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|,
name|get_block_for_section
argument_list|(
name|sect
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|sym
operator|=
name|symbol
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_SYMBOL_REF_CONSTANT
argument_list|(
name|symbol
argument_list|,
name|desc
argument_list|)
expr_stmt|;
comment|/* Construct the MEM.  */
name|desc
operator|->
name|mem
operator|=
name|def
operator|=
name|gen_const_mem
argument_list|(
name|mode
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|def
argument_list|,
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|def
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* If we're dropping a label to the constant pool, make sure we      don't delete it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|LABEL_PRESERVE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|copy_rtx
argument_list|(
name|def
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */
end_comment

begin_function
name|rtx
name|get_pool_constant
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
return|return
name|SYMBOL_REF_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant    and whether it has been output or not.  */
end_comment

begin_function
name|rtx
name|get_pool_constant_mark
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|bool
modifier|*
name|pmarked
parameter_list|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|SYMBOL_REF_CONSTANT
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|*
name|pmarked
operator|=
operator|(
name|desc
operator|->
name|mark
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|desc
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the mode.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_pool_mode
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
return|return
name|SYMBOL_REF_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cfun
operator|->
name|varasm
operator|->
name|pool
operator|->
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Worker function for output_constant_pool_1.  Emit assembly for X    in MODE with known alignment ALIGN.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_pool_2
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_DECIMAL_FLOAT
case|:
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
name|align
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
name|assemble_integer
argument_list|(
name|x
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_VECTOR_FLOAT
case|:
case|case
name|MODE_VECTOR_INT
case|:
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
name|enum
name|machine_mode
name|submode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|subalign
init|=
name|MIN
argument_list|(
name|align
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|submode
argument_list|)
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
argument_list|)
expr_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|output_constant_pool_2
argument_list|(
name|submode
argument_list|,
name|elt
argument_list|,
name|i
condition|?
name|subalign
else|:
name|align
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Worker function for output_constant_pool.  Emit constant DESC,    giving it ALIGN bits of alignment.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_pool_1
parameter_list|(
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|,
name|tmp
decl_stmt|;
name|x
operator|=
name|desc
operator|->
name|constant
expr_stmt|;
comment|/* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF)      whose CODE_LABEL has been deleted.  This can occur if a jump table      is eliminated by optimization.  If so, write a constant of zero      instead.  Note that this can also happen by turning the      CODE_LABEL into a NOTE.  */
comment|/* ??? This seems completely and utterly wrong.  Certainly it's      not true for NOTE_INSN_DELETED_LABEL, but I disbelieve proper      functioning even with INSN_DELETED_P and friends.  */
name|tmp
operator|=
name|x
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
break|break;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU  */
case|case
name|LABEL_REF
case|:
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|NOTE_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|desc
operator|->
name|mode
argument_list|,
name|align
argument_list|,
name|desc
operator|->
name|labelno
argument_list|,
name|done
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assemble_align
argument_list|(
name|align
argument_list|)
expr_stmt|;
comment|/* Output the label.  */
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|desc
operator|->
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the data.  */
name|output_constant_pool_2
argument_list|(
name|desc
operator|->
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Make sure all constants in SECTION_MERGE and not SECTION_STRINGS      sections have proper size.  */
if|if
condition|(
name|align
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|desc
operator|->
name|mode
argument_list|)
operator|&&
name|in_section
operator|&&
operator|(
name|in_section
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_MERGE
operator|)
condition|)
name|assemble_align
argument_list|(
name|align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|done
label|:
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers    to as used.  Emit referenced deferred strings.  This function can    be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */
end_comment

begin_function
specifier|static
name|int
name|mark_constant
parameter_list|(
name|rtx
modifier|*
name|current_rtx
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|current_rtx
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
init|=
name|SYMBOL_REF_CONSTANT
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|->
name|mark
operator|==
literal|0
condition|)
block|{
name|desc
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|desc
operator|->
name|constant
argument_list|,
name|mark_constant
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tree
name|exp
init|=
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|n_deferred_constants
operator|--
expr_stmt|;
name|output_constant_def_contents
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Look through appropriate parts of INSN, marking all entries in the    constant pool which are actually being used.  Entries that are only    referenced by other constants are also marked as used.  Emit    deferred strings that are used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_constants
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* Insns may appear inside a SEQUENCE.  Only check the patterns of      insns, not any notes that may be attached.  We don't want to mark      a constant just because it happens to appear in a REG_EQUIV note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|seq
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
init|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|subinsn
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|subinsn
argument_list|)
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|subinsn
argument_list|)
argument_list|,
name|mark_constant
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_constant
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the instructions for this function, and mark all the    entries in POOL which are actually being used.  Emit deferred constants    which have indeed been used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_constant_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|current_function_uses_const_pool
operator|&&
name|n_deferred_constants
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|mark_constants
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_function_epilogue_delay_list
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|mark_constants
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write all the constants in POOL.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_pool_contents
parameter_list|(
name|struct
name|rtx_constant_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|desc
operator|=
name|pool
operator|->
name|first
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|desc
operator|->
name|mark
condition|)
block|{
comment|/* If the constant is part of an object_block, make sure that 	   the constant has been positioned within its block, but do not 	   write out its definition yet.  output_object_blocks will do 	   that later.  */
if|if
condition|(
name|SYMBOL_REF_HAS_BLOCK_INFO_P
argument_list|(
name|desc
operator|->
name|sym
argument_list|)
operator|&&
name|SYMBOL_REF_BLOCK
argument_list|(
name|desc
operator|->
name|sym
argument_list|)
condition|)
name|place_block_symbol
argument_list|(
name|desc
operator|->
name|sym
argument_list|)
expr_stmt|;
else|else
block|{
name|switch_to_section
argument_list|(
name|targetm
operator|.
name|asm_out
operator|.
name|select_rtx_section
argument_list|(
name|desc
operator|->
name|mode
argument_list|,
name|desc
operator|->
name|constant
argument_list|,
name|desc
operator|->
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|output_constant_pool_1
argument_list|(
name|desc
argument_list|,
name|desc
operator|->
name|align
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark all constants that are used in the current function, then write    out the function's private constant pool.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_pool
parameter_list|(
specifier|const
name|char
modifier|*
name|fnname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|rtx_constant_pool
modifier|*
name|pool
init|=
name|cfun
operator|->
name|varasm
operator|->
name|pool
decl_stmt|;
comment|/* It is possible for gcc to call force_const_mem and then to later      discard the instructions which refer to the constant.  In such a      case we do not need to output the constant.  */
name|mark_constant_pool
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_PROLOGUE
name|ASM_OUTPUT_POOL_PROLOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|output_constant_pool_contents
argument_list|(
name|pool
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_EPILOGUE
name|ASM_OUTPUT_POOL_EPILOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write the contents of the shared constant pool.  */
end_comment

begin_function
name|void
name|output_shared_constant_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|output_constant_pool_contents
argument_list|(
name|shared_constant_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine what kind of relocations EXP may need.  */
end_comment

begin_function
name|int
name|compute_reloc_for_constant
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|int
name|reloc
init|=
literal|0
decl_stmt|,
name|reloc2
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|exp
operator|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
comment|/* Go inside any operations that get_inner_reference can handle and see 	 if what's inside is a constant: no need to do anything here for 	 addresses of variables or functions.  */
for|for
control|(
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
condition|)
name|reloc
operator||=
literal|2
expr_stmt|;
else|else
name|reloc
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator||=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reloc2
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The difference of two local labels is computable at link time.  */
if|if
condition|(
name|reloc
operator|==
literal|1
operator|&&
name|reloc2
operator|==
literal|1
condition|)
name|reloc
operator|=
literal|0
expr_stmt|;
else|else
name|reloc
operator||=
name|reloc2
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
name|reloc
operator|=
name|compute_reloc_for_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|tem
argument_list|)
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|reloc
operator||=
name|compute_reloc_for_constant
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Find all the constants whose addresses are referenced inside of EXP,    and make sure assembler code with a label has been output for each one.    Indicate whether an ADDR_EXPR has been encountered.  */
end_comment

begin_function
specifier|static
name|void
name|output_addressed_constants
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|exp
operator|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
comment|/* Go inside any operations that get_inner_reference can handle and see 	 if what's inside is a constant: no need to do anything here for 	 addresses of variables or functions.  */
for|for
control|(
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* If we have an initialized CONST_DECL, retrieve the initializer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|DECL_INITIAL
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constant_def
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|tem
argument_list|)
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|output_addressed_constants
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Whether a constructor CTOR is a valid static constant initializer if all    its elements are.  This used to be internal to initializer_constant_valid_p    and has been exposed to let other functions like categorize_ctor_elements    evaluate the property while walking a constructor for other purposes.  */
end_comment

begin_function
name|bool
name|constructor_static_from_elts_p
parameter_list|(
name|tree
name|ctor
parameter_list|)
block|{
return|return
operator|(
name|TREE_CONSTANT
argument_list|(
name|ctor
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|&&
operator|!
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|ctor
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if VALUE is a valid constant-valued expression    for use in initializing a static variable; one that can be an    element of a "constant" initializer.     Return null_pointer_node if the value is absolute;    if it is relocatable, return the variable that determines the relocation.    We assume that VALUE has been folded as much as possible;    therefore, we do not need to check for such things as    arithmetic-combinations of integers.  */
end_comment

begin_function
name|tree
name|initializer_constant_valid_p
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|endtype
parameter_list|)
block|{
comment|/* Give the front-end a chance to convert VALUE to something that      looks more like a constant to the back-end.  */
name|value
operator|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|constructor_static_from_elts_p
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|elt
decl_stmt|;
name|bool
name|absolute
init|=
name|true
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (value)
argument_list|,
argument|idx
argument_list|,
argument|elt
argument_list|)
block|{
name|tree
name|reloc
decl_stmt|;
name|reloc
operator|=
name|initializer_constant_valid_p
argument_list|(
name|elt
argument_list|,
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|reloc
operator|!=
name|null_pointer_node
condition|)
name|absolute
operator|=
name|false
expr_stmt|;
block|}
comment|/* For a non-absolute relocation, there is no single 	     variable that can be "the variable that determines the 	     relocation."  */
return|return
name|absolute
condition|?
name|null_pointer_node
else|:
name|error_mark_node
return|;
block|}
return|return
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|?
name|null_pointer_node
else|:
name|NULL_TREE
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
return|return
name|null_pointer_node
return|;
case|case
name|ADDR_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
name|value
operator|=
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
comment|/* "&(*a).f" is like unto pointer arithmetic.  If "a" turns out to 	     be a constant, this is old-skool offsetof-like nonsense.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
comment|/* Taking the address of a nested function involves a trampoline.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|decl_function_context
argument_list|(
name|value
argument_list|)
operator|&&
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|value
argument_list|)
operator|)
operator|||
name|DECL_DLLIMPORT_P
argument_list|(
name|value
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* "&{...}" requires a temporary to hold the constructed 	     object.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|value
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|src
decl_stmt|;
name|tree
name|src_type
decl_stmt|;
name|tree
name|dest_type
decl_stmt|;
name|src
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src_type
operator|=
name|TREE_TYPE
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dest_type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Allow conversions between pointer types, floating-point 	   types, and offset types.  */
if|if
condition|(
operator|(
name|POINTER_TYPE_P
argument_list|(
name|dest_type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|src_type
argument_list|)
operator|)
operator|||
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|dest_type
argument_list|)
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|src_type
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|dest_type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|src_type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|src
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow length-preserving conversions between integer types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|dest_type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|src_type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|dest_type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|src_type
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|src
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between other integer types only if 	   explicit value.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|dest_type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|src_type
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|initializer_constant_valid_p
argument_list|(
name|src
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|null_pointer_node
condition|)
return|return
name|null_pointer_node
return|;
break|break;
block|}
comment|/* Allow (int)&foo provided int is as wide as a pointer.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|dest_type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|src_type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|dest_type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|src_type
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|src
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Likewise conversions from int to pointers, but also allow 	   conversions from 0.  */
if|if
condition|(
operator|(
name|POINTER_TYPE_P
argument_list|(
name|dest_type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|dest_type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|src_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|dest_type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|src_type
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|src
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|dest_type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|src_type
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|src
argument_list|,
name|endtype
argument_list|)
return|;
block|}
comment|/* Allow conversions to struct or union types if the value 	   inside is okay.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dest_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|dest_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|src
argument_list|,
name|endtype
argument_list|)
return|;
block|}
break|break;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|>=
name|POINTER_SIZE
condition|)
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* If either term is absolute, use the other terms relocation.  */
if|if
condition|(
name|valid0
operator|==
name|null_pointer_node
condition|)
return|return
name|valid1
return|;
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
block|}
break|break;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|>=
name|POINTER_SIZE
condition|)
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* Win if second argument is absolute.  */
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
comment|/* Win if both arguments have the same relocation. 	     Then the value is absolute.  */
if|if
condition|(
name|valid0
operator|==
name|valid1
operator|&&
name|valid0
operator|!=
literal|0
condition|)
return|return
name|null_pointer_node
return|;
comment|/* Since GCC guarantees that string constants are unique in the 	     generated code, a subtraction between two copies of the same 	     constant string is absolute.  */
if|if
condition|(
name|valid0
operator|&&
name|TREE_CODE
argument_list|(
name|valid0
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|valid1
operator|&&
name|TREE_CODE
argument_list|(
name|valid1
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|operand_equal_p
argument_list|(
name|valid0
argument_list|,
name|valid1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
block|}
comment|/* Support narrowing differences.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|endtype
argument_list|)
condition|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Like STRIP_NOPS except allow the operand mode to widen. 	     This works around a feature of fold that simplifies 	     (int)(p1 - p2) to ((int)p1 - (int)p2) under the theory 	     that the narrower operation is cheaper.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|error_mark_node
operator|||
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|op0
operator|=
name|inner
expr_stmt|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|error_mark_node
operator|||
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|op1
operator|=
name|inner
expr_stmt|;
block|}
name|op0
operator|=
name|initializer_constant_valid_p
argument_list|(
name|op0
argument_list|,
name|endtype
argument_list|)
expr_stmt|;
name|op1
operator|=
name|initializer_constant_valid_p
argument_list|(
name|op1
argument_list|,
name|endtype
argument_list|)
expr_stmt|;
comment|/* Both initializers must be known.  */
if|if
condition|(
name|op0
operator|&&
name|op1
condition|)
block|{
if|if
condition|(
name|op0
operator|==
name|op1
condition|)
return|return
name|null_pointer_node
return|;
comment|/* Support differences between labels.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LABEL_DECL
condition|)
return|return
name|null_pointer_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|operand_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for constant EXP to FILE, with no label.    This includes the pseudo-op such as ".int" or ".byte", and a newline.    Assumes output_addressed_constants has been done on EXP already.     Generate exactly SIZE bytes of assembler data, padding at the end    with zeros if necessary.  SIZE must always be specified.     SIZE is important for structure constructors,    since trailing members may have been omitted from the constructor.    It is also important for initialization of arrays from string constants    since the full length of the string constant might not be wanted.    It is also needed for initialization of unions, where the initializer's    type is just one member, and that may not be as long as the union.     There a case in which we would fail to output exactly SIZE bytes:    for a structure constructor that wants to produce more than SIZE bytes.    But such constructors will never be generated for any possible input.     ALIGN is the alignment of the data in bits.  */
end_comment

begin_function
name|void
name|output_constant
parameter_list|(
name|tree
name|exp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|thissize
decl_stmt|;
comment|/* Some front-ends use constants other than the standard language-independent      varieties, but which may still be output directly.  Give the front-end a      chance to convert EXP to a language-independent representation.  */
name|exp
operator|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|flag_syntax_only
condition|)
return|return;
comment|/* See if we're trying to initialize a pointer in a non-default mode      to the address of some declaration somewhere.  If the target says      the mode is valid for pointers, assume the target has a way of      resolving it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|targetm
operator|.
name|valid_pointer_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|saved_type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Peel off any intermediate conversions-to-pointer for valid 	 pointer modes.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|targetm
operator|.
name|valid_pointer_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If what we're left with is the address of something, we can 	 convert the address to the final type and output it that 	 way.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|saved_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Likewise for constant ints.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|exp
operator|=
name|build_int_cst_wide
argument_list|(
name|saved_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Eliminate any conversions since we'll be outputting the underlying      constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
block|{
name|HOST_WIDE_INT
name|type_size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|op_size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure eliminating the conversion is really a no-op, except with 	 VIEW_CONVERT_EXPRs to allow for wild Ada unchecked conversions and 	 union types to allow for Ada unchecked unions.  */
if|if
condition|(
name|type_size
operator|>
name|op_size
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VIEW_CONVERT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
comment|/* Keep the conversion. */
break|break;
else|else
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|thissize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Give the front end another chance to expand constants.  */
name|exp
operator|=
name|lang_hooks
operator|.
name|expand_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Allow a constructor with no elements for any data type.      This means to fill the space with zeros.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FDESC_EXPR
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FDESC
name|HOST_WIDE_INT
name|part
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_FDESC
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|part
argument_list|)
expr_stmt|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Now output the underlying data.  If we've handling the padding, return.      Otherwise, break and ensure SIZE is the size written.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
operator|!
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|size
argument_list|,
name|thissize
argument_list|)
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"initializer for integer value is too complicated"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|REAL_CST
condition|)
name|error
argument_list|(
literal|"initializer for floating value is not a floating constant"
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|output_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
operator|/
literal|2
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
operator|/
literal|2
argument_list|,
name|min_align
argument_list|(
name|align
argument_list|,
name|BITS_PER_UNIT
operator|*
operator|(
name|thissize
operator|/
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRING_CST
case|:
name|thissize
operator|=
name|MIN
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_CST
case|:
block|{
name|int
name|elt_size
decl_stmt|;
name|tree
name|link
decl_stmt|;
name|unsigned
name|int
name|nalign
decl_stmt|;
name|enum
name|machine_mode
name|inner
decl_stmt|;
name|inner
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nalign
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|elt_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|link
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|elt_size
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|thissize
operator|=
name|elt_size
expr_stmt|;
while|while
condition|(
operator|(
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|output_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|elt_size
argument_list|,
name|nalign
argument_list|)
expr_stmt|;
name|thissize
operator|+=
name|elt_size
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
argument_list|)
expr_stmt|;
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR_MARK
case|:
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|thissize
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|thissize
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_constructor, used for computing the size of    arrays of unspecified length.  VAL must be a CONSTRUCTOR of an array    type with an unspecified upper bound.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|array_size_for_constructor
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
name|tree
name|max_index
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cnt
decl_stmt|;
name|tree
name|index
decl_stmt|,
name|value
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* This code used to attempt to handle string constants that are not      arrays of single-bytes, but nothing else does, so there's no point in      doing it here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|val
argument_list|)
return|;
name|max_index
operator|=
name|NULL_TREE
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (val)
argument_list|,
argument|cnt
argument_list|,
argument|index
argument_list|,
argument|value
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
name|index
operator|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_index
operator|==
name|NULL_TREE
operator|||
name|tree_int_cst_lt
argument_list|(
name|max_index
argument_list|,
name|index
argument_list|)
condition|)
name|max_index
operator|=
name|index
expr_stmt|;
block|}
if|if
condition|(
name|max_index
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Compute the total number of array elements.  */
name|tmp
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|max_index
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i
argument_list|,
name|build_int_cst
argument_list|(
name|sizetype
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Multiply by the array element unit size to find number of bytes.  */
name|i
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tree_low_cst
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).    Generate at least SIZE bytes, padding if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|output_constructor
parameter_list|(
name|tree
name|exp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
literal|0
decl_stmt|;
name|tree
name|min_index
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes output or skipped so far.      In other words, current position within the constructor.  */
name|HOST_WIDE_INT
name|total_bytes
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means BYTE contains part of a byte, to be output.  */
name|int
name|byte_buffer_in_use
init|=
literal|0
decl_stmt|;
name|int
name|byte
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cnt
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|gcc_assert
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|min_index
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As LINK goes through the elements of the constant,      FIELD goes through the structure fields, if the constant is a structure.      if the constant is a union, then we override this,      by getting the field from the TREE_LIST element.      But the constant could also be an array.  Then FIELD is zero.       There is always a maximum of one element in the chain LINK for unions      (even if the initializer in a source program incorrectly contains      more one).  */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cnt
argument_list|,
name|ce
argument_list|)
condition|;
name|cnt
operator|++
operator|,
name|field
operator|=
name|field
condition|?
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
else|:
literal|0
control|)
block|{
name|tree
name|val
init|=
name|ce
operator|->
name|value
decl_stmt|;
name|tree
name|index
init|=
literal|0
decl_stmt|;
comment|/* The element in a union constructor specifies the proper field 	 or index.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|ce
operator|->
name|index
operator|!=
literal|0
condition|)
name|field
operator|=
name|ce
operator|->
name|index
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|index
operator|=
name|ce
operator|->
name|index
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_COMMENT_START
if|if
condition|(
name|field
operator|&&
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s %s:\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
else|:
literal|"<anonymous>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Eliminate the marker that makes a cast not be an lvalue.  */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|STRIP_NOPS
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lo_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|hi_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|index
decl_stmt|;
name|unsigned
name|int
name|align2
init|=
name|min_align
argument_list|(
name|align
argument_list|,
name|fieldsize
operator|*
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
for|for
control|(
name|index
operator|=
name|lo_index
init|;
name|index
operator|<=
name|hi_index
condition|;
name|index
operator|++
control|)
block|{
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|,
name|align2
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|==
literal|0
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* An element that is not a bit-field.  */
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
decl_stmt|;
comment|/* Since this structure is static, 	     we know the positions are constant.  */
name|HOST_WIDE_INT
name|pos
init|=
name|field
condition|?
name|int_byte_position
argument_list|(
name|field
argument_list|)
else|:
literal|0
decl_stmt|;
name|unsigned
name|int
name|align2
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|pos
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
operator|(
name|tree_low_cst
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|min_index
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Output any buffered-up bit-fields preceding this element.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Advance to offset of this element. 	     Note no alignment needed in an array, since that is guaranteed 	     if each element has the proper size.  */
if|if
condition|(
operator|(
name|field
operator|!=
literal|0
operator|||
name|index
operator|!=
literal|0
operator|)
operator|&&
name|pos
operator|!=
name|total_bytes
condition|)
block|{
name|gcc_assert
argument_list|(
name|pos
operator|>=
name|total_bytes
argument_list|)
expr_stmt|;
name|assemble_zeros
argument_list|(
name|pos
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|pos
expr_stmt|;
block|}
comment|/* Find the alignment of this element.  */
name|align2
operator|=
name|min_align
argument_list|(
name|align
argument_list|,
name|BITS_PER_UNIT
operator|*
name|pos
argument_list|)
expr_stmt|;
comment|/* Determine size this element should occupy.  */
if|if
condition|(
name|field
condition|)
block|{
name|fieldsize
operator|=
literal|0
expr_stmt|;
comment|/* If this is an array with an unspecified upper bound, 		 the initializer determines the size.  */
comment|/* ??? This ought to only checked if DECL_SIZE_UNIT is NULL, 		 but we cannot do this until the deprecated support for 		 initializing zero-length array members is removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|fieldsize
operator|=
name|array_size_for_constructor
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Given a non-empty initialization, this field had 		     better be last.  */
name|gcc_assert
argument_list|(
operator|!
name|fieldsize
operator|||
operator|!
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* ??? This can't be right.  If the decl size overflows 		     a host integer we will silently emit no data.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|fieldsize
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fieldsize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|,
name|align2
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid initial value for member %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Element that is a bit-field.  */
name|HOST_WIDE_INT
name|next_offset
init|=
name|int_bit_position
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|end_offset
init|=
operator|(
name|next_offset
operator|+
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* If this field does not start in this (or, next) byte, 	     skip some bytes.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
comment|/* Output remnant of any bit field in previous bytes.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still not at proper byte, advance to there.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
name|gcc_assert
argument_list|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|>=
name|total_bytes
argument_list|)
expr_stmt|;
name|assemble_zeros
argument_list|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|next_offset
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|byte_buffer_in_use
condition|)
name|byte
operator|=
literal|0
expr_stmt|;
comment|/* We must split the element into pieces that fall within 	     separate bytes, and combine each byte with previous or 	     following bit-fields.  */
comment|/* next_offset is the offset n fbits from the beginning of 	     the structure to the next bit of this element to be processed. 	     end_offset is the offset of the first bit past the end of 	     this element.  */
while|while
condition|(
name|next_offset
operator|<
name|end_offset
condition|)
block|{
name|int
name|this_time
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|HOST_WIDE_INT
name|next_byte
init|=
name|next_offset
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|next_bit
init|=
name|next_offset
operator|%
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Advance from byte to byte 		 within this element when necessary.  */
while|while
condition|(
name|next_byte
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Number of bits we can process at once 		 (all part of the same byte).  */
name|this_time
operator|=
name|MIN
argument_list|(
name|end_offset
operator|-
name|next_offset
argument_list|,
name|BITS_PER_UNIT
operator|-
name|next_bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* On big-endian machine, take the most significant bits 		     first (of the bits that are significant) 		     and put them into bytes from the most significant end.  */
name|shift
operator|=
name|end_offset
operator|-
name|next_offset
operator|-
name|this_time
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST. We can 		     only select bits from the LOW or HIGH part 		     not from both.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|this_time
operator|=
name|shift
operator|+
name|this_time
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Get the result. This works only when: 		     1<= this_time<= HOST_BITS_PER_WIDE_INT.  */
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|this_time
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|BITS_PER_UNIT
operator|-
name|this_time
operator|-
name|next_bit
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* On little-endian machines, 		     take first the least significant bits of the value 		     and pack them starting at the least significant 		     bits of the bytes.  */
name|shift
operator|=
name|next_offset
operator|-
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		     the word boundary in the INTEGER_CST. We can 		     only select bits from the LOW or HIGH part 		     not from both.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|this_time
operator|=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|shift
operator|)
expr_stmt|;
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Get the result. This works only when: 		     1<= this_time<= HOST_BITS_PER_WIDE_INT.  */
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|this_time
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|next_bit
operator|)
expr_stmt|;
block|}
name|next_offset
operator|+=
name|this_time
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|total_bytes
operator|<
name|size
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This TREE_LIST contains any weak symbol declarations waiting    to be emitted.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|weak_decls
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Mark DECL as weak.  */
end_comment

begin_function
specifier|static
name|void
name|mark_weak
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|SYMBOL_REF_WEAK
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge weak status between NEWDECL and OLDDECL.  */
end_comment

begin_function
name|void
name|merge_weak
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_WEAK
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|SUPPORTS_WEAK
condition|)
block|{
name|tree
modifier|*
name|pwd
decl_stmt|;
comment|/* We put the NEWDECL on the weak_decls list at some point              and OLDDECL as well.  Keep just OLDDECL on the list.  */
for|for
control|(
name|pwd
operator|=
operator|&
name|weak_decls
init|;
operator|*
name|pwd
condition|;
name|pwd
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|pwd
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|pwd
argument_list|)
operator|==
name|newdecl
condition|)
block|{
operator|*
name|pwd
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|pwd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|tree
name|wd
decl_stmt|;
comment|/* NEWDECL is weak, but OLDDECL is not.  */
comment|/* If we already output the OLDDECL, we're in trouble; we can't 	 go back and make it weak.  This error cannot caught in 	 declare_weak because the NEWDECL and OLDDECL was not yet 	 been merged; therefore, TREE_ASM_WRITTEN was not set.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"weak declaration of %q+D must precede definition"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If we've already generated rtl referencing OLDDECL, we may 	 have done so in a way that will not function properly with 	 a weak symbol.  */
elseif|else
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"weak declaration of %q+D after first use results "
literal|"in unspecified behavior"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
block|{
comment|/* We put the NEWDECL on the weak_decls list at some point. 	     Replace it with the OLDDECL.  */
for|for
control|(
name|wd
operator|=
name|weak_decls
init|;
name|wd
condition|;
name|wd
operator|=
name|TREE_CHAIN
argument_list|(
name|wd
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|wd
argument_list|)
operator|==
name|newdecl
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|wd
argument_list|)
operator|=
name|olddecl
expr_stmt|;
break|break;
block|}
comment|/* We may not find the entry on the list.  If NEWDECL is a 	     weak alias, then we will have already called 	     globalize_decl to remove the entry; in that case, we do 	     not need to do anything.  */
block|}
comment|/* Make the OLDDECL weak; it's OLDDECL that we'll be keeping.  */
name|mark_weak
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* OLDDECL was weak, but NEWDECL was not explicitly marked as        weak.  Just update NEWDECL to indicate that it's weak too.  */
name|mark_weak
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declare DECL to be a weak symbol.  */
end_comment

begin_function
name|void
name|declare_weak
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"weak declaration of %q+D must be public"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"weak declaration of %q+D must precede definition"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SUPPORTS_WEAK
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|weak_decls
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|decl
argument_list|,
name|weak_decls
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"weak declaration of %q+D not supported"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|mark_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|weak_finish_1
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ASM_WEAKEN_DECL
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_WEAKEN_LABEL
argument_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASM_WEAKEN_DECL
name|ASM_WEAKEN_DECL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_WEAK_ALIAS
block|{
specifier|static
name|bool
name|warn_once
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warn_once
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"only weak aliases are supported in this configuration"
argument_list|)
expr_stmt|;
name|warn_once
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This TREE_LIST contains weakref targets.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|weakref_targets
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Forward declaration.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|find_decl_and_mark_needed
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Emit any pending weak declarations.  */
end_comment

begin_function
name|void
name|weak_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|weakref_targets
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|alias_decl
init|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|target
init|=
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|alias_decl
argument_list|)
argument_list|)
condition|)
comment|/* Remove alias_decl from the weak list, but leave entries for 	   the target alone.  */
name|target
operator|=
name|NULL_TREE
expr_stmt|;
ifndef|#
directive|ifndef
name|ASM_OUTPUT_WEAKREF
elseif|else
if|if
condition|(
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|target
argument_list|)
condition|)
block|{
comment|/* Use ASM_WEAKEN_LABEL only if ASM_WEAKEN_DECL is not 	     defined, otherwise we and weak_finish_1 would use a 	     different macros.  */
if|#
directive|if
name|defined
name|ASM_WEAKEN_LABEL
operator|&&
operator|!
name|defined
name|ASM_WEAKEN_DECL
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|tree
name|decl
init|=
name|find_decl_and_mark_needed
argument_list|(
name|alias_decl
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|alias_decl
argument_list|)
argument_list|,
name|target
argument_list|,
name|TREE_TYPE
argument_list|(
name|alias_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_NOTHROW
argument_list|(
name|alias_decl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|weak_finish_1
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|{
name|tree
modifier|*
name|p
decl_stmt|;
name|tree
name|t2
decl_stmt|;
comment|/* Remove the alias and the target from the pending weak list 	   so that we do not emit any .weak directives for the former, 	   nor multiple .weak directives for the latter.  */
for|for
control|(
name|p
operator|=
operator|&
name|weak_decls
init|;
operator|(
name|t2
operator|=
operator|*
name|p
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
operator|==
name|alias_decl
operator|||
name|target
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
comment|/* Remove other weakrefs to the same target, to speed things up.  */
for|for
control|(
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
init|;
operator|(
name|t2
operator|=
operator|*
name|p
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|target
operator|==
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|t
operator|=
name|weak_decls
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|weak_finish_1
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit the assembly bits to indicate that DECL is globally visible.  */
end_comment

begin_function
specifier|static
name|void
name|globalize_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ASM_WEAKEN_LABEL
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_WEAKEN_DECL
argument_list|)
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_WEAKEN_DECL
name|ASM_WEAKEN_DECL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_WEAKEN_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove this function from the pending weak list so that 	 we do not emit multiple .weak directives for it.  */
for|for
control|(
name|p
operator|=
operator|&
name|weak_decls
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Remove weakrefs to the same target from the pending weakref 	 list, for the same reason.  */
for|for
control|(
name|p
operator|=
operator|&
name|weakref_targets
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|ASM_MAKE_LABEL_LINKONCE
argument_list|)
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|ASM_MAKE_LABEL_LINKONCE
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We have to be able to tell cgraph about the needed-ness of the target    of an alias.  This requires that the decl have been defined.  Aliases    that precede their definition have to be queued for later processing.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|alias_pair
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|decl
block|;
name|tree
name|target
block|; }
end_typedef

begin_expr_stmt
name|alias_pair
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Define gc'd vector type.  */
end_comment

begin_expr_stmt
name|DEF_VEC_O
argument_list|(
name|alias_pair
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_O
argument_list|(
name|alias_pair
argument_list|,
name|gc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|alias_pair
argument_list|,
name|gc
argument_list|)
operator|*
name|alias_pairs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Given an assembly name, find the decl it is associated with.  At the    same time, mark it needed for cgraph.  */
end_comment

begin_function
specifier|static
name|tree
name|find_decl_and_mark_needed
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|fnode
init|=
name|NULL
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|fnode
operator|=
name|cgraph_node_for_asm
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnode
operator|==
name|NULL
condition|)
name|vnode
operator|=
name|cgraph_varpool_node_for_asm
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vnode
operator|=
name|cgraph_varpool_node_for_asm
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnode
operator|==
name|NULL
condition|)
name|fnode
operator|=
name|cgraph_node_for_asm
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fnode
condition|)
block|{
comment|/* We can't mark function nodes as used after cgraph global info 	 is finished.  This wouldn't generally be necessary, but C++ 	 virtual table thunks are introduced late in the game and 	 might seem like they need marking, although in fact they 	 don't.  */
if|if
condition|(
operator|!
name|cgraph_global_info_ready
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|fnode
argument_list|)
expr_stmt|;
return|return
name|fnode
operator|->
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|vnode
condition|)
block|{
name|cgraph_varpool_mark_needed_node
argument_list|(
name|vnode
argument_list|)
expr_stmt|;
return|return
name|vnode
operator|->
name|decl
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Output the assembler code for a define (equate) using ASM_OUTPUT_DEF    or ASM_OUTPUT_DEF_FROM_DECLS.  The function defines the symbol whose    tree node is DECL to have the value of the tree node TARGET.  */
end_comment

begin_function
specifier|static
name|void
name|do_assemble_alias
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"weakref"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|target
argument_list|)
condition|)
name|weakref_targets
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|target
argument_list|,
name|weakref_targets
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_WEAKREF
name|ASM_OUTPUT_WEAKREF
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|SUPPORTS_WEAK
condition|)
block|{
name|error
argument_list|(
literal|"%Jweakref is not supported in this configuration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
comment|/* Make name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|globalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|maybe_assemble_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF_FROM_DECLS
name|ASM_OUTPUT_DEF_FROM_DECLS
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_WEAKEN_DECL
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_WEAKEN_DECL
name|ASM_WEAKEN_DECL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove this function from the pending weak list so that        we do not emit multiple .weak directives for it.  */
for|for
control|(
name|p
operator|=
operator|&
name|weak_decls
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
control|)
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Remove weakrefs to the same target from the pending weakref        list, for the same reason.  */
for|for
control|(
name|p
operator|=
operator|&
name|weakref_targets
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* First pass of completing pending aliases.  Make sure that cgraph knows    which symbols will be required.  */
end_comment

begin_function
name|void
name|finish_aliases_1
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|alias_pair
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|alias_pair
argument_list|,
name|alias_pairs
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|target_decl
decl_stmt|;
name|target_decl
operator|=
name|find_decl_and_mark_needed
argument_list|(
name|p
operator|->
name|decl
argument_list|,
name|p
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_decl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"weakref"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|p
operator|->
name|decl
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%q+D aliased to undefined symbol %qs"
argument_list|,
name|p
operator|->
name|decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|p
operator|->
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|target_decl
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"weakref"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|p
operator|->
name|decl
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%q+D aliased to external symbol %qs"
argument_list|,
name|p
operator|->
name|decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|p
operator|->
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Second pass of completing pending aliases.  Emit the actual assembly.    This happens at the end of compilation and thus it is assured that the    target symbol has been emitted.  */
end_comment

begin_function
name|void
name|finish_aliases_2
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|alias_pair
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|alias_pair
argument_list|,
name|alias_pairs
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
condition|;
name|i
operator|++
control|)
name|do_assemble_alias
argument_list|(
name|p
operator|->
name|decl
argument_list|,
name|p
operator|->
name|target
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|alias_pair
argument_list|,
name|alias_pairs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an assembler directive to make the symbol for DECL an alias to    the symbol for TARGET.  */
end_comment

begin_function
name|void
name|assemble_alias
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|tree
name|target_decl
decl_stmt|;
name|bool
name|is_weakref
init|=
name|false
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"weakref"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|alias
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|is_weakref
operator|=
name|true
expr_stmt|;
name|ultimate_transparent_alias_target
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|==
name|target
condition|)
name|error
argument_list|(
literal|"weakref %q+D ultimately targets itself"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|ASM_OUTPUT_WEAKREF
name|IDENTIFIER_TRANSPARENT_ALIAS
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|alias
argument_list|)
operator|=
name|target
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"weakref %q+D must have static linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_DEF
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_WEAKEN_DECL
argument_list|)
name|error
argument_list|(
literal|"%Jalias definitions not supported in this configuration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jonly weak aliases are supported in this configuration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
comment|/* We must force creation of DECL_RTL for debug info generation, even though      we don't use it here.  */
name|make_decl_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* A quirk of the initial implementation of aliases required that the user      add "extern" to all of them.  Which is silly, but now historical.  Do      note that the symbol is in fact locally defined.  */
if|if
condition|(
operator|!
name|is_weakref
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Allow aliases to aliases.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cgraph_node
argument_list|(
name|decl
argument_list|)
operator|->
name|alias
operator|=
name|true
expr_stmt|;
else|else
name|cgraph_varpool_node
argument_list|(
name|decl
argument_list|)
operator|->
name|alias
operator|=
name|true
expr_stmt|;
comment|/* If the target has already been emitted, we don't have to queue the      alias.  This saves a tad o memory.  */
name|target_decl
operator|=
name|find_decl_and_mark_needed
argument_list|(
name|decl
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_decl
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|target_decl
argument_list|)
condition|)
name|do_assemble_alias
argument_list|(
name|decl
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
block|{
name|alias_pair
modifier|*
name|p
init|=
name|VEC_safe_push
argument_list|(
name|alias_pair
argument_list|,
name|gc
argument_list|,
name|alias_pairs
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|p
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|p
operator|->
name|target
operator|=
name|target
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit an assembler directive to set symbol for DECL visibility to    the visibility type VIS, which must not be VISIBILITY_DEFAULT.  */
end_comment

begin_function
name|void
name|default_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|vis
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|visibility_types
index|[]
init|=
block|{
name|NULL
block|,
literal|"protected"
block|,
literal|"hidden"
block|,
literal|"internal"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|visibility_types
index|[
name|vis
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.%s\t"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"visibility attribute not supported "
literal|"in this configuration; ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A helper function to call assemble_visibility when needed for a decl.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|enum
name|symbol_visibility
name|vis
init|=
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|vis
operator|!=
name|VISIBILITY_DEFAULT
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|visibility
argument_list|(
name|decl
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the target configuration supports defining public symbols    so that one of them will be chosen at link time instead of generating a    multiply-defined symbol error, whether through the use of weak symbols or    a target-specific mechanism for having duplicates discarded.  */
end_comment

begin_function
name|int
name|supports_one_only
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
return|return
literal|1
return|;
return|return
name|SUPPORTS_WEAK
return|;
block|}
end_function

begin_comment
comment|/* Set up DECL as a public symbol that can be defined in multiple    translation units without generating a linker error.  */
end_comment

begin_function
name|void
name|make_decl_one_only
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
block|{
ifdef|#
directive|ifdef
name|MAKE_DECL_ONE_ONLY
name|MAKE_DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|SUPPORTS_WEAK
argument_list|)
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_varasm_once
parameter_list|(
name|void
parameter_list|)
block|{
name|section_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|section_entry_hash
argument_list|,
name|section_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|object_block_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|object_block_entry_hash
argument_list|,
name|object_block_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|const_desc_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|1009
argument_list|,
name|const_desc_hash
argument_list|,
name|const_desc_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|const_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|shared_constant_pool
operator|=
name|create_constant_pool
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TEXT_SECTION_ASM_OP
name|text_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_CODE
argument_list|,
name|output_section_asm_op
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DATA_SECTION_ASM_OP
name|data_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_WRITE
argument_list|,
name|output_section_asm_op
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDATA_SECTION_ASM_OP
name|sdata_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_WRITE
argument_list|,
name|output_section_asm_op
argument_list|,
name|SDATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION_ASM_OP
name|readonly_data_section
operator|=
name|get_unnamed_section
argument_list|(
literal|0
argument_list|,
name|output_section_asm_op
argument_list|,
name|READONLY_DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CTORS_SECTION_ASM_OP
name|ctors_section
operator|=
name|get_unnamed_section
argument_list|(
literal|0
argument_list|,
name|output_section_asm_op
argument_list|,
name|CTORS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DTORS_SECTION_ASM_OP
name|dtors_section
operator|=
name|get_unnamed_section
argument_list|(
literal|0
argument_list|,
name|output_section_asm_op
argument_list|,
name|DTORS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
name|bss_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_WRITE
operator||
name|SECTION_BSS
argument_list|,
name|output_section_asm_op
argument_list|,
name|BSS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SBSS_SECTION_ASM_OP
name|sbss_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_WRITE
operator||
name|SECTION_BSS
argument_list|,
name|output_section_asm_op
argument_list|,
name|SBSS_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tls_comm_section
operator|=
name|get_noswitch_section
argument_list|(
name|SECTION_WRITE
operator||
name|SECTION_BSS
operator||
name|SECTION_COMMON
argument_list|,
name|emit_tls_common
argument_list|)
expr_stmt|;
name|lcomm_section
operator|=
name|get_noswitch_section
argument_list|(
name|SECTION_WRITE
operator||
name|SECTION_BSS
operator||
name|SECTION_COMMON
argument_list|,
name|emit_local
argument_list|)
expr_stmt|;
name|comm_section
operator|=
name|get_noswitch_section
argument_list|(
name|SECTION_WRITE
operator||
name|SECTION_BSS
operator||
name|SECTION_COMMON
argument_list|,
name|emit_common
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|ASM_OUTPUT_ALIGNED_BSS
operator|||
name|defined
name|ASM_OUTPUT_BSS
name|bss_noswitch_section
operator|=
name|get_noswitch_section
argument_list|(
name|SECTION_WRITE
operator||
name|SECTION_BSS
argument_list|,
name|emit_bss
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|targetm
operator|.
name|asm_out
operator|.
name|init_sections
argument_list|()
expr_stmt|;
if|if
condition|(
name|readonly_data_section
operator|==
name|NULL
condition|)
name|readonly_data_section
operator|=
name|text_section
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|tls_model
name|decl_default_tls_model
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|enum
name|tls_model
name|kind
decl_stmt|;
name|bool
name|is_local
decl_stmt|;
name|is_local
operator|=
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_shlib
condition|)
block|{
if|if
condition|(
name|is_local
condition|)
name|kind
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
else|else
name|kind
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
block|}
comment|/* Local dynamic is inefficient when we're not combining the      parts of the address.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|is_local
condition|)
name|kind
operator|=
name|TLS_MODEL_LOCAL_DYNAMIC
expr_stmt|;
else|else
name|kind
operator|=
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
if|if
condition|(
name|kind
operator|<
name|flag_tls_default
condition|)
name|kind
operator|=
name|flag_tls_default
expr_stmt|;
return|return
name|kind
return|;
block|}
end_function

begin_comment
comment|/* Select a set of attributes for section NAME based on the properties    of DECL and whether or not RELOC indicates that DECL's initializer    might contain runtime relocations.     We make the section read-only and executable for a function decl,    read-only for a const data decl, and writable for a non-const data decl.  */
end_comment

begin_function
name|unsigned
name|int
name|default_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|&&
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|cfun
operator|&&
name|cfun
operator|->
name|unlikely_text_section_name
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|cfun
operator|->
name|unlikely_text_section_name
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|decl
operator|&&
operator|(
operator|!
name|current_function_decl
operator|||
operator|!
name|cfun
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
else|else
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_LINKONCE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_TLS
operator||
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".bss."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.b."
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.sb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SECTION_BSS
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tdata"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".tdata."
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.td."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SECTION_TLS
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".tbss."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.tb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SECTION_TLS
operator||
name|SECTION_BSS
expr_stmt|;
comment|/* These three sections have special ELF types.  They are neither      SHT_PROGBITS nor SHT_NOBITS, so when changing sections we don't      want to print a section type (@progbits or @nobits).  If someone      is silly enough to emit code or TLS variables to one of these      sections, then don't handle them specially.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|SECTION_CODE
operator||
name|SECTION_BSS
operator||
name|SECTION_TLS
operator|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init_array"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini_array"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".preinit_array"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|flags
operator||=
name|SECTION_NOTYPE
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Return true if the target supports some form of global BSS,    either through bss_noswitch_section, or by selecting a BSS    section in TARGET_ASM_SELECT_SECTION.  */
end_comment

begin_function
name|bool
name|have_global_bss_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|bss_noswitch_section
operator|||
name|targetm
operator|.
name|have_switchable_bss_sections
return|;
block|}
end_function

begin_comment
comment|/* Output assembly to switch to section NAME with attribute FLAGS.    Four variants for common object file formats.  */
end_comment

begin_function
name|void
name|default_no_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Some object formats don't support named sections at all.  The      front-end should already have flagged this as an error.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_elf_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|flagchars
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
comment|/* If we have already declared this section, we can use an      abbreviated form to switch back to it -- unless this section is      part of a COMDAT groups, in which case GAS requires the full      declaration every time.  */
if|if
condition|(
operator|!
operator|(
name|HAVE_COMDAT_GROUP
operator|&&
operator|(
name|flags
operator|&
name|SECTION_LINKONCE
operator|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|SECTION_DECLARED
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_DEBUG
operator|)
condition|)
operator|*
name|f
operator|++
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_SMALL
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_MERGE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_STRINGS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_TLS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'T'
expr_stmt|;
if|if
condition|(
name|HAVE_COMDAT_GROUP
operator|&&
operator|(
name|flags
operator|&
name|SECTION_LINKONCE
operator|)
condition|)
operator|*
name|f
operator|++
operator|=
literal|'G'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\""
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_NOTYPE
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_BSS
condition|)
name|type
operator|=
literal|"nobits"
expr_stmt|;
else|else
name|type
operator|=
literal|"progbits"
expr_stmt|;
name|format
operator|=
literal|",@%s"
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_COMMENT_START
comment|/* On platforms that use "@" as the assembly comment character, 	 use "%" instead.  */
if|if
condition|(
name|strcmp
argument_list|(
name|ASM_COMMENT_START
argument_list|,
literal|"@"
argument_list|)
operator|==
literal|0
condition|)
name|format
operator|=
literal|",%%%s"
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_ENTSIZE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",%d"
argument_list|,
name|flags
operator|&
name|SECTION_ENTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_COMDAT_GROUP
operator|&&
operator|(
name|flags
operator|&
name|SECTION_LINKONCE
operator|)
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",%s,comdat"
argument_list|,
name|lang_hooks
operator|.
name|decls
operator|.
name|comdat_group
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_coff_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|flagchars
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\"\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_pe_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|default_coff_asm_named_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_LINKONCE
condition|)
block|{
comment|/* Functions may have been compiled at various levels of          optimization so we can't use `same_size' here.          Instead, have the linker pick one.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.linkonce %s\n"
argument_list|,
operator|(
name|flags
operator|&
name|SECTION_CODE
condition|?
literal|"discard"
else|:
literal|"same_size"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The lame default section selector.  */
end_comment

begin_function
name|section
modifier|*
name|default_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
return|return
name|readonly_data_section
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
operator|||
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|readonly_data_section
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|readonly_data_section
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
return|return
name|readonly_data_section
return|;
return|return
name|data_section
return|;
block|}
end_function

begin_function
name|enum
name|section_category
name|categorize_decl_for_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|enum
name|section_category
name|ret
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|SECCAT_TEXT
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|flag_mudflap
condition|)
comment|/* or !flag_merge_constants */
return|return
name|SECCAT_RODATA
return|;
else|else
return|return
name|SECCAT_RODATA_MERGE_STR
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|bss_initializer_p
argument_list|(
name|decl
argument_list|)
condition|)
name|ret
operator|=
name|SECCAT_BSS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Here the reloc_rw_mask is not testing whether the section should 	     be read-only or not, but whether the dynamic link will have to 	     do something.  If so, we wish to segregate the data in order to 	     minimize cache misses inside the dynamic linker.  */
if|if
condition|(
name|reloc
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|reloc_rw_mask
argument_list|()
condition|)
name|ret
operator|=
name|reloc
operator|==
literal|1
condition|?
name|SECCAT_DATA_REL_LOCAL
else|:
name|SECCAT_DATA_REL
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reloc
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|reloc_rw_mask
argument_list|()
condition|)
name|ret
operator|=
name|reloc
operator|==
literal|1
condition|?
name|SECCAT_DATA_REL_RO_LOCAL
else|:
name|SECCAT_DATA_REL_RO
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc
operator|||
name|flag_merge_constants
operator|<
literal|2
condition|)
comment|/* C and C++ don't allow different variables to share the same 	   location.  -fmerge-all-constants allows even that (at the 	   expense of not conforming).  */
name|ret
operator|=
name|SECCAT_RODATA
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
name|ret
operator|=
name|SECCAT_RODATA_MERGE_STR_INIT
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_RODATA_MERGE_CONST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
operator|(
name|reloc
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|reloc_rw_mask
argument_list|()
operator|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
condition|)
name|ret
operator|=
name|SECCAT_DATA
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_RODATA
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|SECCAT_RODATA
expr_stmt|;
comment|/* There are no read-only thread-local sections.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Note that this would be *just* SECCAT_BSS, except that there's 	 no concept of a read-only thread-local-data section.  */
if|if
condition|(
name|ret
operator|==
name|SECCAT_BSS
operator|||
operator|(
name|flag_zero_initialized_in_bss
operator|&&
name|initializer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
name|ret
operator|=
name|SECCAT_TBSS
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_TDATA
expr_stmt|;
block|}
comment|/* If the target uses small data sections, select it.  */
elseif|else
if|if
condition|(
name|targetm
operator|.
name|in_small_data_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|SECCAT_BSS
condition|)
name|ret
operator|=
name|SECCAT_SBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|targetm
operator|.
name|have_srodata_section
operator|&&
name|ret
operator|==
name|SECCAT_RODATA
condition|)
name|ret
operator|=
name|SECCAT_SRODATA
expr_stmt|;
else|else
name|ret
operator|=
name|SECCAT_SDATA
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|decl_readonly_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
block|{
case|case
name|SECCAT_RODATA
case|:
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
case|case
name|SECCAT_SRODATA
case|:
return|return
name|true
return|;
break|break;
default|default:
return|return
name|false
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Select a section based on the above categorization.  */
end_comment

begin_function
name|section
modifier|*
name|default_elf_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
block|{
case|case
name|SECCAT_TEXT
case|:
comment|/* We're not supposed to be called on FUNCTION_DECLs.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|SECCAT_RODATA
case|:
return|return
name|readonly_data_section
return|;
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
return|return
name|mergeable_string_section
argument_list|(
name|decl
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
return|return
name|mergeable_string_section
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
return|return
name|mergeable_constant_section
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SECCAT_SRODATA
case|:
name|sname
operator|=
literal|".sdata2"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA
case|:
return|return
name|data_section
return|;
case|case
name|SECCAT_DATA_REL
case|:
name|sname
operator|=
literal|".data.rel"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_LOCAL
case|:
name|sname
operator|=
literal|".data.rel.local"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO
case|:
name|sname
operator|=
literal|".data.rel.ro"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO_LOCAL
case|:
name|sname
operator|=
literal|".data.rel.ro.local"
expr_stmt|;
break|break;
case|case
name|SECCAT_SDATA
case|:
name|sname
operator|=
literal|".sdata"
expr_stmt|;
break|break;
case|case
name|SECCAT_TDATA
case|:
name|sname
operator|=
literal|".tdata"
expr_stmt|;
break|break;
case|case
name|SECCAT_BSS
case|:
if|if
condition|(
name|bss_section
condition|)
return|return
name|bss_section
return|;
name|sname
operator|=
literal|".bss"
expr_stmt|;
break|break;
case|case
name|SECCAT_SBSS
case|:
name|sname
operator|=
literal|".sbss"
expr_stmt|;
break|break;
case|case
name|SECCAT_TBSS
case|:
name|sname
operator|=
literal|".tbss"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|get_named_section
argument_list|(
name|decl
argument_list|,
name|sname
argument_list|,
name|reloc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct a unique section name based on the decl name and the    categorization performed above.  */
end_comment

begin_function
name|void
name|default_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
comment|/* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
name|bool
name|one_only
init|=
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|HAVE_COMDAT_GROUP
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|size_t
name|nlen
decl_stmt|,
name|plen
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
block|{
case|case
name|SECCAT_TEXT
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.t."
else|:
literal|".text."
expr_stmt|;
break|break;
case|case
name|SECCAT_RODATA
case|:
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.r."
else|:
literal|".rodata."
expr_stmt|;
break|break;
case|case
name|SECCAT_SRODATA
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.s2."
else|:
literal|".sdata2."
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.d."
else|:
literal|".data."
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.d.rel."
else|:
literal|".data.rel."
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_LOCAL
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.d.rel.local."
else|:
literal|".data.rel.local."
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.d.rel.ro."
else|:
literal|".data.rel.ro."
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO_LOCAL
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.d.rel.ro.local."
else|:
literal|".data.rel.ro.local."
expr_stmt|;
break|break;
case|case
name|SECCAT_SDATA
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.s."
else|:
literal|".sdata."
expr_stmt|;
break|break;
case|case
name|SECCAT_BSS
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.b."
else|:
literal|".bss."
expr_stmt|;
break|break;
case|case
name|SECCAT_SBSS
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.sb."
else|:
literal|".sbss."
expr_stmt|;
break|break;
case|case
name|SECCAT_TDATA
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.td."
else|:
literal|".tdata."
expr_stmt|;
break|break;
case|case
name|SECCAT_TBSS
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.tb."
else|:
literal|".tbss."
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|plen
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|nlen
operator|+
name|plen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|string
argument_list|,
name|prefix
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|string
operator|+
name|plen
argument_list|,
name|name
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|nlen
operator|+
name|plen
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like compute_reloc_for_constant, except for an RTX.  The return value    is a mask for which bit 1 indicates a global relocation, and bit 0    indicates a local relocation.  */
end_comment

begin_function
specifier|static
name|int
name|compute_reloc_for_rtx_1
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|preloc
init|=
name|data
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
operator|*
name|preloc
operator||=
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
operator|*
name|preloc
operator||=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compute_reloc_for_rtx
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|reloc
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
name|reloc
operator|=
literal|0
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|compute_reloc_for_rtx_1
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|section
modifier|*
name|default_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|compute_reloc_for_rtx
argument_list|(
name|x
argument_list|)
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|reloc_rw_mask
argument_list|()
condition|)
return|return
name|data_section
return|;
else|else
return|return
name|readonly_data_section
return|;
block|}
end_function

begin_function
name|section
modifier|*
name|default_elf_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
name|int
name|reloc
init|=
name|compute_reloc_for_rtx
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* ??? Handle small data here somehow.  */
if|if
condition|(
name|reloc
operator|&
name|targetm
operator|.
name|asm_out
operator|.
name|reloc_rw_mask
argument_list|()
condition|)
block|{
if|if
condition|(
name|reloc
operator|==
literal|1
condition|)
return|return
name|get_named_section
argument_list|(
name|NULL
argument_list|,
literal|".data.rel.ro.local"
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|get_named_section
argument_list|(
name|NULL
argument_list|,
literal|".data.rel.ro"
argument_list|,
literal|3
argument_list|)
return|;
block|}
return|return
name|mergeable_constant_section
argument_list|(
name|mode
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the generally applicable flags on the SYMBOL_REF for EXP.  */
end_comment

begin_function
name|void
name|default_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|symbol
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Careful not to prod global register variables.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|rtl
argument_list|)
condition|)
return|return;
name|symbol
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|symbol
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
name|flags
operator|=
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|&
name|SYMBOL_FLAG_HAS_BLOCK_INFO
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_FUNCTION
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|DECL_TLS_MODEL
argument_list|(
name|decl
argument_list|)
operator|<<
name|SYMBOL_FLAG_TLS_SHIFT
expr_stmt|;
elseif|else
if|if
condition|(
name|targetm
operator|.
name|in_small_data_p
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_SMALL
expr_stmt|;
comment|/* ??? Why is DECL_EXTERNAL ever set for non-PUBLIC names?  Without      being PUBLIC, the thing *must* be defined in this translation unit.      Prevent this buglet from being propagated into rtl code as well.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SYMBOL_FLAG_EXTERNAL
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/* By default, we do nothing for encode_section_info, so we need not    do anything but discard the '*' marker.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|default_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|str
operator|+
operator|(
operator|*
name|str
operator|==
literal|'*'
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
end_ifdef

begin_comment
comment|/* The default implementation of TARGET_ASM_OUTPUT_ANCHOR.  Define the    anchor relative to ".", the current section position.  */
end_comment

begin_function
name|void
name|default_asm_output_anchor
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|". + "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default implementation of TARGET_USE_ANCHORS_FOR_SYMBOL_P.  */
end_comment

begin_function
name|bool
name|default_use_anchors_for_symbol_p
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
name|section
modifier|*
name|sect
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Don't use anchors for mergeable sections.  The linker might move      the objects around.  */
name|sect
operator|=
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
operator|->
name|sect
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_MERGE
condition|)
return|return
name|false
return|;
comment|/* Don't use anchors for small data sections.  The small data register      acts as an anchor for such sections.  */
if|if
condition|(
name|sect
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_SMALL
condition|)
return|return
name|false
return|;
name|decl
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Don't use section anchors for decls that might be defined by 	 other modules.  */
if|if
condition|(
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Don't use section anchors for decls that will be placed in a 	 small data section.  */
comment|/* ??? Ideally, this check would be redundant with the SECTION_SMALL 	 one above.  The problem is that we only use SECTION_SMALL for 	 sections that should be marked as small in the section directive.  */
if|if
condition|(
name|targetm
operator|.
name|in_small_data_p
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Assume ELF-ish defaults, since that's pretty much the most liberal    wrt cross-module name binding.  */
end_comment

begin_function
name|bool
name|default_binds_local_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
return|return
name|default_binds_local_p_1
argument_list|(
name|exp
argument_list|,
name|flag_shlib
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|default_binds_local_p_1
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|shlib
parameter_list|)
block|{
name|bool
name|local_p
decl_stmt|;
comment|/* A non-decl is an entry in the constant pool.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* Weakrefs may not bind locally, even though the weakref itself is      always static and therefore local.  */
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"weakref"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* Static variables are always local.  */
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* A variable is local if the user has said explicitly that it will      be.  */
elseif|else
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|exp
argument_list|)
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|exp
argument_list|)
operator|!=
name|VISIBILITY_DEFAULT
condition|)
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* Variables defined outside this object might not be local.  */
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* If defined in this object and visibility is not default, must be      local.  */
elseif|else
if|if
condition|(
name|DECL_VISIBILITY
argument_list|(
name|exp
argument_list|)
operator|!=
name|VISIBILITY_DEFAULT
condition|)
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* Default visibility weak data can be overridden by a strong symbol      in another module and so are not local.  */
elseif|else
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|exp
argument_list|)
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* If PIC, then assume that any global name can be overridden by      symbols resolved from other modules, unless we are compiling with      -fwhole-program, which assumes that names are local.  */
elseif|else
if|if
condition|(
name|shlib
condition|)
name|local_p
operator|=
name|flag_whole_program
expr_stmt|;
comment|/* Uninitialized COMMON variable may be unified with symbols      resolved from other modules.  */
elseif|else
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL
operator|||
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|local_p
operator|=
name|false
expr_stmt|;
comment|/* Otherwise we're left with initialized (or non-common) global data      which is of necessity defined locally.  */
else|else
name|local_p
operator|=
name|true
expr_stmt|;
return|return
name|local_p
return|;
block|}
end_function

begin_comment
comment|/* Determine whether or not a pointer mode is valid. Assume defaults    of ptr_mode or Pmode - can be overridden.  */
end_comment

begin_function
name|bool
name|default_valid_pointer_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|mode
operator|==
name|ptr_mode
operator|||
name|mode
operator|==
name|Pmode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Default function to output code that will globalize a label.  A    target must define GLOBAL_ASM_OP or provide its own function to    globalize a label.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GLOBAL_ASM_OP
end_ifdef

begin_function
name|void
name|default_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fputs
argument_list|(
name|GLOBAL_ASM_OP
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GLOBAL_ASM_OP */
end_comment

begin_comment
comment|/* Default function to output a label for unwind information.  The    default is to do nothing.  A target that needs nonlocal labels for    unwind information must provide its own function to do this.  */
end_comment

begin_function
name|void
name|default_emit_unwind_label
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|for_eh
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|empty
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Default function to output a label to divide up the exception table.    The default is to do nothing.  A target that needs/wants to divide    up the table must provide it's own function to do this.  */
end_comment

begin_function
name|void
name|default_emit_except_table_label
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* This is how to output an internal numbered label where PREFIX is    the class of label and LABELNO is the number within the class.  */
end_comment

begin_function
name|void
name|default_internal_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|unsigned
name|long
name|labelno
parameter_list|)
block|{
name|char
modifier|*
specifier|const
name|buf
init|=
name|alloca
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
name|prefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the default behavior at the beginning of a file.  It's    controlled by two other target-hook toggles.  */
end_comment

begin_function
name|void
name|default_file_start
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|targetm
operator|.
name|file_start_app_off
operator|&&
operator|!
name|flag_verbose_asm
condition|)
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|file_start_file_directive
condition|)
name|output_file_directive
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a generic routine suitable for use as TARGET_ASM_FILE_END    which emits a special section directive used to indicate whether or    not this object file needs an executable stack.  This is primarily    a GNU extension to ELF but could be used on other targets.  */
end_comment

begin_decl_stmt
name|int
name|trampolines_created
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|file_end_indicate_exec_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
name|SECTION_DEBUG
decl_stmt|;
if|if
condition|(
name|trampolines_created
condition|)
name|flags
operator||=
name|SECTION_CODE
expr_stmt|;
name|switch_to_section
argument_list|(
name|get_section
argument_list|(
literal|".note.GNU-stack"
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output DIRECTIVE (a C string) followed by a newline.  This is used as    a get_unnamed_section callback.  */
end_comment

begin_function
name|void
name|output_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|directive
parameter_list|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|directive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit assembly code to switch to section NEW_SECTION.  Do nothing if    the current section is NEW_SECTION.  */
end_comment

begin_function
name|void
name|switch_to_section
parameter_list|(
name|section
modifier|*
name|new_section
parameter_list|)
block|{
if|if
condition|(
name|in_section
operator|==
name|new_section
condition|)
return|return;
if|if
condition|(
name|new_section
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_FORGET
condition|)
name|in_section
operator|=
name|NULL
expr_stmt|;
else|else
name|in_section
operator|=
name|new_section
expr_stmt|;
switch|switch
condition|(
name|SECTION_STYLE
argument_list|(
name|new_section
argument_list|)
condition|)
block|{
case|case
name|SECTION_NAMED
case|:
if|if
condition|(
name|cfun
operator|&&
operator|!
name|cfun
operator|->
name|unlikely_text_section_name
operator|&&
name|strcmp
argument_list|(
name|new_section
operator|->
name|named
operator|.
name|name
argument_list|,
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|cfun
operator|->
name|unlikely_text_section_name
operator|=
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|named_section
argument_list|(
name|new_section
operator|->
name|named
operator|.
name|name
argument_list|,
name|new_section
operator|->
name|named
operator|.
name|common
operator|.
name|flags
argument_list|,
name|new_section
operator|->
name|named
operator|.
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECTION_UNNAMED
case|:
name|new_section
operator|->
name|unnamed
operator|.
name|callback
argument_list|(
name|new_section
operator|->
name|unnamed
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECTION_NOSWITCH
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
block|}
name|new_section
operator|->
name|common
operator|.
name|flags
operator||=
name|SECTION_DECLARED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If block symbol SYMBOL has not yet been assigned an offset, place    it at the end of its block.  */
end_comment

begin_function
name|void
name|place_block_symbol
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|mask
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
decl_stmt|;
name|unsigned
name|int
name|alignment
decl_stmt|;
name|struct
name|object_block
modifier|*
name|block
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|gcc_assert
argument_list|(
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* Work out the symbol's size and alignment.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|desc
operator|=
name|SYMBOL_REF_CONSTANT
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|desc
operator|->
name|align
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|desc
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|decl
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|get_constant_alignment
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|size
operator|=
name|get_constant_size
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|size
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the object's offset from the start of the block.  */
name|block
operator|=
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|mask
operator|=
name|alignment
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
operator|(
name|block
operator|->
name|size
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
expr_stmt|;
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
operator|=
name|offset
expr_stmt|;
comment|/* Record the block's new alignment and size.  */
name|block
operator|->
name|alignment
operator|=
name|MAX
argument_list|(
name|block
operator|->
name|alignment
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|block
operator|->
name|size
operator|=
name|offset
operator|+
name|size
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|rtx
argument_list|,
name|gc
argument_list|,
name|block
operator|->
name|objects
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the anchor that should be used to address byte offset OFFSET    from the first object in BLOCK.  MODEL is the TLS model used    to access it.  */
end_comment

begin_function
name|rtx
name|get_section_anchor
parameter_list|(
name|struct
name|object_block
modifier|*
name|block
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|enum
name|tls_model
name|model
parameter_list|)
block|{
name|char
name|label
index|[
literal|100
index|]
decl_stmt|;
name|unsigned
name|int
name|begin
decl_stmt|,
name|middle
decl_stmt|,
name|end
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|min_offset
decl_stmt|,
name|max_offset
decl_stmt|,
name|range
decl_stmt|,
name|bias
decl_stmt|,
name|delta
decl_stmt|;
name|rtx
name|anchor
decl_stmt|;
comment|/* Work out the anchor's offset.  Use an offset of 0 for the first      anchor so that we don't pessimize the case where we take the address      of a variable at the beginning of the block.  This is particularly      useful when a block has only one variable assigned to it.       We try to place anchors RANGE bytes apart, so there can then be      anchors at +/-RANGE, +/-2 * RANGE, and so on, up to the limits of      a ptr_mode offset.  With some target settings, the lowest such      anchor might be out of range for the lowest ptr_mode offset;      likewise the highest anchor for the highest offset.  Use anchors      at the extreme ends of the ptr_mode range in such cases.       All arithmetic uses unsigned integers in order to avoid      signed overflow.  */
name|max_offset
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|targetm
operator|.
name|max_anchor_offset
expr_stmt|;
name|min_offset
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|targetm
operator|.
name|min_anchor_offset
expr_stmt|;
name|range
operator|=
name|max_offset
operator|-
name|min_offset
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|range
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bias
operator|=
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|ptr_mode
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|delta
operator|=
operator|-
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|+
name|max_offset
expr_stmt|;
name|delta
operator|-=
name|delta
operator|%
name|range
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|bias
condition|)
name|delta
operator|=
name|bias
expr_stmt|;
name|offset
operator|=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|-
name|min_offset
expr_stmt|;
name|delta
operator|-=
name|delta
operator|%
name|range
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|bias
operator|-
literal|1
condition|)
name|delta
operator|=
name|bias
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|delta
expr_stmt|;
block|}
block|}
comment|/* Do a binary search to see if there's already an anchor we can use.      Set BEGIN to the new anchor's index if not.  */
name|begin
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|VEC_length
argument_list|(
name|rtx
argument_list|,
name|block
operator|->
name|anchors
argument_list|)
expr_stmt|;
while|while
condition|(
name|begin
operator|!=
name|end
condition|)
block|{
name|middle
operator|=
operator|(
name|end
operator|+
name|begin
operator|)
operator|/
literal|2
expr_stmt|;
name|anchor
operator|=
name|VEC_index
argument_list|(
name|rtx
argument_list|,
name|block
operator|->
name|anchors
argument_list|,
name|middle
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|anchor
argument_list|)
operator|>
name|offset
condition|)
name|end
operator|=
name|middle
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|anchor
argument_list|)
operator|<
name|offset
condition|)
name|begin
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|anchor
argument_list|)
operator|>
name|model
condition|)
name|end
operator|=
name|middle
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|anchor
argument_list|)
operator|<
name|model
condition|)
name|begin
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|anchor
return|;
block|}
comment|/* Create a new anchor with a unique label.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LANCHOR"
argument_list|,
name|anchor_labelno
operator|++
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|create_block_symbol
argument_list|(
name|ggc_strdup
argument_list|(
name|label
argument_list|)
argument_list|,
name|block
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|anchor
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
operator||
name|SYMBOL_FLAG_ANCHOR
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|anchor
argument_list|)
operator||=
name|model
operator|<<
name|SYMBOL_FLAG_TLS_SHIFT
expr_stmt|;
comment|/* Insert it at index BEGIN.  */
name|VEC_safe_insert
argument_list|(
name|rtx
argument_list|,
name|gc
argument_list|,
name|block
operator|->
name|anchors
argument_list|,
name|begin
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
return|return
name|anchor
return|;
block|}
end_function

begin_comment
comment|/* Output the objects in BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|output_object_block
parameter_list|(
name|struct
name|object_block
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|constant_descriptor_rtx
modifier|*
name|desc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|rtx
name|symbol
decl_stmt|;
if|if
condition|(
name|block
operator|->
name|objects
operator|==
name|NULL
condition|)
return|return;
comment|/* Switch to the section and make sure that the first byte is      suitably aligned.  */
name|switch_to_section
argument_list|(
name|block
operator|->
name|sect
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|block
operator|->
name|alignment
argument_list|)
expr_stmt|;
comment|/* Define the values of all anchors relative to the current section      position.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|rtx
argument_list|,
name|block
operator|->
name|anchors
argument_list|,
name|i
argument_list|,
name|symbol
argument_list|)
condition|;
name|i
operator|++
control|)
name|targetm
operator|.
name|asm_out
operator|.
name|output_anchor
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
comment|/* Output the objects themselves.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|rtx
argument_list|,
name|block
operator|->
name|objects
argument_list|,
name|i
argument_list|,
name|symbol
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Move to the object's offset, padding with zeros if necessary.  */
name|assemble_zeros
argument_list|(
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
operator|-
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|desc
operator|=
name|SYMBOL_REF_CONSTANT
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|output_constant_pool_1
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|desc
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|decl
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|assemble_constant_contents
argument_list|(
name|decl
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|,
name|get_constant_alignment
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|get_constant_size
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|assemble_variable_contents
argument_list|(
name|decl
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A htab_traverse callback used to call output_object_block for    each member of object_block_htab.  */
end_comment

begin_function
specifier|static
name|int
name|output_object_block_htab
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|output_object_block
argument_list|(
operator|(
expr|struct
name|object_block
operator|*
operator|)
operator|(
operator|*
name|slot
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output the definitions of all object_blocks.  */
end_comment

begin_function
name|void
name|output_object_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_traverse
argument_list|(
name|object_block_htab
argument_list|,
name|output_object_block_htab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-varasm.h"
end_include

end_unit

