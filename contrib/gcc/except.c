begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implements exception handling.    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Mike Stump<mrs@cygnus.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* An exception is an event that can be signaled from within a    function. This event can then be "caught" or "trapped" by the    callers of this function. This potentially allows program flow to    be transferred to any arbitrary code associated with a function call    several levels up the stack.     The intended use for this mechanism is for signaling "exceptional    events" in an out-of-band fashion, hence its name. The C++ language    (and many other OO-styled or functional languages) practically    requires such a mechanism, as otherwise it becomes very difficult    or even impossible to signal failure conditions in complex    situations.  The traditional C++ example is when an error occurs in    the process of constructing an object; without such a mechanism, it    is impossible to signal that the error occurs without adding global    state variables and error checks around every object construction.     The act of causing this event to occur is referred to as "throwing    an exception". (Alternate terms include "raising an exception" or    "signaling an exception".) The term "throw" is used because control    is returned to the callers of the function that is signaling the    exception, and thus there is the concept of "throwing" the    exception up the call stack.     [ Add updated documentation on how to use this.  ]  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Provide defaults for stuff that may not be defined when using    sjlj exceptions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EH_RETURN_DATA_REGNO
end_ifndef

begin_define
define|#
directive|define
name|EH_RETURN_DATA_REGNO
parameter_list|(
name|N
parameter_list|)
value|INVALID_REGNUM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means enable synchronous exceptions for non-call instructions.  */
end_comment

begin_decl_stmt
name|int
name|flag_non_call_exceptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protect cleanup actions with must-not-throw regions, with a call    to the given failure handler.  */
end_comment

begin_macro
name|tree
argument_list|(
argument|*lang_protect_cleanup_actions
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return true if type A catches type B.  */
end_comment

begin_macro
name|int
argument_list|(
argument|*lang_eh_type_covers
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
name|a
operator|,
name|tree
name|b
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Map a type to a runtime object to match type.  */
end_comment

begin_macro
name|tree
argument_list|(
argument|*lang_eh_runtime_type
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A hash table of label to region number.  */
end_comment

begin_decl_stmt
name|struct
name|ehl_map_entry
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|int
name|call_site_base
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (union tree_node))
argument_list|)
name|htab_t
name|type_to_runtime_map
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Describe the SjLj_Function_Context structure.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|sjlj_fc_type_node
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_call_site_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_data_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_personality_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_lsda_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_jbuf_ofs
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Describes one exception region.  */
end_comment

begin_decl_stmt
name|struct
name|eh_region
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The immediately surrounding region.  */
name|struct
name|eh_region
modifier|*
name|outer
decl_stmt|;
comment|/* The list of immediately contained regions.  */
name|struct
name|eh_region
modifier|*
name|inner
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|next_peer
decl_stmt|;
comment|/* An identifier for this region.  */
name|int
name|region_number
decl_stmt|;
comment|/* When a region is deleted, its parents inherit the REG_EH_REGION      numbers already assigned.  */
name|bitmap
name|aka
decl_stmt|;
comment|/* Each region does exactly one thing.  */
enum|enum
name|eh_region_type
block|{
name|ERT_UNKNOWN
init|=
literal|0
block|,
name|ERT_CLEANUP
block|,
name|ERT_TRY
block|,
name|ERT_CATCH
block|,
name|ERT_ALLOWED_EXCEPTIONS
block|,
name|ERT_MUST_NOT_THROW
block|,
name|ERT_THROW
block|,
name|ERT_FIXUP
block|}
name|type
enum|;
comment|/* Holds the action to perform based on the preceding type.  */
union|union
name|eh_region_u
block|{
comment|/* A list of catch blocks, a surrounding try block,        and the label for continuing after a catch.  */
struct|struct
name|eh_region_u_try
block|{
name|struct
name|eh_region
modifier|*
name|catch
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|last_catch
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|prev_try
decl_stmt|;
name|rtx
name|continue_label
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_TRY"
argument_list|)
operator|)
argument_list|)
name|try
struct|;
comment|/* The list through the catch handlers, the list of type objects        matched, and the list of associated filters.  */
struct|struct
name|eh_region_u_catch
block|{
name|struct
name|eh_region
modifier|*
name|next_catch
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|prev_catch
decl_stmt|;
name|tree
name|type_list
decl_stmt|;
name|tree
name|filter_list
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_CATCH"
argument_list|)
operator|)
argument_list|)
name|catch
struct|;
comment|/* A tree_list of allowed types.  */
struct|struct
name|eh_region_u_allowed
block|{
name|tree
name|type_list
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_ALLOWED_EXCEPTIONS"
argument_list|)
operator|)
argument_list|)
name|allowed
struct|;
comment|/* The type given by a call to "throw foo();", or discovered        for a throw.  */
struct|struct
name|eh_region_u_throw
block|{
name|tree
name|type
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_THROW"
argument_list|)
operator|)
argument_list|)
name|throw
struct|;
comment|/* Retain the cleanup expression even after expansion so that        we can match up fixup regions.  */
struct|struct
name|eh_region_u_cleanup
block|{
name|tree
name|exp
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|prev_try
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_CLEANUP"
argument_list|)
operator|)
argument_list|)
name|cleanup
struct|;
comment|/* The real region (by expression and by pointer) that fixup code        should live in.  */
struct|struct
name|eh_region_u_fixup
block|{
name|tree
name|cleanup_exp
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|real_region
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_FIXUP"
argument_list|)
operator|)
argument_list|)
name|fixup
struct|;
block|}
name|GTY
argument_list|(
operator|(
name|desc
argument_list|(
literal|"%0.type"
argument_list|)
operator|)
argument_list|)
name|u
union|;
comment|/* Entry point for this region's handler before landing pads are built.  */
name|rtx
name|label
decl_stmt|;
comment|/* Entry point for this region's handler from the runtime eh library.  */
name|rtx
name|landing_pad
decl_stmt|;
comment|/* Entry point for this region's handler from an inner region.  */
name|rtx
name|post_landing_pad
decl_stmt|;
comment|/* The RESX insn for handing off control to the next outermost handler,      if appropriate.  */
name|rtx
name|resume
decl_stmt|;
comment|/* True if something in this region may throw.  */
name|unsigned
name|may_contain_throw
range|:
literal|1
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|call_site_record
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|landing_pad
decl_stmt|;
name|int
name|action
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Used to save exception status for each function.  */
end_comment

begin_decl_stmt
name|struct
name|eh_status
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The tree of all regions for this function.  */
name|struct
name|eh_region
modifier|*
name|region_tree
decl_stmt|;
comment|/* The same information as an indexable array.  */
name|struct
name|eh_region
modifier|*
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"%h.last_region_number"
argument_list|)
operator|)
argument_list|)
name|region_array
decl_stmt|;
comment|/* The most recently open region.  */
name|struct
name|eh_region
modifier|*
name|cur_region
decl_stmt|;
comment|/* This is the region for which we are processing catch blocks.  */
name|struct
name|eh_region
modifier|*
name|try_region
decl_stmt|;
name|rtx
name|filter
decl_stmt|;
name|rtx
name|exc_ptr
decl_stmt|;
name|int
name|built_landing_pads
decl_stmt|;
name|int
name|last_region_number
decl_stmt|;
name|varray_type
name|ttype_data
decl_stmt|;
name|varray_type
name|ehspec_data
decl_stmt|;
name|varray_type
name|action_record_data
decl_stmt|;
name|htab_t
name|GTY
argument_list|(
operator|(
name|param_is
argument_list|(
expr|struct
name|ehl_map_entry
argument_list|)
operator|)
argument_list|)
name|exception_handler_label_map
decl_stmt|;
name|struct
name|call_site_record
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"%h.call_site_data_used"
argument_list|)
operator|)
argument_list|)
name|call_site_data
decl_stmt|;
name|int
name|call_site_data_used
decl_stmt|;
name|int
name|call_site_data_size
decl_stmt|;
name|rtx
name|ehr_stackadj
decl_stmt|;
name|rtx
name|ehr_handler
decl_stmt|;
name|rtx
name|ehr_label
decl_stmt|;
name|rtx
name|sjlj_fc
decl_stmt|;
name|rtx
name|sjlj_exit_after
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|t2r_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|t2r_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_type_for_runtime
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_type_for_runtime
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eh_region
modifier|*
name|expand_eh_region_end
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_exception_filter
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|collect_eh_region_array
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resolve_fixup_regions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_fixup_regions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_unreachable_regions
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_from_eh_region_ranges_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eh_region
modifier|*
name|duplicate_eh_region_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|eh_region
operator|*
operator|,
expr|struct
name|inline_remap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|duplicate_eh_region_2
name|PARAMS
argument_list|(
operator|(
expr|struct
name|eh_region
operator|*
operator|,
expr|struct
name|eh_region
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ttypes_filter_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|ttypes_filter_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ehspec_filter_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|ehspec_filter_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_ttypes_entry
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_ehspec_entry
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|htab_t
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assign_filter_values
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_post_landing_pads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|connect_post_landing_pads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dw2_build_landing_pads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|sjlj_lp_info
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|bool
name|sjlj_find_directly_reachable_regions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|sjlj_lp_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sjlj_assign_call_site_values
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|sjlj_lp_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sjlj_mark_call_sites
name|PARAMS
argument_list|(
operator|(
expr|struct
name|sjlj_lp_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sjlj_emit_function_enter
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sjlj_emit_function_exit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sjlj_emit_dispatch_table
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|sjlj_lp_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sjlj_build_landing_pads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|ehl_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ehl_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_ehl_entry
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|eh_region
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_exception_handler_label
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_eh_handler
name|PARAMS
argument_list|(
operator|(
expr|struct
name|eh_region
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|for_each_eh_label_1
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|reachable_info
struct_decl|;
end_struct_decl

begin_comment
comment|/* The return value of reachable_next_level.  */
end_comment

begin_enum
enum|enum
name|reachable_code
block|{
comment|/* The given exception is not processed by the given region.  */
name|RNL_NOT_CAUGHT
block|,
comment|/* The given exception may need processing by the given region.  */
name|RNL_MAYBE_CAUGHT
block|,
comment|/* The given exception is completely processed by the given region.  */
name|RNL_CAUGHT
block|,
comment|/* The given exception is completely processed by the runtime.  */
name|RNL_BLOCKED
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|check_handled
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_reachable_handler
name|PARAMS
argument_list|(
operator|(
expr|struct
name|reachable_info
operator|*
operator|,
expr|struct
name|eh_region
operator|*
operator|,
expr|struct
name|eh_region
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|reachable_code
name|reachable_next_level
name|PARAMS
argument_list|(
operator|(
expr|struct
name|eh_region
operator|*
operator|,
name|tree
operator|,
expr|struct
name|reachable_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|action_record_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|action_record_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_action_record
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|collect_one_action_chain
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
expr|struct
name|eh_region
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_call_site
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_uleb128
name|PARAMS
argument_list|(
operator|(
name|varray_type
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_sleb128
name|PARAMS
argument_list|(
operator|(
name|varray_type
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_AS_LEB128
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|dw2_size_of_call_site_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_size_of_call_site_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dw2_output_call_site_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sjlj_output_call_site_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Routine to see if exception handling is turned on.    DO_WARN is nonzero if we want to inform the user that exception    handling is turned off.     This is used to ensure that -fexceptions has been specified if the    compiler tries to use any exception-specific functions.  */
end_comment

begin_function
name|int
name|doing_eh
parameter_list|(
name|do_warn
parameter_list|)
name|int
name|do_warn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|do_warn
condition|)
block|{
name|error
argument_list|(
literal|"exception handling disabled, use -fexceptions to enable"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_eh
parameter_list|()
block|{
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
return|return;
name|type_to_runtime_map
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|t2r_hash
argument_list|,
name|t2r_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create the SjLj_Function_Context structure.  This should match      the definition in unwind-sjlj.c.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
block|{
name|tree
name|f_jbuf
decl_stmt|,
name|f_per
decl_stmt|,
name|f_lsda
decl_stmt|,
name|f_prev
decl_stmt|,
name|f_cs
decl_stmt|,
name|f_data
decl_stmt|,
name|tmp
decl_stmt|;
name|sjlj_fc_type_node
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|f_prev
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__prev"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_prev
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|f_cs
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__call_site"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_cs
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|tmp
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
literal|4
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_array_type
argument_list|(
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|word_mode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|f_data
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__data"
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_data
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|f_per
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__personality"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_per
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|f_lsda
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__lsda"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_lsda
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
ifdef|#
directive|ifdef
name|JMP_BUF_SIZE
name|tmp
operator|=
name|build_int_2
argument_list|(
name|JMP_BUF_SIZE
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Should be large enough for most systems, if it is not, 	 JMP_BUF_SIZE should be defined with the proper value.  It will 	 also tend to be larger than necessary for most systems, a more 	 optimal port will define JMP_BUF_SIZE.  */
name|tmp
operator|=
name|build_int_2
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|+
literal|2
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* This is 2 for builtin_setjmp, plus whatever the target requires 	 via STACK_SAVEAREA_MODE (SAVE_NONLOCAL).  */
name|tmp
operator|=
name|build_int_2
argument_list|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
operator|)
operator|+
literal|2
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|build_index_type
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|f_jbuf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__jbuf"
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
comment|/* We don't know what the alignment requirements of the 	 runtime's jmp_buf has.  Overestimate.  */
name|DECL_ALIGN
argument_list|(
name|f_jbuf
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|f_jbuf
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_jbuf
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|sjlj_fc_type_node
argument_list|)
operator|=
name|f_prev
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_prev
argument_list|)
operator|=
name|f_cs
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_cs
argument_list|)
operator|=
name|f_data
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_data
argument_list|)
operator|=
name|f_per
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_per
argument_list|)
operator|=
name|f_lsda
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_lsda
argument_list|)
operator|=
name|f_jbuf
expr_stmt|;
name|layout_type
argument_list|(
name|sjlj_fc_type_node
argument_list|)
expr_stmt|;
comment|/* Cache the interesting field offsets so that we have 	 easy access from rtl.  */
name|sjlj_fc_call_site_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_cs
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_cs
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_data_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_data
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_data
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_personality_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_per
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_per
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_lsda_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_lsda
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_lsda
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_jbuf_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_jbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_jbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_eh_for_function
parameter_list|()
block|{
name|cfun
operator|->
name|eh
operator|=
operator|(
expr|struct
name|eh_status
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start an exception handling region.  All instructions emitted    after this point are considered to be part of the region until    expand_eh_region_end is invoked.  */
end_comment

begin_function
name|void
name|expand_eh_region_start
parameter_list|()
block|{
name|struct
name|eh_region
modifier|*
name|new_region
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|cur_region
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
comment|/* Insert a new blank region as a leaf in the tree.  */
name|new_region
operator|=
operator|(
expr|struct
name|eh_region
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_region
argument_list|)
argument_list|)
expr_stmt|;
name|cur_region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|cur_region
expr_stmt|;
name|new_region
operator|->
name|outer
operator|=
name|cur_region
expr_stmt|;
if|if
condition|(
name|cur_region
condition|)
block|{
name|new_region
operator|->
name|next_peer
operator|=
name|cur_region
operator|->
name|inner
expr_stmt|;
name|cur_region
operator|->
name|inner
operator|=
name|new_region
expr_stmt|;
block|}
else|else
block|{
name|new_region
operator|->
name|next_peer
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|=
name|new_region
expr_stmt|;
block|}
name|cfun
operator|->
name|eh
operator|->
name|cur_region
operator|=
name|new_region
expr_stmt|;
comment|/* Create a note marking the start of this region.  */
name|new_region
operator|->
name|region_number
operator|=
operator|++
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_EH_REGION_BEG
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|new_region
operator|->
name|region_number
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Common code to end a region.  Returns the region just ended.  */
end_comment

begin_function
specifier|static
name|struct
name|eh_region
modifier|*
name|expand_eh_region_end
parameter_list|()
block|{
name|struct
name|eh_region
modifier|*
name|cur_region
init|=
name|cfun
operator|->
name|eh
operator|->
name|cur_region
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Create a note marking the end of this region.  */
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_EH_REGION_END
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|cur_region
operator|->
name|region_number
expr_stmt|;
comment|/* Pop.  */
name|cfun
operator|->
name|eh
operator|->
name|cur_region
operator|=
name|cur_region
operator|->
name|outer
expr_stmt|;
return|return
name|cur_region
return|;
block|}
end_function

begin_comment
comment|/* End an exception handling region for a cleanup.  HANDLER is an    expression to expand for the cleanup.  */
end_comment

begin_function
name|void
name|expand_eh_region_end_cleanup
parameter_list|(
name|handler
parameter_list|)
name|tree
name|handler
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|protect_cleanup_actions
decl_stmt|;
name|rtx
name|around_label
decl_stmt|;
name|rtx
name|data_save
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|region
operator|=
name|expand_eh_region_end
argument_list|()
expr_stmt|;
name|region
operator|->
name|type
operator|=
name|ERT_CLEANUP
expr_stmt|;
name|region
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|region
operator|->
name|u
operator|.
name|cleanup
operator|.
name|exp
operator|=
name|handler
expr_stmt|;
name|region
operator|->
name|u
operator|.
name|cleanup
operator|.
name|prev_try
operator|=
name|cfun
operator|->
name|eh
operator|->
name|try_region
expr_stmt|;
name|around_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_non_call_exceptions
operator|||
name|region
operator|->
name|may_contain_throw
condition|)
block|{
comment|/* Give the language a chance to specify an action to be taken if an 	 exception is thrown that would propagate out of the HANDLER.  */
name|protect_cleanup_actions
operator|=
operator|(
name|lang_protect_cleanup_actions
condition|?
call|(
modifier|*
name|lang_protect_cleanup_actions
call|)
argument_list|()
else|:
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|protect_cleanup_actions
condition|)
name|expand_eh_region_start
argument_list|()
expr_stmt|;
comment|/* In case this cleanup involves an inline destructor with a try block in 	 it, we need to save the EH return data registers around it.  */
name|data_save
index|[
literal|0
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|ptr_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|data_save
index|[
literal|0
index|]
argument_list|,
name|get_exception_pointer
argument_list|(
name|cfun
argument_list|)
argument_list|)
expr_stmt|;
name|data_save
index|[
literal|1
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|data_save
index|[
literal|1
index|]
argument_list|,
name|get_exception_filter
argument_list|(
name|cfun
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|handler
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exc_ptr
argument_list|,
name|data_save
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|data_save
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|protect_cleanup_actions
condition|)
name|expand_eh_region_end_must_not_throw
argument_list|(
name|protect_cleanup_actions
argument_list|)
expr_stmt|;
comment|/* We need any stack adjustment complete before the around_label.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
comment|/* We delay the generation of the _Unwind_Resume until we generate      landing pads.  We emit a marker here so as to get good control      flow data in the meantime.  */
name|region
operator|->
name|resume
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_RESX
argument_list|(
name|VOIDmode
argument_list|,
name|region
operator|->
name|region_number
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End an exception handling region for a try block, and prepares    for subsequent calls to expand_start_catch.  */
end_comment

begin_function
name|void
name|expand_start_all_catch
parameter_list|()
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|region
operator|=
name|expand_eh_region_end
argument_list|()
expr_stmt|;
name|region
operator|->
name|type
operator|=
name|ERT_TRY
expr_stmt|;
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|prev_try
operator|=
name|cfun
operator|->
name|eh
operator|->
name|try_region
expr_stmt|;
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|try_region
operator|=
name|region
expr_stmt|;
name|emit_jump
argument_list|(
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a catch clause.  TYPE is the type caught, a list of such types, or    null if this is a catch-all clause. Providing a type list enables to    associate the catch region with potentially several exception types, which    is useful e.g. for Ada.  */
end_comment

begin_function
name|void
name|expand_start_catch
parameter_list|(
name|type_or_list
parameter_list|)
name|tree
name|type_or_list
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|t
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|tree
name|type_list
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|type_list
operator|=
name|type_or_list
expr_stmt|;
if|if
condition|(
name|type_or_list
condition|)
block|{
comment|/* Ensure to always end up with a type list to normalize further          processing, then register each type against the runtime types          map.  */
name|tree
name|type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_or_list
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|type_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type_or_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|type_node
operator|=
name|type_list
expr_stmt|;
for|for
control|(
init|;
name|type_node
condition|;
name|type_node
operator|=
name|TREE_CHAIN
argument_list|(
name|type_node
argument_list|)
control|)
name|add_type_for_runtime
argument_list|(
name|TREE_VALUE
argument_list|(
name|type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|t
operator|=
name|cfun
operator|->
name|eh
operator|->
name|try_region
expr_stmt|;
name|c
operator|=
name|cfun
operator|->
name|eh
operator|->
name|cur_region
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|ERT_CATCH
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|=
name|type_list
expr_stmt|;
name|c
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|l
operator|=
name|t
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|l
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
operator|=
name|c
expr_stmt|;
else|else
name|t
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|=
name|c
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
operator|=
name|c
expr_stmt|;
name|emit_label
argument_list|(
name|c
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a catch clause.  Control will resume after the try/catch block.  */
end_comment

begin_function
name|void
name|expand_end_catch
parameter_list|()
block|{
name|struct
name|eh_region
modifier|*
name|try_region
decl_stmt|,
modifier|*
name|catch_region
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|catch_region
operator|=
name|expand_eh_region_end
argument_list|()
expr_stmt|;
name|try_region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|try_region
expr_stmt|;
name|emit_jump
argument_list|(
name|try_region
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a sequence of catch handlers for a try block.  */
end_comment

begin_function
name|void
name|expand_end_all_catch
parameter_list|()
block|{
name|struct
name|eh_region
modifier|*
name|try_region
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|try_region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|try_region
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|try_region
operator|=
name|try_region
operator|->
name|u
operator|.
name|try
operator|.
name|prev_try
expr_stmt|;
name|emit_label
argument_list|(
name|try_region
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End an exception region for an exception type filter.  ALLOWED is a    TREE_LIST of types to be matched by the runtime.  FAILURE is an    expression to invoke if a mismatch occurs.     ??? We could use these semantics for calls to rethrow, too; if we can    see the surrounding catch clause, we know that the exception we're    rethrowing satisfies the "filter" of the catch type.  */
end_comment

begin_function
name|void
name|expand_eh_region_end_allowed
parameter_list|(
name|allowed
parameter_list|,
name|failure
parameter_list|)
name|tree
name|allowed
decl_stmt|,
name|failure
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|rtx
name|around_label
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|region
operator|=
name|expand_eh_region_end
argument_list|()
expr_stmt|;
name|region
operator|->
name|type
operator|=
name|ERT_ALLOWED_EXCEPTIONS
expr_stmt|;
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
operator|=
name|allowed
expr_stmt|;
name|region
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|allowed
condition|;
name|allowed
operator|=
name|TREE_CHAIN
argument_list|(
name|allowed
argument_list|)
control|)
name|add_type_for_runtime
argument_list|(
name|TREE_VALUE
argument_list|(
name|allowed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must emit the call to FAILURE here, so that if this function      throws a different exception, that it will be processed by the      correct region.  */
name|around_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|failure
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* We must adjust the stack before we reach the AROUND_LABEL because      the call to FAILURE does not occur on all paths to the      AROUND_LABEL.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End an exception region for a must-not-throw filter.  FAILURE is an    expression invoke if an uncaught exception propagates this far.     This is conceptually identical to expand_eh_region_end_allowed with    an empty allowed list (if you passed "std::terminate" instead of    "__cxa_call_unexpected"), but they are represented differently in    the C++ LSDA.  */
end_comment

begin_function
name|void
name|expand_eh_region_end_must_not_throw
parameter_list|(
name|failure
parameter_list|)
name|tree
name|failure
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|rtx
name|around_label
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|region
operator|=
name|expand_eh_region_end
argument_list|()
expr_stmt|;
name|region
operator|->
name|type
operator|=
name|ERT_MUST_NOT_THROW
expr_stmt|;
name|region
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* We must emit the call to FAILURE here, so that if this function      throws a different exception, that it will be processed by the      correct region.  */
name|around_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|failure
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End an exception region for a throw.  No handling goes on here,    but it's the easiest way for the front-end to indicate what type    is being thrown.  */
end_comment

begin_function
name|void
name|expand_eh_region_end_throw
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|region
operator|=
name|expand_eh_region_end
argument_list|()
expr_stmt|;
name|region
operator|->
name|type
operator|=
name|ERT_THROW
expr_stmt|;
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a fixup region.  Within this region the cleanups for the immediately    enclosing region are _not_ run.  This is used for goto cleanup to avoid    destroying an object twice.     This would be an extraordinarily simple prospect, were it not for the    fact that we don't actually know what the immediately enclosing region    is.  This surprising fact is because expand_cleanups is currently    generating a sequence that it will insert somewhere else.  We collect    the proper notion of "enclosing" in convert_from_eh_region_ranges.  */
end_comment

begin_function
name|void
name|expand_eh_region_end_fixup
parameter_list|(
name|handler
parameter_list|)
name|tree
name|handler
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|fixup
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|fixup
operator|=
name|expand_eh_region_end
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|type
operator|=
name|ERT_FIXUP
expr_stmt|;
name|fixup
operator|->
name|u
operator|.
name|fixup
operator|.
name|cleanup_exp
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that the current EH region (if any) may contain a throw, or a    call to a function which itself may contain a throw.  */
end_comment

begin_function
name|void
name|note_eh_region_may_contain_throw
parameter_list|()
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|cur_region
expr_stmt|;
while|while
condition|(
name|region
operator|&&
operator|!
name|region
operator|->
name|may_contain_throw
condition|)
block|{
name|region
operator|->
name|may_contain_throw
operator|=
literal|1
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an rtl expression for a pointer to the exception object    within a handler.  */
end_comment

begin_function
name|rtx
name|get_exception_pointer
parameter_list|(
name|fun
parameter_list|)
name|struct
name|function
modifier|*
name|fun
decl_stmt|;
block|{
name|rtx
name|exc_ptr
init|=
name|fun
operator|->
name|eh
operator|->
name|exc_ptr
decl_stmt|;
if|if
condition|(
name|fun
operator|==
name|cfun
operator|&&
operator|!
name|exc_ptr
condition|)
block|{
name|exc_ptr
operator|=
name|gen_reg_rtx
argument_list|(
name|ptr_mode
argument_list|)
expr_stmt|;
name|fun
operator|->
name|eh
operator|->
name|exc_ptr
operator|=
name|exc_ptr
expr_stmt|;
block|}
return|return
name|exc_ptr
return|;
block|}
end_function

begin_comment
comment|/* Return an rtl expression for the exception dispatch filter    within a handler.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_exception_filter
parameter_list|(
name|fun
parameter_list|)
name|struct
name|function
modifier|*
name|fun
decl_stmt|;
block|{
name|rtx
name|filter
init|=
name|fun
operator|->
name|eh
operator|->
name|filter
decl_stmt|;
if|if
condition|(
name|fun
operator|==
name|cfun
operator|&&
operator|!
name|filter
condition|)
block|{
name|filter
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|fun
operator|->
name|eh
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
block|}
return|return
name|filter
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section is for the exception handling specific optimization pass.  */
end_comment

begin_comment
comment|/* Random access the exception region tree.  It's just as simple to    collect the regions this way as in expand_eh_region_start, but    without having to realloc memory.  */
end_comment

begin_function
specifier|static
name|void
name|collect_eh_region_array
parameter_list|()
block|{
name|struct
name|eh_region
modifier|*
modifier|*
name|array
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
return|return;
name|array
operator|=
name|ggc_alloc_cleared
argument_list|(
operator|(
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|region_array
operator|=
name|array
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|array
index|[
name|i
operator|->
name|region_number
index|]
operator|=
name|i
expr_stmt|;
comment|/* If there are sub-regions, process them.  */
if|if
condition|(
name|i
operator|->
name|inner
condition|)
name|i
operator|=
name|i
operator|->
name|inner
expr_stmt|;
comment|/* If there are peers, process them.  */
elseif|else
if|if
condition|(
name|i
operator|->
name|next_peer
condition|)
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
comment|/* Otherwise, step back up the tree to the next peer.  */
else|else
block|{
do|do
block|{
name|i
operator|=
name|i
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
return|return;
block|}
do|while
condition|(
name|i
operator|->
name|next_peer
operator|==
name|NULL
condition|)
do|;
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|resolve_fixup_regions
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|fixup
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|cleanup
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fixup
operator|||
name|fixup
operator|->
name|type
operator|!=
name|ERT_FIXUP
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
operator|++
name|j
control|)
block|{
name|cleanup
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|cleanup
operator|->
name|type
operator|==
name|ERT_CLEANUP
operator|&&
name|cleanup
operator|->
name|u
operator|.
name|cleanup
operator|.
name|exp
operator|==
name|fixup
operator|->
name|u
operator|.
name|fixup
operator|.
name|cleanup_exp
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
name|n
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|u
operator|.
name|fixup
operator|.
name|real_region
operator|=
name|cleanup
operator|->
name|outer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Now that we've discovered what region actually encloses a fixup,    we can shuffle pointers and remove them from the tree.  */
end_comment

begin_function
specifier|static
name|void
name|remove_fixup_regions
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|fixup
decl_stmt|;
comment|/* Walk the insn chain and adjust the REG_EH_REGION numbers      for instructions referencing fixup regions.  This is only      strictly necessary for fixup regions with no parent, but      doesn't hurt to do it for all regions.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL
argument_list|)
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|fixup
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|)
operator|&&
name|fixup
operator|->
name|type
operator|==
name|ERT_FIXUP
condition|)
block|{
if|if
condition|(
name|fixup
operator|->
name|u
operator|.
name|fixup
operator|.
name|real_region
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|fixup
operator|->
name|u
operator|.
name|fixup
operator|.
name|real_region
operator|->
name|region_number
argument_list|)
expr_stmt|;
else|else
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the fixup regions from the tree.  */
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|fixup
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fixup
condition|)
continue|continue;
comment|/* Allow GC to maybe free some memory.  */
if|if
condition|(
name|fixup
operator|->
name|type
operator|==
name|ERT_CLEANUP
condition|)
name|fixup
operator|->
name|u
operator|.
name|cleanup
operator|.
name|exp
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fixup
operator|->
name|type
operator|!=
name|ERT_FIXUP
condition|)
continue|continue;
if|if
condition|(
name|fixup
operator|->
name|inner
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|parent
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|parent
operator|=
name|fixup
operator|->
name|u
operator|.
name|fixup
operator|.
name|real_region
expr_stmt|;
comment|/* Fix up the children's parent pointers; find the end of 	     the list.  */
for|for
control|(
name|p
operator|=
name|fixup
operator|->
name|inner
init|;
condition|;
name|p
operator|=
name|p
operator|->
name|next_peer
control|)
block|{
name|p
operator|->
name|outer
operator|=
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|next_peer
condition|)
break|break;
block|}
comment|/* In the tree of cleanups, only outer-inner ordering matters. 	     So link the children back in anywhere at the correct level.  */
if|if
condition|(
name|parent
condition|)
name|pp
operator|=
operator|&
name|parent
operator|->
name|inner
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
name|p
operator|->
name|next_peer
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
name|fixup
operator|->
name|inner
expr_stmt|;
name|fixup
operator|->
name|inner
operator|=
name|NULL
expr_stmt|;
block|}
name|remove_eh_handler
argument_list|(
name|fixup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove all regions whose labels are not reachable from insns.  */
end_comment

begin_function
specifier|static
name|void
name|remove_unreachable_regions
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
modifier|*
name|uid_region_num
decl_stmt|;
name|bool
modifier|*
name|reachable
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|r
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|uid_region_num
operator|=
name|xcalloc
argument_list|(
name|get_max_uid
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reachable
operator|=
name|xcalloc
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|||
name|r
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|r
operator|->
name|resume
condition|)
block|{
if|if
condition|(
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|resume
argument_list|)
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|resume
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|label
condition|)
block|{
if|if
condition|(
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|label
argument_list|)
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|label
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|ERT_TRY
operator|&&
name|r
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
condition|)
block|{
if|if
condition|(
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
argument_list|)
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|reachable
index|[
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
index|]
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|region_number
operator|==
name|i
operator|&&
operator|!
name|reachable
index|[
name|i
index|]
condition|)
block|{
comment|/* Don't remove ERT_THROW regions if their outer region 	     is reachable.  */
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|ERT_THROW
operator|&&
name|r
operator|->
name|outer
operator|&&
name|reachable
index|[
name|r
operator|->
name|outer
operator|->
name|region_number
index|]
condition|)
continue|continue;
name|remove_eh_handler
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reachable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uid_region_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn NOTE_INSN_EH_REGION notes into REG_EH_REGION notes for each    can_throw instruction in the region.  */
end_comment

begin_function
specifier|static
name|void
name|convert_from_eh_region_ranges_1
parameter_list|(
name|pinsns
parameter_list|,
name|orig_sp
parameter_list|,
name|cur
parameter_list|)
name|rtx
modifier|*
name|pinsns
decl_stmt|;
name|int
modifier|*
name|orig_sp
decl_stmt|;
name|int
name|cur
decl_stmt|;
block|{
name|int
modifier|*
name|sp
init|=
name|orig_sp
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
operator|*
name|pinsns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|int
name|kind
init|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|kind
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|r
decl_stmt|;
operator|*
name|sp
operator|++
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|NOTE_EH_HANDLER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|r
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|cur
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|ERT_FIXUP
condition|)
block|{
name|r
operator|=
name|r
operator|->
name|u
operator|.
name|fixup
operator|.
name|real_region
expr_stmt|;
name|cur
operator|=
name|r
condition|?
name|r
operator|->
name|region_number
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|ERT_CATCH
condition|)
block|{
name|r
operator|=
name|r
operator|->
name|outer
expr_stmt|;
name|cur
operator|=
name|r
condition|?
name|r
operator|->
name|region_number
else|:
literal|0
expr_stmt|;
block|}
block|}
else|else
name|cur
operator|=
operator|*
operator|--
name|sp
expr_stmt|;
comment|/* Removing the first insn of a CALL_PLACEHOLDER sequence 		 requires extra care to adjust sequence start.  */
if|if
condition|(
name|insn
operator|==
operator|*
name|pinsns
condition|)
operator|*
name|pinsns
operator|=
name|next
expr_stmt|;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur
operator|>
literal|0
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
comment|/* Calls can always potentially throw exceptions, unless 		 they have a REG_EH_REGION note with a value of 0 or less. 		 Which should be the only possible kind so far.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
comment|/* If we wanted exceptions for non-call insns, then 		     any may_trap_p instruction could throw.  */
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|GEN_INT
argument_list|(
name|cur
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|convert_from_eh_region_ranges_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sp
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|convert_from_eh_region_ranges_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sp
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|convert_from_eh_region_ranges_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
name|sp
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sp
operator|!=
name|orig_sp
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_from_eh_region_ranges
parameter_list|()
block|{
name|int
modifier|*
name|stack
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|collect_eh_region_array
argument_list|()
expr_stmt|;
name|resolve_fixup_regions
argument_list|()
expr_stmt|;
name|stack
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|convert_from_eh_region_ranges_1
argument_list|(
operator|&
name|insns
argument_list|,
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|remove_fixup_regions
argument_list|()
expr_stmt|;
name|remove_unreachable_regions
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_ehl_entry
parameter_list|(
name|label
parameter_list|,
name|region
parameter_list|)
name|rtx
name|label
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
block|{
name|struct
name|ehl_map_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|entry
operator|->
name|region
operator|=
name|region
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* Before landing pad creation, each exception handler has its own      label.  After landing pad creation, the exception handlers may      share landing pads.  This is ok, since maybe_remove_eh_handler      only requires the 1-1 mapping before landing pad creation.  */
if|if
condition|(
operator|*
name|slot
operator|&&
operator|!
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|slot
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
name|void
name|find_exception_handler_labels
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
condition|)
name|htab_empty
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* ??? The expansion factor here (3/2) must be greater than the htab 	 occupancy factor (4/3) to avoid unnecessary resizing.  */
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
operator|=
name|htab_create_ggc
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|*
literal|3
operator|/
literal|2
argument_list|,
name|ehl_hash
argument_list|,
name|ehl_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|lab
decl_stmt|;
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|lab
operator|=
name|region
operator|->
name|landing_pad
expr_stmt|;
else|else
name|lab
operator|=
name|region
operator|->
name|label
expr_stmt|;
if|if
condition|(
name|lab
condition|)
name|add_ehl_entry
argument_list|(
name|lab
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
comment|/* For sjlj exceptions, need the return label to remain live until      after landing pad generation.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
operator|&&
operator|!
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|add_ehl_entry
argument_list|(
name|return_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|current_function_has_exception_handlers
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|region
operator|->
name|type
operator|!=
name|ERT_THROW
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|eh_region
modifier|*
name|duplicate_eh_region_1
parameter_list|(
name|o
parameter_list|,
name|map
parameter_list|)
name|struct
name|eh_region
modifier|*
name|o
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|n
init|=
operator|(
expr|struct
name|eh_region
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_region
argument_list|)
argument_list|)
decl_stmt|;
name|n
operator|->
name|region_number
operator|=
name|o
operator|->
name|region_number
operator|+
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|o
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ERT_CLEANUP
case|:
case|case
name|ERT_MUST_NOT_THROW
case|:
break|break;
case|case
name|ERT_TRY
case|:
if|if
condition|(
name|o
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
condition|)
name|n
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
operator|=
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|o
operator|->
name|u
operator|.
name|try
operator|.
name|continue_label
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERT_CATCH
case|:
name|n
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|=
name|o
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
expr_stmt|;
break|break;
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
name|n
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
operator|=
name|o
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
expr_stmt|;
break|break;
case|case
name|ERT_THROW
case|:
name|n
operator|->
name|u
operator|.
name|throw
operator|.
name|type
operator|=
name|o
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|label
condition|)
name|n
operator|->
name|label
operator|=
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|o
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|resume
condition|)
block|{
name|n
operator|->
name|resume
operator|=
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|o
operator|->
name|resume
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|resume
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|duplicate_eh_region_2
parameter_list|(
name|o
parameter_list|,
name|n_array
parameter_list|)
name|struct
name|eh_region
modifier|*
name|o
decl_stmt|;
name|struct
name|eh_region
modifier|*
modifier|*
name|n_array
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|n
init|=
name|n_array
index|[
name|o
operator|->
name|region_number
index|]
decl_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ERT_TRY
case|:
name|n
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|=
name|n_array
index|[
name|o
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|->
name|region_number
index|]
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
operator|=
name|n_array
index|[
name|o
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
operator|->
name|region_number
index|]
expr_stmt|;
break|break;
case|case
name|ERT_CATCH
case|:
if|if
condition|(
name|o
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
condition|)
name|n
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
operator|=
name|n_array
index|[
name|o
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
operator|->
name|region_number
index|]
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
condition|)
name|n
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
operator|=
name|n_array
index|[
name|o
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
operator|->
name|region_number
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|o
operator|->
name|outer
condition|)
name|n
operator|->
name|outer
operator|=
name|n_array
index|[
name|o
operator|->
name|outer
operator|->
name|region_number
index|]
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|inner
condition|)
name|n
operator|->
name|inner
operator|=
name|n_array
index|[
name|o
operator|->
name|inner
operator|->
name|region_number
index|]
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|next_peer
condition|)
name|n
operator|->
name|next_peer
operator|=
name|n_array
index|[
name|o
operator|->
name|next_peer
operator|->
name|region_number
index|]
expr_stmt|;
block|}
end_function

begin_function
name|int
name|duplicate_eh_regions
parameter_list|(
name|ifun
parameter_list|,
name|map
parameter_list|)
name|struct
name|function
modifier|*
name|ifun
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|int
name|ifun_last_region_number
init|=
name|ifun
operator|->
name|eh
operator|->
name|last_region_number
decl_stmt|;
name|struct
name|eh_region
modifier|*
modifier|*
name|n_array
decl_stmt|,
modifier|*
name|root
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ifun_last_region_number
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n_array
operator|=
name|xcalloc
argument_list|(
name|ifun_last_region_number
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n_array
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ifun_last_region_number
condition|;
operator|++
name|i
control|)
block|{
name|cur
operator|=
name|ifun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cur
operator|||
name|cur
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
name|n_array
index|[
name|i
index|]
operator|=
name|duplicate_eh_region_1
argument_list|(
name|cur
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ifun_last_region_number
condition|;
operator|++
name|i
control|)
block|{
name|cur
operator|=
name|ifun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cur
operator|||
name|cur
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
name|duplicate_eh_region_2
argument_list|(
name|cur
argument_list|,
name|n_array
argument_list|)
expr_stmt|;
block|}
name|root
operator|=
name|n_array
index|[
name|ifun
operator|->
name|eh
operator|->
name|region_tree
operator|->
name|region_number
index|]
expr_stmt|;
name|cur
operator|=
name|cfun
operator|->
name|eh
operator|->
name|cur_region
expr_stmt|;
if|if
condition|(
name|cur
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|p
init|=
name|cur
operator|->
name|inner
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
while|while
condition|(
name|p
operator|->
name|next_peer
condition|)
name|p
operator|=
name|p
operator|->
name|next_peer
expr_stmt|;
name|p
operator|->
name|next_peer
operator|=
name|root
expr_stmt|;
block|}
else|else
name|cur
operator|->
name|inner
operator|=
name|root
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ifun_last_region_number
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|n_array
index|[
name|i
index|]
operator|&&
name|n_array
index|[
name|i
index|]
operator|->
name|outer
operator|==
name|NULL
condition|)
name|n_array
index|[
name|i
index|]
operator|->
name|outer
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
name|struct
name|eh_region
modifier|*
name|p
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_tree
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
while|while
condition|(
name|p
operator|->
name|next_peer
condition|)
name|p
operator|=
name|p
operator|->
name|next_peer
expr_stmt|;
name|p
operator|->
name|next_peer
operator|=
name|root
expr_stmt|;
block|}
else|else
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|=
name|root
expr_stmt|;
block|}
name|free
argument_list|(
name|n_array
argument_list|)
expr_stmt|;
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|=
name|i
operator|+
name|ifun_last_region_number
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|t2r_eq
parameter_list|(
name|pentry
parameter_list|,
name|pdata
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
specifier|const
name|PTR
name|pdata
decl_stmt|;
block|{
name|tree
name|entry
init|=
operator|(
name|tree
operator|)
name|pentry
decl_stmt|;
name|tree
name|data
init|=
operator|(
name|tree
operator|)
name|pdata
decl_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
name|entry
argument_list|)
operator|==
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|t2r_hash
parameter_list|(
name|pentry
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
block|{
name|tree
name|entry
init|=
operator|(
name|tree
operator|)
name|pentry
decl_stmt|;
return|return
name|TYPE_HASH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|entry
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_type_for_runtime
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
name|tree
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|type_to_runtime_map
argument_list|,
name|type
argument_list|,
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|tree
name|runtime
init|=
call|(
modifier|*
name|lang_eh_runtime_type
call|)
argument_list|(
name|type
argument_list|)
decl_stmt|;
operator|*
name|slot
operator|=
name|tree_cons
argument_list|(
name|type
argument_list|,
name|runtime
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_type_for_runtime
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
name|tree
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|type_to_runtime_map
argument_list|,
name|type
argument_list|,
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
comment|/* We should have always inserted the data earlier.  */
return|return
name|TREE_VALUE
argument_list|(
operator|*
name|slot
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Represent an entry in @TTypes for either catch actions    or exception filter actions.  */
end_comment

begin_decl_stmt
name|struct
name|ttypes_filter
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Compare ENTRY (a ttypes_filter entry in the hash table) with DATA    (a tree) for a @TTypes type node we are thinking about adding.  */
end_comment

begin_function
specifier|static
name|int
name|ttypes_filter_eq
parameter_list|(
name|pentry
parameter_list|,
name|pdata
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
specifier|const
name|PTR
name|pdata
decl_stmt|;
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
name|tree
name|data
init|=
operator|(
name|tree
operator|)
name|pdata
decl_stmt|;
return|return
name|entry
operator|->
name|t
operator|==
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|ttypes_filter_hash
parameter_list|(
name|pentry
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
return|return
name|TYPE_HASH
argument_list|(
name|entry
operator|->
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare ENTRY with DATA (both struct ttypes_filter) for a @TTypes    exception specification list we are thinking about adding.  */
end_comment

begin_comment
comment|/* ??? Currently we use the type lists in the order given.  Someone    should put these in some canonical order.  */
end_comment

begin_function
specifier|static
name|int
name|ehspec_filter_eq
parameter_list|(
name|pentry
parameter_list|,
name|pdata
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
specifier|const
name|PTR
name|pdata
decl_stmt|;
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|data
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pdata
decl_stmt|;
return|return
name|type_list_equal
argument_list|(
name|entry
operator|->
name|t
argument_list|,
name|data
operator|->
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hash function for exception specification lists.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|ehspec_filter_hash
parameter_list|(
name|pentry
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
name|hashval_t
name|h
init|=
literal|0
decl_stmt|;
name|tree
name|list
decl_stmt|;
for|for
control|(
name|list
operator|=
name|entry
operator|->
name|t
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|5
operator|)
operator|+
operator|(
name|h
operator|>>
literal|27
operator|)
operator|+
name|TYPE_HASH
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Add TYPE to cfun->eh->ttype_data, using TYPES_HASH to speed    up the search.  Return the filter value to be used.  */
end_comment

begin_function
specifier|static
name|int
name|add_ttypes_entry
parameter_list|(
name|ttypes_hash
parameter_list|,
name|type
parameter_list|)
name|htab_t
name|ttypes_hash
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|ttypes_filter
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ttypes_filter
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|ttypes_hash
argument_list|,
name|type
argument_list|,
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|slot
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Filter value is a 1 based table index.  */
name|n
operator|=
operator|(
expr|struct
name|ttypes_filter
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|t
operator|=
name|type
expr_stmt|;
name|n
operator|->
name|filter
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|slot
operator|=
name|n
expr_stmt|;
name|VARRAY_PUSH_TREE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|n
operator|->
name|filter
return|;
block|}
end_function

begin_comment
comment|/* Add LIST to cfun->eh->ehspec_data, using EHSPEC_HASH and TYPES_HASH    to speed up the search.  Return the filter value to be used.  */
end_comment

begin_function
specifier|static
name|int
name|add_ehspec_entry
parameter_list|(
name|ehspec_hash
parameter_list|,
name|ttypes_hash
parameter_list|,
name|list
parameter_list|)
name|htab_t
name|ehspec_hash
decl_stmt|;
name|htab_t
name|ttypes_hash
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|struct
name|ttypes_filter
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|ttypes_filter
name|dummy
decl_stmt|;
name|dummy
operator|.
name|t
operator|=
name|list
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ttypes_filter
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|ehspec_hash
argument_list|,
operator|&
name|dummy
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|slot
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Filter value is a -1 based byte index into a uleb128 buffer.  */
name|n
operator|=
operator|(
expr|struct
name|ttypes_filter
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|t
operator|=
name|list
expr_stmt|;
name|n
operator|->
name|filter
operator|=
operator|-
operator|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|slot
operator|=
name|n
expr_stmt|;
comment|/* Look up each type in the list and encode its filter 	 value as a uleb128.  Terminate the list with 0.  */
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
name|push_uleb128
argument_list|(
operator|&
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
name|add_ttypes_entry
argument_list|(
name|ttypes_hash
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_UCHAR
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|n
operator|->
name|filter
return|;
block|}
end_function

begin_comment
comment|/* Generate the action filter values to be used for CATCH and    ALLOWED_EXCEPTIONS regions.  When using dwarf2 exception regions,    we use lots of landing pads, and so every type or list can share    the same filter value, which saves table space.  */
end_comment

begin_function
specifier|static
name|void
name|assign_filter_values
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|htab_t
name|ttypes
decl_stmt|,
name|ehspec
decl_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|,
literal|16
argument_list|,
literal|"ttype_data"
argument_list|)
expr_stmt|;
name|VARRAY_UCHAR_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
literal|64
argument_list|,
literal|"ehspec_data"
argument_list|)
expr_stmt|;
name|ttypes
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|ttypes_filter_hash
argument_list|,
name|ttypes_filter_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|ehspec
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|ehspec_filter_hash
argument_list|,
name|ehspec_filter_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|r
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|r
operator|||
name|r
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
switch|switch
condition|(
name|r
operator|->
name|type
condition|)
block|{
case|case
name|ERT_CATCH
case|:
comment|/* Whatever type_list is (NULL or true list), we build a list 	     of filters for the region.  */
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|!=
name|NULL
condition|)
block|{
comment|/* Get a filter value for each of the types caught and store 		 them in the region's dedicated list.  */
name|tree
name|tp_node
init|=
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
for|for
control|(
init|;
name|tp_node
condition|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
control|)
block|{
name|int
name|flt
init|=
name|add_ttypes_entry
argument_list|(
name|ttypes
argument_list|,
name|TREE_VALUE
argument_list|(
name|tp_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|flt_node
init|=
name|build_int_2
argument_list|(
name|flt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|flt_node
argument_list|,
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Get a filter value for the NULL list also since it will need 		 an action record anyway.  */
name|int
name|flt
init|=
name|add_ttypes_entry
argument_list|(
name|ttypes
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|flt_node
init|=
name|build_int_2
argument_list|(
name|flt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|flt_node
argument_list|,
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
name|r
operator|->
name|u
operator|.
name|allowed
operator|.
name|filter
operator|=
name|add_ehspec_entry
argument_list|(
name|ehspec
argument_list|,
name|ttypes
argument_list|,
name|r
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|htab_delete
argument_list|(
name|ttypes
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ehspec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_post_landing_pads
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
switch|switch
condition|(
name|region
operator|->
name|type
condition|)
block|{
case|case
name|ERT_TRY
case|:
comment|/* ??? Collect the set of all non-overlapping catch handlers 	       all the way up the chain until blocked by a cleanup.  */
comment|/* ??? Outer try regions can share landing pads with inner 	     try regions if the types are completely non-overlapping, 	     and there are no intervening cleanups.  */
name|region
operator|->
name|post_landing_pad
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
comment|/* ??? It is mighty inconvenient to call back into the 	     switch statement generation code in expand_end_case. 	     Rapid prototyping sez a sequence of ifs.  */
block|{
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|catch
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
control|)
block|{
if|if
condition|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|==
name|NULL
condition|)
name|emit_jump
argument_list|(
name|c
operator|->
name|label
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Need for one cmp/jump per type caught. Each type 		       list entry has a matching entry in the filter list 		       (see assign_filter_values).  */
name|tree
name|tp_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
name|tree
name|flt_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
decl_stmt|;
for|for
control|(
init|;
name|tp_node
condition|;
control|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|flt_node
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|label
argument_list|)
expr_stmt|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
expr_stmt|;
name|flt_node
operator|=
name|TREE_CHAIN
argument_list|(
name|flt_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* We delay the generation of the _Unwind_Resume until we generate 	     landing pads.  We emit a marker here so as to get good control 	     flow data in the meantime.  */
name|region
operator|->
name|resume
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_RESX
argument_list|(
name|VOIDmode
argument_list|,
name|region
operator|->
name|region_number
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|->
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
name|region
operator|->
name|post_landing_pad
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|GEN_INT
argument_list|(
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|filter
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
literal|0
argument_list|,
name|region
operator|->
name|label
argument_list|)
expr_stmt|;
comment|/* We delay the generation of the _Unwind_Resume until we generate 	     landing pads.  We emit a marker here so as to get good control 	     flow data in the meantime.  */
name|region
operator|->
name|resume
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_RESX
argument_list|(
name|VOIDmode
argument_list|,
name|region
operator|->
name|region_number
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERT_CLEANUP
case|:
case|case
name|ERT_MUST_NOT_THROW
case|:
name|region
operator|->
name|post_landing_pad
operator|=
name|region
operator|->
name|label
expr_stmt|;
break|break;
case|case
name|ERT_CATCH
case|:
case|case
name|ERT_THROW
case|:
comment|/* Nothing to do.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace RESX patterns with jumps to the next handler if any, or calls to    _Unwind_Resume otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|connect_post_landing_pads
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|outer
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
comment|/* If there is no RESX, or it has been deleted by flow, there's 	 nothing to fix up.  */
if|if
condition|(
operator|!
name|region
operator|->
name|resume
operator|||
name|INSN_DELETED_P
argument_list|(
name|region
operator|->
name|resume
argument_list|)
condition|)
continue|continue;
comment|/* Search for another landing pad in this function.  */
for|for
control|(
name|outer
operator|=
name|region
operator|->
name|outer
init|;
name|outer
condition|;
name|outer
operator|=
name|outer
operator|->
name|outer
control|)
if|if
condition|(
name|outer
operator|->
name|post_landing_pad
condition|)
break|break;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|outer
condition|)
name|emit_jump
argument_list|(
name|outer
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
else|else
name|emit_library_call
argument_list|(
name|unwind_resume_libfunc
argument_list|,
name|LCT_THROW
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|exc_ptr
argument_list|,
name|ptr_mode
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|resume
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|region
operator|->
name|resume
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dw2_build_landing_pads
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|bool
name|clobbers_hard_regs
init|=
name|false
decl_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|region
operator|->
name|type
operator|!=
name|ERT_CLEANUP
operator|&&
name|region
operator|->
name|type
operator|!=
name|ERT_TRY
operator|&&
name|region
operator|->
name|type
operator|!=
name|ERT_ALLOWED_EXCEPTIONS
condition|)
continue|continue;
name|start_sequence
argument_list|()
expr_stmt|;
name|region
operator|->
name|landing_pad
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|landing_pad
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_exception_receiver
if|if
condition|(
name|HAVE_exception_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_exception_receiver
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Nothing */
block|}
comment|/* If the eh_return data registers are call-saved, then we 	 won't have considered them clobbered from the call that 	 threw.  Kill them now.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
operator|++
name|j
control|)
block|{
name|unsigned
name|r
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|INVALID_REGNUM
condition|)
break|break;
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|r
index|]
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|clobbers_hard_regs
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clobbers_hard_regs
condition|)
block|{
comment|/* @@@ This is a kludge.  Not all machine descriptions define a 	     blockage insn, but we must not allow the code we just generated 	     to be reordered by scheduling.  So emit an ASM_INPUT to act as 	     blockage insn.  */
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exc_ptr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
name|EH_RETURN_DATA_REGNO
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|EH_RETURN_DATA_REGNO
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|sjlj_lp_info
block|{
name|int
name|directly_reachable
decl_stmt|;
name|int
name|action_index
decl_stmt|;
name|int
name|dispatch_index
decl_stmt|;
name|int
name|call_site_index
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bool
name|sjlj_find_directly_reachable_regions
parameter_list|(
name|lp_info
parameter_list|)
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|bool
name|found_one
init|=
name|false
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|enum
name|reachable_code
name|rc
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
comment|/* Find the first containing region that might handle the exception. 	 That's the landing pad to which we will transfer control.  */
name|rc
operator|=
name|RNL_NOT_CAUGHT
expr_stmt|;
for|for
control|(
init|;
name|region
condition|;
name|region
operator|=
name|region
operator|->
name|outer
control|)
block|{
name|rc
operator|=
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|RNL_NOT_CAUGHT
condition|)
break|break;
block|}
if|if
condition|(
name|rc
operator|==
name|RNL_MAYBE_CAUGHT
operator|||
name|rc
operator|==
name|RNL_CAUGHT
condition|)
block|{
name|lp_info
index|[
name|region
operator|->
name|region_number
index|]
operator|.
name|directly_reachable
operator|=
literal|1
expr_stmt|;
name|found_one
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|found_one
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_assign_call_site_values
parameter_list|(
name|dispatch_label
parameter_list|,
name|lp_info
parameter_list|)
name|rtx
name|dispatch_label
decl_stmt|;
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
decl_stmt|;
block|{
name|htab_t
name|ar_hash
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
decl_stmt|;
comment|/* First task: build the action table.  */
name|VARRAY_UCHAR_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
literal|64
argument_list|,
literal|"action_record_data"
argument_list|)
expr_stmt|;
name|ar_hash
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|action_record_hash
argument_list|,
name|action_record_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|r
init|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
decl_stmt|;
name|r
operator|->
name|landing_pad
operator|=
name|dispatch_label
expr_stmt|;
name|lp_info
index|[
name|i
index|]
operator|.
name|action_index
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|action_index
operator|!=
operator|-
literal|1
condition|)
name|cfun
operator|->
name|uses_eh_lsda
operator|=
literal|1
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|ar_hash
argument_list|)
expr_stmt|;
comment|/* Next: assign dispatch values.  In dwarf2 terms, this would be the      landing pad label for the region.  For sjlj though, there is one      common landing pad from which we dispatch to the post-landing pads.       A region receives a dispatch index if it is directly reachable      and requires in-function processing.  Regions that share post-landing      pads may share dispatch indices.  */
comment|/* ??? Post-landing pad sharing doesn't actually happen at the moment      (see build_post_landing_pads) so we don't bother checking for it.  */
name|index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
name|lp_info
index|[
name|i
index|]
operator|.
name|dispatch_index
operator|=
name|index
operator|++
expr_stmt|;
comment|/* Finally: assign call-site values.  If dwarf2 terms, this would be      the region number assigned by convert_to_eh_region_ranges, but      handles no-action and must-not-throw differently.  */
name|call_site_base
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
block|{
name|int
name|action
init|=
name|lp_info
index|[
name|i
index|]
operator|.
name|action_index
decl_stmt|;
comment|/* Map must-not-throw to otherwise unused call-site index 0.  */
if|if
condition|(
name|action
operator|==
operator|-
literal|2
condition|)
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Map no-action to otherwise unused call-site index -1.  */
elseif|else
if|if
condition|(
name|action
operator|==
operator|-
literal|1
condition|)
name|index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Otherwise, look it up in the table.  */
else|else
name|index
operator|=
name|add_call_site
argument_list|(
name|GEN_INT
argument_list|(
name|lp_info
index|[
name|i
index|]
operator|.
name|dispatch_index
argument_list|)
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|lp_info
index|[
name|i
index|]
operator|.
name|call_site_index
operator|=
name|index
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_mark_call_sites
parameter_list|(
name|lp_info
parameter_list|)
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
decl_stmt|;
block|{
name|int
name|last_call_site
init|=
operator|-
literal|2
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|mem
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|int
name|this_call_site
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|before
decl_stmt|,
name|p
decl_stmt|;
comment|/* Reset value tracking at extended basic block boundaries.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last_call_site
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
block|{
comment|/* Calls (and trapping insns) without notes are outside any 	     exception handling region in this function.  Mark them as 	     no action.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
name|this_call_site
operator|=
operator|-
literal|1
expr_stmt|;
else|else
continue|continue;
block|}
else|else
block|{
comment|/* Calls that are known to not throw need not be marked.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|this_call_site
operator|=
name|lp_info
index|[
name|region
operator|->
name|region_number
index|]
operator|.
name|call_site_index
expr_stmt|;
block|}
if|if
condition|(
name|this_call_site
operator|==
name|last_call_site
condition|)
continue|continue;
comment|/* Don't separate a call from it's argument loads.  */
name|before
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|before
operator|=
name|find_first_parameter_load
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|sjlj_fc_call_site_ofs
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|this_call_site
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|p
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last_call_site
operator|=
name|this_call_site
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Construct the SjLj_Function_Context.  */
end_comment

begin_function
specifier|static
name|void
name|sjlj_emit_function_enter
parameter_list|(
name|dispatch_label
parameter_list|)
name|rtx
name|dispatch_label
decl_stmt|;
block|{
name|rtx
name|fn_begin
decl_stmt|,
name|fc
decl_stmt|,
name|mem
decl_stmt|,
name|seq
decl_stmt|;
name|fc
operator|=
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* We're storing this libcall's address into memory instead of      calling it directly.  Thus, we must call assemble_external_libcall      here, as we can not depend on emit_library_call to do it for us.  */
name|assemble_external_libcall
argument_list|(
name|eh_personality_libfunc
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|Pmode
argument_list|,
name|sjlj_fc_personality_ofs
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|eh_personality_libfunc
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|Pmode
argument_list|,
name|sjlj_fc_lsda_ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|uses_eh_lsda
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LLSDA"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
block|{
name|rtx
name|x
decl_stmt|,
name|note
decl_stmt|;
name|x
operator|=
name|emit_library_call_value
argument_list|(
name|setjmp_libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_RETURNS_TWICE
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sjlj_fc_jbuf_ofs
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_EXPECTED_VALUE
argument_list|)
expr_stmt|;
name|NOTE_EXPECTED_VALUE
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|x
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dispatch_label
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|expand_builtin_setjmp_setup
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sjlj_fc_jbuf_ofs
argument_list|)
argument_list|,
name|dispatch_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|unwind_sjlj_register_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|XEXP
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* ??? Instead of doing this at the beginning of the function,      do this in a block that is at loop level 0 and dominates all      can_throw_internal instructions.  */
for|for
control|(
name|fn_begin
operator|=
name|get_insns
argument_list|()
init|;
condition|;
name|fn_begin
operator|=
name|NEXT_INSN
argument_list|(
name|fn_begin
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|fn_begin
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|fn_begin
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
break|break;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|fn_begin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call back from expand_function_end to know where we should put    the call to unwind_sjlj_unregister_libfunc if needed.  */
end_comment

begin_function
name|void
name|sjlj_emit_function_exit_after
parameter_list|(
name|after
parameter_list|)
name|rtx
name|after
decl_stmt|;
block|{
name|cfun
operator|->
name|eh
operator|->
name|sjlj_exit_after
operator|=
name|after
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_emit_function_exit
parameter_list|()
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|unwind_sjlj_unregister_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|XEXP
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* ??? Really this can be done in any block at loop level 0 that      post-dominates all can_throw_internal instructions.  This is      the last possible moment.  */
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|sjlj_exit_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_emit_dispatch_table
parameter_list|(
name|dispatch_label
parameter_list|,
name|lp_info
parameter_list|)
name|rtx
name|dispatch_label
decl_stmt|;
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|first_reachable
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|dispatch
decl_stmt|,
name|seq
decl_stmt|,
name|fc
decl_stmt|;
name|fc
operator|=
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|dispatch_label
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DONT_USE_BUILTIN_SETJMP
name|expand_builtin_setjmp_receiver
argument_list|(
name|dispatch_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Load up dispatch index, exc_ptr and filter values from the      function context.  */
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|sjlj_fc_call_site_ofs
argument_list|)
expr_stmt|;
name|dispatch
operator|=
name|copy_to_reg
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|word_mode
argument_list|,
name|sjlj_fc_data_ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|word_mode
operator|!=
name|Pmode
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|mem
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|#
directive|else
name|mem
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exc_ptr
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|word_mode
argument_list|,
name|sjlj_fc_data_ofs
operator|+
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|mem
argument_list|)
expr_stmt|;
comment|/* Jump to one of the directly reachable regions.  */
comment|/* ??? This really ought to be using a switch statement.  */
name|first_reachable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
continue|continue;
if|if
condition|(
operator|!
name|first_reachable
condition|)
block|{
name|first_reachable
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|dispatch
argument_list|,
name|GEN_INT
argument_list|(
name|lp_info
index|[
name|i
index|]
operator|.
name|dispatch_index
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|i
index|]
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
operator|(
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|first_reachable
index|]
operator|->
name|post_landing_pad
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_build_landing_pads
parameter_list|()
block|{
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
decl_stmt|;
name|lp_info
operator|=
operator|(
expr|struct
name|sjlj_lp_info
operator|*
operator|)
name|xcalloc
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sjlj_lp_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sjlj_find_directly_reachable_regions
argument_list|(
name|lp_info
argument_list|)
condition|)
block|{
name|rtx
name|dispatch_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
operator|=
name|assign_stack_local
argument_list|(
name|TYPE_MODE
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|sjlj_assign_call_site_values
argument_list|(
name|dispatch_label
argument_list|,
name|lp_info
argument_list|)
expr_stmt|;
name|sjlj_mark_call_sites
argument_list|(
name|lp_info
argument_list|)
expr_stmt|;
name|sjlj_emit_function_enter
argument_list|(
name|dispatch_label
argument_list|)
expr_stmt|;
name|sjlj_emit_dispatch_table
argument_list|(
name|dispatch_label
argument_list|,
name|lp_info
argument_list|)
expr_stmt|;
name|sjlj_emit_function_exit
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|lp_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_eh_generation
parameter_list|()
block|{
comment|/* Nothing to do if no regions created.  */
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|==
name|NULL
condition|)
return|return;
comment|/* The object here is to provide find_basic_blocks with detailed      information (via reachable_handlers) on how exception control      flows within the function.  In this first pass, we can include      type information garnered from ERT_THROW and ERT_ALLOWED_EXCEPTIONS      regions, and hope that it will be useful in deleting unreachable      handlers.  Subsequently, we will generate landing pads which will      connect many of the handlers, and then type information will not      be effective.  Still, this is a win over previous implementations.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_PRE_LOOP
operator||
name|CLEANUP_NO_INSN_DEL
argument_list|)
expr_stmt|;
comment|/* These registers are used by the landing pads.  Make sure they      have been generated.  */
name|get_exception_pointer
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|get_exception_filter
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
comment|/* Construct the landing pads.  */
name|assign_filter_values
argument_list|()
expr_stmt|;
name|build_post_landing_pads
argument_list|()
expr_stmt|;
name|connect_post_landing_pads
argument_list|()
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|sjlj_build_landing_pads
argument_list|()
expr_stmt|;
else|else
name|dw2_build_landing_pads
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
operator|=
literal|1
expr_stmt|;
comment|/* We've totally changed the CFG.  Start over.  */
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_PRE_LOOP
operator||
name|CLEANUP_NO_INSN_DEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|hashval_t
name|ehl_hash
parameter_list|(
name|pentry
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
block|{
name|struct
name|ehl_map_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|)
name|pentry
decl_stmt|;
comment|/* 2^32 * ((sqrt(5) - 1) / 2) */
specifier|const
name|hashval_t
name|scaled_golden_ratio
init|=
literal|0x9e3779b9
decl_stmt|;
return|return
name|CODE_LABEL_NUMBER
argument_list|(
name|entry
operator|->
name|label
argument_list|)
operator|*
name|scaled_golden_ratio
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ehl_eq
parameter_list|(
name|pentry
parameter_list|,
name|pdata
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
specifier|const
name|PTR
name|pdata
decl_stmt|;
block|{
name|struct
name|ehl_map_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|)
name|pentry
decl_stmt|;
name|struct
name|ehl_map_entry
modifier|*
name|data
init|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|)
name|pdata
decl_stmt|;
return|return
name|entry
operator|->
name|label
operator|==
name|data
operator|->
name|label
return|;
block|}
end_function

begin_comment
comment|/* This section handles removing dead code for flow.  */
end_comment

begin_comment
comment|/* Remove LABEL from exception_handler_label_map.  */
end_comment

begin_function
specifier|static
name|void
name|remove_exception_handler_label
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|struct
name|ehl_map_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* If exception_handler_label_map was not built yet,      there is nothing to do.  */
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
operator|==
name|NULL
condition|)
return|return;
name|tmp
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|&
name|tmp
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Splice REGION from the region tree etc.  */
end_comment

begin_function
specifier|static
name|void
name|remove_eh_handler
parameter_list|(
name|region
parameter_list|)
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
modifier|*
name|pp_start
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|outer
decl_stmt|,
modifier|*
name|inner
decl_stmt|;
name|rtx
name|lab
decl_stmt|;
comment|/* For the benefit of efficiently handling REG_EH_REGION notes,      replace this region in the region array with its containing      region.  Note that previous region deletions may result in      multiple copies of this region in the array, so we have a      list of alternate numbers by which we are known.  */
name|outer
operator|=
name|region
operator|->
name|outer
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|region
operator|->
name|region_number
index|]
operator|=
name|outer
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|aka
condition|)
block|{
name|int
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|region->aka
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ cfun->eh->region_array[i] = outer; }
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|outer
condition|)
block|{
if|if
condition|(
operator|!
name|outer
operator|->
name|aka
condition|)
name|outer
operator|->
name|aka
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|aka
condition|)
name|bitmap_a_or_b
argument_list|(
name|outer
operator|->
name|aka
argument_list|,
name|outer
operator|->
name|aka
argument_list|,
name|region
operator|->
name|aka
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|outer
operator|->
name|aka
argument_list|,
name|region
operator|->
name|region_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|lab
operator|=
name|region
operator|->
name|landing_pad
expr_stmt|;
else|else
name|lab
operator|=
name|region
operator|->
name|label
expr_stmt|;
if|if
condition|(
name|lab
condition|)
name|remove_exception_handler_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer
condition|)
name|pp_start
operator|=
operator|&
name|outer
operator|->
name|inner
expr_stmt|;
else|else
name|pp_start
operator|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pp_start
operator|,
name|p
operator|=
operator|*
name|pp
init|;
name|p
operator|!=
name|region
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next_peer
operator|,
name|p
operator|=
operator|*
name|pp
control|)
continue|continue;
operator|*
name|pp
operator|=
name|region
operator|->
name|next_peer
expr_stmt|;
name|inner
operator|=
name|region
operator|->
name|inner
expr_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
for|for
control|(
name|p
operator|=
name|inner
init|;
name|p
operator|->
name|next_peer
condition|;
name|p
operator|=
name|p
operator|->
name|next_peer
control|)
name|p
operator|->
name|outer
operator|=
name|outer
expr_stmt|;
name|p
operator|->
name|outer
operator|=
name|outer
expr_stmt|;
name|p
operator|->
name|next_peer
operator|=
operator|*
name|pp_start
expr_stmt|;
operator|*
name|pp_start
operator|=
name|inner
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_CATCH
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|try
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|try
operator|=
name|region
operator|->
name|next_peer
init|;
name|try
operator|->
name|type
operator|==
name|ERT_CATCH
condition|;
name|try
operator|=
name|try
operator|->
name|next_peer
control|)
continue|continue;
if|if
condition|(
name|try
operator|->
name|type
operator|!=
name|ERT_TRY
condition|)
name|abort
argument_list|()
expr_stmt|;
name|next
operator|=
name|region
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
expr_stmt|;
name|prev
operator|=
name|region
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
operator|=
name|prev
expr_stmt|;
else|else
name|try
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
operator|=
name|next
expr_stmt|;
else|else
block|{
name|try
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|=
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
name|remove_eh_handler
argument_list|(
name|try
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* LABEL heads a basic block that is about to be deleted.  If this    label corresponds to an exception region, we may be able to    delete the region.  */
end_comment

begin_function
name|void
name|maybe_remove_eh_handler
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|struct
name|ehl_map_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
comment|/* ??? After generating landing pads, it's not so simple to determine      if the region data is completely unused.  One must examine the      landing pad and the post landing pad, and whether an inner try block      is referencing the catch handlers directly.  */
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
return|return;
name|tmp
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|&
name|tmp
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return;
name|region
operator|=
operator|(
operator|*
name|slot
operator|)
operator|->
name|region
expr_stmt|;
if|if
condition|(
operator|!
name|region
condition|)
return|return;
comment|/* Flow will want to remove MUST_NOT_THROW regions as unreachable      because there is no path to the fallback call to terminate.      But the region continues to affect call-site data until there      are no more contained calls, which we don't see here.  */
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_MUST_NOT_THROW
condition|)
block|{
name|htab_clear_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
name|region
operator|->
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
name|remove_eh_handler
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invokes CALLBACK for every exception handler label.  Only used by old    loop hackery; should not be used by new code.  */
end_comment

begin_function_decl
name|void
name|for_each_eh_label
parameter_list|(
name|callback
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*callback
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|htab_traverse
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
name|for_each_eh_label_1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|callback
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|for_each_eh_label_1
parameter_list|(
name|pentry
parameter_list|,
name|data
parameter_list|)
name|PTR
modifier|*
name|pentry
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|ehl_map_entry
modifier|*
name|entry
init|=
operator|*
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|pentry
decl_stmt|;
name|void
argument_list|(
argument|*callback
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
operator|)
name|data
expr_stmt|;
call|(
modifier|*
name|callback
call|)
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section describes CFG exception edges for flow.  */
end_comment

begin_comment
comment|/* For communicating between calls to reachable_next_level.  */
end_comment

begin_decl_stmt
name|struct
name|reachable_info
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|types_caught
decl_stmt|;
name|tree
name|types_allowed
decl_stmt|;
name|rtx
name|handlers
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* A subroutine of reachable_next_level.  Return true if TYPE, or a    base class of TYPE, is in HANDLED.  */
end_comment

begin_function
specifier|static
name|int
name|check_handled
parameter_list|(
name|handled
parameter_list|,
name|type
parameter_list|)
name|tree
name|handled
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* We can check for exact matches without front-end help.  */
if|if
condition|(
operator|!
name|lang_eh_type_covers
condition|)
block|{
for|for
control|(
name|t
operator|=
name|handled
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
for|for
control|(
name|t
operator|=
name|handled
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
call|(
modifier|*
name|lang_eh_type_covers
call|)
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of reachable_next_level.  If we are collecting a list    of handlers, add one.  After landing pad generation, reference    it instead of the handlers themselves.  Further, the handlers are    all wired together, so by referencing one, we've got them all.    Before landing pad generation we reference each handler individually.     LP_REGION contains the landing pad; REGION is the handler.  */
end_comment

begin_function
specifier|static
name|void
name|add_reachable_handler
parameter_list|(
name|info
parameter_list|,
name|lp_region
parameter_list|,
name|region
parameter_list|)
name|struct
name|reachable_info
modifier|*
name|info
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|lp_region
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|info
condition|)
return|return;
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|handlers
condition|)
name|info
operator|->
name|handlers
operator|=
name|alloc_INSN_LIST
argument_list|(
name|lp_region
operator|->
name|landing_pad
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
name|info
operator|->
name|handlers
operator|=
name|alloc_INSN_LIST
argument_list|(
name|region
operator|->
name|label
argument_list|,
name|info
operator|->
name|handlers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process one level of exception regions for reachability.    If TYPE_THROWN is non-null, then it is the *exact* type being    propagated.  If INFO is non-null, then collect handler labels    and caught/allowed type information between invocations.  */
end_comment

begin_function
specifier|static
name|enum
name|reachable_code
name|reachable_next_level
parameter_list|(
name|region
parameter_list|,
name|type_thrown
parameter_list|,
name|info
parameter_list|)
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|struct
name|reachable_info
modifier|*
name|info
decl_stmt|;
block|{
switch|switch
condition|(
name|region
operator|->
name|type
condition|)
block|{
case|case
name|ERT_CLEANUP
case|:
comment|/* Before landing-pad generation, we model control flow 	 directly to the individual handlers.  In this way we can 	 see that catch handler types may shadow one another.  */
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_MAYBE_CAUGHT
return|;
case|case
name|ERT_TRY
case|:
block|{
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|;
name|enum
name|reachable_code
name|ret
init|=
name|RNL_NOT_CAUGHT
decl_stmt|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|catch
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
control|)
block|{
comment|/* A catch-all handler ends the search.  */
if|if
condition|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|==
name|NULL
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
if|if
condition|(
name|type_thrown
condition|)
block|{
comment|/* If we have at least one type match, end the search.  */
name|tree
name|tp_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
for|for
control|(
init|;
name|tp_node
condition|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|tp_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|type_thrown
operator|||
operator|(
name|lang_eh_type_covers
operator|&&
call|(
modifier|*
name|lang_eh_type_covers
call|)
argument_list|(
name|type
argument_list|,
name|type_thrown
argument_list|)
operator|)
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
block|}
comment|/* If we have definitive information of a match failure, 		   the catch won't trigger.  */
if|if
condition|(
name|lang_eh_type_covers
condition|)
return|return
name|RNL_NOT_CAUGHT
return|;
block|}
comment|/* At this point, we either don't know what type is thrown or 	       don't have front-end assistance to help deciding if it is 	       covered by one of the types in the list for this region.  	       We'd then like to add this region to the list of reachable 	       handlers since it is indeed potentially reachable based on the 	       information we have.  	       Actually, this handler is for sure not reachable if all the 	       types it matches have already been caught. That is, it is only 	       potentially reachable if at least one of the types it catches 	       has not been previously caught.  */
if|if
condition|(
operator|!
name|info
condition|)
name|ret
operator|=
name|RNL_MAYBE_CAUGHT
expr_stmt|;
else|else
block|{
name|tree
name|tp_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
name|bool
name|maybe_reachable
init|=
name|false
decl_stmt|;
comment|/* Compute the potential reachability of this handler and 		   update the list of types caught at the same time.  */
for|for
control|(
init|;
name|tp_node
condition|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|tp_node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|check_handled
argument_list|(
name|info
operator|->
name|types_caught
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|info
operator|->
name|types_caught
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|type
argument_list|,
name|info
operator|->
name|types_caught
argument_list|)
expr_stmt|;
name|maybe_reachable
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maybe_reachable
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* ??? If the catch type is a base class of every allowed 		       type, then we know we can stop the search.  */
name|ret
operator|=
name|RNL_MAYBE_CAUGHT
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
comment|/* An empty list of types definitely ends the search.  */
if|if
condition|(
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
operator|==
name|NULL_TREE
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
comment|/* Collect a list of lists of allowed types for use in detecting 	 when a catch may be transformed into a catch-all.  */
if|if
condition|(
name|info
condition|)
name|info
operator|->
name|types_allowed
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
argument_list|,
name|info
operator|->
name|types_allowed
argument_list|)
expr_stmt|;
comment|/* If we have definitive information about the type hierarchy, 	 then we can tell if the thrown type will pass through the 	 filter.  */
if|if
condition|(
name|type_thrown
operator|&&
name|lang_eh_type_covers
condition|)
block|{
if|if
condition|(
name|check_handled
argument_list|(
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
argument_list|,
name|type_thrown
argument_list|)
condition|)
return|return
name|RNL_NOT_CAUGHT
return|;
else|else
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
block|}
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_MAYBE_CAUGHT
return|;
case|case
name|ERT_CATCH
case|:
comment|/* Catch regions are handled by their controling try region.  */
return|return
name|RNL_NOT_CAUGHT
return|;
case|case
name|ERT_MUST_NOT_THROW
case|:
comment|/* Here we end our search, since no exceptions may propagate. 	 If we've touched down at some landing pad previous, then the 	 explicit function call we generated may be used.  Otherwise 	 the call is made by the runtime.  */
if|if
condition|(
name|info
operator|&&
name|info
operator|->
name|handlers
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
else|else
return|return
name|RNL_BLOCKED
return|;
case|case
name|ERT_THROW
case|:
case|case
name|ERT_FIXUP
case|:
case|case
name|ERT_UNKNOWN
case|:
comment|/* Shouldn't see these here.  */
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve a list of labels of exception handlers which can be    reached by a given insn.  */
end_comment

begin_function
name|rtx
name|reachable_handlers
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|reachable_info
name|info
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|int
name|region_number
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RESX
condition|)
name|region_number
operator|=
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|region_number
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|region_number
index|]
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RESX
condition|)
block|{
comment|/* A RESX leaves a region instead of entering it.  Thus the 	 region itself may have been deleted out from under us.  */
if|if
condition|(
name|region
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
while|while
condition|(
name|region
condition|)
block|{
if|if
condition|(
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
operator|&
name|info
argument_list|)
operator|>=
name|RNL_CAUGHT
condition|)
break|break;
comment|/* If we have processed one cleanup, there is no point in 	 processing any more of them.  Each cleanup will have an edge 	 to the next outer cleanup region, so the flow graph will be 	 accurate.  */
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_CLEANUP
condition|)
name|region
operator|=
name|region
operator|->
name|u
operator|.
name|cleanup
operator|.
name|prev_try
expr_stmt|;
else|else
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
return|return
name|info
operator|.
name|handlers
return|;
block|}
end_function

begin_comment
comment|/* Determine if the given INSN can throw an exception that is caught    within the function.  */
end_comment

begin_function
name|bool
name|can_throw_internal
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|sub
init|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|sub
condition|;
name|sub
operator|=
name|NEXT_INSN
argument_list|(
name|sub
argument_list|)
control|)
if|if
condition|(
name|can_throw_internal
argument_list|(
name|sub
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/* Every insn that might throw has an EH_REGION note.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|false
return|;
name|region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
comment|/* If this exception is ignored by each and every containing region,      then control passes straight out.  The runtime may handle some      regions, which also do not require processing internally.  */
for|for
control|(
init|;
name|region
condition|;
name|region
operator|=
name|region
operator|->
name|outer
control|)
block|{
name|enum
name|reachable_code
name|how
init|=
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|how
operator|==
name|RNL_BLOCKED
condition|)
return|return
name|false
return|;
if|if
condition|(
name|how
operator|!=
name|RNL_NOT_CAUGHT
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if the given INSN can throw an exception that is    visible outside the function.  */
end_comment

begin_function
name|bool
name|can_throw_external
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|sub
init|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|sub
condition|;
name|sub
operator|=
name|NEXT_INSN
argument_list|(
name|sub
argument_list|)
control|)
if|if
condition|(
name|can_throw_external
argument_list|(
name|sub
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
block|{
comment|/* Calls (and trapping insns) without notes are outside any 	 exception handling region in this function.  We have to 	 assume it might throw.  Given that the front end and middle 	 ends mark known NOTHROW functions, this isn't so wildly 	 inaccurate.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|false
return|;
name|region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
comment|/* If the exception is caught or blocked by any containing region,      then it is not seen by any calling function.  */
for|for
control|(
init|;
name|region
condition|;
name|region
operator|=
name|region
operator|->
name|outer
control|)
if|if
condition|(
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
name|NULL
argument_list|)
operator|>=
name|RNL_CAUGHT
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set current_function_nothrow and cfun->all_throwers_are_sibcalls.  */
end_comment

begin_function
name|void
name|set_nothrow_function_flags
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|current_function_nothrow
operator|=
literal|1
expr_stmt|;
comment|/* Assume cfun->all_throwers_are_sibcalls until we encounter      something that can throw an exception.  We specifically exempt      CALL_INSNs that are SIBLING_CALL_P, as these are really jumps,      and can't throw.  Most CALL_INSNs are not SIBLING_CALL_P, so this      is optimistic.  */
name|cfun
operator|->
name|all_throwers_are_sibcalls
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
return|return;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|can_throw_external
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|current_function_nothrow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|||
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|all_throwers_are_sibcalls
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|can_throw_external
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|current_function_nothrow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|||
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|all_throwers_are_sibcalls
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Various hooks for unwind library.  */
end_comment

begin_comment
comment|/* Do any necessary initialization to access arbitrary stack frames.    On the SPARC, this means flushing the register windows.  */
end_comment

begin_function
name|void
name|expand_builtin_unwind_init
parameter_list|()
block|{
comment|/* Set this so all the registers get saved in our frame; we need to be      able to copy the saved values for any registers from frames we unwind.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|rtx
name|expand_builtin_eh_return_data_regno
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|which
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|iwhich
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|which
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"argument of `__builtin_eh_return_regno' must be constant"
argument_list|)
expr_stmt|;
return|return
name|constm1_rtx
return|;
block|}
name|iwhich
operator|=
name|tree_low_cst
argument_list|(
name|which
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iwhich
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|iwhich
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwhich
operator|==
name|INVALID_REGNUM
condition|)
return|return
name|constm1_rtx
return|;
ifdef|#
directive|ifdef
name|DWARF_FRAME_REGNUM
name|iwhich
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|iwhich
argument_list|)
expr_stmt|;
else|#
directive|else
name|iwhich
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|iwhich
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|GEN_INT
argument_list|(
name|iwhich
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value extracted from the return address register or stack slot,    return the actual address encoded in that value.  */
end_comment

begin_function
name|rtx
name|expand_builtin_extract_return_addr
parameter_list|(
name|addr_tree
parameter_list|)
name|tree
name|addr_tree
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|#
directive|else
name|addr
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* First mask out any unwanted bits.  */
ifdef|#
directive|ifdef
name|MASK_RETURN_ADDR
name|expand_and
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|MASK_RETURN_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Then adjust to find the real return address.  */
if|#
directive|if
name|defined
argument_list|(
name|RETURN_ADDR_OFFSET
argument_list|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Given an actual address in addr_tree, do any necessary encoding    and return the value to be stored in the return address register or    stack slot so the epilogue will return to that address.  */
end_comment

begin_function
name|rtx
name|expand_builtin_frob_return_addr
parameter_list|(
name|addr_tree
parameter_list|)
name|tree
name|addr_tree
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|Pmode
condition|)
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RETURN_ADDR_OFFSET
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|-
name|RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Set up the epilogue with the magic bits we'll need to return to the    exception handler.  */
end_comment

begin_function
name|void
name|expand_builtin_eh_return
parameter_list|(
name|stackadj_tree
parameter_list|,
name|handler_tree
parameter_list|)
name|tree
name|stackadj_tree
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|handler_tree
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
name|tmp
operator|=
name|expand_expr
argument_list|(
name|stackadj_tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|Pmode
condition|)
name|tmp
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
condition|)
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
operator|=
name|copy_to_reg
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
condition|)
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|expand_expr
argument_list|(
name|handler_tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|Pmode
condition|)
name|tmp
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
condition|)
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
operator|=
name|copy_to_reg
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
condition|)
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
condition|)
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_eh_return
parameter_list|()
block|{
name|rtx
name|around_label
decl_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
condition|)
return|return;
name|current_function_calls_eh_return
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
name|emit_move_insn
argument_list|(
name|EH_RETURN_STACKADJ_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|around_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
argument_list|)
expr_stmt|;
name|clobber_return_register
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
name|emit_move_insn
argument_list|(
name|EH_RETURN_STACKADJ_RTX
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_eh_return
if|if
condition|(
name|HAVE_eh_return
condition|)
name|emit_insn
argument_list|(
name|gen_eh_return
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|EH_RETURN_HANDLER_RTX
name|emit_move_insn
argument_list|(
name|EH_RETURN_HANDLER_RTX
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"__builtin_eh_return not supported on this target"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|emit_label
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In the following functions, we represent entries in the action table    as 1-based indices.  Special cases are:  	 0:	null action record, non-null landing pad; implies cleanups 	-1:	null action record, null landing pad; implies no action 	-2:	no call-site entry; implies must_not_throw 	-3:	we have yet to process outer regions     Further, no special cases apply to the "next" field of the record.    For next, 0 means end of list.  */
end_comment

begin_struct
struct|struct
name|action_record
block|{
name|int
name|offset
decl_stmt|;
name|int
name|filter
decl_stmt|;
name|int
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|action_record_eq
parameter_list|(
name|pentry
parameter_list|,
name|pdata
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
specifier|const
name|PTR
name|pdata
decl_stmt|;
block|{
specifier|const
name|struct
name|action_record
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|action_record
operator|*
operator|)
name|pentry
decl_stmt|;
specifier|const
name|struct
name|action_record
modifier|*
name|data
init|=
operator|(
specifier|const
expr|struct
name|action_record
operator|*
operator|)
name|pdata
decl_stmt|;
return|return
name|entry
operator|->
name|filter
operator|==
name|data
operator|->
name|filter
operator|&&
name|entry
operator|->
name|next
operator|==
name|data
operator|->
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|action_record_hash
parameter_list|(
name|pentry
parameter_list|)
specifier|const
name|PTR
name|pentry
decl_stmt|;
block|{
specifier|const
name|struct
name|action_record
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|action_record
operator|*
operator|)
name|pentry
decl_stmt|;
return|return
name|entry
operator|->
name|next
operator|*
literal|1009
operator|+
name|entry
operator|->
name|filter
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_action_record
parameter_list|(
name|ar_hash
parameter_list|,
name|filter
parameter_list|,
name|next
parameter_list|)
name|htab_t
name|ar_hash
decl_stmt|;
name|int
name|filter
decl_stmt|,
name|next
decl_stmt|;
block|{
name|struct
name|action_record
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|tmp
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|tmp
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|action_record
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|ar_hash
argument_list|,
operator|&
name|tmp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
operator|*
name|slot
operator|)
operator|==
name|NULL
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|action_record
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|offset
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|new
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|next
expr_stmt|;
operator|*
name|slot
operator|=
name|new
expr_stmt|;
comment|/* The filter value goes in untouched.  The link to the next 	 record is a "self-relative" byte offset, or zero to indicate 	 that there is no next record.  So convert the absolute 1 based 	 indices we've been carrying around into a displacement.  */
name|push_sleb128
argument_list|(
operator|&
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|-=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|push_sleb128
argument_list|(
operator|&
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|new
operator|->
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_one_action_chain
parameter_list|(
name|ar_hash
parameter_list|,
name|region
parameter_list|)
name|htab_t
name|ar_hash
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
block|{
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|;
name|int
name|next
decl_stmt|;
comment|/* If we've reached the top of the region chain, then we have      no actions, and require no landing pad.  */
if|if
condition|(
name|region
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|region
operator|->
name|type
condition|)
block|{
case|case
name|ERT_CLEANUP
case|:
comment|/* A cleanup adds a zero filter to the beginning of the chain, but 	 there are special cases to look out for.  If there are *only* 	 cleanups along a path, then it compresses to a zero action. 	 Further, if there are multiple cleanups along a path, we only 	 need to represent one of them, as that is enough to trigger 	 entry to the landing pad at runtime.  */
name|next
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|outer
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|outer
control|)
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|ERT_CLEANUP
condition|)
return|return
name|next
return|;
return|return
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
literal|0
argument_list|,
name|next
argument_list|)
return|;
case|case
name|ERT_TRY
case|:
comment|/* Process the associated catch regions in reverse order. 	 If there's a catch-all handler, then we don't need to 	 search outer regions.  Use a magic -3 value to record 	 that we haven't done the outer search.  */
name|next
operator|=
operator|-
literal|3
expr_stmt|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
control|)
block|{
if|if
condition|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|==
name|NULL
condition|)
block|{
comment|/* Retrieve the filter from the head of the filter list 		 where we have stored it (see assign_filter_values).  */
name|int
name|filter
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|=
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
name|filter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Once the outer search is done, trigger an action record for                  each filter we have.  */
name|tree
name|flt_node
decl_stmt|;
if|if
condition|(
name|next
operator|==
operator|-
literal|3
condition|)
block|{
name|next
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
expr_stmt|;
comment|/* If there is no next action, terminate the chain.  */
if|if
condition|(
name|next
operator|==
operator|-
literal|1
condition|)
name|next
operator|=
literal|0
expr_stmt|;
comment|/* If all outer actions are cleanups or must_not_throw, 		     we'll have no action record for it, since we had wanted 		     to encode these states in the call-site record directly. 		     Add a cleanup action to the chain to catch these.  */
elseif|else
if|if
condition|(
name|next
operator|<=
literal|0
condition|)
name|next
operator|=
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|flt_node
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
expr_stmt|;
for|for
control|(
init|;
name|flt_node
condition|;
name|flt_node
operator|=
name|TREE_CHAIN
argument_list|(
name|flt_node
argument_list|)
control|)
block|{
name|int
name|filter
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|flt_node
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|=
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
name|filter
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|next
return|;
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
comment|/* An exception specification adds its filter to the 	 beginning of the chain.  */
name|next
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
expr_stmt|;
return|return
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|filter
argument_list|,
name|next
operator|<
literal|0
condition|?
literal|0
else|:
name|next
argument_list|)
return|;
case|case
name|ERT_MUST_NOT_THROW
case|:
comment|/* A must-not-throw region with no inner handlers or cleanups 	 requires no call-site entry.  Note that this differs from 	 the no handler or cleanup case in that we do require an lsda 	 to be generated.  Return a magic -2 value to record this.  */
return|return
operator|-
literal|2
return|;
case|case
name|ERT_CATCH
case|:
case|case
name|ERT_THROW
case|:
comment|/* CATCH regions are handled in TRY above.  THROW regions are 	 for optimization information only and produce no output.  */
return|return
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|add_call_site
parameter_list|(
name|landing_pad
parameter_list|,
name|action
parameter_list|)
name|rtx
name|landing_pad
decl_stmt|;
name|int
name|action
decl_stmt|;
block|{
name|struct
name|call_site_record
modifier|*
name|data
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
decl_stmt|;
name|int
name|used
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|size
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_size
decl_stmt|;
if|if
condition|(
name|used
operator|>=
name|size
condition|)
block|{
name|size
operator|=
operator|(
name|size
condition|?
name|size
operator|*
literal|2
else|:
literal|64
operator|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|call_site_record
operator|*
operator|)
name|ggc_realloc
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
operator|=
name|data
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_size
operator|=
name|size
expr_stmt|;
block|}
name|data
index|[
name|used
index|]
operator|.
name|landing_pad
operator|=
name|landing_pad
expr_stmt|;
name|data
index|[
name|used
index|]
operator|.
name|action
operator|=
name|action
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
operator|=
name|used
operator|+
literal|1
expr_stmt|;
return|return
name|used
operator|+
name|call_site_base
return|;
block|}
end_function

begin_comment
comment|/* Turn REG_EH_REGION notes back into NOTE_INSN_EH_REGION notes.    The new note numbers will not refer to region numbers, but    instead to call site entries.  */
end_comment

begin_function
name|void
name|convert_to_eh_region_ranges
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|iter
decl_stmt|,
name|note
decl_stmt|;
name|htab_t
name|ar_hash
decl_stmt|;
name|int
name|last_action
init|=
operator|-
literal|3
decl_stmt|;
name|rtx
name|last_action_insn
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|last_landing_pad
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|first_no_action_insn
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|call_site
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
operator|||
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|==
name|NULL
condition|)
return|return;
name|VARRAY_UCHAR_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
literal|64
argument_list|,
literal|"action_record_data"
argument_list|)
expr_stmt|;
name|ar_hash
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|action_record_hash
argument_list|,
name|action_record_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|get_insns
argument_list|()
init|;
name|iter
condition|;
name|iter
operator|=
name|NEXT_INSN
argument_list|(
name|iter
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|iter
argument_list|)
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|int
name|this_action
decl_stmt|;
name|rtx
name|this_landing_pad
decl_stmt|;
name|insn
operator|=
name|iter
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
name|this_action
operator|=
operator|-
literal|1
expr_stmt|;
name|region
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|region
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_array
index|[
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|this_action
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
comment|/* Existence of catch handlers, or must-not-throw regions 	   implies that an lsda is needed (even if empty).  */
if|if
condition|(
name|this_action
operator|!=
operator|-
literal|1
condition|)
name|cfun
operator|->
name|uses_eh_lsda
operator|=
literal|1
expr_stmt|;
comment|/* Delay creation of region notes for no-action regions 	   until we're sure that an lsda will be required.  */
elseif|else
if|if
condition|(
name|last_action
operator|==
operator|-
literal|3
condition|)
block|{
name|first_no_action_insn
operator|=
name|iter
expr_stmt|;
name|last_action
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Cleanups and handlers may share action chains but not 	   landing pads.  Collect the landing pad for this region.  */
if|if
condition|(
name|this_action
operator|>=
literal|0
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|region
init|;
operator|!
name|o
operator|->
name|landing_pad
condition|;
name|o
operator|=
name|o
operator|->
name|outer
control|)
continue|continue;
name|this_landing_pad
operator|=
name|o
operator|->
name|landing_pad
expr_stmt|;
block|}
else|else
name|this_landing_pad
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Differing actions or landing pads implies a change in call-site 	   info, which implies some EH_REGION note should be emitted.  */
if|if
condition|(
name|last_action
operator|!=
name|this_action
operator|||
name|last_landing_pad
operator|!=
name|this_landing_pad
condition|)
block|{
comment|/* If we'd not seen a previous action (-3) or the previous 	       action was must-not-throw (-2), then we do not need an 	       end note.  */
if|if
condition|(
name|last_action
operator|>=
operator|-
literal|1
condition|)
block|{
comment|/* If we delayed the creation of the begin, do it now.  */
if|if
condition|(
name|first_no_action_insn
condition|)
block|{
name|call_site
operator|=
name|add_call_site
argument_list|(
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_EH_REGION_BEG
argument_list|,
name|first_no_action_insn
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
name|first_no_action_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_EH_REGION_END
argument_list|,
name|last_action_insn
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
block|}
comment|/* If the new action is must-not-throw, then no region notes 	       are created.  */
if|if
condition|(
name|this_action
operator|>=
operator|-
literal|1
condition|)
block|{
name|call_site
operator|=
name|add_call_site
argument_list|(
name|this_landing_pad
argument_list|,
name|this_action
operator|<
literal|0
condition|?
literal|0
else|:
name|this_action
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_EH_REGION_BEG
argument_list|,
name|iter
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
block|}
name|last_action
operator|=
name|this_action
expr_stmt|;
name|last_landing_pad
operator|=
name|this_landing_pad
expr_stmt|;
block|}
name|last_action_insn
operator|=
name|iter
expr_stmt|;
block|}
if|if
condition|(
name|last_action
operator|>=
operator|-
literal|1
operator|&&
operator|!
name|first_no_action_insn
condition|)
block|{
name|note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_EH_REGION_END
argument_list|,
name|last_action_insn
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|ar_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|push_uleb128
parameter_list|(
name|data_area
parameter_list|,
name|value
parameter_list|)
name|varray_type
modifier|*
name|data_area
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|{
do|do
block|{
name|unsigned
name|char
name|byte
init|=
name|value
operator|&
literal|0x7f
decl_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
name|VARRAY_PUSH_UCHAR
argument_list|(
operator|*
name|data_area
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|value
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_sleb128
parameter_list|(
name|data_area
parameter_list|,
name|value
parameter_list|)
name|varray_type
modifier|*
name|data_area
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|unsigned
name|char
name|byte
decl_stmt|;
name|int
name|more
decl_stmt|;
do|do
block|{
name|byte
operator|=
name|value
operator|&
literal|0x7f
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
name|more
operator|=
operator|!
operator|(
operator|(
name|value
operator|==
literal|0
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|value
operator|==
operator|-
literal|1
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
name|VARRAY_PUSH_UCHAR
argument_list|(
operator|*
name|data_area
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_AS_LEB128
end_ifndef

begin_function
specifier|static
name|int
name|dw2_size_of_call_site_table
parameter_list|()
block|{
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|size
init|=
name|n
operator|*
operator|(
literal|4
operator|+
literal|4
operator|+
literal|4
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sjlj_size_of_call_site_table
parameter_list|()
block|{
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|INTVAL
argument_list|(
name|cs
operator|->
name|landing_pad
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dw2_output_call_site_table
parameter_list|()
block|{
specifier|const
name|char
modifier|*
specifier|const
name|function_start_lab
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|current_function_func_begin_label
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|char
name|reg_start_lab
index|[
literal|32
index|]
decl_stmt|;
name|char
name|reg_end_lab
index|[
literal|32
index|]
decl_stmt|;
name|char
name|landing_pad_lab
index|[
literal|32
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|reg_start_lab
argument_list|,
literal|"LEHB"
argument_list|,
name|call_site_base
operator|+
name|i
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|reg_end_lab
argument_list|,
literal|"LEHE"
argument_list|,
name|call_site_base
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|landing_pad
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|landing_pad_lab
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|cs
operator|->
name|landing_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Perhaps use insn length scaling if the assembler supports 	 generic arithmetic.  */
comment|/* ??? Perhaps use attr_length to choose data1 or data2 instead of 	 data4 if the function is small enough.  */
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|dw2_asm_output_delta_uleb128
argument_list|(
name|reg_start_lab
argument_list|,
name|function_start_lab
argument_list|,
literal|"region %d start"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta_uleb128
argument_list|(
name|reg_end_lab
argument_list|,
name|reg_start_lab
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|landing_pad
condition|)
name|dw2_asm_output_delta_uleb128
argument_list|(
name|landing_pad_lab
argument_list|,
name|function_start_lab
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|reg_start_lab
argument_list|,
name|function_start_lab
argument_list|,
literal|"region %d start"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|reg_end_lab
argument_list|,
name|reg_start_lab
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|landing_pad
condition|)
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|landing_pad_lab
argument_list|,
name|function_start_lab
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dw2_asm_output_data_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|,
literal|"action"
argument_list|)
expr_stmt|;
block|}
name|call_site_base
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_output_call_site_table
parameter_list|()
block|{
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|INTVAL
argument_list|(
name|cs
operator|->
name|landing_pad
argument_list|)
argument_list|,
literal|"region %d landing pad"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|,
literal|"action"
argument_list|)
expr_stmt|;
block|}
name|call_site_base
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to the section for the exception handling    table.  */
end_comment

begin_function
name|void
name|default_exception_section
parameter_list|()
block|{
if|if
condition|(
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LD_RO_RW_SECTION_MIXING
name|int
name|tt_format
init|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|0
argument_list|,
comment|/*global=*/
literal|1
argument_list|)
decl_stmt|;
name|flags
operator|=
operator|(
operator|!
name|flag_pic
operator|||
operator|(
operator|(
name|tt_format
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_absptr
operator|&&
operator|(
name|tt_format
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_aligned
operator|)
operator|)
condition|?
literal|0
else|:
name|SECTION_WRITE
expr_stmt|;
else|#
directive|else
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
endif|#
directive|endif
name|named_section_flags
argument_list|(
literal|".gcc_except_table"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|readonly_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_function_exception_table
parameter_list|()
block|{
name|int
name|tt_format
decl_stmt|,
name|cs_format
decl_stmt|,
name|lp_format
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|char
name|ttype_label
index|[
literal|32
index|]
decl_stmt|;
name|char
name|cs_after_size_label
index|[
literal|32
index|]
decl_stmt|;
name|char
name|cs_end_label
index|[
literal|32
index|]
decl_stmt|;
else|#
directive|else
name|int
name|call_site_len
decl_stmt|;
endif|#
directive|endif
name|int
name|have_tt_data
decl_stmt|;
name|int
name|tt_format_size
init|=
literal|0
decl_stmt|;
comment|/* Not all functions need anything.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|uses_eh_lsda
condition|)
return|return;
ifdef|#
directive|ifdef
name|IA64_UNWIND_INFO
name|fputs
argument_list|(
literal|"\t.personality\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|eh_personality_libfunc
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\t.handlerdata\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Note that varasm still thinks we're in the function's code section.      The ".endp" directive that will immediately follow will take us back.  */
else|#
directive|else
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|exception_section
call|)
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|have_tt_data
operator|=
operator|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
operator|>
literal|0
operator|||
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* Indicate the format of the @TType entries.  */
if|if
condition|(
operator|!
name|have_tt_data
condition|)
name|tt_format
operator|=
name|DW_EH_PE_omit
expr_stmt|;
else|else
block|{
name|tt_format
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|0
argument_list|,
comment|/*global=*/
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ttype_label
argument_list|,
literal|"LLSDATT"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tt_format_size
operator|=
name|size_of_encoded_value
argument_list|(
name|tt_format
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|tt_format_size
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LLSDA"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
comment|/* The LSDA header.  */
comment|/* Indicate the format of the landing pad start pointer.  An omitted      field implies @LPStart == @Start.  */
comment|/* Currently we always put @LPStart == @Start.  This field would      be most useful in moving the landing pads completely out of      line to another section, but it could also be used to minimize      the size of uleb128 landing pad offsets.  */
name|lp_format
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|lp_format
argument_list|,
literal|"@LPStart format (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|lp_format
argument_list|)
argument_list|)
expr_stmt|;
comment|/* @LPStart pointer would go here.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|tt_format
argument_list|,
literal|"@TType format (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|tt_format
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_AS_LEB128
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|call_site_len
operator|=
name|sjlj_size_of_call_site_table
argument_list|()
expr_stmt|;
else|else
name|call_site_len
operator|=
name|dw2_size_of_call_site_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* A pc-relative 4-byte displacement to the @TType data.  */
if|if
condition|(
name|have_tt_data
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|char
name|ttype_after_disp_label
index|[
literal|32
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ttype_after_disp_label
argument_list|,
literal|"LLSDATTD"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta_uleb128
argument_list|(
name|ttype_label
argument_list|,
name|ttype_after_disp_label
argument_list|,
literal|"@TType base offset"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|ttype_after_disp_label
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Ug.  Alignment queers things.  */
name|unsigned
name|int
name|before_disp
decl_stmt|,
name|after_disp
decl_stmt|,
name|last_disp
decl_stmt|,
name|disp
decl_stmt|;
name|before_disp
operator|=
literal|1
operator|+
literal|1
expr_stmt|;
name|after_disp
operator|=
operator|(
literal|1
operator|+
name|size_of_uleb128
argument_list|(
name|call_site_len
argument_list|)
operator|+
name|call_site_len
operator|+
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
operator|+
operator|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
operator|*
name|tt_format_size
operator|)
operator|)
expr_stmt|;
name|disp
operator|=
name|after_disp
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|disp_size
decl_stmt|,
name|pad
decl_stmt|;
name|last_disp
operator|=
name|disp
expr_stmt|;
name|disp_size
operator|=
name|size_of_uleb128
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|pad
operator|=
name|before_disp
operator|+
name|disp_size
operator|+
name|after_disp
expr_stmt|;
if|if
condition|(
name|pad
operator|%
name|tt_format_size
condition|)
name|pad
operator|=
name|tt_format_size
operator|-
operator|(
name|pad
operator|%
name|tt_format_size
operator|)
expr_stmt|;
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|disp
operator|=
name|after_disp
operator|+
name|pad
expr_stmt|;
block|}
do|while
condition|(
name|disp
operator|!=
name|last_disp
condition|)
do|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|disp
argument_list|,
literal|"@TType base offset"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Indicate the format of the call-site offsets.  */
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|cs_format
operator|=
name|DW_EH_PE_uleb128
expr_stmt|;
else|#
directive|else
name|cs_format
operator|=
name|DW_EH_PE_udata4
expr_stmt|;
endif|#
directive|endif
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|cs_format
argument_list|,
literal|"call-site format (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|cs_format
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|cs_after_size_label
argument_list|,
literal|"LLSDACSB"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|cs_end_label
argument_list|,
literal|"LLSDACSE"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta_uleb128
argument_list|(
name|cs_end_label
argument_list|,
name|cs_after_size_label
argument_list|,
literal|"Call-site table length"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cs_after_size_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|sjlj_output_call_site_table
argument_list|()
expr_stmt|;
else|else
name|dw2_output_call_site_table
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cs_end_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_asm_output_data_uleb128
argument_list|(
name|call_site_len
argument_list|,
literal|"Call-site table length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|sjlj_output_call_site_table
argument_list|()
expr_stmt|;
else|else
name|dw2_output_call_site_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ??? Decode and interpret the data for flag_debug_asm.  */
name|n
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|VARRAY_UCHAR
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|i
condition|?
name|NULL
else|:
literal|"Action record table"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_tt_data
condition|)
name|assemble_align
argument_list|(
name|tt_format_size
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|i
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|VARRAY_TREE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|value
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|type
operator|=
name|lookup_type_for_runtime
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|type
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_format
operator|==
name|DW_EH_PE_absptr
operator|||
name|tt_format
operator|==
name|DW_EH_PE_aligned
condition|)
name|assemble_integer
argument_list|(
name|value
argument_list|,
name|tt_format_size
argument_list|,
name|tt_format_size
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|tt_format
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
if|if
condition|(
name|have_tt_data
condition|)
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|ttype_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ??? Decode and interpret the data for flag_debug_asm.  */
name|n
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|VARRAY_UCHAR
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|i
condition|?
name|NULL
else|:
literal|"Exception specification table"
operator|)
argument_list|)
expr_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-except.h"
end_include

end_unit

