begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implements exception handling.    Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.    Contributed by Mike Stump<mrs@cygnus.com>.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* An exception is an event that can be signaled from within a    function. This event can then be "caught" or "trapped" by the    callers of this function. This potentially allows program flow to    be transferred to any arbitrary code associated with a function call    several levels up the stack.     The intended use for this mechanism is for signaling "exceptional    events" in an out-of-band fashion, hence its name. The C++ language    (and many other OO-styled or functional languages) practically    requires such a mechanism, as otherwise it becomes very difficult    or even impossible to signal failure conditions in complex    situations.  The traditional C++ example is when an error occurs in    the process of constructing an object; without such a mechanism, it    is impossible to signal that the error occurs without adding global    state variables and error checks around every object construction.     The act of causing this event to occur is referred to as "throwing    an exception". (Alternate terms include "raising an exception" or    "signaling an exception".) The term "throw" is used because control    is returned to the callers of the function that is signaling the    exception, and thus there is the concept of "throwing" the    exception up the call stack.     There are two major codegen options for exception handling.  The    flag -fsjlj-exceptions can be used to select the setjmp/longjmp    approach, which is the default.  -fno-sjlj-exceptions can be used to    get the PC range table approach.  While this is a compile time    flag, an entire application must be compiled with the same codegen    option.  The first is a PC range table approach, the second is a    setjmp/longjmp based scheme.  We will first discuss the PC range    table approach, after that, we will discuss the setjmp/longjmp    based approach.     It is appropriate to speak of the "context of a throw". This    context refers to the address where the exception is thrown from,    and is used to determine which exception region will handle the    exception.     Regions of code within a function can be marked such that if it    contains the context of a throw, control will be passed to a    designated "exception handler". These areas are known as "exception    regions".  Exception regions cannot overlap, but they can be nested    to any arbitrary depth. Also, exception regions cannot cross    function boundaries.     Exception handlers can either be specified by the user (which we    will call a "user-defined handler") or generated by the compiler    (which we will designate as a "cleanup"). Cleanups are used to    perform tasks such as destruction of objects allocated on the    stack.     In the current implementation, cleanups are handled by allocating an    exception region for the area that the cleanup is designated for,    and the handler for the region performs the cleanup and then    rethrows the exception to the outer exception region. From the    standpoint of the current implementation, there is little    distinction made between a cleanup and a user-defined handler, and    the phrase "exception handler" can be used to refer to either one    equally well. (The section "Future Directions" below discusses how    this will change).     Each object file that is compiled with exception handling contains    a static array of exception handlers named __EXCEPTION_TABLE__.    Each entry contains the starting and ending addresses of the    exception region, and the address of the handler designated for    that region.     If the target does not use the DWARF 2 frame unwind information, at    program startup each object file invokes a function named    __register_exceptions with the address of its local    __EXCEPTION_TABLE__. __register_exceptions is defined in libgcc2.c, and    is responsible for recording all of the exception regions into one list    (which is kept in a static variable named exception_table_list).     On targets that support crtstuff.c, the unwind information    is stored in a section named .eh_frame and the information for the    entire shared object or program is registered with a call to    __register_frame_info.  On other targets, the information for each    translation unit is registered from the file generated by collect2.    __register_frame_info is defined in frame.c, and is responsible for    recording all of the unwind regions into one list (which is kept in a    static variable named unwind_table_list).     The function __throw is actually responsible for doing the    throw. On machines that have unwind info support, __throw is generated    by code in libgcc2.c, otherwise __throw is generated on a    per-object-file basis for each source file compiled with    -fexceptions by the C++ frontend.  Before __throw is invoked,    the current context of the throw needs to be placed in the global    variable __eh_pc.     __throw attempts to find the appropriate exception handler for the     PC value stored in __eh_pc by calling __find_first_exception_table_match    (which is defined in libgcc2.c). If __find_first_exception_table_match    finds a relevant handler, __throw transfers control directly to it.     If a handler for the context being thrown from can't be found, __throw    walks (see Walking the stack below) the stack up the dynamic call chain to    continue searching for an appropriate exception handler based upon the    caller of the function it last sought a exception handler for.  It stops    then either an exception handler is found, or when the top of the    call chain is reached.     If no handler is found, an external library function named    __terminate is called.  If a handler is found, then we restart    our search for a handler at the end of the call chain, and repeat    the search process, but instead of just walking up the call chain,    we unwind the call chain as we walk up it.     Internal implementation details:     To associate a user-defined handler with a block of statements, the    function expand_start_try_stmts is used to mark the start of the    block of statements with which the handler is to be associated    (which is known as a "try block"). All statements that appear    afterwards will be associated with the try block.     A call to expand_start_all_catch marks the end of the try block,    and also marks the start of the "catch block" (the user-defined    handler) associated with the try block.     This user-defined handler will be invoked for *every* exception    thrown with the context of the try block. It is up to the handler    to decide whether or not it wishes to handle any given exception,    as there is currently no mechanism in this implementation for doing    this. (There are plans for conditionally processing an exception    based on its "type", which will provide a language-independent    mechanism).     If the handler chooses not to process the exception (perhaps by    looking at an "exception type" or some other additional data    supplied with the exception), it can fall through to the end of the    handler. expand_end_all_catch and expand_leftover_cleanups    add additional code to the end of each handler to take care of    rethrowing to the outer exception handler.     The handler also has the option to continue with "normal flow of    code", or in other words to resume executing at the statement    immediately after the end of the exception region. The variable    caught_return_label_stack contains a stack of labels, and jumping    to the topmost entry's label via expand_goto will resume normal    flow to the statement immediately after the end of the exception    region. If the handler falls through to the end, the exception will    be rethrown to the outer exception region.     The instructions for the catch block are kept as a separate    sequence, and will be emitted at the end of the function along with    the handlers specified via expand_eh_region_end. The end of the    catch block is marked with expand_end_all_catch.     Any data associated with the exception must currently be handled by    some external mechanism maintained in the frontend.  For example,    the C++ exception mechanism passes an arbitrary value along with    the exception, and this is handled in the C++ frontend by using a    global variable to hold the value. (This will be changing in the    future.)     The mechanism in C++ for handling data associated with the    exception is clearly not thread-safe. For a thread-based    environment, another mechanism must be used (possibly using a    per-thread allocation mechanism if the size of the area that needs    to be allocated isn't known at compile time.)     Internally-generated exception regions (cleanups) are marked by    calling expand_eh_region_start to mark the start of the region,    and expand_eh_region_end (handler) is used to both designate the    end of the region and to associate a specified handler/cleanup with    the region. The rtl code in HANDLER will be invoked whenever an    exception occurs in the region between the calls to    expand_eh_region_start and expand_eh_region_end. After HANDLER is    executed, additional code is emitted to handle rethrowing the    exception to the outer exception handler. The code for HANDLER will    be emitted at the end of the function.     TARGET_EXPRs can also be used to designate exception regions. A    TARGET_EXPR gives an unwind-protect style interface commonly used    in functional languages such as LISP. The associated expression is    evaluated, and whether or not it (or any of the functions that it    calls) throws an exception, the protect expression is always    invoked. This implementation takes care of the details of    associating an exception table entry with the expression and    generating the necessary code (it actually emits the protect    expression twice, once for normal flow and once for the exception    case). As for the other handlers, the code for the exception case    will be emitted at the end of the function.     Cleanups can also be specified by using add_partial_entry (handler)    and end_protect_partials. add_partial_entry creates the start of    a new exception region; HANDLER will be invoked if an exception is    thrown with the context of the region between the calls to    add_partial_entry and end_protect_partials. end_protect_partials is    used to mark the end of these regions. add_partial_entry can be    called as many times as needed before calling end_protect_partials.    However, end_protect_partials should only be invoked once for each    group of calls to add_partial_entry as the entries are queued    and all of the outstanding entries are processed simultaneously    when end_protect_partials is invoked. Similarly to the other    handlers, the code for HANDLER will be emitted at the end of the    function.     The generated RTL for an exception region includes    NOTE_INSN_EH_REGION_BEG and NOTE_INSN_EH_REGION_END notes that mark    the start and end of the exception region. A unique label is also    generated at the start of the exception region, which is available    by looking at the ehstack variable. The topmost entry corresponds    to the current region.     In the current implementation, an exception can only be thrown from    a function call (since the mechanism used to actually throw an    exception involves calling __throw).  If an exception region is    created but no function calls occur within that region, the region    can be safely optimized away (along with its exception handlers)    since no exceptions can ever be caught in that region.  This    optimization is performed unless -fasynchronous-exceptions is    given.  If the user wishes to throw from a signal handler, or other    asynchronous place, -fasynchronous-exceptions should be used when    compiling for maximally correct code, at the cost of additional    exception regions.  Using -fasynchronous-exceptions only produces    code that is reasonably safe in such situations, but a correct    program cannot rely upon this working.  It can be used in failsafe    code, where trying to continue on, and proceeding with potentially    incorrect results is better than halting the program.      Walking the stack:     The stack is walked by starting with a pointer to the current    frame, and finding the pointer to the callers frame.  The unwind info    tells __throw how to find it.     Unwinding the stack:     When we use the term unwinding the stack, we mean undoing the    effects of the function prologue in a controlled fashion so that we    still have the flow of control.  Otherwise, we could just return    (jump to the normal end of function epilogue).     This is done in __throw in libgcc2.c when we know that a handler exists    in a frame higher up the call stack than its immediate caller.     To unwind, we find the unwind data associated with the frame, if any.    If we don't find any, we call the library routine __terminate.  If we do    find it, we use the information to copy the saved register values from    that frame into the register save area in the frame for __throw, return    into a stub which updates the stack pointer, and jump to the handler.    The normal function epilogue for __throw handles restoring the saved    values into registers.     When unwinding, we use this method if we know it will    work (if DWARF2_UNWIND_INFO is defined).  Otherwise, we know that    an inline unwinder will have been emitted for any function that    __unwind_function cannot unwind.  The inline unwinder appears as a    normal exception handler for the entire function, for any function    that we know cannot be unwound by __unwind_function.  We inform the    compiler of whether a function can be unwound with    __unwind_function by having DOESNT_NEED_UNWINDER evaluate to true    when the unwinder isn't needed.  __unwind_function is used as an    action of last resort.  If no other method can be used for    unwinding, __unwind_function is used.  If it cannot unwind, it    should call __terminate.     By default, if the target-specific backend doesn't supply a definition    for __unwind_function and doesn't support DWARF2_UNWIND_INFO, inlined    unwinders will be used instead. The main tradeoff here is in text space    utilization.  Obviously, if inline unwinders have to be generated    repeatedly, this uses much more space than if a single routine is used.     However, it is simply not possible on some platforms to write a    generalized routine for doing stack unwinding without having some    form of additional data associated with each function.  The current    implementation can encode this data in the form of additional    machine instructions or as static data in tabular form.  The later    is called the unwind data.     The backend macro DOESNT_NEED_UNWINDER is used to conditionalize whether    or not per-function unwinders are needed. If DOESNT_NEED_UNWINDER is    defined and has a non-zero value, a per-function unwinder is not emitted    for the current function.  If the static unwind data is supported, then    a per-function unwinder is not emitted.     On some platforms it is possible that neither __unwind_function    nor inlined unwinders are available. For these platforms it is not    possible to throw through a function call, and abort will be    invoked instead of performing the throw.      The reason the unwind data may be needed is that on some platforms    the order and types of data stored on the stack can vary depending    on the type of function, its arguments and returned values, and the    compilation options used (optimization versus non-optimization,    -fomit-frame-pointer, processor variations, etc).     Unfortunately, this also means that throwing through functions that    aren't compiled with exception handling support will still not be    possible on some platforms. This problem is currently being    investigated, but no solutions have been found that do not imply    some unacceptable performance penalties.     Future directions:     Currently __throw makes no differentiation between cleanups and    user-defined exception regions. While this makes the implementation    simple, it also implies that it is impossible to determine if a    user-defined exception handler exists for a given exception without    completely unwinding the stack in the process. This is undesirable    from the standpoint of debugging, as ideally it would be possible    to trap unhandled exceptions in the debugger before the process of    unwinding has even started.     This problem can be solved by marking user-defined handlers in a    special way (probably by adding additional bits to exception_table_list).    A two-pass scheme could then be used by __throw to iterate    through the table. The first pass would search for a relevant    user-defined handler for the current context of the throw, and if    one is found, the second pass would then invoke all needed cleanups    before jumping to the user-defined handler.     Many languages (including C++ and Ada) make execution of a    user-defined handler conditional on the "type" of the exception    thrown. (The type of the exception is actually the type of the data    that is thrown with the exception.) It will thus be necessary for    __throw to be able to determine if a given user-defined    exception handler will actually be executed, given the type of    exception.     One scheme is to add additional information to exception_table_list    as to the types of exceptions accepted by each handler. __throw    can do the type comparisons and then determine if the handler is    actually going to be executed.     There is currently no significant level of debugging support    available, other than to place a breakpoint on __throw. While    this is sufficient in most cases, it would be helpful to be able to    know where a given exception was going to be thrown to before it is    actually thrown, and to be able to choose between stopping before    every exception region (including cleanups), or just user-defined    exception regions. This should be possible to do in the two-pass    scheme by adding additional labels to __throw for appropriate    breakpoints, and additional debugger commands could be added to    query various state variables to determine what actions are to be    performed next.     Another major problem that is being worked on is the issue with stack    unwinding on various platforms. Currently the only platforms that have    support for the generation of a generic unwinder are the SPARC and MIPS.    All other ports require per-function unwinders, which produce large    amounts of code bloat.     For setjmp/longjmp based exception handling, some of the details    are as above, but there are some additional details.  This section    discusses the details.     We don't use NOTE_INSN_EH_REGION_{BEG,END} pairs.  We don't    optimize EH regions yet.  We don't have to worry about machine    specific issues with unwinding the stack, as we rely upon longjmp    for all the machine specific details.  There is no variable context    of a throw, just the one implied by the dynamic handler stack    pointed to by the dynamic handler chain.  There is no exception    table, and no calls to __register_exceptions.  __sjthrow is used    instead of __throw, and it works by using the dynamic handler    chain, and longjmp.  -fasynchronous-exceptions has no effect, as    the elimination of trivial exception regions is not yet performed.     A frontend can set protect_cleanup_actions_with_terminate when all    the cleanup actions should be protected with an EH region that    calls terminate when an unhandled exception is throw.  C++ does    this, Ada does not.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"eh-common.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* One to use setjmp/longjmp method of generating code for exception    handling.  */
end_comment

begin_decl_stmt
name|int
name|exceptions_via_longjmp
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One to enable asynchronous exception support.  */
end_comment

begin_decl_stmt
name|int
name|asynchronous_exceptions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One to protect cleanup actions with a handler that calls    __terminate, zero otherwise.  */
end_comment

begin_decl_stmt
name|int
name|protect_cleanup_actions_with_terminate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of labels used for exception handlers.  Created by    find_exception_handler_labels for the optimization passes.  */
end_comment

begin_decl_stmt
name|rtx
name|exception_handler_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The EH context.  Nonzero if the function has already    fetched a pointer to the EH context  for exception handling.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_ehc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A stack used for keeping track of the currently active exception    handling region.  As each exception region is started, an entry    describing the region is pushed onto this stack.  The current    region can be found by looking at the top of the stack, and as we    exit regions, the corresponding entries are popped.      Entries cannot overlap; they can be nested. So there is only one    entry at most that corresponds to the current instruction, and that    is the entry on the top of the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|eh_stack
name|ehstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This stack is used to represent what the current eh region is    for the catch blocks beings processed */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|eh_stack
name|catchstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A queue used for tracking which exception regions have closed but    whose handlers have not yet been expanded. Regions are emitted in    groups in an attempt to improve paging performance.     As we exit a region, we enqueue a new entry. The entries are then    dequeued during expand_leftover_cleanups and expand_start_all_catch,     We should redo things so that we either take RTL for the handler,    or we expand the handler expressed as a tree immediately at region    end time.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|eh_queue
name|ehqueue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insns for all of the exception handlers for the current function.    They are currently emitted by the frontend code.  */
end_comment

begin_decl_stmt
name|rtx
name|catch_clauses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A TREE_CHAINed list of handlers for regions that are not yet    closed. The TREE_VALUE of each entry contains the handler for the    corresponding entry on the ehstack.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|protect_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stacks to keep track of various labels.  */
end_comment

begin_comment
comment|/* Keeps track of the label to resume to should one want to resume    normal control flow out of a handler (instead of, say, returning to    the caller of the current function or exiting the program).  */
end_comment

begin_decl_stmt
name|struct
name|label_node
modifier|*
name|caught_return_label_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keeps track of the label used as the context of a throw to rethrow an    exception to the outer exception region.  */
end_comment

begin_decl_stmt
name|struct
name|label_node
modifier|*
name|outer_context_label_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A random data area for the front end's own use.  */
end_comment

begin_decl_stmt
name|struct
name|label_node
modifier|*
name|false_label_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudos used to hold exception return data in the interim between    __builtin_eh_return and the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|eh_return_context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|eh_return_stack_adjust
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|eh_return_handler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to mark the eh return stub for flow, so that the Right Thing    happens with the values for the hardregs therin.  */
end_comment

begin_decl_stmt
name|rtx
name|eh_return_stub_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used for targets which can call rethrow with an offset instead    of an address. This is subtracted from the rethrow label we are    interested in. */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|first_rethrow_symbol
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|final_rethrow
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|last_rethrow_symbol
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|push_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|eh_stack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eh_entry
modifier|*
name|pop_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|eh_stack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enqueue_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|eh_queue
operator|*
operator|,
expr|struct
name|eh_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eh_entry
modifier|*
name|dequeue_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|eh_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|call_get_eh_context
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_dynamic_cleanup
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_dynamic_handler
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_rethrow
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_exception_table_entry
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_throw
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|scan_region
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eh_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_insn_eh_region
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|jumpif_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|rtx
name|expand_builtin_return_addr
name|PROTO
argument_list|(
operator|(
expr|enum
name|built_in_function
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Various support routines to manipulate the various data structures    used by the exception handling code.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate a SYMBOL_REF for rethrow to use */
end_comment

begin_function
specifier|static
name|rtx
name|create_rethrow_ref
parameter_list|(
name|region_num
parameter_list|)
name|int
name|region_num
decl_stmt|;
block|{
name|rtx
name|def
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LRTH"
argument_list|,
name|region_num
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|def
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|SYMBOL_REF_NEED_ADJUST
argument_list|(
name|def
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|def
return|;
block|}
end_function

begin_comment
comment|/* Push a label entry onto the given STACK.  */
end_comment

begin_function
name|void
name|push_label_entry
parameter_list|(
name|stack
parameter_list|,
name|rlabel
parameter_list|,
name|tlabel
parameter_list|)
name|struct
name|label_node
modifier|*
modifier|*
name|stack
decl_stmt|;
name|rtx
name|rlabel
decl_stmt|;
name|tree
name|tlabel
decl_stmt|;
block|{
name|struct
name|label_node
modifier|*
name|newnode
init|=
operator|(
expr|struct
name|label_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label_node
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rlabel
condition|)
name|newnode
operator|->
name|u
operator|.
name|rlabel
operator|=
name|rlabel
expr_stmt|;
else|else
name|newnode
operator|->
name|u
operator|.
name|tlabel
operator|=
name|tlabel
expr_stmt|;
name|newnode
operator|->
name|chain
operator|=
operator|*
name|stack
expr_stmt|;
operator|*
name|stack
operator|=
name|newnode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a label entry from the given STACK.  */
end_comment

begin_function
name|rtx
name|pop_label_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|label_node
modifier|*
modifier|*
name|stack
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|label_node
modifier|*
name|tempnode
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|stack
condition|)
return|return
name|NULL_RTX
return|;
name|tempnode
operator|=
operator|*
name|stack
expr_stmt|;
name|label
operator|=
name|tempnode
operator|->
name|u
operator|.
name|rlabel
expr_stmt|;
operator|*
name|stack
operator|=
operator|(
operator|*
name|stack
operator|)
operator|->
name|chain
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Return the top element of the given STACK.  */
end_comment

begin_function
name|tree
name|top_label_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|label_node
modifier|*
modifier|*
name|stack
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|*
name|stack
condition|)
return|return
name|NULL_TREE
return|;
return|return
operator|(
operator|*
name|stack
operator|)
operator|->
name|u
operator|.
name|tlabel
return|;
block|}
end_function

begin_comment
comment|/* get an exception label. These must be on the permanent obstack */
end_comment

begin_function
name|rtx
name|gen_exception_label
parameter_list|()
block|{
name|rtx
name|lab
decl_stmt|;
name|lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
return|return
name|lab
return|;
block|}
end_function

begin_comment
comment|/* Push a new eh_node entry onto STACK.  */
end_comment

begin_function
specifier|static
name|void
name|push_eh_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|eh_stack
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|eh_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|eh_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_node
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|eh_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|eh_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_entry
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|rlab
init|=
name|gen_exception_label
argument_list|()
decl_stmt|;
name|entry
operator|->
name|finalization
operator|=
name|NULL_TREE
expr_stmt|;
name|entry
operator|->
name|label_used
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|exception_handler_label
operator|=
name|rlab
expr_stmt|;
name|entry
operator|->
name|false_label
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|flag_new_exceptions
condition|)
name|entry
operator|->
name|outer_context
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|else
name|entry
operator|->
name|outer_context
operator|=
name|create_rethrow_ref
argument_list|(
name|CODE_LABEL_NUMBER
argument_list|(
name|rlab
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|rethrow_label
operator|=
name|entry
operator|->
name|outer_context
expr_stmt|;
name|node
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|node
operator|->
name|chain
operator|=
name|stack
operator|->
name|top
expr_stmt|;
name|stack
operator|->
name|top
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* push an existing entry onto a stack. */
end_comment

begin_function
specifier|static
name|void
name|push_entry
parameter_list|(
name|stack
parameter_list|,
name|entry
parameter_list|)
name|struct
name|eh_stack
modifier|*
name|stack
decl_stmt|;
name|struct
name|eh_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|eh_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|eh_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_node
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|node
operator|->
name|chain
operator|=
name|stack
operator|->
name|top
expr_stmt|;
name|stack
operator|->
name|top
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop an entry from the given STACK.  */
end_comment

begin_function
specifier|static
name|struct
name|eh_entry
modifier|*
name|pop_eh_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|eh_stack
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|eh_node
modifier|*
name|tempnode
decl_stmt|;
name|struct
name|eh_entry
modifier|*
name|tempentry
decl_stmt|;
name|tempnode
operator|=
name|stack
operator|->
name|top
expr_stmt|;
name|tempentry
operator|=
name|tempnode
operator|->
name|entry
expr_stmt|;
name|stack
operator|->
name|top
operator|=
name|stack
operator|->
name|top
operator|->
name|chain
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|tempentry
return|;
block|}
end_function

begin_comment
comment|/* Enqueue an ENTRY onto the given QUEUE.  */
end_comment

begin_function
specifier|static
name|void
name|enqueue_eh_entry
parameter_list|(
name|queue
parameter_list|,
name|entry
parameter_list|)
name|struct
name|eh_queue
modifier|*
name|queue
decl_stmt|;
name|struct
name|eh_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|eh_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|eh_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_node
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|node
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|queue
operator|->
name|head
operator|==
name|NULL
condition|)
block|{
name|queue
operator|->
name|head
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|->
name|tail
operator|->
name|chain
operator|=
name|node
expr_stmt|;
block|}
name|queue
operator|->
name|tail
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dequeue an entry from the given QUEUE.  */
end_comment

begin_function
specifier|static
name|struct
name|eh_entry
modifier|*
name|dequeue_eh_entry
parameter_list|(
name|queue
parameter_list|)
name|struct
name|eh_queue
modifier|*
name|queue
decl_stmt|;
block|{
name|struct
name|eh_node
modifier|*
name|tempnode
decl_stmt|;
name|struct
name|eh_entry
modifier|*
name|tempentry
decl_stmt|;
if|if
condition|(
name|queue
operator|->
name|head
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tempnode
operator|=
name|queue
operator|->
name|head
expr_stmt|;
name|queue
operator|->
name|head
operator|=
name|queue
operator|->
name|head
operator|->
name|chain
expr_stmt|;
name|tempentry
operator|=
name|tempnode
operator|->
name|entry
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|tempentry
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|receive_exception_label
parameter_list|(
name|handler_label
parameter_list|)
name|rtx
name|handler_label
decl_stmt|;
block|{
name|rtx
name|around_label
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
operator|!
name|flag_new_exceptions
operator|||
name|exceptions_via_longjmp
condition|)
block|{
name|around_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|handler_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exceptions_via_longjmp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_exception_receiver
if|if
condition|(
name|HAVE_exception_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_exception_receiver
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Nothing */
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|DONT_USE_BUILTIN_SETJMP
name|expand_builtin_setjmp_receiver
argument_list|(
name|handler_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|around_label
condition|)
name|emit_label
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|func_eh_entry
block|{
name|int
name|range_number
decl_stmt|;
comment|/* EH region number from EH NOTE insn's */
name|rtx
name|rethrow_label
decl_stmt|;
comment|/* Label for rethrow */
name|struct
name|handler_info
modifier|*
name|handlers
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* table of function eh regions */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|func_eh_entry
modifier|*
name|function_eh_regions
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_func_eh_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_func_eh_entry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIZE_FUNC_EH
parameter_list|(
name|X
parameter_list|)
value|(sizeof (struct func_eh_entry) * X)
end_define

begin_comment
comment|/* Add a new eh_entry for this function, and base it off of the information    in the EH_ENTRY parameter. A NULL parameter is invalid.     OUTER_CONTEXT is a label which is used for rethrowing. The number    returned is an number which uniquely identifies this exception range. */
end_comment

begin_function
specifier|static
name|int
name|new_eh_region_entry
parameter_list|(
name|note_eh_region
parameter_list|,
name|rethrow
parameter_list|)
name|int
name|note_eh_region
decl_stmt|;
name|rtx
name|rethrow
decl_stmt|;
block|{
if|if
condition|(
name|current_func_eh_entry
operator|==
name|num_func_eh_entries
condition|)
block|{
if|if
condition|(
name|num_func_eh_entries
operator|==
literal|0
condition|)
block|{
name|function_eh_regions
operator|=
operator|(
expr|struct
name|func_eh_entry
operator|*
operator|)
name|malloc
argument_list|(
name|SIZE_FUNC_EH
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|num_func_eh_entries
operator|=
literal|50
expr_stmt|;
block|}
else|else
block|{
name|num_func_eh_entries
operator|=
name|num_func_eh_entries
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
name|function_eh_regions
operator|=
operator|(
expr|struct
name|func_eh_entry
operator|*
operator|)
name|realloc
argument_list|(
name|function_eh_regions
argument_list|,
name|SIZE_FUNC_EH
argument_list|(
name|num_func_eh_entries
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|function_eh_regions
index|[
name|current_func_eh_entry
index|]
operator|.
name|range_number
operator|=
name|note_eh_region
expr_stmt|;
if|if
condition|(
name|rethrow
operator|==
name|NULL_RTX
condition|)
name|function_eh_regions
index|[
name|current_func_eh_entry
index|]
operator|.
name|rethrow_label
operator|=
name|create_rethrow_ref
argument_list|(
name|note_eh_region
argument_list|)
expr_stmt|;
else|else
name|function_eh_regions
index|[
name|current_func_eh_entry
index|]
operator|.
name|rethrow_label
operator|=
name|rethrow
expr_stmt|;
name|function_eh_regions
index|[
name|current_func_eh_entry
index|]
operator|.
name|handlers
operator|=
name|NULL
expr_stmt|;
return|return
name|current_func_eh_entry
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Add new handler information to an exception range. The  first parameter    specifies the range number (returned from new_eh_entry()). The second    parameter specifies the handler.  By default the handler is inserted at    the end of the list. A handler list may contain only ONE NULL_TREE    typeinfo entry. Regardless where it is positioned, a NULL_TREE entry    is always output as the LAST handler in the exception table for a region. */
end_comment

begin_function
name|void
name|add_new_handler
parameter_list|(
name|region
parameter_list|,
name|newhandler
parameter_list|)
name|int
name|region
decl_stmt|;
name|struct
name|handler_info
modifier|*
name|newhandler
decl_stmt|;
block|{
name|struct
name|handler_info
modifier|*
name|last
decl_stmt|;
name|newhandler
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
name|function_eh_regions
index|[
name|region
index|]
operator|.
name|handlers
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|function_eh_regions
index|[
name|region
index|]
operator|.
name|handlers
operator|=
name|newhandler
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
condition|;
name|last
operator|=
name|last
operator|->
name|next
control|)
block|{
if|if
condition|(
name|last
operator|->
name|type_info
operator|==
name|CATCH_ALL_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"additional handler after ..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|->
name|next
operator|==
name|NULL
condition|)
break|break;
block|}
name|last
operator|->
name|next
operator|=
name|newhandler
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove a handler label. The handler label is being deleted, so all    regions which reference this handler should have it removed from their    list of possible handlers. Any region which has the final handler    removed can be deleted. */
end_comment

begin_function
name|void
name|remove_handler
parameter_list|(
name|removing_label
parameter_list|)
name|rtx
name|removing_label
decl_stmt|;
block|{
name|struct
name|handler_info
modifier|*
name|handler
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|current_func_eh_entry
condition|;
operator|++
name|x
control|)
block|{
name|last
operator|=
name|NULL
expr_stmt|;
name|handler
operator|=
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|handlers
expr_stmt|;
for|for
control|(
init|;
name|handler
condition|;
name|last
operator|=
name|handler
operator|,
name|handler
operator|=
name|handler
operator|->
name|next
control|)
if|if
condition|(
name|handler
operator|->
name|handler_label
operator|==
name|removing_label
condition|)
block|{
if|if
condition|(
name|last
condition|)
block|{
name|last
operator|->
name|next
operator|=
name|handler
operator|->
name|next
expr_stmt|;
name|handler
operator|=
name|last
expr_stmt|;
block|}
else|else
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|handlers
operator|=
name|handler
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function will return a malloc'd pointer to an array of     void pointer representing the runtime match values that     currently exist in all regions. */
end_comment

begin_function
name|int
name|find_all_handler_type_matches
parameter_list|(
name|array
parameter_list|)
name|void
modifier|*
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
name|struct
name|handler_info
modifier|*
name|handler
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|void
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|int
name|max_ptr
decl_stmt|;
name|int
name|n_ptr
init|=
literal|0
decl_stmt|;
operator|*
name|array
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
operator|||
operator|!
name|flag_new_exceptions
condition|)
return|return
literal|0
return|;
name|max_ptr
operator|=
literal|100
expr_stmt|;
name|ptr
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|max_ptr
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|current_func_eh_entry
condition|;
name|x
operator|++
control|)
block|{
name|last
operator|=
name|NULL
expr_stmt|;
name|handler
operator|=
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|handlers
expr_stmt|;
for|for
control|(
init|;
name|handler
condition|;
name|last
operator|=
name|handler
operator|,
name|handler
operator|=
name|handler
operator|->
name|next
control|)
block|{
name|val
operator|=
name|handler
operator|->
name|type_info
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NULL
operator|&&
name|val
operator|!=
name|CATCH_ALL_TYPE
condition|)
block|{
comment|/* See if this match value has already been found. */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|n_ptr
condition|;
name|y
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|y
index|]
operator|==
name|val
condition|)
break|break;
comment|/* If we break early, we already found this value. */
if|if
condition|(
name|y
operator|<
name|n_ptr
condition|)
continue|continue;
comment|/* Do we need to allocate more space? */
if|if
condition|(
name|n_ptr
operator|>=
name|max_ptr
condition|)
block|{
name|max_ptr
operator|+=
name|max_ptr
operator|/
literal|2
expr_stmt|;
name|ptr
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|max_ptr
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|ptr
index|[
name|n_ptr
index|]
operator|=
name|val
expr_stmt|;
name|n_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|array
operator|=
name|ptr
expr_stmt|;
return|return
name|n_ptr
return|;
block|}
end_function

begin_comment
comment|/* Create a new handler structure initialized with the handler label and    typeinfo fields passed in. */
end_comment

begin_function
name|struct
name|handler_info
modifier|*
name|get_new_handler
parameter_list|(
name|handler
parameter_list|,
name|typeinfo
parameter_list|)
name|rtx
name|handler
decl_stmt|;
name|void
modifier|*
name|typeinfo
decl_stmt|;
block|{
name|struct
name|handler_info
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
expr|struct
name|handler_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|handler_info
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|handler_label
operator|=
name|handler
expr_stmt|;
name|ptr
operator|->
name|handler_number
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|type_info
operator|=
name|typeinfo
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Find the index in function_eh_regions associated with a NOTE region. If    the region cannot be found, a -1 is returned. This should never happen! */
end_comment

begin_function
name|int
name|find_func_region
parameter_list|(
name|insn_region
parameter_list|)
name|int
name|insn_region
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|current_func_eh_entry
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|range_number
operator|==
name|insn_region
condition|)
return|return
name|x
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get a pointer to the first handler in an exception region's list. */
end_comment

begin_function
name|struct
name|handler_info
modifier|*
name|get_first_handler
parameter_list|(
name|region
parameter_list|)
name|int
name|region
decl_stmt|;
block|{
return|return
name|function_eh_regions
index|[
name|find_func_region
argument_list|(
name|region
argument_list|)
index|]
operator|.
name|handlers
return|;
block|}
end_function

begin_comment
comment|/* Clean out the function_eh_region table and free all memory */
end_comment

begin_function
specifier|static
name|void
name|clear_function_eh_region
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|struct
name|handler_info
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|current_func_eh_entry
condition|;
name|x
operator|++
control|)
for|for
control|(
name|ptr
operator|=
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|handlers
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|function_eh_regions
argument_list|)
expr_stmt|;
name|num_func_eh_entries
operator|=
literal|0
expr_stmt|;
name|current_func_eh_entry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a duplicate of an exception region by copying all the handlers    for an exception region. Return the new handler index. The final    parameter is a routine which maps old labels to new ones. */
end_comment

begin_function_decl
name|int
name|duplicate_eh_handlers
parameter_list|(
name|old_note_eh_region
parameter_list|,
name|new_note_eh_region
parameter_list|,
name|map
parameter_list|)
name|int
name|old_note_eh_region
decl_stmt|,
name|new_note_eh_region
decl_stmt|;
function_decl|rtx
parameter_list|(
function_decl|*map
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|handler_info
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|new_ptr
decl_stmt|;
name|int
name|new_region
decl_stmt|,
name|region
decl_stmt|;
name|region
operator|=
name|find_func_region
argument_list|(
name|old_note_eh_region
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Cannot duplicate non-existant exception region."
argument_list|)
expr_stmt|;
comment|/* duplicate_eh_handlers may have been called during a symbol remap. */
name|new_region
operator|=
name|find_func_region
argument_list|(
name|new_note_eh_region
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_region
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|new_region
operator|)
return|;
name|new_region
operator|=
name|new_eh_region_entry
argument_list|(
name|new_note_eh_region
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|function_eh_regions
index|[
name|region
index|]
operator|.
name|handlers
expr_stmt|;
for|for
control|(
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|new_ptr
operator|=
name|get_new_handler
argument_list|(
name|map
argument_list|(
name|ptr
operator|->
name|handler_label
argument_list|)
argument_list|,
name|ptr
operator|->
name|type_info
argument_list|)
expr_stmt|;
name|add_new_handler
argument_list|(
name|new_region
argument_list|,
name|new_ptr
argument_list|)
expr_stmt|;
block|}
return|return
name|new_region
return|;
block|}
end_block

begin_comment
comment|/* Given a rethrow symbol, find the EH region number this is for. */
end_comment

begin_function
name|int
name|eh_region_from_symbol
parameter_list|(
name|sym
parameter_list|)
name|rtx
name|sym
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_rethrow_symbol
condition|)
return|return
literal|1
return|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|current_func_eh_entry
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|rethrow_label
operator|==
name|sym
condition|)
return|return
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|range_number
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* When inlining/unrolling, we have to map the symbols passed to    __rethrow as well. This performs the remap. If a symbol isn't foiund,    the original one is returned. This is not an efficient routine,    so don't call it on everything!! */
end_comment

begin_function_decl
name|rtx
name|rethrow_symbol_map
parameter_list|(
name|sym
parameter_list|,
name|map
parameter_list|)
name|rtx
name|sym
decl_stmt|;
function_decl|rtx
parameter_list|(
function_decl|*map
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|current_func_eh_entry
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|rethrow_label
operator|==
name|sym
condition|)
block|{
comment|/* We've found the original region, now lets determine which region            this now maps to. */
name|rtx
name|l1
init|=
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|handlers
operator|->
name|handler_label
decl_stmt|;
name|rtx
name|l2
init|=
name|map
argument_list|(
name|l1
argument_list|)
decl_stmt|;
name|y
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|l2
argument_list|)
expr_stmt|;
comment|/* This is the new region number */
name|x
operator|=
name|find_func_region
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* Get the new permanent region */
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
comment|/* Hmm, Doesn't exist yet */
block|{
name|x
operator|=
name|duplicate_eh_handlers
argument_list|(
name|CODE_LABEL_NUMBER
argument_list|(
name|l1
argument_list|)
argument_list|,
name|y
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Since we're mapping it, it must be used. */
name|SYMBOL_REF_USED
argument_list|(
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|rethrow_label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|function_eh_regions
index|[
name|x
index|]
operator|.
name|rethrow_label
return|;
block|}
return|return
name|sym
return|;
block|}
end_block

begin_function
name|int
name|rethrow_used
parameter_list|(
name|region
parameter_list|)
name|int
name|region
decl_stmt|;
block|{
if|if
condition|(
name|flag_new_exceptions
condition|)
block|{
name|rtx
name|lab
init|=
name|function_eh_regions
index|[
name|find_func_region
argument_list|(
name|region
argument_list|)
index|]
operator|.
name|rethrow_label
decl_stmt|;
return|return
operator|(
name|SYMBOL_REF_USED
argument_list|(
name|lab
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to see if exception handling is turned on.    DO_WARN is non-zero if we want to inform the user that exception    handling is turned off.      This is used to ensure that -fexceptions has been specified if the    compiler tries to use any exception-specific functions.  */
end_comment

begin_function
name|int
name|doing_eh
parameter_list|(
name|do_warn
parameter_list|)
name|int
name|do_warn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|do_warn
condition|)
block|{
name|error
argument_list|(
literal|"exception handling disabled, use -fexceptions to enable"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a return address in ADDR, determine the address we should use    to find the corresponding EH region.  */
end_comment

begin_function
name|rtx
name|eh_outer_context
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
comment|/* First mask out any unwanted bits.  */
ifdef|#
directive|ifdef
name|MASK_RETURN_ADDR
name|expand_and
argument_list|(
name|addr
argument_list|,
name|MASK_RETURN_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Then adjust to find the real return address.  */
if|#
directive|if
name|defined
argument_list|(
name|RETURN_ADDR_OFFSET
argument_list|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Start a new exception region for a region of code that has a    cleanup action and push the HANDLER for the region onto    protect_list. All of the regions created with add_partial_entry    will be ended when end_protect_partials is invoked.  */
end_comment

begin_function
name|void
name|add_partial_entry
parameter_list|(
name|handler
parameter_list|)
name|tree
name|handler
decl_stmt|;
block|{
name|expand_eh_region_start
argument_list|()
expr_stmt|;
comment|/* Make sure the entry is on the correct obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Because this is a cleanup action, we may have to protect the handler      with __terminate.  */
name|handler
operator|=
name|protect_with_terminate
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|protect_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|handler
argument_list|,
name|protect_list
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to get EH context to current function.  */
end_comment

begin_function
specifier|static
name|rtx
name|call_get_eh_context
parameter_list|()
block|{
specifier|static
name|tree
name|fn
decl_stmt|;
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|fntype
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__get_eh_context"
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|fntype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|fn
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|copy_to_reg
argument_list|(
name|expand_expr
argument_list|(
name|expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a reference to the EH context.    We will only generate a register for the current function EH context here,    and emit a USE insn to mark that this is a EH context register.     Later, emit_eh_context will emit needed call to __get_eh_context    in libgcc2, and copy the value to the register we have generated. */
end_comment

begin_function
name|rtx
name|get_eh_context
parameter_list|()
block|{
if|if
condition|(
name|current_function_ehc
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|current_function_ehc
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_USE
argument_list|(
name|GET_MODE
argument_list|(
name|current_function_ehc
argument_list|)
argument_list|,
name|current_function_ehc
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|insn
argument_list|,
name|get_first_nonparm_insn
argument_list|()
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_CONTEXT
argument_list|,
name|current_function_ehc
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|current_function_ehc
return|;
block|}
end_function

begin_comment
comment|/* Get a reference to the dynamic handler chain.  It points to the    pointer to the next element in the dynamic handler chain.  It ends    when there are no more elements in the dynamic handler chain, when    the value is&top_elt from libgcc2.c.  Immediately after the    pointer, is an area suitable for setjmp/longjmp when    DONT_USE_BUILTIN_SETJMP is defined, and an area suitable for    __builtin_setjmp/__builtin_longjmp when DONT_USE_BUILTIN_SETJMP    isn't defined. */
end_comment

begin_function
name|rtx
name|get_dynamic_handler_chain
parameter_list|()
block|{
name|rtx
name|ehc
decl_stmt|,
name|dhc
decl_stmt|,
name|result
decl_stmt|;
name|ehc
operator|=
name|get_eh_context
argument_list|()
expr_stmt|;
comment|/* This is the offset of dynamic_handler_chain in the eh_context struct      declared in eh-common.h. If its location is change, change this offset */
name|dhc
operator|=
name|plus_constant
argument_list|(
name|ehc
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|result
operator|=
name|copy_to_reg
argument_list|(
name|dhc
argument_list|)
expr_stmt|;
comment|/* We don't want a copy of the dcc, but rather, the single dcc.  */
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a reference to the dynamic cleanup chain.  It points to the    pointer to the next element in the dynamic cleanup chain.    Immediately after the pointer, are two Pmode variables, one for a    pointer to a function that performs the cleanup action, and the    second, the argument to pass to that function.  */
end_comment

begin_function
name|rtx
name|get_dynamic_cleanup_chain
parameter_list|()
block|{
name|rtx
name|dhc
decl_stmt|,
name|dcc
decl_stmt|,
name|result
decl_stmt|;
name|dhc
operator|=
name|get_dynamic_handler_chain
argument_list|()
expr_stmt|;
name|dcc
operator|=
name|plus_constant
argument_list|(
name|dhc
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|result
operator|=
name|copy_to_reg
argument_list|(
name|dcc
argument_list|)
expr_stmt|;
comment|/* We don't want a copy of the dcc, but rather, the single dcc.  */
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
end_ifdef

begin_comment
comment|/* Generate code to evaluate X and jump to LABEL if the value is nonzero.    LABEL is an rtx of code CODE_LABEL, in this function.  */
end_comment

begin_function
specifier|static
name|void
name|jumpif_rtx
parameter_list|(
name|x
parameter_list|,
name|label
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|jumpif
argument_list|(
name|make_tree
argument_list|(
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Start a dynamic cleanup on the EH runtime dynamic cleanup stack.    We just need to create an element for the cleanup list, and push it    into the chain.     A dynamic cleanup is a cleanup action implied by the presence of an    element on the EH runtime dynamic cleanup stack that is to be    performed when an exception is thrown.  The cleanup action is    performed by __sjthrow when an exception is thrown.  Only certain    actions can be optimized into dynamic cleanup actions.  For the    restrictions on what actions can be performed using this routine,    see expand_eh_region_start_tree.  */
end_comment

begin_function
specifier|static
name|void
name|start_dynamic_cleanup
parameter_list|(
name|func
parameter_list|,
name|arg
parameter_list|)
name|tree
name|func
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|rtx
name|dcc
decl_stmt|;
name|rtx
name|new_func
decl_stmt|,
name|new_arg
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* We allocate enough room for a pointer to the function, and      one argument.  */
name|size
operator|=
literal|2
expr_stmt|;
comment|/* XXX, FIXME: The stack space allocated this way is too long lived,      but there is no allocation routine that allocates at the level of      the last binding contour.  */
name|buf
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
operator|*
operator|(
name|size
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|change_address
argument_list|(
name|buf
argument_list|,
name|Pmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Store dcc into the first word of the newly allocated buffer.  */
name|dcc
operator|=
name|get_dynamic_cleanup_chain
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|buf
argument_list|,
name|dcc
argument_list|)
expr_stmt|;
comment|/* Store func and arg into the cleanup list element.  */
name|new_func
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new_arg
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_expr
argument_list|(
name|func
argument_list|,
name|new_func
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|new_func
condition|)
name|emit_move_insn
argument_list|(
name|new_func
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|new_arg
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|new_arg
condition|)
name|emit_move_insn
argument_list|(
name|new_arg
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Update the cleanup chain.  */
name|emit_move_insn
argument_list|(
name|dcc
argument_list|,
name|XEXP
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit RTL to start a dynamic handler on the EH runtime dynamic    handler stack.  This should only be used by expand_eh_region_start    or expand_eh_region_start_tree.  */
end_comment

begin_function
specifier|static
name|void
name|start_dynamic_handler
parameter_list|()
block|{
name|rtx
name|dhc
decl_stmt|,
name|dcc
decl_stmt|;
name|rtx
name|arg
decl_stmt|,
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
ifndef|#
directive|ifndef
name|DONT_USE_BUILTIN_SETJMP
comment|/* The number of Pmode words for the setjmp buffer, when using the      builtin setjmp/longjmp, see expand_builtin, case      BUILT_IN_LONGJMP.  */
name|size
operator|=
literal|5
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|JMP_BUF_SIZE
name|size
operator|=
name|JMP_BUF_SIZE
expr_stmt|;
else|#
directive|else
comment|/* Should be large enough for most systems, if it is not,      JMP_BUF_SIZE should be defined with the proper value.  It will      also tend to be larger than necessary for most systems, a more      optimal port will define JMP_BUF_SIZE.  */
name|size
operator|=
name|FIRST_PSEUDO_REGISTER
operator|+
literal|2
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* XXX, FIXME: The stack space allocated this way is too long lived,      but there is no allocation routine that allocates at the level of      the last binding contour.  */
name|arg
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
operator|*
operator|(
name|size
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|change_address
argument_list|(
name|arg
argument_list|,
name|Pmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Store dhc into the first word of the newly allocated buffer.  */
name|dhc
operator|=
name|get_dynamic_handler_chain
argument_list|()
expr_stmt|;
name|dcc
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|arg
argument_list|,
name|dhc
argument_list|)
expr_stmt|;
comment|/* Zero out the start of the cleanup chain.  */
name|emit_move_insn
argument_list|(
name|dcc
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* The jmpbuf starts two words into the area allocated.  */
name|buf
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|emit_library_call_value
argument_list|(
name|setjmp_libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|1
argument_list|,
name|buf
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
comment|/* If we come back here for a catch, transfer control to the handler.  */
name|jumpif_rtx
argument_list|(
name|x
argument_list|,
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|expand_builtin_setjmp_setup
argument_list|(
name|buf
argument_list|,
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We are committed to this, so update the handler chain.  */
name|emit_move_insn
argument_list|(
name|dhc
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an exception handling region for the given cleanup action.    All instructions emitted after this point are considered to be part    of the region until expand_eh_region_end is invoked.  CLEANUP is    the cleanup action to perform.  The return value is true if the    exception region was optimized away.  If that case,    expand_eh_region_end does not need to be called for this cleanup,    nor should it be.     This routine notices one particular common case in C++ code    generation, and optimizes it so as to not need the exception    region.  It works by creating a dynamic cleanup action, instead of    a using an exception region.  */
end_comment

begin_function
name|int
name|expand_eh_region_start_tree
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
block|{
comment|/* This is the old code.  */
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The optimization only applies to actions protected with      terminate, and only applies if we are using the setjmp/longjmp      codegen method.  */
if|if
condition|(
name|exceptions_via_longjmp
operator|&&
name|protect_cleanup_actions_with_terminate
condition|)
block|{
name|tree
name|func
decl_stmt|,
name|arg
decl_stmt|;
name|tree
name|args
decl_stmt|;
comment|/* Ignore any UNSAVE_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cleanup
argument_list|)
operator|==
name|UNSAVE_EXPR
condition|)
name|cleanup
operator|=
name|TREE_OPERAND
argument_list|(
name|cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Further, it only applies if the action is a call, if there 	 are 2 arguments, and if the second argument is 2.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cleanup
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|cleanup
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
operator|(
name|func
operator|=
name|TREE_OPERAND
argument_list|(
name|cleanup
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|)
operator|&&
operator|(
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|)
comment|/* is the second argument 2?  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
literal|2
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
literal|0
comment|/* Make sure there are no other arguments.  */
operator|&&
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Arrange for returns and gotos to pop the entry we make on the 	     dynamic cleanup stack.  */
name|expand_dcc_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|start_dynamic_cleanup
argument_list|(
name|func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|expand_eh_region_start_for_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|finalization
operator|=
name|cleanup
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Just like expand_eh_region_start, except if a cleanup action is    entered on the cleanup chain, the TREE_PURPOSE of the element put    on the chain is DECL.  DECL should be the associated VAR_DECL, if    any, otherwise it should be NULL_TREE.  */
end_comment

begin_function
name|void
name|expand_eh_region_start_for_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
comment|/* This is the old code.  */
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|exceptions_via_longjmp
condition|)
block|{
comment|/* We need a new block to record the start and end of the 	 dynamic handler chain.  We could always do this, but we 	 really want to permit jumping into such a block, and we want 	 to avoid any errors or performance impact in the SJ EH code 	 for now.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* But we don't need or want a new temporary level.  */
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* Mark this block as created by expand_eh_region_start.  This 	 is so that we can pop the block with expand_end_bindings 	 automatically.  */
name|mark_block_as_eh_region
argument_list|()
expr_stmt|;
comment|/* Arrange for returns and gotos to pop the entry we make on the 	 dynamic handler stack.  */
name|expand_dhc_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|push_eh_entry
argument_list|(
operator|&
name|ehstack
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_EH_REGION_BEG
argument_list|)
expr_stmt|;
name|NOTE_BLOCK_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceptions_via_longjmp
condition|)
name|start_dynamic_handler
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an exception handling region.  All instructions emitted after    this point are considered to be part of the region until    expand_eh_region_end is invoked.  */
end_comment

begin_function
name|void
name|expand_eh_region_start
parameter_list|()
block|{
name|expand_eh_region_start_for_decl
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End an exception handling region.  The information about the region    is found on the top of ehstack.     HANDLER is either the cleanup for the exception region, or if we're    marking the end of a try block, HANDLER is integer_zero_node.     HANDLER will be transformed to rtl when expand_leftover_cleanups    is invoked.  */
end_comment

begin_function
name|void
name|expand_eh_region_end
parameter_list|(
name|handler
parameter_list|)
name|tree
name|handler
decl_stmt|;
block|{
name|struct
name|eh_entry
modifier|*
name|entry
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|entry
operator|=
name|pop_eh_entry
argument_list|(
operator|&
name|ehstack
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_EH_REGION_END
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NOTE_BLOCK_NUMBER
argument_list|(
name|note
argument_list|)
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceptions_via_longjmp
operator|==
literal|0
operator|&&
operator|!
name|flag_new_exceptions
comment|/* We share outer_context between regions; only emit it once.  */
operator|&&
name|INSN_UID
argument_list|(
name|entry
operator|->
name|outer_context
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* Emit a label marking the end of this exception region that 	 is used for rethrowing into the outer context.  */
name|emit_label
argument_list|(
name|entry
operator|->
name|outer_context
argument_list|)
expr_stmt|;
name|expand_internal_throw
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|finalization
operator|=
name|handler
expr_stmt|;
comment|/* create region entry in final exception table */
name|r
operator|=
name|new_eh_region_entry
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|,
name|entry
operator|->
name|rethrow_label
argument_list|)
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* If we have already started ending the bindings, don't recurse.      This only happens when exceptions_via_longjmp is true.  */
if|if
condition|(
name|is_eh_region
argument_list|()
condition|)
block|{
comment|/* Because we don't need or want a new temporary level and 	 because we didn't create one in expand_eh_region_start, 	 create a fake one now to avoid removing one in 	 expand_end_bindings.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|mark_block_as_not_eh_region
argument_list|()
expr_stmt|;
comment|/* Maybe do this to prevent jumping in and so on...  */
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End the EH region for a goto fixup.  We only need them in the region-based    EH scheme.  */
end_comment

begin_function
name|void
name|expand_fixup_region_start
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
operator|||
name|exceptions_via_longjmp
condition|)
return|return;
name|expand_eh_region_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End the EH region for a goto fixup.  CLEANUP is the cleanup we just    expanded; to avoid running it twice if it throws, we look through the    ehqueue for a matching region and rethrow from its outer_context.  */
end_comment

begin_function
name|void
name|expand_fixup_region_end
parameter_list|(
name|cleanup
parameter_list|)
name|tree
name|cleanup
decl_stmt|;
block|{
name|struct
name|eh_node
modifier|*
name|node
decl_stmt|;
name|int
name|dont_issue
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
operator|||
name|exceptions_via_longjmp
condition|)
return|return;
for|for
control|(
name|node
operator|=
name|ehstack
operator|.
name|top
init|;
name|node
operator|&&
name|node
operator|->
name|entry
operator|->
name|finalization
operator|!=
name|cleanup
condition|;
control|)
name|node
operator|=
name|node
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|0
condition|)
for|for
control|(
name|node
operator|=
name|ehqueue
operator|.
name|head
init|;
name|node
operator|&&
name|node
operator|->
name|entry
operator|->
name|finalization
operator|!=
name|cleanup
condition|;
control|)
name|node
operator|=
name|node
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the outer context label has not been issued yet, we don't want      to issue it as a part of this region, unless this is the      correct region for the outer context. If we did, then the label for      the outer context will be WITHIN the begin/end labels,       and we could get an infinte loop when it tried to rethrow, or just      generally incorrect execution following a throw. */
name|dont_issue
operator|=
operator|(
operator|(
name|INSN_UID
argument_list|(
name|node
operator|->
name|entry
operator|->
name|outer_context
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|!=
name|node
operator|->
name|entry
operator|)
operator|)
expr_stmt|;
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|outer_context
operator|=
name|node
operator|->
name|entry
operator|->
name|outer_context
expr_stmt|;
comment|/* Since we are rethrowing to the OUTER region, we know we don't need      a jump around sequence for this region, so we'll pretend the outer       context label has been issued by setting INSN_UID to 1, then clearing      it again afterwards. */
if|if
condition|(
name|dont_issue
condition|)
name|INSN_UID
argument_list|(
name|node
operator|->
name|entry
operator|->
name|outer_context
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Just rethrow.  size_zero_node is just a NOP.  */
name|expand_eh_region_end
argument_list|(
name|size_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|dont_issue
condition|)
name|INSN_UID
argument_list|(
name|node
operator|->
name|entry
operator|->
name|outer_context
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we are using the setjmp/longjmp EH codegen method, we emit a    call to __sjthrow.     Otherwise, we emit a call to __throw and note that we threw    something, so we know we need to generate the necessary code for    __throw.     Before invoking throw, the __eh_pc variable must have been set up    to contain the PC being thrown from. This address is used by    __throw to determine which exception region (if any) is    responsible for handling the exception.  */
end_comment

begin_function
name|void
name|emit_throw
parameter_list|()
block|{
if|if
condition|(
name|exceptions_via_longjmp
condition|)
block|{
name|emit_library_call
argument_list|(
name|sjthrow_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|JUMP_TO_THROW
name|emit_indirect_jump
argument_list|(
name|throw_libfunc
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|throw_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Throw the current exception.  If appropriate, this is done by jumping    to the next handler.  */
end_comment

begin_function
name|void
name|expand_internal_throw
parameter_list|()
block|{
name|emit_throw
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from expand_exception_blocks and expand_end_catch_block to    emit any pending handlers/cleanups queued from expand_eh_region_end.  */
end_comment

begin_function
name|void
name|expand_leftover_cleanups
parameter_list|()
block|{
name|struct
name|eh_entry
modifier|*
name|entry
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* A leftover try block. Shouldn't be one here.  */
if|if
condition|(
name|entry
operator|->
name|finalization
operator|==
name|integer_zero_node
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Output the label for the start of the exception handler.  */
name|receive_exception_label
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
comment|/* register a handler for this cleanup region */
name|add_new_handler
argument_list|(
name|find_func_region
argument_list|(
name|CODE_LABEL_NUMBER
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
argument_list|)
argument_list|,
name|get_new_handler
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And now generate the insns for the handler.  */
name|expand_expr
argument_list|(
name|entry
operator|->
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|BARRIER
condition|)
comment|/* Emit code to throw to the outer context if we fall off 	   the end of the handler.  */
name|expand_rethrow
argument_list|(
name|entry
operator|->
name|outer_context
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called at the start of a block of try statements.  */
end_comment

begin_function
name|void
name|expand_start_try_stmts
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|expand_eh_region_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to begin a catch clause. The parameter is the object which    will be passed to the runtime type check routine. */
end_comment

begin_function
name|void
name|start_catch_handler
parameter_list|(
name|rtime
parameter_list|)
name|tree
name|rtime
decl_stmt|;
block|{
name|rtx
name|handler_label
decl_stmt|;
name|int
name|insn_region_num
decl_stmt|;
name|int
name|eh_region_entry
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|handler_label
operator|=
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|exception_handler_label
expr_stmt|;
name|insn_region_num
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|handler_label
argument_list|)
expr_stmt|;
name|eh_region_entry
operator|=
name|find_func_region
argument_list|(
name|insn_region_num
argument_list|)
expr_stmt|;
comment|/* If we've already issued this label, pick a new one */
if|if
condition|(
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|label_used
condition|)
name|handler_label
operator|=
name|gen_exception_label
argument_list|()
expr_stmt|;
else|else
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|label_used
operator|=
literal|1
expr_stmt|;
name|receive_exception_label
argument_list|(
name|handler_label
argument_list|)
expr_stmt|;
name|add_new_handler
argument_list|(
name|eh_region_entry
argument_list|,
name|get_new_handler
argument_list|(
name|handler_label
argument_list|,
name|rtime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_new_exceptions
operator|&&
operator|!
name|exceptions_via_longjmp
condition|)
return|return;
comment|/* Under the old mechanism, as well as setjmp/longjmp, we need to      issue code to compare 'rtime' to the value in eh_info, via the      matching function in eh_info. If its is false, we branch around      the handler we are about to issue. */
if|if
condition|(
name|rtime
operator|!=
name|NULL_TREE
operator|&&
name|rtime
operator|!=
name|CATCH_ALL_TYPE
condition|)
block|{
name|rtx
name|call_rtx
decl_stmt|,
name|rtime_address
decl_stmt|;
if|if
condition|(
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|false_label
operator|!=
name|NULL_RTX
condition|)
name|fatal
argument_list|(
literal|"Compiler Bug: Never issued previous false_label"
argument_list|)
expr_stmt|;
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|false_label
operator|=
name|gen_exception_label
argument_list|()
expr_stmt|;
name|rtime_address
operator|=
name|expand_expr
argument_list|(
name|rtime
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|rtime_address
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|rtime_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rtime_address
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|rtime_address
argument_list|)
expr_stmt|;
comment|/* Now issue the call, and branch around handler if needed */
name|call_rtx
operator|=
name|emit_library_call_value
argument_list|(
name|eh_rtime_match_libfunc
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|rtime_address
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Did the function return true? */
name|emit_cmp_and_jump_insns
argument_list|(
name|call_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|call_rtx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|false_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called to end a catch clause. If we aren't using the new exception    model tabel mechanism, we need to issue the branch-around label    for the end of the catch block. */
end_comment

begin_function
name|void
name|end_catch_handler
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
name|flag_new_exceptions
operator|&&
operator|!
name|exceptions_via_longjmp
condition|)
block|{
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* A NULL label implies the catch clause was a catch all or cleanup */
if|if
condition|(
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|false_label
operator|==
name|NULL_RTX
condition|)
return|return;
name|emit_label
argument_list|(
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|false_label
argument_list|)
expr_stmt|;
name|catchstack
operator|.
name|top
operator|->
name|entry
operator|->
name|false_label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the start of a group of catch clauses.      It is responsible for starting a new instruction sequence for the    instructions in the catch block, and expanding the handlers for the    internally-generated exception regions nested within the try block    corresponding to this catch block.  */
end_comment

begin_function
name|void
name|expand_start_all_catch
parameter_list|()
block|{
name|struct
name|eh_entry
modifier|*
name|entry
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|rtx
name|outer_context
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|outer_context
operator|=
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|outer_context
expr_stmt|;
comment|/* End the try block.  */
name|expand_eh_region_end
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The label for the exception handling block that we will save.      This is Lresume in the documentation.  */
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* Push the label that points to where normal flow is resumed onto      the top of the label stack.  */
name|push_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Start a new sequence for all the catch blocks.  We will add this      to the global sequence catch_clauses when we have completed all      the handlers in this handler-seq.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|entry
operator|->
name|finalization
operator|!=
name|integer_zero_node
condition|;
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Emit the label for the cleanup handler for this region, and 	 expand the code for the handler.   	 Note that a catch region is handled as a side-effect here; 	 for a try block, entry->finalization will contain 	 integer_zero_node, so no code will be generated in the 	 expand_expr call below. But, the label for the handler will 	 still be emitted, so any code emitted after this point will 	 end up being the handler.  */
name|receive_exception_label
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
comment|/* register a handler for this cleanup region */
name|add_new_handler
argument_list|(
name|find_func_region
argument_list|(
name|CODE_LABEL_NUMBER
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
argument_list|)
argument_list|,
name|get_new_handler
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And now generate the insns for the cleanup handler.  */
name|expand_expr
argument_list|(
name|entry
operator|->
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|BARRIER
condition|)
comment|/* Code to throw out to outer context when we fall off end 	   of the handler. We can't do this here for catch blocks, 	   so it's done in expand_end_all_catch instead.  */
name|expand_rethrow
argument_list|(
name|entry
operator|->
name|outer_context
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, all the cleanups are done, and the ehqueue now has      the current exception region at its head. We dequeue it, and put it      on the catch stack. */
name|push_entry
argument_list|(
operator|&
name|catchstack
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* If we are not doing setjmp/longjmp EH, because we are reordered      out of line, we arrange to rethrow in the outer context.  We need to      do this because we are not physically within the region, if any, that      logically contains this catch block.  */
if|if
condition|(
operator|!
name|exceptions_via_longjmp
condition|)
block|{
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|outer_context
operator|=
name|outer_context
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the catch block.  At this point all the insns for the    catch clauses have already been generated, so we only have to add    them to the catch_clauses list. We also want to make sure that if    we fall off the end of the catch clauses that we rethrow to the    outer EH region.  */
end_comment

begin_function
name|void
name|expand_end_all_catch
parameter_list|()
block|{
name|rtx
name|new_catch_clause
decl_stmt|;
name|struct
name|eh_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* Dequeue the current catch clause region. */
name|entry
operator|=
name|pop_eh_entry
argument_list|(
operator|&
name|catchstack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exceptions_via_longjmp
condition|)
block|{
name|rtx
name|outer_context
init|=
name|ehstack
operator|.
name|top
operator|->
name|entry
operator|->
name|outer_context
decl_stmt|;
comment|/* Finish the rethrow region.  size_zero_node is just a NOP.  */
name|expand_eh_region_end
argument_list|(
name|size_zero_node
argument_list|)
expr_stmt|;
comment|/* New exceptions handling models will never have a fall through          of a catch clause */
if|if
condition|(
operator|!
name|flag_new_exceptions
condition|)
name|expand_rethrow
argument_list|(
name|outer_context
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_rethrow
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Code to throw out to outer context, if we fall off end of catch      handlers.  This is rethrow (Lresume, same id, same obj) in the      documentation. We use Lresume because we know that it will throw      to the correct context.       In other words, if the catch handler doesn't exit or return, we      do a "throw" (using the address of Lresume as the point being      thrown from) so that the outer EH region can then try to process      the exception.  */
comment|/* Now we have the complete catch sequence.  */
name|new_catch_clause
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* This level of catch blocks is done, so set up the successful      catch jump label for the next layer of catch blocks.  */
name|pop_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
expr_stmt|;
name|pop_label_entry
argument_list|(
operator|&
name|outer_context_label_stack
argument_list|)
expr_stmt|;
comment|/* Add the new sequence of catches to the main one for this function.  */
name|push_to_sequence
argument_list|(
name|catch_clauses
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|new_catch_clause
argument_list|)
expr_stmt|;
name|catch_clauses
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Here we fall through into the continuation code.  */
block|}
end_function

begin_comment
comment|/* Rethrow from the outer context LABEL.  */
end_comment

begin_function
specifier|static
name|void
name|expand_rethrow
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
if|if
condition|(
name|exceptions_via_longjmp
condition|)
name|emit_throw
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_new_exceptions
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL_RTX
condition|)
name|label
operator|=
name|last_rethrow_symbol
expr_stmt|;
name|emit_library_call
argument_list|(
name|rethrow_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|SYMBOL_REF_USED
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Search backwards for the actual call insn.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_insns_since
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Mark the label/symbol on the call. */
name|val
operator|=
name|GEN_INT
argument_list|(
name|eh_region_from_symbol
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_RETHROW
argument_list|,
name|val
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End all the pending exception regions on protect_list. The handlers    will be emitted when expand_leftover_cleanups is invoked.  */
end_comment

begin_function
name|void
name|end_protect_partials
parameter_list|()
block|{
while|while
condition|(
name|protect_list
condition|)
block|{
name|expand_eh_region_end
argument_list|(
name|TREE_VALUE
argument_list|(
name|protect_list
argument_list|)
argument_list|)
expr_stmt|;
name|protect_list
operator|=
name|TREE_CHAIN
argument_list|(
name|protect_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Arrange for __terminate to be called if there is an unhandled throw    from within E.  */
end_comment

begin_function
name|tree
name|protect_with_terminate
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
comment|/* We only need to do this when using setjmp/longjmp EH and the      language requires it, as otherwise we protect all of the handlers      at once, if we need to.  */
if|if
condition|(
name|exceptions_via_longjmp
operator|&&
name|protect_cleanup_actions_with_terminate
condition|)
block|{
name|tree
name|handler
decl_stmt|,
name|result
decl_stmt|;
comment|/* All cleanups must be on the function_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|handler
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|handler
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|handler
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|handler
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|terminate_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|handler
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|build
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|e
operator|=
name|result
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The exception table that we build that is used for looking up and    dispatching exceptions, the current number of entries, and its    maximum size before we have to extend it.      The number in eh_table is the code label number of the exception    handler for the region. This is added by add_eh_table_entry and    used by output_exception_table_entry.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|eh_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eh_table_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eh_table_max_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note the need for an exception table entry for region N.  If we    don't need to output an explicit exception table, avoid all of the    extra work.     Called from final_scan_insn when a NOTE_INSN_EH_REGION_BEG is seen.    (Or NOTE_INSN_EH_REGION_END sometimes)    N is the NOTE_BLOCK_NUMBER of the note, which comes from the code    label number of the exception handler for the region.  */
end_comment

begin_function
name|void
name|add_eh_table_entry
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|OMIT_EH_TABLE
if|if
condition|(
name|eh_table_size
operator|>=
name|eh_table_max_size
condition|)
block|{
if|if
condition|(
name|eh_table
condition|)
block|{
name|eh_table_max_size
operator|+=
name|eh_table_max_size
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|eh_table_max_size
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|eh_table
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|eh_table
argument_list|,
name|eh_table_max_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eh_table_max_size
operator|=
literal|252
expr_stmt|;
name|eh_table
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|eh_table_max_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|eh_table
index|[
name|eh_table_size
operator|++
index|]
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a non-zero value if we need to output an exception table.     On some platforms, we don't have to output a table explicitly.    This routine doesn't mean we don't have one.  */
end_comment

begin_function
name|int
name|exception_table_p
parameter_list|()
block|{
if|if
condition|(
name|eh_table
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output the entry of the exception table corresponding to the    exception region numbered N to file FILE.      N is the code label number corresponding to the handler of the    region.  */
end_comment

begin_function
specifier|static
name|void
name|output_exception_table_entry
parameter_list|(
name|file
parameter_list|,
name|n
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|sym
decl_stmt|;
name|struct
name|handler_info
modifier|*
name|handler
init|=
name|get_first_handler
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|find_func_region
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|rtx
name|rethrow
decl_stmt|;
comment|/* form and emit the rethrow label, if needed  */
name|rethrow
operator|=
name|function_eh_regions
index|[
name|index
index|]
operator|.
name|rethrow_label
expr_stmt|;
if|if
condition|(
name|rethrow
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|flag_new_exceptions
condition|)
name|rethrow
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|rethrow
operator|!=
name|NULL_RTX
operator|&&
name|handler
operator|==
name|NULL
condition|)
if|if
condition|(
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|rethrow
argument_list|)
condition|)
name|rethrow
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
init|;
name|handler
operator|!=
name|NULL
operator|||
name|rethrow
operator|!=
name|NULL_RTX
condition|;
name|handler
operator|=
name|handler
operator|->
name|next
control|)
block|{
comment|/* rethrow label should indicate the LAST entry for a region */
if|if
condition|(
name|rethrow
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|handler
operator|==
name|NULL
operator|||
name|handler
operator|->
name|next
operator|==
name|NULL
operator|)
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LRTH"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rethrow
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LEHB"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|sym
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LEHE"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|sym
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|==
name|NULL
condition|)
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|handler
operator|->
name|handler_number
argument_list|)
expr_stmt|;
name|sym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|sym
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_new_exceptions
condition|)
block|{
if|if
condition|(
name|handler
operator|==
name|NULL
operator|||
name|handler
operator|->
name|type_info
operator|==
name|NULL
condition|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|handler
operator|->
name|type_info
operator|==
name|CATCH_ALL_TYPE
condition|)
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|CATCH_ALL_TYPE
argument_list|)
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
call|(
name|tree
call|)
argument_list|(
name|handler
operator|->
name|type_info
argument_list|)
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* blank line */
comment|/* We only output the first label under the old scheme */
if|if
condition|(
operator|!
name|flag_new_exceptions
operator|||
name|handler
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output the exception table if we have and need one.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|language_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|version_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine will set the language code for exceptions. */
end_comment

begin_function
name|void
name|set_exception_lang_code
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
name|language_code
operator|=
name|code
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine will set the language version code for exceptions. */
end_comment

begin_function
name|void
name|set_exception_version_code
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
name|version_code
operator|=
name|code
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_exception_table
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
operator|||
operator|!
name|eh_table
condition|)
return|return;
name|exception_section
argument_list|()
expr_stmt|;
comment|/* Beginning marker for table.  */
name|assemble_align
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|ptr_mode
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
literal|"__EXCEPTION_TABLE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_new_exceptions
condition|)
block|{
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|NEW_EH_RUNTIME
argument_list|)
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|language_code
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|version_code
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Add enough padding to make sure table aligns on a pointer boundry. */
name|i
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|ptr_mode
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|-
literal|4
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|0
condition|;
name|i
operator|=
name|i
operator|+
name|GET_MODE_ALIGNMENT
argument_list|(
name|ptr_mode
argument_list|)
operator|/
name|BITS_PER_UNIT
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate the label for offset calculations on rethrows */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LRTH"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eh_table_size
condition|;
operator|++
name|i
control|)
name|output_exception_table_entry
argument_list|(
name|asm_out_file
argument_list|,
name|eh_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|eh_table
argument_list|)
expr_stmt|;
name|clear_function_eh_region
argument_list|()
expr_stmt|;
comment|/* Ending marker for table.  */
comment|/* Generate the label for end of table. */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LRTH"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|final_rethrow
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|constm1_rtx
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* for binary compatability, the old __throw checked the second      position for a -1, so we should output at least 2 -1's */
if|if
condition|(
operator|!
name|flag_new_exceptions
condition|)
name|assemble_integer
argument_list|(
name|constm1_rtx
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* blank line */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to get EH context.        We have to scan thru the code to find possible EH context registers.    Inlined functions may use it too, and thus we'll have to be able    to change them too.     This is done only if using exceptions_via_longjmp. */
end_comment

begin_function
name|void
name|emit_eh_context
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ehc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|rtx
name|reg
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_CONTEXT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If this is the first use insn, emit the call here.  This 	       will always be at the top of our function, because if 	       expand_inline_function notices a REG_EH_CONTEXT note, it 	       adds a use insn to this function as well.  */
if|if
condition|(
name|ehc
operator|==
literal|0
condition|)
name|ehc
operator|=
name|call_get_eh_context
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ehc
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* At -O0, we must make the context register stay alive so                that the stupid.c register allocator doesn't get confused. */
if|if
condition|(
name|obey_regdecls
operator|!=
literal|0
condition|)
block|{
name|insns
operator|=
name|gen_rtx_USE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|insns
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the current insns and build a list of handler labels. The    resulting list is placed in the global variable exception_handler_labels.     It is called after the last exception handling region is added to    the current function (when the rtl is almost all built for the    current function) and before the jump optimization pass.  */
end_comment

begin_function
name|void
name|find_exception_handler_labels
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|exception_handler_labels
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If we aren't doing exception handling, there isn't much to check.  */
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
comment|/* For each start of a region, add its label to the list.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|handler_info
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
block|{
name|ptr
operator|=
name|get_first_handler
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
comment|/* make sure label isn't in the list already */
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|exception_handler_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|ptr
operator|->
name|handler_label
condition|)
break|break;
if|if
condition|(
operator|!
name|x
condition|)
name|exception_handler_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|ptr
operator|->
name|handler_label
argument_list|,
name|exception_handler_labels
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a value of 1 if the parameter label number is an exception handler    label. Return 0 otherwise. */
end_comment

begin_function
name|int
name|is_exception_handler_label
parameter_list|(
name|lab
parameter_list|)
name|int
name|lab
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|exception_handler_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|lab
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform sanity checking on the exception_handler_labels list.     Can be called after find_exception_handler_labels is called to    build the list of exception handlers for the current function and    before we finish processing the current function.  */
end_comment

begin_function
name|void
name|check_exception_handler_labels
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|insn2
decl_stmt|;
comment|/* If we aren't doing exception handling, there isn't much to check.  */
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
comment|/* Make sure there is no more than 1 copy of a label */
for|for
control|(
name|insn
operator|=
name|exception_handler_labels
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn2
operator|=
name|exception_handler_labels
init|;
name|insn2
condition|;
name|insn2
operator|=
name|XEXP
argument_list|(
name|insn2
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|insn2
argument_list|,
literal|0
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|warning
argument_list|(
literal|"Counted %d copies of EH region %d in list.\n"
argument_list|,
name|count
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This group of functions initializes the exception handling data    structures at the start of the compilation, initializes the data    structures at the start of a function, and saves and restores the    exception handling data structures for the start/end of a nested    function.  */
end_comment

begin_comment
comment|/* Toplevel initialization for EH things.  */
end_comment

begin_function
name|void
name|init_eh
parameter_list|()
block|{
name|first_rethrow_symbol
operator|=
name|create_rethrow_ref
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|final_rethrow
operator|=
name|gen_exception_label
argument_list|()
expr_stmt|;
name|last_rethrow_symbol
operator|=
name|create_rethrow_ref
argument_list|(
name|CODE_LABEL_NUMBER
argument_list|(
name|final_rethrow
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the per-function EH information.  */
end_comment

begin_function
name|void
name|init_eh_for_function
parameter_list|()
block|{
name|ehstack
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|catchstack
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|ehqueue
operator|.
name|head
operator|=
name|ehqueue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|catch_clauses
operator|=
name|NULL_RTX
expr_stmt|;
name|false_label_stack
operator|=
literal|0
expr_stmt|;
name|caught_return_label_stack
operator|=
literal|0
expr_stmt|;
name|protect_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_function_ehc
operator|=
name|NULL_RTX
expr_stmt|;
name|eh_return_context
operator|=
name|NULL_RTX
expr_stmt|;
name|eh_return_stack_adjust
operator|=
name|NULL_RTX
expr_stmt|;
name|eh_return_handler
operator|=
name|NULL_RTX
expr_stmt|;
name|eh_return_stub_label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save some of the per-function EH info into the save area denoted by    P.      This is currently called from save_stmt_status.  */
end_comment

begin_function
name|void
name|save_eh_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|->
name|ehstack
operator|=
name|ehstack
expr_stmt|;
name|p
operator|->
name|catchstack
operator|=
name|catchstack
expr_stmt|;
name|p
operator|->
name|ehqueue
operator|=
name|ehqueue
expr_stmt|;
name|p
operator|->
name|catch_clauses
operator|=
name|catch_clauses
expr_stmt|;
name|p
operator|->
name|false_label_stack
operator|=
name|false_label_stack
expr_stmt|;
name|p
operator|->
name|caught_return_label_stack
operator|=
name|caught_return_label_stack
expr_stmt|;
name|p
operator|->
name|protect_list
operator|=
name|protect_list
expr_stmt|;
name|p
operator|->
name|ehc
operator|=
name|current_function_ehc
expr_stmt|;
name|p
operator|->
name|eh_return_stub_label
operator|=
name|eh_return_stub_label
expr_stmt|;
name|init_eh_for_function
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the per-function EH info saved into the area denoted by P.       This is currently called from restore_stmt_status.  */
end_comment

begin_function
name|void
name|restore_eh_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|protect_list
operator|=
name|p
operator|->
name|protect_list
expr_stmt|;
name|caught_return_label_stack
operator|=
name|p
operator|->
name|caught_return_label_stack
expr_stmt|;
name|false_label_stack
operator|=
name|p
operator|->
name|false_label_stack
expr_stmt|;
name|catch_clauses
operator|=
name|p
operator|->
name|catch_clauses
expr_stmt|;
name|ehqueue
operator|=
name|p
operator|->
name|ehqueue
expr_stmt|;
name|ehstack
operator|=
name|p
operator|->
name|ehstack
expr_stmt|;
name|catchstack
operator|=
name|p
operator|->
name|catchstack
expr_stmt|;
name|current_function_ehc
operator|=
name|p
operator|->
name|ehc
expr_stmt|;
name|eh_return_stub_label
operator|=
name|p
operator|->
name|eh_return_stub_label
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section is for the exception handling specific optimization    pass.  First are the internal routines, and then the main    optimization pass.  */
end_comment

begin_comment
comment|/* Determine if the given INSN can throw an exception.  */
end_comment

begin_function
specifier|static
name|int
name|can_throw
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Calls can always potentially throw exceptions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|asynchronous_exceptions
condition|)
block|{
comment|/* If we wanted asynchronous exceptions, then everything but NOTEs 	 and CODE_LABELs could throw.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan a exception region looking for the matching end and then    remove it if possible. INSN is the start of the region, N is the    region number, and DELETE_OUTER is to note if anything in this    region can throw.     Regions are removed if they cannot possibly catch an exception.    This is determined by invoking can_throw on each insn within the    region; if can_throw returns true for any of the instructions, the    region can catch an exception, since there is an insn within the    region that is capable of throwing an exception.     Returns the NOTE_INSN_EH_REGION_END corresponding to this region, or    calls abort if it can't find one.     Can abort if INSN is not a NOTE_INSN_EH_REGION_BEGIN, or if N doesn't    correspond to the region number, or if DELETE_OUTER is NULL.  */
end_comment

begin_function
specifier|static
name|rtx
name|scan_region
parameter_list|(
name|insn
parameter_list|,
name|n
parameter_list|,
name|delete_outer
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
modifier|*
name|delete_outer
decl_stmt|;
block|{
name|rtx
name|start
init|=
name|insn
decl_stmt|;
comment|/* Assume we can delete the region.  */
name|int
name|delete
init|=
literal|1
decl_stmt|;
name|int
name|r
init|=
name|find_func_region
argument_list|(
name|n
argument_list|)
decl_stmt|;
comment|/* Can't delete something which is rethrown to. */
if|if
condition|(
name|SYMBOL_REF_USED
argument_list|(
operator|(
name|function_eh_regions
index|[
name|r
index|]
operator|.
name|rethrow_label
operator|)
argument_list|)
condition|)
name|delete
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|n
operator|||
name|delete_outer
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Look for the matching end.  */
while|while
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|)
condition|)
block|{
comment|/* If anything can throw, we can't remove the region.  */
if|if
condition|(
name|delete
operator|&&
name|can_throw
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|delete
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Watch out for and handle nested regions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
block|{
name|insn
operator|=
name|scan_region
argument_list|(
name|insn
argument_list|,
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|delete
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* The _BEG/_END NOTEs must match and nest.  */
if|if
condition|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|n
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If anything in this exception region can throw, we can throw.  */
if|if
condition|(
operator|!
name|delete
condition|)
operator|*
name|delete_outer
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Delete the start and end of the region.  */
name|delete_insn
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We no longer removed labels here, since flow will now remove any    handler which cannot be called any more. */
if|#
directive|if
literal|0
comment|/* Only do this part if we have built the exception handler          labels.  */
block|if (exception_handler_labels) 	{ 	  rtx x, *prev =&exception_handler_labels;
comment|/* Find it in the list of handlers.  */
block|for (x = exception_handler_labels; x; x = XEXP (x, 1)) 	    { 	      rtx label = XEXP (x, 0); 	      if (CODE_LABEL_NUMBER (label) == n) 		{
comment|/* If we are the last reference to the handler,                      delete it.  */
block|if (--LABEL_NUSES (label) == 0) 		    delete_insn (label);  		  if (optimize) 		    {
comment|/* Remove it from the list of exception handler 			 labels, if we are optimizing.  If we are not, then 			 leave it in the list, as we are not really going to 			 remove the region.  */
block|*prev = XEXP (x, 1); 		      XEXP (x, 1) = 0; 		      XEXP (x, 0) = 0; 		    }  		  break; 		} 	      prev =&XEXP (x, 1); 	    } 	}
endif|#
directive|endif
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Perform various interesting optimizations for exception handling    code.     We look for empty exception regions and make them go (away). The    jump optimization code will remove the handler if nothing else uses    it.  */
end_comment

begin_function
name|void
name|exception_optimize
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Remove empty regions.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
block|{
comment|/* Since scan_region will return the NOTE_INSN_EH_REGION_END 	     insn, we will indirectly skip through all the insns 	     inbetween. We are also guaranteed that the value of insn 	     returned will be valid, as otherwise scan_region won't 	     return.  */
name|insn
operator|=
name|scan_region
argument_list|(
name|insn
argument_list|,
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Various hooks for the DWARF 2 __throw routine.  */
end_comment

begin_comment
comment|/* Do any necessary initialization to access arbitrary stack frames.    On the SPARC, this means flushing the register windows.  */
end_comment

begin_function
name|void
name|expand_builtin_unwind_init
parameter_list|()
block|{
comment|/* Set this so all the registers get saved in our frame; we need to be      able to copy the saved values for any registers from frames we unwind. */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Given a value extracted from the return address register or stack slot,    return the actual address encoded in that value.  */
end_comment

begin_function
name|rtx
name|expand_builtin_extract_return_addr
parameter_list|(
name|addr_tree
parameter_list|)
name|tree
name|addr_tree
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|eh_outer_context
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an actual address in addr_tree, do any necessary encoding    and return the value to be stored in the return address register or    stack slot so the epilogue will return to that address.  */
end_comment

begin_function
name|rtx
name|expand_builtin_frob_return_addr
parameter_list|(
name|addr_tree
parameter_list|)
name|tree
name|addr_tree
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ADDR_OFFSET
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|-
name|RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Choose three registers for communication between the main body of    __throw and the epilogue (or eh stub) and the exception handler.     We must do this with hard registers because the epilogue itself    will be generated after reload, at which point we may not reference    pseudos at all.     The first passes the exception context to the handler.  For this    we use the return value register for a void*.     The second holds the stack pointer value to be restored.  For    this we use the static chain register if it exists and is different    from the previous, otherwise some arbitrary call-clobbered register.     The third holds the address of the handler itself.  Here we use    some arbitrary call-clobbered register.  */
end_comment

begin_function
specifier|static
name|void
name|eh_regs
parameter_list|(
name|pcontext
parameter_list|,
name|psp
parameter_list|,
name|pra
parameter_list|,
name|outgoing
parameter_list|)
name|rtx
modifier|*
name|pcontext
decl_stmt|,
decl|*
name|psp
decl_stmt|,
modifier|*
name|pra
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|outgoing
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|rcontext
decl_stmt|,
name|rsp
decl_stmt|,
name|rra
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
if|if
condition|(
name|outgoing
condition|)
name|rcontext
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|rcontext
operator|=
name|FUNCTION_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
if|if
condition|(
name|outgoing
condition|)
name|rsp
operator|=
name|static_chain_incoming_rtx
expr_stmt|;
else|else
name|rsp
operator|=
name|static_chain_rtx
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|rsp
argument_list|)
operator|==
name|REGNO
argument_list|(
name|rcontext
argument_list|)
condition|)
endif|#
directive|endif
comment|/* STATIC_CHAIN_REGNUM */
name|rsp
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL_RTX
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|REGNO
argument_list|(
name|rcontext
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rsp
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|REGNO
argument_list|(
name|rcontext
argument_list|)
operator|&&
name|i
operator|!=
name|REGNO
argument_list|(
name|rsp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rra
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|pcontext
operator|=
name|rcontext
expr_stmt|;
operator|*
name|psp
operator|=
name|rsp
expr_stmt|;
operator|*
name|pra
operator|=
name|rra
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Retrieve the register which contains the pointer to the eh_context    structure set the __throw. */
end_comment

begin_function
name|rtx
name|get_reg_for_handler
parameter_list|()
block|{
name|rtx
name|reg1
decl_stmt|;
name|reg1
operator|=
name|FUNCTION_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
return|return
name|reg1
return|;
block|}
end_function

begin_comment
comment|/* Set up the epilogue with the magic bits we'll need to return to the    exception handler.  */
end_comment

begin_function
name|void
name|expand_builtin_eh_return
parameter_list|(
name|context
parameter_list|,
name|stack
parameter_list|,
name|handler
parameter_list|)
name|tree
name|context
decl_stmt|,
name|stack
decl_stmt|,
name|handler
decl_stmt|;
block|{
if|if
condition|(
name|eh_return_context
condition|)
name|error
argument_list|(
literal|"Duplicate call to __builtin_eh_return"
argument_list|)
expr_stmt|;
name|eh_return_context
operator|=
name|copy_to_reg
argument_list|(
name|expand_expr
argument_list|(
name|context
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|eh_return_stack_adjust
operator|=
name|copy_to_reg
argument_list|(
name|expand_expr
argument_list|(
name|stack
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|eh_return_handler
operator|=
name|copy_to_reg
argument_list|(
name|expand_expr
argument_list|(
name|handler
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_eh_return
parameter_list|()
block|{
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|reg3
decl_stmt|;
name|rtx
name|stub_start
decl_stmt|,
name|after_stub
decl_stmt|;
name|rtx
name|ra
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|eh_return_context
condition|)
return|return;
name|current_function_cannot_inline
operator|=
name|N_
argument_list|(
literal|"function uses __builtin_eh_return"
argument_list|)
expr_stmt|;
name|eh_regs
argument_list|(
operator|&
name|reg1
argument_list|,
operator|&
name|reg2
argument_list|,
operator|&
name|reg3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|eh_return_context
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|eh_return_context
argument_list|)
expr_stmt|;
name|eh_return_stack_adjust
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|eh_return_stack_adjust
argument_list|)
expr_stmt|;
name|eh_return_handler
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|eh_return_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|reg1
argument_list|,
name|eh_return_context
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg2
argument_list|,
name|eh_return_stack_adjust
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg3
argument_list|,
name|eh_return_handler
argument_list|)
expr_stmt|;
comment|/* Talk directly to the target's epilogue code when possible.  */
ifdef|#
directive|ifdef
name|HAVE_eh_epilogue
if|if
condition|(
name|HAVE_eh_epilogue
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_eh_epilogue
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Otherwise, use the same stub technique we had before.  */
name|eh_return_stub_label
operator|=
name|stub_start
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|after_stub
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Set the return address to the stub label.  */
name|ra
operator|=
name|expand_builtin_return_addr
argument_list|(
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
literal|0
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ra
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|ra
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|stub_start
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ADDR_OFFSET
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
operator|-
name|RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|force_operand
argument_list|(
name|tmp
argument_list|,
name|ra
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|ra
condition|)
name|emit_move_insn
argument_list|(
name|ra
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Indicate that the registers are in fact used.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ra
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|ra
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the stub.  */
name|emit_jump
argument_list|(
name|after_stub
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|stub_start
argument_list|)
expr_stmt|;
name|eh_regs
argument_list|(
operator|&
name|reg1
argument_list|,
operator|&
name|reg2
argument_list|,
operator|&
name|reg3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adjust_stack
argument_list|(
name|reg2
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|reg3
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|after_stub
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This contains the code required to verify whether arbitrary instructions    are in the same exception region. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_eh_region
init|=
operator|(
name|int
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maximum_uid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_insn_eh_region
parameter_list|(
name|first
parameter_list|,
name|region_num
parameter_list|)
name|rtx
modifier|*
name|first
decl_stmt|;
name|int
name|region_num
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|rnum
decl_stmt|;
for|for
control|(
name|insn
operator|=
operator|*
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|)
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|)
condition|)
block|{
name|rnum
operator|=
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_eh_region
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|rnum
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|set_insn_eh_region
argument_list|(
operator|&
name|insn
argument_list|,
name|rnum
argument_list|)
expr_stmt|;
comment|/* Upon return, insn points to the EH_REGION_END of nested region */
continue|continue;
block|}
name|insn_eh_region
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|region_num
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|)
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|)
condition|)
break|break;
block|}
operator|*
name|first
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the insn table, an make sure it cannot be used again. */
end_comment

begin_function
name|void
name|free_insn_eh_region
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|insn_eh_region
condition|)
block|{
name|free
argument_list|(
name|insn_eh_region
argument_list|)
expr_stmt|;
name|insn_eh_region
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the table. max_uid must be calculated and handed into     this routine. If it is unavailable, passing a value of 0 will     cause this routine to calculate it as well. */
end_comment

begin_function
name|void
name|init_insn_eh_region
parameter_list|(
name|first
parameter_list|,
name|max_uid
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|insn_eh_region
condition|)
name|free_insn_eh_region
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_uid
operator|==
literal|0
condition|)
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
comment|/* find largest UID */
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|maximum_uid
operator|=
name|max_uid
expr_stmt|;
name|insn_eh_region
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|first
expr_stmt|;
name|set_insn_eh_region
argument_list|(
operator|&
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether 2 instructions are within the same region. */
end_comment

begin_function
name|int
name|in_same_eh_region
parameter_list|(
name|insn1
parameter_list|,
name|insn2
parameter_list|)
name|rtx
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|uid1
decl_stmt|,
name|uid2
decl_stmt|;
comment|/* If no exceptions, instructions are always in same region. */
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the table isn't allocated, assume the worst. */
if|if
condition|(
operator|!
name|insn_eh_region
condition|)
return|return
literal|0
return|;
name|uid1
operator|=
name|INSN_UID
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|uid2
operator|=
name|INSN_UID
argument_list|(
name|insn2
argument_list|)
expr_stmt|;
comment|/* if instructions have been allocated beyond the end, either      the table is out of date, or this is a late addition, or      something... Assume the worst. */
if|if
condition|(
name|uid1
operator|>
name|maximum_uid
operator|||
name|uid2
operator|>
name|maximum_uid
condition|)
return|return
literal|0
return|;
name|ret
operator|=
operator|(
name|insn_eh_region
index|[
name|uid1
index|]
operator|==
name|insn_eh_region
index|[
name|uid2
index|]
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

