begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implements exception handling.    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Mike Stump<mrs@cygnus.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* An exception is an event that can be signaled from within a    function. This event can then be "caught" or "trapped" by the    callers of this function. This potentially allows program flow to    be transferred to any arbitrary code associated with a function call    several levels up the stack.     The intended use for this mechanism is for signaling "exceptional    events" in an out-of-band fashion, hence its name. The C++ language    (and many other OO-styled or functional languages) practically    requires such a mechanism, as otherwise it becomes very difficult    or even impossible to signal failure conditions in complex    situations.  The traditional C++ example is when an error occurs in    the process of constructing an object; without such a mechanism, it    is impossible to signal that the error occurs without adding global    state variables and error checks around every object construction.     The act of causing this event to occur is referred to as "throwing    an exception". (Alternate terms include "raising an exception" or    "signaling an exception".) The term "throw" is used because control    is returned to the callers of the function that is signaling the    exception, and thus there is the concept of "throwing" the    exception up the call stack.     [ Add updated documentation on how to use this.  ]  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* Provide defaults for stuff that may not be defined when using    sjlj exceptions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EH_RETURN_DATA_REGNO
end_ifndef

begin_define
define|#
directive|define
name|EH_RETURN_DATA_REGNO
parameter_list|(
name|N
parameter_list|)
value|INVALID_REGNUM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Protect cleanup actions with must-not-throw regions, with a call    to the given failure handler.  */
end_comment

begin_function_decl
name|tree
function_decl|(
modifier|*
name|lang_protect_cleanup_actions
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return true if type A catches type B.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|lang_eh_type_covers
function_decl|)
parameter_list|(
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Map a type to a runtime object to match type.  */
end_comment

begin_function_decl
name|tree
function_decl|(
modifier|*
name|lang_eh_runtime_type
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A hash table of label to region number.  */
end_comment

begin_decl_stmt
name|struct
name|ehl_map_entry
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|call_site_base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (union tree_node))
argument_list|)
name|htab_t
name|type_to_runtime_map
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Describe the SjLj_Function_Context structure.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|sjlj_fc_type_node
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_call_site_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_data_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_personality_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_lsda_ofs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sjlj_fc_jbuf_ofs
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Describes one exception region.  */
end_comment

begin_decl_stmt
name|struct
name|eh_region
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The immediately surrounding region.  */
name|struct
name|eh_region
modifier|*
name|outer
decl_stmt|;
comment|/* The list of immediately contained regions.  */
name|struct
name|eh_region
modifier|*
name|inner
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|next_peer
decl_stmt|;
comment|/* An identifier for this region.  */
name|int
name|region_number
decl_stmt|;
comment|/* When a region is deleted, its parents inherit the REG_EH_REGION      numbers already assigned.  */
name|bitmap
name|aka
decl_stmt|;
comment|/* Each region does exactly one thing.  */
enum|enum
name|eh_region_type
block|{
name|ERT_UNKNOWN
init|=
literal|0
block|,
name|ERT_CLEANUP
block|,
name|ERT_TRY
block|,
name|ERT_CATCH
block|,
name|ERT_ALLOWED_EXCEPTIONS
block|,
name|ERT_MUST_NOT_THROW
block|,
name|ERT_THROW
block|}
name|type
enum|;
comment|/* Holds the action to perform based on the preceding type.  */
union|union
name|eh_region_u
block|{
comment|/* A list of catch blocks, a surrounding try block,        and the label for continuing after a catch.  */
struct|struct
name|eh_region_u_try
block|{
name|struct
name|eh_region
modifier|*
name|catch
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|last_catch
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_TRY"
argument_list|)
operator|)
argument_list|)
name|try
struct|;
comment|/* The list through the catch handlers, the list of type objects        matched, and the list of associated filters.  */
struct|struct
name|eh_region_u_catch
block|{
name|struct
name|eh_region
modifier|*
name|next_catch
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|prev_catch
decl_stmt|;
name|tree
name|type_list
decl_stmt|;
name|tree
name|filter_list
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_CATCH"
argument_list|)
operator|)
argument_list|)
name|catch
struct|;
comment|/* A tree_list of allowed types.  */
struct|struct
name|eh_region_u_allowed
block|{
name|tree
name|type_list
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_ALLOWED_EXCEPTIONS"
argument_list|)
operator|)
argument_list|)
name|allowed
struct|;
comment|/* The type given by a call to "throw foo();", or discovered        for a throw.  */
struct|struct
name|eh_region_u_throw
block|{
name|tree
name|type
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_THROW"
argument_list|)
operator|)
argument_list|)
name|throw
struct|;
comment|/* Retain the cleanup expression even after expansion so that        we can match up fixup regions.  */
struct|struct
name|eh_region_u_cleanup
block|{
name|struct
name|eh_region
modifier|*
name|prev_try
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"ERT_CLEANUP"
argument_list|)
operator|)
argument_list|)
name|cleanup
struct|;
block|}
name|GTY
argument_list|(
operator|(
name|desc
argument_list|(
literal|"%0.type"
argument_list|)
operator|)
argument_list|)
name|u
union|;
comment|/* Entry point for this region's handler before landing pads are built.  */
name|rtx
name|label
decl_stmt|;
name|tree
name|tree_label
decl_stmt|;
comment|/* Entry point for this region's handler from the runtime eh library.  */
name|rtx
name|landing_pad
decl_stmt|;
comment|/* Entry point for this region's handler from an inner region.  */
name|rtx
name|post_landing_pad
decl_stmt|;
comment|/* The RESX insn for handing off control to the next outermost handler,      if appropriate.  */
name|rtx
name|resume
decl_stmt|;
comment|/* True if something in this region may throw.  */
name|unsigned
name|may_contain_throw
range|:
literal|1
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|struct
name|eh_region
modifier|*
name|eh_region
typedef|;
end_typedef

begin_decl_stmt
name|struct
name|call_site_record
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|landing_pad
decl_stmt|;
name|int
name|action
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|eh_region
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|eh_region
argument_list|,
name|gc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Used to save exception status for each function.  */
end_comment

begin_decl_stmt
name|struct
name|eh_status
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The tree of all regions for this function.  */
name|struct
name|eh_region
modifier|*
name|region_tree
decl_stmt|;
comment|/* The same information as an indexable array.  */
name|VEC
argument_list|(
name|eh_region
argument_list|,
name|gc
argument_list|)
operator|*
name|region_array
expr_stmt|;
comment|/* The most recently open region.  */
name|struct
name|eh_region
modifier|*
name|cur_region
decl_stmt|;
comment|/* This is the region for which we are processing catch blocks.  */
name|struct
name|eh_region
modifier|*
name|try_region
decl_stmt|;
name|rtx
name|filter
decl_stmt|;
name|rtx
name|exc_ptr
decl_stmt|;
name|int
name|built_landing_pads
decl_stmt|;
name|int
name|last_region_number
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|ttype_data
expr_stmt|;
name|varray_type
name|ehspec_data
decl_stmt|;
name|varray_type
name|action_record_data
decl_stmt|;
name|htab_t
name|GTY
argument_list|(
operator|(
name|param_is
argument_list|(
expr|struct
name|ehl_map_entry
argument_list|)
operator|)
argument_list|)
name|exception_handler_label_map
decl_stmt|;
name|struct
name|call_site_record
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"%h.call_site_data_used"
argument_list|)
operator|)
argument_list|)
name|call_site_data
decl_stmt|;
name|int
name|call_site_data_used
decl_stmt|;
name|int
name|call_site_data_size
decl_stmt|;
name|rtx
name|ehr_stackadj
decl_stmt|;
name|rtx
name|ehr_handler
decl_stmt|;
name|rtx
name|ehr_label
decl_stmt|;
name|rtx
name|sjlj_fc
decl_stmt|;
name|rtx
name|sjlj_exit_after
decl_stmt|;
name|htab_t
name|GTY
argument_list|(
operator|(
name|param_is
argument_list|(
expr|struct
name|throw_stmt_node
argument_list|)
operator|)
argument_list|)
name|throw_stmt_table
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|t2r_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|t2r_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_type_for_runtime
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_type_for_runtime
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_unreachable_regions
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ttypes_filter_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|ttypes_filter_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ehspec_filter_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|ehspec_filter_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_ttypes_entry
parameter_list|(
name|htab_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_ehspec_entry
parameter_list|(
name|htab_t
parameter_list|,
name|htab_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|assign_filter_values
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_post_landing_pads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_post_landing_pads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dw2_build_landing_pads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|sjlj_lp_info
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|bool
name|sjlj_find_directly_reachable_regions
parameter_list|(
name|struct
name|sjlj_lp_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sjlj_assign_call_site_values
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|sjlj_lp_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sjlj_mark_call_sites
parameter_list|(
name|struct
name|sjlj_lp_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sjlj_emit_function_enter
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sjlj_emit_function_exit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sjlj_emit_dispatch_table
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|sjlj_lp_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sjlj_build_landing_pads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|ehl_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ehl_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_ehl_entry
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|eh_region
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_exception_handler_label
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_eh_handler
parameter_list|(
name|struct
name|eh_region
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|for_each_eh_label_1
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The return value of reachable_next_level.  */
end_comment

begin_enum
enum|enum
name|reachable_code
block|{
comment|/* The given exception is not processed by the given region.  */
name|RNL_NOT_CAUGHT
block|,
comment|/* The given exception may need processing by the given region.  */
name|RNL_MAYBE_CAUGHT
block|,
comment|/* The given exception is completely processed by the given region.  */
name|RNL_CAUGHT
block|,
comment|/* The given exception is completely processed by the runtime.  */
name|RNL_BLOCKED
block|}
enum|;
end_enum

begin_struct_decl
struct_decl|struct
name|reachable_info
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|enum
name|reachable_code
name|reachable_next_level
parameter_list|(
name|struct
name|eh_region
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|struct
name|reachable_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|action_record_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|action_record_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_action_record
parameter_list|(
name|htab_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collect_one_action_chain
parameter_list|(
name|htab_t
parameter_list|,
name|struct
name|eh_region
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_call_site
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_uleb128
parameter_list|(
name|varray_type
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_sleb128
parameter_list|(
name|varray_type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_AS_LEB128
end_ifndef

begin_function_decl
specifier|static
name|int
name|dw2_size_of_call_site_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sjlj_size_of_call_site_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|dw2_output_call_site_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sjlj_output_call_site_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Routine to see if exception handling is turned on.    DO_WARN is nonzero if we want to inform the user that exception    handling is turned off.     This is used to ensure that -fexceptions has been specified if the    compiler tries to use any exception-specific functions.  */
end_comment

begin_function
name|int
name|doing_eh
parameter_list|(
name|int
name|do_warn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|do_warn
condition|)
block|{
name|error
argument_list|(
literal|"exception handling disabled, use -fexceptions to enable"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_eh
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
return|return;
name|type_to_runtime_map
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|t2r_hash
argument_list|,
name|t2r_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create the SjLj_Function_Context structure.  This should match      the definition in unwind-sjlj.c.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
block|{
name|tree
name|f_jbuf
decl_stmt|,
name|f_per
decl_stmt|,
name|f_lsda
decl_stmt|,
name|f_prev
decl_stmt|,
name|f_cs
decl_stmt|,
name|f_data
decl_stmt|,
name|tmp
decl_stmt|;
name|sjlj_fc_type_node
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|f_prev
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__prev"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_prev
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|f_cs
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__call_site"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_cs
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|tmp
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|4
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_array_type
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|word_mode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|f_data
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__data"
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_data
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|f_per
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__personality"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_per
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|f_lsda
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__lsda"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_lsda
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
ifdef|#
directive|ifdef
name|JMP_BUF_SIZE
name|tmp
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|JMP_BUF_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Should be large enough for most systems, if it is not, 	 JMP_BUF_SIZE should be defined with the proper value.  It will 	 also tend to be larger than necessary for most systems, a more 	 optimal port will define JMP_BUF_SIZE.  */
name|tmp
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* builtin_setjmp takes a pointer to 5 words.  */
name|tmp
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|5
operator|*
name|BITS_PER_WORD
operator|/
name|POINTER_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|build_index_type
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|f_jbuf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__jbuf"
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
comment|/* We don't know what the alignment requirements of the 	 runtime's jmp_buf has.  Overestimate.  */
name|DECL_ALIGN
argument_list|(
name|f_jbuf
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|f_jbuf
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_jbuf
argument_list|)
operator|=
name|sjlj_fc_type_node
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|sjlj_fc_type_node
argument_list|)
operator|=
name|f_prev
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_prev
argument_list|)
operator|=
name|f_cs
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_cs
argument_list|)
operator|=
name|f_data
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_data
argument_list|)
operator|=
name|f_per
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_per
argument_list|)
operator|=
name|f_lsda
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_lsda
argument_list|)
operator|=
name|f_jbuf
expr_stmt|;
name|layout_type
argument_list|(
name|sjlj_fc_type_node
argument_list|)
expr_stmt|;
comment|/* Cache the interesting field offsets so that we have 	 easy access from rtl.  */
name|sjlj_fc_call_site_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_cs
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_cs
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_data_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_data
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_data
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_personality_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_per
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_per
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_lsda_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_lsda
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_lsda
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|sjlj_fc_jbuf_ofs
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f_jbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f_jbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_eh_for_function
parameter_list|(
name|void
parameter_list|)
block|{
name|cfun
operator|->
name|eh
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to generate the exception tree somewhat directly.    These are used from tree-eh.c when processing exception related    nodes during tree optimization.  */
end_comment

begin_function
specifier|static
name|struct
name|eh_region
modifier|*
name|gen_eh_region
parameter_list|(
name|enum
name|eh_region_type
name|type
parameter_list|,
name|struct
name|eh_region
modifier|*
name|outer
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|new
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|doing_eh
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Insert a new blank region as a leaf in the tree.  */
name|new
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|outer
operator|=
name|outer
expr_stmt|;
if|if
condition|(
name|outer
condition|)
block|{
name|new
operator|->
name|next_peer
operator|=
name|outer
operator|->
name|inner
expr_stmt|;
name|outer
operator|->
name|inner
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|next_peer
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|=
name|new
expr_stmt|;
block|}
name|new
operator|->
name|region_number
operator|=
operator|++
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|struct
name|eh_region
modifier|*
name|gen_eh_region_cleanup
parameter_list|(
name|struct
name|eh_region
modifier|*
name|outer
parameter_list|,
name|struct
name|eh_region
modifier|*
name|prev_try
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|cleanup
init|=
name|gen_eh_region
argument_list|(
name|ERT_CLEANUP
argument_list|,
name|outer
argument_list|)
decl_stmt|;
name|cleanup
operator|->
name|u
operator|.
name|cleanup
operator|.
name|prev_try
operator|=
name|prev_try
expr_stmt|;
return|return
name|cleanup
return|;
block|}
end_function

begin_function
name|struct
name|eh_region
modifier|*
name|gen_eh_region_try
parameter_list|(
name|struct
name|eh_region
modifier|*
name|outer
parameter_list|)
block|{
return|return
name|gen_eh_region
argument_list|(
name|ERT_TRY
argument_list|,
name|outer
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|eh_region
modifier|*
name|gen_eh_region_catch
parameter_list|(
name|struct
name|eh_region
modifier|*
name|t
parameter_list|,
name|tree
name|type_or_list
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|tree
name|type_list
decl_stmt|,
name|type_node
decl_stmt|;
comment|/* Ensure to always end up with a type list to normalize further      processing, then register each type against the runtime types map.  */
name|type_list
operator|=
name|type_or_list
expr_stmt|;
if|if
condition|(
name|type_or_list
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_or_list
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|type_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type_or_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|type_node
operator|=
name|type_list
expr_stmt|;
for|for
control|(
init|;
name|type_node
condition|;
name|type_node
operator|=
name|TREE_CHAIN
argument_list|(
name|type_node
argument_list|)
control|)
name|add_type_for_runtime
argument_list|(
name|TREE_VALUE
argument_list|(
name|type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|gen_eh_region
argument_list|(
name|ERT_CATCH
argument_list|,
name|t
operator|->
name|outer
argument_list|)
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|=
name|type_list
expr_stmt|;
name|l
operator|=
name|t
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|l
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
operator|=
name|c
expr_stmt|;
else|else
name|t
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|=
name|c
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
operator|=
name|c
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|struct
name|eh_region
modifier|*
name|gen_eh_region_allowed
parameter_list|(
name|struct
name|eh_region
modifier|*
name|outer
parameter_list|,
name|tree
name|allowed
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|region
init|=
name|gen_eh_region
argument_list|(
name|ERT_ALLOWED_EXCEPTIONS
argument_list|,
name|outer
argument_list|)
decl_stmt|;
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
operator|=
name|allowed
expr_stmt|;
for|for
control|(
init|;
name|allowed
condition|;
name|allowed
operator|=
name|TREE_CHAIN
argument_list|(
name|allowed
argument_list|)
control|)
name|add_type_for_runtime
argument_list|(
name|TREE_VALUE
argument_list|(
name|allowed
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|region
return|;
block|}
end_function

begin_function
name|struct
name|eh_region
modifier|*
name|gen_eh_region_must_not_throw
parameter_list|(
name|struct
name|eh_region
modifier|*
name|outer
parameter_list|)
block|{
return|return
name|gen_eh_region
argument_list|(
name|ERT_MUST_NOT_THROW
argument_list|,
name|outer
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|get_eh_region_number
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
return|return
name|region
operator|->
name|region_number
return|;
block|}
end_function

begin_function
name|bool
name|get_eh_region_may_contain_throw
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
return|return
name|region
operator|->
name|may_contain_throw
return|;
block|}
end_function

begin_function
name|tree
name|get_eh_region_tree_label
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
return|return
name|region
operator|->
name|tree_label
return|;
block|}
end_function

begin_function
name|void
name|set_eh_region_tree_label
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|,
name|tree
name|lab
parameter_list|)
block|{
name|region
operator|->
name|tree_label
operator|=
name|lab
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|expand_resx_expr
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|int
name|region_nr
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|reg
init|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_nr
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|reg
operator|->
name|resume
argument_list|)
expr_stmt|;
name|reg
operator|->
name|resume
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_RESX
argument_list|(
name|VOIDmode
argument_list|,
name|region_nr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that the current EH region (if any) may contain a throw, or a    call to a function which itself may contain a throw.  */
end_comment

begin_function
name|void
name|note_eh_region_may_contain_throw
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
while|while
condition|(
name|region
operator|&&
operator|!
name|region
operator|->
name|may_contain_throw
condition|)
block|{
name|region
operator|->
name|may_contain_throw
operator|=
literal|1
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|note_current_region_may_contain_throw
parameter_list|(
name|void
parameter_list|)
block|{
name|note_eh_region_may_contain_throw
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|cur_region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtl expression for a pointer to the exception object    within a handler.  */
end_comment

begin_function
name|rtx
name|get_exception_pointer
parameter_list|(
name|struct
name|function
modifier|*
name|fun
parameter_list|)
block|{
name|rtx
name|exc_ptr
init|=
name|fun
operator|->
name|eh
operator|->
name|exc_ptr
decl_stmt|;
if|if
condition|(
name|fun
operator|==
name|cfun
operator|&&
operator|!
name|exc_ptr
condition|)
block|{
name|exc_ptr
operator|=
name|gen_reg_rtx
argument_list|(
name|ptr_mode
argument_list|)
expr_stmt|;
name|fun
operator|->
name|eh
operator|->
name|exc_ptr
operator|=
name|exc_ptr
expr_stmt|;
block|}
return|return
name|exc_ptr
return|;
block|}
end_function

begin_comment
comment|/* Return an rtl expression for the exception dispatch filter    within a handler.  */
end_comment

begin_function
name|rtx
name|get_exception_filter
parameter_list|(
name|struct
name|function
modifier|*
name|fun
parameter_list|)
block|{
name|rtx
name|filter
init|=
name|fun
operator|->
name|eh
operator|->
name|filter
decl_stmt|;
if|if
condition|(
name|fun
operator|==
name|cfun
operator|&&
operator|!
name|filter
condition|)
block|{
name|filter
operator|=
name|gen_reg_rtx
argument_list|(
name|targetm
operator|.
name|eh_return_filter_mode
argument_list|()
argument_list|)
expr_stmt|;
name|fun
operator|->
name|eh
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
block|}
return|return
name|filter
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section is for the exception handling specific optimization pass.  */
end_comment

begin_comment
comment|/* Random access the exception region tree.  */
end_comment

begin_function
name|void
name|collect_eh_region_array
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
return|return;
name|VEC_safe_grow
argument_list|(
name|eh_region
argument_list|,
name|gc
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|VEC_replace
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
operator|->
name|region_number
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If there are sub-regions, process them.  */
if|if
condition|(
name|i
operator|->
name|inner
condition|)
name|i
operator|=
name|i
operator|->
name|inner
expr_stmt|;
comment|/* If there are peers, process them.  */
elseif|else
if|if
condition|(
name|i
operator|->
name|next_peer
condition|)
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
comment|/* Otherwise, step back up the tree to the next peer.  */
else|else
block|{
do|do
block|{
name|i
operator|=
name|i
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
return|return;
block|}
do|while
condition|(
name|i
operator|->
name|next_peer
operator|==
name|NULL
condition|)
do|;
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove all regions whose labels are not reachable from insns.  */
end_comment

begin_function
specifier|static
name|void
name|remove_unreachable_regions
parameter_list|(
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
modifier|*
name|uid_region_num
decl_stmt|;
name|bool
modifier|*
name|reachable
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|r
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|uid_region_num
operator|=
name|xcalloc
argument_list|(
name|get_max_uid
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reachable
operator|=
name|xcalloc
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|||
name|r
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|r
operator|->
name|resume
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|resume
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|resume
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|label
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|label
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|r
operator|->
name|label
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|reachable
index|[
name|uid_region_num
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
index|]
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|region_number
operator|==
name|i
operator|&&
operator|!
name|reachable
index|[
name|i
index|]
condition|)
block|{
name|bool
name|kill_it
init|=
name|true
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|type
condition|)
block|{
case|case
name|ERT_THROW
case|:
comment|/* Don't remove ERT_THROW regions if their outer region 		 is reachable.  */
if|if
condition|(
name|r
operator|->
name|outer
operator|&&
name|reachable
index|[
name|r
operator|->
name|outer
operator|->
name|region_number
index|]
condition|)
name|kill_it
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ERT_MUST_NOT_THROW
case|:
comment|/* MUST_NOT_THROW regions are implementable solely in the 		 runtime, but their existence continues to affect calls 		 within that region.  Never delete them here.  */
name|kill_it
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ERT_TRY
case|:
block|{
comment|/* TRY regions are reachable if any of its CATCH regions 		   are reachable.  */
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|r
operator|->
name|u
operator|.
name|try
operator|.
name|catch
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
control|)
if|if
condition|(
name|reachable
index|[
name|c
operator|->
name|region_number
index|]
condition|)
block|{
name|kill_it
operator|=
name|false
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|kill_it
condition|)
name|remove_eh_handler
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reachable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uid_region_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up EH labels for RTL.  */
end_comment

begin_function
name|void
name|convert_from_eh_region_ranges
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insns
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
decl_stmt|;
comment|/* Most of the work is already done at the tree level.  All we need to      do is collect the rtl labels that correspond to the tree labels that      collect the rtl labels that correspond to the tree labels      we allocated earlier.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|&&
name|region
operator|->
name|tree_label
condition|)
name|region
operator|->
name|label
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|region
operator|->
name|tree_label
argument_list|)
expr_stmt|;
block|}
name|remove_unreachable_regions
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_ehl_entry
parameter_list|(
name|rtx
name|label
parameter_list|,
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|ehl_map_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|entry
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|entry
operator|->
name|region
operator|=
name|region
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* Before landing pad creation, each exception handler has its own      label.  After landing pad creation, the exception handlers may      share landing pads.  This is ok, since maybe_remove_eh_handler      only requires the 1-1 mapping before landing pad creation.  */
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
operator|||
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
name|void
name|find_exception_handler_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
condition|)
name|htab_empty
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* ??? The expansion factor here (3/2) must be greater than the htab 	 occupancy factor (4/3) to avoid unnecessary resizing.  */
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
operator|=
name|htab_create_ggc
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|*
literal|3
operator|/
literal|2
argument_list|,
name|ehl_hash
argument_list|,
name|ehl_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|rtx
name|lab
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|lab
operator|=
name|region
operator|->
name|landing_pad
expr_stmt|;
else|else
name|lab
operator|=
name|region
operator|->
name|label
expr_stmt|;
if|if
condition|(
name|lab
condition|)
name|add_ehl_entry
argument_list|(
name|lab
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
comment|/* For sjlj exceptions, need the return label to remain live until      after landing pad generation.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
operator|&&
operator|!
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|add_ehl_entry
argument_list|(
name|return_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if the current function has exception handling regions.  */
end_comment

begin_function
name|bool
name|current_function_has_exception_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|&&
name|region
operator|->
name|region_number
operator|==
name|i
operator|&&
name|region
operator|->
name|type
operator|!=
name|ERT_THROW
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of duplicate_eh_regions.  Search the region tree under O    for the minimum and maximum region numbers.  Update *MIN and *MAX.  */
end_comment

begin_function
specifier|static
name|void
name|duplicate_eh_regions_0
parameter_list|(
name|eh_region
name|o
parameter_list|,
name|int
modifier|*
name|min
parameter_list|,
name|int
modifier|*
name|max
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|region_number
operator|<
operator|*
name|min
condition|)
operator|*
name|min
operator|=
name|o
operator|->
name|region_number
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|region_number
operator|>
operator|*
name|max
condition|)
operator|*
name|max
operator|=
name|o
operator|->
name|region_number
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|inner
condition|)
block|{
name|o
operator|=
name|o
operator|->
name|inner
expr_stmt|;
name|duplicate_eh_regions_0
argument_list|(
name|o
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
while|while
condition|(
name|o
operator|->
name|next_peer
condition|)
block|{
name|o
operator|=
name|o
operator|->
name|next_peer
expr_stmt|;
name|duplicate_eh_regions_0
argument_list|(
name|o
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of duplicate_eh_regions.  Copy the region tree under OLD.    Root it at OUTER, and apply EH_OFFSET to the region number.  Don't worry    about the other internal pointers just yet, just the tree-like pointers.  */
end_comment

begin_function
specifier|static
name|eh_region
name|duplicate_eh_regions_1
parameter_list|(
name|eh_region
name|old
parameter_list|,
name|eh_region
name|outer
parameter_list|,
name|int
name|eh_offset
parameter_list|)
block|{
name|eh_region
name|ret
decl_stmt|,
name|n
decl_stmt|;
name|ret
operator|=
name|n
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_region
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|*
name|old
expr_stmt|;
name|n
operator|->
name|outer
operator|=
name|outer
expr_stmt|;
name|n
operator|->
name|next_peer
operator|=
name|NULL
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|old
operator|->
name|aka
argument_list|)
expr_stmt|;
name|n
operator|->
name|region_number
operator|+=
name|eh_offset
expr_stmt|;
name|VEC_replace
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|n
operator|->
name|region_number
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|inner
condition|)
block|{
name|old
operator|=
name|old
operator|->
name|inner
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|inner
operator|=
name|duplicate_eh_regions_1
argument_list|(
name|old
argument_list|,
name|ret
argument_list|,
name|eh_offset
argument_list|)
expr_stmt|;
while|while
condition|(
name|old
operator|->
name|next_peer
condition|)
block|{
name|old
operator|=
name|old
operator|->
name|next_peer
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next_peer
operator|=
name|duplicate_eh_regions_1
argument_list|(
name|old
argument_list|,
name|ret
argument_list|,
name|eh_offset
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Duplicate the EH regions of IFUN, rooted at COPY_REGION, into current    function and root the tree below OUTER_REGION.  Remap labels using MAP    callback.  The special case of COPY_REGION of 0 means all regions.  */
end_comment

begin_function
name|int
name|duplicate_eh_regions
parameter_list|(
name|struct
name|function
modifier|*
name|ifun
parameter_list|,
name|duplicate_eh_regions_map
name|map
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|copy_region
parameter_list|,
name|int
name|outer_region
parameter_list|)
block|{
name|eh_region
name|cur
decl_stmt|,
name|prev_try
decl_stmt|,
name|outer
decl_stmt|,
modifier|*
name|splice
decl_stmt|;
name|int
name|i
decl_stmt|,
name|min_region
decl_stmt|,
name|max_region
decl_stmt|,
name|eh_offset
decl_stmt|,
name|cfun_last_region_number
decl_stmt|;
name|int
name|num_regions
decl_stmt|;
if|if
condition|(
operator|!
name|ifun
operator|->
name|eh
operator|->
name|region_tree
condition|)
return|return
literal|0
return|;
comment|/* Find the range of region numbers to be copied.  The interface we       provide here mandates a single offset to find new number from old,      which means we must look at the numbers present, instead of the      count or something else.  */
if|if
condition|(
name|copy_region
operator|>
literal|0
condition|)
block|{
name|min_region
operator|=
name|INT_MAX
expr_stmt|;
name|max_region
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|ifun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|copy_region
argument_list|)
expr_stmt|;
name|duplicate_eh_regions_0
argument_list|(
name|cur
argument_list|,
operator|&
name|min_region
argument_list|,
operator|&
name|max_region
argument_list|)
expr_stmt|;
block|}
else|else
name|min_region
operator|=
literal|1
operator|,
name|max_region
operator|=
name|ifun
operator|->
name|eh
operator|->
name|last_region_number
expr_stmt|;
name|num_regions
operator|=
name|max_region
operator|-
name|min_region
operator|+
literal|1
expr_stmt|;
name|cfun_last_region_number
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
expr_stmt|;
name|eh_offset
operator|=
name|cfun_last_region_number
operator|+
literal|1
operator|-
name|min_region
expr_stmt|;
comment|/* If we've not yet created a region array, do so now.  */
name|VEC_safe_grow
argument_list|(
name|eh_region
argument_list|,
name|gc
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|cfun_last_region_number
operator|+
literal|1
operator|+
name|num_regions
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|=
name|max_region
operator|+
name|eh_offset
expr_stmt|;
comment|/* We may have just allocated the array for the first time.      Make sure that element zero is null.  */
name|VEC_replace
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero all entries in the range allocated.  */
name|memset
argument_list|(
name|VEC_address
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|)
operator|+
name|cfun_last_region_number
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|num_regions
operator|*
sizeof|sizeof
argument_list|(
name|eh_region
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Locate the spot at which to insert the new tree.  */
if|if
condition|(
name|outer_region
operator|>
literal|0
condition|)
block|{
name|outer
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|outer_region
argument_list|)
expr_stmt|;
name|splice
operator|=
operator|&
name|outer
operator|->
name|inner
expr_stmt|;
block|}
else|else
block|{
name|outer
operator|=
name|NULL
expr_stmt|;
name|splice
operator|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|splice
condition|)
name|splice
operator|=
operator|&
operator|(
operator|*
name|splice
operator|)
operator|->
name|next_peer
expr_stmt|;
comment|/* Copy all the regions in the subtree.  */
if|if
condition|(
name|copy_region
operator|>
literal|0
condition|)
block|{
name|cur
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|ifun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|copy_region
argument_list|)
expr_stmt|;
operator|*
name|splice
operator|=
name|duplicate_eh_regions_1
argument_list|(
name|cur
argument_list|,
name|outer
argument_list|,
name|eh_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eh_region
name|n
decl_stmt|;
name|cur
operator|=
name|ifun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
operator|*
name|splice
operator|=
name|n
operator|=
name|duplicate_eh_regions_1
argument_list|(
name|cur
argument_list|,
name|outer
argument_list|,
name|eh_offset
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|->
name|next_peer
condition|)
block|{
name|cur
operator|=
name|cur
operator|->
name|next_peer
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next_peer
operator|=
name|duplicate_eh_regions_1
argument_list|(
name|cur
argument_list|,
name|outer
argument_list|,
name|eh_offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remap all the labels in the new regions.  */
for|for
control|(
name|i
operator|=
name|cfun_last_region_number
operator|+
literal|1
init|;
name|VEC_iterate
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|,
name|cur
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|cur
operator|&&
name|cur
operator|->
name|tree_label
condition|)
name|cur
operator|->
name|tree_label
operator|=
name|map
argument_list|(
name|cur
operator|->
name|tree_label
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Search for the containing ERT_TRY region to fix up      the prev_try short-cuts for ERT_CLEANUP regions.  */
name|prev_try
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|outer_region
operator|>
literal|0
condition|)
for|for
control|(
name|prev_try
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|outer_region
argument_list|)
init|;
name|prev_try
operator|&&
name|prev_try
operator|->
name|type
operator|!=
name|ERT_TRY
condition|;
name|prev_try
operator|=
name|prev_try
operator|->
name|outer
control|)
if|if
condition|(
name|prev_try
operator|->
name|type
operator|==
name|ERT_MUST_NOT_THROW
condition|)
block|{
name|prev_try
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Remap all of the internal catch and cleanup linkages.  Since we       duplicate entire subtrees, all of the referenced regions will have      been copied too.  And since we renumbered them as a block, a simple      bit of arithmetic finds us the index for the replacement region.  */
for|for
control|(
name|i
operator|=
name|cfun_last_region_number
operator|+
literal|1
init|;
name|VEC_iterate
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|,
name|cur
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
continue|continue;
define|#
directive|define
name|REMAP
parameter_list|(
name|REG
parameter_list|)
define|\
value|(REG) = VEC_index (eh_region, cfun->eh->region_array, \ 			   (REG)->region_number + eh_offset)
switch|switch
condition|(
name|cur
operator|->
name|type
condition|)
block|{
case|case
name|ERT_TRY
case|:
if|if
condition|(
name|cur
operator|->
name|u
operator|.
name|try
operator|.
name|catch
condition|)
name|REMAP
argument_list|(
name|cur
operator|->
name|u
operator|.
name|try
operator|.
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
condition|)
name|REMAP
argument_list|(
name|cur
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERT_CATCH
case|:
if|if
condition|(
name|cur
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
condition|)
name|REMAP
argument_list|(
name|cur
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
condition|)
name|REMAP
argument_list|(
name|cur
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERT_CLEANUP
case|:
if|if
condition|(
name|cur
operator|->
name|u
operator|.
name|cleanup
operator|.
name|prev_try
condition|)
name|REMAP
argument_list|(
name|cur
operator|->
name|u
operator|.
name|cleanup
operator|.
name|prev_try
argument_list|)
expr_stmt|;
else|else
name|cur
operator|->
name|u
operator|.
name|cleanup
operator|.
name|prev_try
operator|=
name|prev_try
expr_stmt|;
break|break;
default|default:
break|break;
block|}
undef|#
directive|undef
name|REMAP
block|}
return|return
name|eh_offset
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGION_A is outer to REGION_B in IFUN.  */
end_comment

begin_function
name|bool
name|eh_region_outer_p
parameter_list|(
name|struct
name|function
modifier|*
name|ifun
parameter_list|,
name|int
name|region_a
parameter_list|,
name|int
name|region_b
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|rp_a
decl_stmt|,
modifier|*
name|rp_b
decl_stmt|;
name|gcc_assert
argument_list|(
name|ifun
operator|->
name|eh
operator|->
name|last_region_number
operator|>
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ifun
operator|->
name|eh
operator|->
name|region_tree
argument_list|)
expr_stmt|;
name|rp_a
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|ifun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_a
argument_list|)
expr_stmt|;
name|rp_b
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|ifun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_b
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rp_a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rp_b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rp_a
operator|==
name|rp_b
condition|)
return|return
name|true
return|;
name|rp_b
operator|=
name|rp_b
operator|->
name|outer
expr_stmt|;
block|}
do|while
condition|(
name|rp_b
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return region number of region that is outer to both if REGION_A and    REGION_B in IFUN.  */
end_comment

begin_function
name|int
name|eh_region_outermost
parameter_list|(
name|struct
name|function
modifier|*
name|ifun
parameter_list|,
name|int
name|region_a
parameter_list|,
name|int
name|region_b
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|rp_a
decl_stmt|,
modifier|*
name|rp_b
decl_stmt|;
name|sbitmap
name|b_outer
decl_stmt|;
name|gcc_assert
argument_list|(
name|ifun
operator|->
name|eh
operator|->
name|last_region_number
operator|>
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ifun
operator|->
name|eh
operator|->
name|region_tree
argument_list|)
expr_stmt|;
name|rp_a
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|ifun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_a
argument_list|)
expr_stmt|;
name|rp_b
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|ifun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_b
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rp_a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rp_b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b_outer
operator|=
name|sbitmap_alloc
argument_list|(
name|ifun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|b_outer
argument_list|)
expr_stmt|;
do|do
block|{
name|SET_BIT
argument_list|(
name|b_outer
argument_list|,
name|rp_b
operator|->
name|region_number
argument_list|)
expr_stmt|;
name|rp_b
operator|=
name|rp_b
operator|->
name|outer
expr_stmt|;
block|}
do|while
condition|(
name|rp_b
condition|)
do|;
do|do
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|b_outer
argument_list|,
name|rp_a
operator|->
name|region_number
argument_list|)
condition|)
block|{
name|sbitmap_free
argument_list|(
name|b_outer
argument_list|)
expr_stmt|;
return|return
name|rp_a
operator|->
name|region_number
return|;
block|}
name|rp_a
operator|=
name|rp_a
operator|->
name|outer
expr_stmt|;
block|}
do|while
condition|(
name|rp_a
condition|)
do|;
name|sbitmap_free
argument_list|(
name|b_outer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|t2r_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|)
block|{
name|tree
name|entry
init|=
operator|(
name|tree
operator|)
name|pentry
decl_stmt|;
name|tree
name|data
init|=
operator|(
name|tree
operator|)
name|pdata
decl_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
name|entry
argument_list|)
operator|==
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|t2r_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|)
block|{
name|tree
name|entry
init|=
operator|(
name|tree
operator|)
name|pentry
decl_stmt|;
return|return
name|TREE_HASH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|entry
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_type_for_runtime
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
name|tree
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|type_to_runtime_map
argument_list|,
name|type
argument_list|,
name|TREE_HASH
argument_list|(
name|type
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|tree
name|runtime
init|=
call|(
modifier|*
name|lang_eh_runtime_type
call|)
argument_list|(
name|type
argument_list|)
decl_stmt|;
operator|*
name|slot
operator|=
name|tree_cons
argument_list|(
name|type
argument_list|,
name|runtime
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_type_for_runtime
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
name|tree
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|type_to_runtime_map
argument_list|,
name|type
argument_list|,
name|TREE_HASH
argument_list|(
name|type
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
comment|/* We should have always inserted the data earlier.  */
return|return
name|TREE_VALUE
argument_list|(
operator|*
name|slot
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Represent an entry in @TTypes for either catch actions    or exception filter actions.  */
end_comment

begin_decl_stmt
name|struct
name|ttypes_filter
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Compare ENTRY (a ttypes_filter entry in the hash table) with DATA    (a tree) for a @TTypes type node we are thinking about adding.  */
end_comment

begin_function
specifier|static
name|int
name|ttypes_filter_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|)
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
name|tree
name|data
init|=
operator|(
name|tree
operator|)
name|pdata
decl_stmt|;
return|return
name|entry
operator|->
name|t
operator|==
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|ttypes_filter_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|)
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
return|return
name|TREE_HASH
argument_list|(
name|entry
operator|->
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare ENTRY with DATA (both struct ttypes_filter) for a @TTypes    exception specification list we are thinking about adding.  */
end_comment

begin_comment
comment|/* ??? Currently we use the type lists in the order given.  Someone    should put these in some canonical order.  */
end_comment

begin_function
specifier|static
name|int
name|ehspec_filter_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|)
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|data
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pdata
decl_stmt|;
return|return
name|type_list_equal
argument_list|(
name|entry
operator|->
name|t
argument_list|,
name|data
operator|->
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hash function for exception specification lists.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|ehspec_filter_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|)
block|{
specifier|const
name|struct
name|ttypes_filter
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|ttypes_filter
operator|*
operator|)
name|pentry
decl_stmt|;
name|hashval_t
name|h
init|=
literal|0
decl_stmt|;
name|tree
name|list
decl_stmt|;
for|for
control|(
name|list
operator|=
name|entry
operator|->
name|t
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|5
operator|)
operator|+
operator|(
name|h
operator|>>
literal|27
operator|)
operator|+
name|TREE_HASH
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Add TYPE (which may be NULL) to cfun->eh->ttype_data, using TYPES_HASH    to speed up the search.  Return the filter value to be used.  */
end_comment

begin_function
specifier|static
name|int
name|add_ttypes_entry
parameter_list|(
name|htab_t
name|ttypes_hash
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|struct
name|ttypes_filter
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ttypes_filter
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|ttypes_hash
argument_list|,
name|type
argument_list|,
name|TREE_HASH
argument_list|(
name|type
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|slot
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Filter value is a 1 based table index.  */
name|n
operator|=
name|XNEW
argument_list|(
expr|struct
name|ttypes_filter
argument_list|)
expr_stmt|;
name|n
operator|->
name|t
operator|=
name|type
expr_stmt|;
name|n
operator|->
name|filter
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|slot
operator|=
name|n
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|n
operator|->
name|filter
return|;
block|}
end_function

begin_comment
comment|/* Add LIST to cfun->eh->ehspec_data, using EHSPEC_HASH and TYPES_HASH    to speed up the search.  Return the filter value to be used.  */
end_comment

begin_function
specifier|static
name|int
name|add_ehspec_entry
parameter_list|(
name|htab_t
name|ehspec_hash
parameter_list|,
name|htab_t
name|ttypes_hash
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|struct
name|ttypes_filter
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|ttypes_filter
name|dummy
decl_stmt|;
name|dummy
operator|.
name|t
operator|=
name|list
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ttypes_filter
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|ehspec_hash
argument_list|,
operator|&
name|dummy
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|slot
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Filter value is a -1 based byte index into a uleb128 buffer.  */
name|n
operator|=
name|XNEW
argument_list|(
expr|struct
name|ttypes_filter
argument_list|)
expr_stmt|;
name|n
operator|->
name|t
operator|=
name|list
expr_stmt|;
name|n
operator|->
name|filter
operator|=
operator|-
operator|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|slot
operator|=
name|n
expr_stmt|;
comment|/* Generate a 0 terminated list of filter values.  */
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
name|targetm
operator|.
name|arm_eabi_unwinder
condition|)
name|VARRAY_PUSH_TREE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Look up each type in the list and encode its filter 		 value as a uleb128.  */
name|push_uleb128
argument_list|(
operator|&
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
name|add_ttypes_entry
argument_list|(
name|ttypes_hash
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|targetm
operator|.
name|arm_eabi_unwinder
condition|)
name|VARRAY_PUSH_TREE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|VARRAY_PUSH_UCHAR
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|n
operator|->
name|filter
return|;
block|}
end_function

begin_comment
comment|/* Generate the action filter values to be used for CATCH and    ALLOWED_EXCEPTIONS regions.  When using dwarf2 exception regions,    we use lots of landing pads, and so every type or list can share    the same filter value, which saves table space.  */
end_comment

begin_function
specifier|static
name|void
name|assign_filter_values
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|htab_t
name|ttypes
decl_stmt|,
name|ehspec
decl_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|arm_eabi_unwinder
condition|)
name|VARRAY_TREE_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
literal|64
argument_list|,
literal|"ehspec_data"
argument_list|)
expr_stmt|;
else|else
name|VARRAY_UCHAR_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
literal|64
argument_list|,
literal|"ehspec_data"
argument_list|)
expr_stmt|;
name|ttypes
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|ttypes_filter_hash
argument_list|,
name|ttypes_filter_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|ehspec
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|ehspec_filter_hash
argument_list|,
name|ehspec_filter_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|r
operator|||
name|r
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
switch|switch
condition|(
name|r
operator|->
name|type
condition|)
block|{
case|case
name|ERT_CATCH
case|:
comment|/* Whatever type_list is (NULL or true list), we build a list 	     of filters for the region.  */
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|!=
name|NULL
condition|)
block|{
comment|/* Get a filter value for each of the types caught and store 		 them in the region's dedicated list.  */
name|tree
name|tp_node
init|=
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
for|for
control|(
init|;
name|tp_node
condition|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
control|)
block|{
name|int
name|flt
init|=
name|add_ttypes_entry
argument_list|(
name|ttypes
argument_list|,
name|TREE_VALUE
argument_list|(
name|tp_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|flt_node
init|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|flt
argument_list|)
decl_stmt|;
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|flt_node
argument_list|,
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Get a filter value for the NULL list also since it will need 		 an action record anyway.  */
name|int
name|flt
init|=
name|add_ttypes_entry
argument_list|(
name|ttypes
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|flt_node
init|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|flt
argument_list|)
decl_stmt|;
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|flt_node
argument_list|,
name|r
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
name|r
operator|->
name|u
operator|.
name|allowed
operator|.
name|filter
operator|=
name|add_ehspec_entry
argument_list|(
name|ehspec
argument_list|,
name|ttypes
argument_list|,
name|r
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|htab_delete
argument_list|(
name|ttypes
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ehspec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit SEQ into basic block just before INSN (that is assumed to be    first instruction of some existing BB and return the newly    produced block.  */
end_comment

begin_function
specifier|static
name|basic_block
name|emit_to_new_bb_before
parameter_list|(
name|rtx
name|seq
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|last
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* If there happens to be a fallthru edge (possibly created by cleanup_cfg      call), we don't want it to go into newly created landing pad or other EH      construct.  */
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|force_nonfallthru
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
name|last
operator|=
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BARRIER_P
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|bb
operator|=
name|create_basic_block
argument_list|(
name|seq
argument_list|,
name|last
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|->
name|flags
operator||=
name|BB_SUPERBLOCK
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Generate the code to actually handle exceptions, which will follow the    landing pads.  */
end_comment

begin_function
specifier|static
name|void
name|build_post_landing_pads
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
switch|switch
condition|(
name|region
operator|->
name|type
condition|)
block|{
case|case
name|ERT_TRY
case|:
comment|/* ??? Collect the set of all non-overlapping catch handlers 	       all the way up the chain until blocked by a cleanup.  */
comment|/* ??? Outer try regions can share landing pads with inner 	     try regions if the types are completely non-overlapping, 	     and there are no intervening cleanups.  */
name|region
operator|->
name|post_landing_pad
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
comment|/* ??? It is mighty inconvenient to call back into the 	     switch statement generation code in expand_end_case. 	     Rapid prototyping sez a sequence of ifs.  */
block|{
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|catch
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
control|)
block|{
if|if
condition|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|==
name|NULL
condition|)
name|emit_jump
argument_list|(
name|c
operator|->
name|label
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Need for one cmp/jump per type caught. Each type 		       list entry has a matching entry in the filter list 		       (see assign_filter_values).  */
name|tree
name|tp_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
name|tree
name|flt_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
decl_stmt|;
for|for
control|(
init|;
name|tp_node
condition|;
control|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|flt_node
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|targetm
operator|.
name|eh_return_filter_mode
argument_list|()
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|label
argument_list|)
expr_stmt|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
expr_stmt|;
name|flt_node
operator|=
name|TREE_CHAIN
argument_list|(
name|flt_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* We delay the generation of the _Unwind_Resume until we generate 	     landing pads.  We emit a marker here so as to get good control 	     flow data in the meantime.  */
name|region
operator|->
name|resume
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_RESX
argument_list|(
name|VOIDmode
argument_list|,
name|region
operator|->
name|region_number
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_to_new_bb_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|->
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
name|region
operator|->
name|post_landing_pad
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|GEN_INT
argument_list|(
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|filter
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|targetm
operator|.
name|eh_return_filter_mode
argument_list|()
argument_list|,
literal|0
argument_list|,
name|region
operator|->
name|label
argument_list|)
expr_stmt|;
comment|/* We delay the generation of the _Unwind_Resume until we generate 	     landing pads.  We emit a marker here so as to get good control 	     flow data in the meantime.  */
name|region
operator|->
name|resume
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_RESX
argument_list|(
name|VOIDmode
argument_list|,
name|region
operator|->
name|region_number
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_to_new_bb_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERT_CLEANUP
case|:
case|case
name|ERT_MUST_NOT_THROW
case|:
name|region
operator|->
name|post_landing_pad
operator|=
name|region
operator|->
name|label
expr_stmt|;
break|break;
case|case
name|ERT_CATCH
case|:
case|case
name|ERT_THROW
case|:
comment|/* Nothing to do.  */
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace RESX patterns with jumps to the next handler if any, or calls to    _Unwind_Resume otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|connect_post_landing_pads
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|outer
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
comment|/* If there is no RESX, or it has been deleted by flow, there's 	 nothing to fix up.  */
if|if
condition|(
operator|!
name|region
operator|->
name|resume
operator|||
name|INSN_DELETED_P
argument_list|(
name|region
operator|->
name|resume
argument_list|)
condition|)
continue|continue;
comment|/* Search for another landing pad in this function.  */
for|for
control|(
name|outer
operator|=
name|region
operator|->
name|outer
init|;
name|outer
condition|;
name|outer
operator|=
name|outer
operator|->
name|outer
control|)
if|if
condition|(
name|outer
operator|->
name|post_landing_pad
condition|)
break|break;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|outer
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|emit_jump
argument_list|(
name|outer
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
name|src
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|region
operator|->
name|resume
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|outer
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
while|while
condition|(
name|EDGE_COUNT
argument_list|(
name|src
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
name|remove_edge
argument_list|(
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|src
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
name|emit_library_call
argument_list|(
name|unwind_resume_libfunc
argument_list|,
name|LCT_THROW
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|exc_ptr
argument_list|,
name|ptr_mode
argument_list|)
expr_stmt|;
comment|/* What we just emitted was a throwing libcall, so it got a 	     barrier automatically added after it.  If the last insn in 	     the libcall sequence isn't the barrier, it's because the 	     target emits multiple insns for a call, and there are insns 	     after the actual call insn (which are redundant and would be 	     optimized away).  The barrier is inserted exactly after the 	     call insn, so let's go get that and delete the insns after 	     it, because below we need the barrier to be the last insn in 	     the sequence.  */
name|delete_insns_since
argument_list|(
name|NEXT_INSN
argument_list|(
name|last_call_insn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|barrier
operator|=
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|resume
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate barrier.  */
name|gcc_assert
argument_list|(
name|BARRIER_P
argument_list|(
name|barrier
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|region
operator|->
name|resume
argument_list|)
expr_stmt|;
comment|/* ??? From tree-ssa we can wind up with catch regions whose 	 label is not instantiated, but whose resx is present.  Now 	 that we've dealt with the resx, kill the region.  */
if|if
condition|(
name|region
operator|->
name|label
operator|==
name|NULL
operator|&&
name|region
operator|->
name|type
operator|==
name|ERT_CLEANUP
condition|)
name|remove_eh_handler
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dw2_build_landing_pads
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Mind we don't process a region more than once.  */
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|region_number
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|region
operator|->
name|type
operator|!=
name|ERT_CLEANUP
operator|&&
name|region
operator|->
name|type
operator|!=
name|ERT_TRY
operator|&&
name|region
operator|->
name|type
operator|!=
name|ERT_ALLOWED_EXCEPTIONS
condition|)
continue|continue;
name|start_sequence
argument_list|()
expr_stmt|;
name|region
operator|->
name|landing_pad
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|region
operator|->
name|landing_pad
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_exception_receiver
if|if
condition|(
name|HAVE_exception_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_exception_receiver
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Nothing */
block|}
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exc_ptr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
name|EH_RETURN_DATA_REGNO
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|gen_rtx_REG
argument_list|(
name|targetm
operator|.
name|eh_return_filter_mode
argument_list|()
argument_list|,
name|EH_RETURN_DATA_REGNO
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|bb
operator|=
name|emit_to_new_bb_before
argument_list|(
name|seq
argument_list|,
name|region
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|bb
operator|->
name|next_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|sjlj_lp_info
block|{
name|int
name|directly_reachable
decl_stmt|;
name|int
name|action_index
decl_stmt|;
name|int
name|dispatch_index
decl_stmt|;
name|int
name|call_site_index
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bool
name|sjlj_find_directly_reachable_regions
parameter_list|(
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|bool
name|found_one
init|=
name|false
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|enum
name|reachable_code
name|rc
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
comment|/* Find the first containing region that might handle the exception. 	 That's the landing pad to which we will transfer control.  */
name|rc
operator|=
name|RNL_NOT_CAUGHT
expr_stmt|;
for|for
control|(
init|;
name|region
condition|;
name|region
operator|=
name|region
operator|->
name|outer
control|)
block|{
name|rc
operator|=
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|RNL_NOT_CAUGHT
condition|)
break|break;
block|}
if|if
condition|(
name|rc
operator|==
name|RNL_MAYBE_CAUGHT
operator|||
name|rc
operator|==
name|RNL_CAUGHT
condition|)
block|{
name|lp_info
index|[
name|region
operator|->
name|region_number
index|]
operator|.
name|directly_reachable
operator|=
literal|1
expr_stmt|;
name|found_one
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|found_one
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_assign_call_site_values
parameter_list|(
name|rtx
name|dispatch_label
parameter_list|,
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
parameter_list|)
block|{
name|htab_t
name|ar_hash
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
decl_stmt|;
comment|/* First task: build the action table.  */
name|VARRAY_UCHAR_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
literal|64
argument_list|,
literal|"action_record_data"
argument_list|)
expr_stmt|;
name|ar_hash
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|action_record_hash
argument_list|,
name|action_record_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|r
init|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|r
operator|->
name|landing_pad
operator|=
name|dispatch_label
expr_stmt|;
name|lp_info
index|[
name|i
index|]
operator|.
name|action_index
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|action_index
operator|!=
operator|-
literal|1
condition|)
name|cfun
operator|->
name|uses_eh_lsda
operator|=
literal|1
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|ar_hash
argument_list|)
expr_stmt|;
comment|/* Next: assign dispatch values.  In dwarf2 terms, this would be the      landing pad label for the region.  For sjlj though, there is one      common landing pad from which we dispatch to the post-landing pads.       A region receives a dispatch index if it is directly reachable      and requires in-function processing.  Regions that share post-landing      pads may share dispatch indices.  */
comment|/* ??? Post-landing pad sharing doesn't actually happen at the moment      (see build_post_landing_pads) so we don't bother checking for it.  */
name|index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
name|lp_info
index|[
name|i
index|]
operator|.
name|dispatch_index
operator|=
name|index
operator|++
expr_stmt|;
comment|/* Finally: assign call-site values.  If dwarf2 terms, this would be      the region number assigned by convert_to_eh_region_ranges, but      handles no-action and must-not-throw differently.  */
name|call_site_base
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
block|{
name|int
name|action
init|=
name|lp_info
index|[
name|i
index|]
operator|.
name|action_index
decl_stmt|;
comment|/* Map must-not-throw to otherwise unused call-site index 0.  */
if|if
condition|(
name|action
operator|==
operator|-
literal|2
condition|)
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Map no-action to otherwise unused call-site index -1.  */
elseif|else
if|if
condition|(
name|action
operator|==
operator|-
literal|1
condition|)
name|index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Otherwise, look it up in the table.  */
else|else
name|index
operator|=
name|add_call_site
argument_list|(
name|GEN_INT
argument_list|(
name|lp_info
index|[
name|i
index|]
operator|.
name|dispatch_index
argument_list|)
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|lp_info
index|[
name|i
index|]
operator|.
name|call_site_index
operator|=
name|index
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_mark_call_sites
parameter_list|(
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
parameter_list|)
block|{
name|int
name|last_call_site
init|=
operator|-
literal|2
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|mem
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|int
name|this_call_site
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|before
decl_stmt|,
name|p
decl_stmt|;
comment|/* Reset value tracking at extended basic block boundaries.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|last_call_site
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
block|{
comment|/* Calls (and trapping insns) without notes are outside any 	     exception handling region in this function.  Mark them as 	     no action.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
name|this_call_site
operator|=
operator|-
literal|1
expr_stmt|;
else|else
continue|continue;
block|}
else|else
block|{
comment|/* Calls that are known to not throw need not be marked.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this_call_site
operator|=
name|lp_info
index|[
name|region
operator|->
name|region_number
index|]
operator|.
name|call_site_index
expr_stmt|;
block|}
if|if
condition|(
name|this_call_site
operator|==
name|last_call_site
condition|)
continue|continue;
comment|/* Don't separate a call from it's argument loads.  */
name|before
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|before
operator|=
name|find_first_parameter_load
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|sjlj_fc_call_site_ofs
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|this_call_site
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|p
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last_call_site
operator|=
name|this_call_site
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Construct the SjLj_Function_Context.  */
end_comment

begin_function
specifier|static
name|void
name|sjlj_emit_function_enter
parameter_list|(
name|rtx
name|dispatch_label
parameter_list|)
block|{
name|rtx
name|fn_begin
decl_stmt|,
name|fc
decl_stmt|,
name|mem
decl_stmt|,
name|seq
decl_stmt|;
name|bool
name|fn_begin_outside_block
decl_stmt|;
name|fc
operator|=
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* We're storing this libcall's address into memory instead of      calling it directly.  Thus, we must call assemble_external_libcall      here, as we can not depend on emit_library_call to do it for us.  */
name|assemble_external_libcall
argument_list|(
name|eh_personality_libfunc
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|Pmode
argument_list|,
name|sjlj_fc_personality_ofs
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|eh_personality_libfunc
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|Pmode
argument_list|,
name|sjlj_fc_lsda_ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|uses_eh_lsda
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|rtx
name|sym
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LLSDA"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|sym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
block|{
name|rtx
name|x
decl_stmt|,
name|note
decl_stmt|;
name|x
operator|=
name|emit_library_call_value
argument_list|(
name|setjmp_libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_RETURNS_TWICE
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sjlj_fc_jbuf_ofs
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_EXPECTED_VALUE
argument_list|)
expr_stmt|;
name|NOTE_EXPECTED_VALUE
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|x
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dispatch_label
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|expand_builtin_setjmp_setup
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sjlj_fc_jbuf_ofs
argument_list|)
argument_list|,
name|dispatch_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|unwind_sjlj_register_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|XEXP
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* ??? Instead of doing this at the beginning of the function,      do this in a block that is at loop level 0 and dominates all      can_throw_internal instructions.  */
name|fn_begin_outside_block
operator|=
name|true
expr_stmt|;
for|for
control|(
name|fn_begin
operator|=
name|get_insns
argument_list|()
init|;
condition|;
name|fn_begin
operator|=
name|NEXT_INSN
argument_list|(
name|fn_begin
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|fn_begin
argument_list|)
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|fn_begin
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
break|break;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|fn_begin
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
name|fn_begin_outside_block
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|fn_begin_outside_block
condition|)
name|insert_insn_on_edge
argument_list|(
name|seq
argument_list|,
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|fn_begin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call back from expand_function_end to know where we should put    the call to unwind_sjlj_unregister_libfunc if needed.  */
end_comment

begin_function
name|void
name|sjlj_emit_function_exit_after
parameter_list|(
name|rtx
name|after
parameter_list|)
block|{
name|cfun
operator|->
name|eh
operator|->
name|sjlj_exit_after
operator|=
name|after
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_emit_function_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|seq
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|unwind_sjlj_unregister_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|XEXP
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* ??? Really this can be done in any block at loop level 0 that      post-dominates all can_throw_internal instructions.  This is      the last possible moment.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Figure out whether the place we are supposed to insert libcall          is inside the last basic block or after it.  In the other case          we need to emit to edge.  */
name|gcc_assert
argument_list|(
name|e
operator|->
name|src
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|src
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|cfun
operator|->
name|eh
operator|->
name|sjlj_exit_after
condition|)
block|{
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
condition|)
break|break;
block|}
name|insert_insn_on_edge
argument_list|(
name|seq
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_emit_dispatch_table
parameter_list|(
name|rtx
name|dispatch_label
parameter_list|,
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first_reachable
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|dispatch
decl_stmt|,
name|seq
decl_stmt|,
name|fc
decl_stmt|;
name|rtx
name|before
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|fc
operator|=
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|dispatch_label
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DONT_USE_BUILTIN_SETJMP
name|expand_builtin_setjmp_receiver
argument_list|(
name|dispatch_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Load up dispatch index, exc_ptr and filter values from the      function context.  */
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|sjlj_fc_call_site_ofs
argument_list|)
expr_stmt|;
name|dispatch
operator|=
name|copy_to_reg
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|word_mode
argument_list|,
name|sjlj_fc_data_ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|word_mode
operator|!=
name|ptr_mode
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|#
directive|else
name|mem
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exc_ptr
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|fc
argument_list|,
name|word_mode
argument_list|,
name|sjlj_fc_data_ofs
operator|+
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|filter
argument_list|,
name|mem
argument_list|)
expr_stmt|;
comment|/* Jump to one of the directly reachable regions.  */
comment|/* ??? This really ought to be using a switch statement.  */
name|first_reachable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|lp_info
index|[
name|i
index|]
operator|.
name|directly_reachable
condition|)
continue|continue;
if|if
condition|(
operator|!
name|first_reachable
condition|)
block|{
name|first_reachable
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|dispatch
argument_list|,
name|GEN_INT
argument_list|(
name|lp_info
index|[
name|i
index|]
operator|.
name|dispatch_index
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
expr|struct
name|eh_region
operator|*
operator|)
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
operator|)
operator|->
name|post_landing_pad
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|before
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eh_region
operator|*
operator|)
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|first_reachable
argument_list|)
operator|)
operator|->
name|post_landing_pad
operator|)
expr_stmt|;
name|bb
operator|=
name|emit_to_new_bb_before
argument_list|(
name|seq
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|bb
operator|->
name|next_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_build_landing_pads
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sjlj_lp_info
modifier|*
name|lp_info
decl_stmt|;
name|lp_info
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|sjlj_lp_info
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sjlj_find_directly_reachable_regions
argument_list|(
name|lp_info
argument_list|)
condition|)
block|{
name|rtx
name|dispatch_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|sjlj_fc
operator|=
name|assign_stack_local
argument_list|(
name|TYPE_MODE
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|sjlj_fc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|sjlj_assign_call_site_values
argument_list|(
name|dispatch_label
argument_list|,
name|lp_info
argument_list|)
expr_stmt|;
name|sjlj_mark_call_sites
argument_list|(
name|lp_info
argument_list|)
expr_stmt|;
name|sjlj_emit_function_enter
argument_list|(
name|dispatch_label
argument_list|)
expr_stmt|;
name|sjlj_emit_dispatch_table
argument_list|(
name|dispatch_label
argument_list|,
name|lp_info
argument_list|)
expr_stmt|;
name|sjlj_emit_function_exit
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|lp_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_eh_generation
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* Nothing to do if no regions created.  */
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|==
name|NULL
condition|)
return|return;
comment|/* The object here is to provide find_basic_blocks with detailed      information (via reachable_handlers) on how exception control      flows within the function.  In this first pass, we can include      type information garnered from ERT_THROW and ERT_ALLOWED_EXCEPTIONS      regions, and hope that it will be useful in deleting unreachable      handlers.  Subsequently, we will generate landing pads which will      connect many of the handlers, and then type information will not      be effective.  Still, this is a win over previous implementations.  */
comment|/* These registers are used by the landing pads.  Make sure they      have been generated.  */
name|get_exception_pointer
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|get_exception_filter
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
comment|/* Construct the landing pads.  */
name|assign_filter_values
argument_list|()
expr_stmt|;
name|build_post_landing_pads
argument_list|()
expr_stmt|;
name|connect_post_landing_pads
argument_list|()
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|sjlj_build_landing_pads
argument_list|()
expr_stmt|;
else|else
name|dw2_build_landing_pads
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
operator|=
literal|1
expr_stmt|;
comment|/* We've totally changed the CFG.  Start over.  */
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|break_superblocks
argument_list|()
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|eh
init|=
name|false
decl_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|eh
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eh
condition|)
name|rtl_make_eh_edge
argument_list|(
name|NULL
argument_list|,
name|bb
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|hashval_t
name|ehl_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|)
block|{
name|struct
name|ehl_map_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|)
name|pentry
decl_stmt|;
comment|/* 2^32 * ((sqrt(5) - 1) / 2) */
specifier|const
name|hashval_t
name|scaled_golden_ratio
init|=
literal|0x9e3779b9
decl_stmt|;
return|return
name|CODE_LABEL_NUMBER
argument_list|(
name|entry
operator|->
name|label
argument_list|)
operator|*
name|scaled_golden_ratio
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ehl_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|)
block|{
name|struct
name|ehl_map_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|)
name|pentry
decl_stmt|;
name|struct
name|ehl_map_entry
modifier|*
name|data
init|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|)
name|pdata
decl_stmt|;
return|return
name|entry
operator|->
name|label
operator|==
name|data
operator|->
name|label
return|;
block|}
end_function

begin_comment
comment|/* This section handles removing dead code for flow.  */
end_comment

begin_comment
comment|/* Remove LABEL from exception_handler_label_map.  */
end_comment

begin_function
specifier|static
name|void
name|remove_exception_handler_label
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|struct
name|ehl_map_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* If exception_handler_label_map was not built yet,      there is nothing to do.  */
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
operator|==
name|NULL
condition|)
return|return;
name|tmp
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|&
name|tmp
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Splice REGION from the region tree etc.  */
end_comment

begin_function
specifier|static
name|void
name|remove_eh_handler
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
modifier|*
name|pp_start
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|outer
decl_stmt|,
modifier|*
name|inner
decl_stmt|;
name|rtx
name|lab
decl_stmt|;
comment|/* For the benefit of efficiently handling REG_EH_REGION notes,      replace this region in the region array with its containing      region.  Note that previous region deletions may result in      multiple copies of this region in the array, so we have a      list of alternate numbers by which we are known.  */
name|outer
operator|=
name|region
operator|->
name|outer
expr_stmt|;
name|VEC_replace
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region
operator|->
name|region_number
argument_list|,
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|aka
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|region->aka
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|VEC_replace
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|,
name|outer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outer
condition|)
block|{
if|if
condition|(
operator|!
name|outer
operator|->
name|aka
condition|)
name|outer
operator|->
name|aka
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|aka
condition|)
name|bitmap_ior_into
argument_list|(
name|outer
operator|->
name|aka
argument_list|,
name|region
operator|->
name|aka
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|outer
operator|->
name|aka
argument_list|,
name|region
operator|->
name|region_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|lab
operator|=
name|region
operator|->
name|landing_pad
expr_stmt|;
else|else
name|lab
operator|=
name|region
operator|->
name|label
expr_stmt|;
if|if
condition|(
name|lab
condition|)
name|remove_exception_handler_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer
condition|)
name|pp_start
operator|=
operator|&
name|outer
operator|->
name|inner
expr_stmt|;
else|else
name|pp_start
operator|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pp_start
operator|,
name|p
operator|=
operator|*
name|pp
init|;
name|p
operator|!=
name|region
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next_peer
operator|,
name|p
operator|=
operator|*
name|pp
control|)
continue|continue;
operator|*
name|pp
operator|=
name|region
operator|->
name|next_peer
expr_stmt|;
name|inner
operator|=
name|region
operator|->
name|inner
expr_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
for|for
control|(
name|p
operator|=
name|inner
init|;
name|p
operator|->
name|next_peer
condition|;
name|p
operator|=
name|p
operator|->
name|next_peer
control|)
name|p
operator|->
name|outer
operator|=
name|outer
expr_stmt|;
name|p
operator|->
name|outer
operator|=
name|outer
expr_stmt|;
name|p
operator|->
name|next_peer
operator|=
operator|*
name|pp_start
expr_stmt|;
operator|*
name|pp_start
operator|=
name|inner
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_CATCH
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|try
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|try
operator|=
name|region
operator|->
name|next_peer
init|;
name|try
operator|->
name|type
operator|==
name|ERT_CATCH
condition|;
name|try
operator|=
name|try
operator|->
name|next_peer
control|)
continue|continue;
name|gcc_assert
argument_list|(
name|try
operator|->
name|type
operator|==
name|ERT_TRY
argument_list|)
expr_stmt|;
name|next
operator|=
name|region
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
expr_stmt|;
name|prev
operator|=
name|region
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
operator|=
name|prev
expr_stmt|;
else|else
name|try
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
operator|=
name|next
expr_stmt|;
else|else
block|{
name|try
operator|->
name|u
operator|.
name|try
operator|.
name|catch
operator|=
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
name|remove_eh_handler
argument_list|(
name|try
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* LABEL heads a basic block that is about to be deleted.  If this    label corresponds to an exception region, we may be able to    delete the region.  */
end_comment

begin_function
name|void
name|maybe_remove_eh_handler
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|struct
name|ehl_map_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
comment|/* ??? After generating landing pads, it's not so simple to determine      if the region data is completely unused.  One must examine the      landing pad and the post landing pad, and whether an inner try block      is referencing the catch handlers directly.  */
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
return|return;
name|tmp
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|&
name|tmp
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return;
name|region
operator|=
operator|(
operator|*
name|slot
operator|)
operator|->
name|region
expr_stmt|;
if|if
condition|(
operator|!
name|region
condition|)
return|return;
comment|/* Flow will want to remove MUST_NOT_THROW regions as unreachable      because there is no path to the fallback call to terminate.      But the region continues to affect call-site data until there      are no more contained calls, which we don't see here.  */
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_MUST_NOT_THROW
condition|)
block|{
name|htab_clear_slot
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
name|region
operator|->
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
name|remove_eh_handler
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invokes CALLBACK for every exception handler label.  Only used by old    loop hackery; should not be used by new code.  */
end_comment

begin_function
name|void
name|for_each_eh_label
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
parameter_list|)
block|{
name|htab_traverse
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|exception_handler_label_map
argument_list|,
name|for_each_eh_label_1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|for_each_eh_label_1
parameter_list|(
name|void
modifier|*
modifier|*
name|pentry
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ehl_map_entry
modifier|*
name|entry
init|=
operator|*
operator|(
expr|struct
name|ehl_map_entry
operator|*
operator|*
operator|)
name|pentry
decl_stmt|;
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
init|=
operator|*
operator|(
name|void
argument_list|(
operator|*
operator|*
argument_list|)
operator|(
name|rtx
operator|)
operator|)
name|data
function_decl|;
call|(
modifier|*
name|callback
call|)
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Invoke CALLBACK for every exception region in the current function.  */
end_comment

begin_function
name|void
name|for_each_eh_region
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|eh_region
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|last_region_number
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section describes CFG exception edges for flow.  */
end_comment

begin_comment
comment|/* For communicating between calls to reachable_next_level.  */
end_comment

begin_struct
struct|struct
name|reachable_info
block|{
name|tree
name|types_caught
decl_stmt|;
name|tree
name|types_allowed
decl_stmt|;
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|eh_region
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|callback_data
decl_stmt|;
name|bool
name|saw_any_handlers
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A subroutine of reachable_next_level.  Return true if TYPE, or a    base class of TYPE, is in HANDLED.  */
end_comment

begin_function
specifier|static
name|int
name|check_handled
parameter_list|(
name|tree
name|handled
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* We can check for exact matches without front-end help.  */
if|if
condition|(
operator|!
name|lang_eh_type_covers
condition|)
block|{
for|for
control|(
name|t
operator|=
name|handled
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
for|for
control|(
name|t
operator|=
name|handled
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
call|(
modifier|*
name|lang_eh_type_covers
call|)
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of reachable_next_level.  If we are collecting a list    of handlers, add one.  After landing pad generation, reference    it instead of the handlers themselves.  Further, the handlers are    all wired together, so by referencing one, we've got them all.    Before landing pad generation we reference each handler individually.     LP_REGION contains the landing pad; REGION is the handler.  */
end_comment

begin_function
specifier|static
name|void
name|add_reachable_handler
parameter_list|(
name|struct
name|reachable_info
modifier|*
name|info
parameter_list|,
name|struct
name|eh_region
modifier|*
name|lp_region
parameter_list|,
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
if|if
condition|(
operator|!
name|info
condition|)
return|return;
name|info
operator|->
name|saw_any_handlers
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|)
name|info
operator|->
name|callback
argument_list|(
name|lp_region
argument_list|,
name|info
operator|->
name|callback_data
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|callback
argument_list|(
name|region
argument_list|,
name|info
operator|->
name|callback_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process one level of exception regions for reachability.    If TYPE_THROWN is non-null, then it is the *exact* type being    propagated.  If INFO is non-null, then collect handler labels    and caught/allowed type information between invocations.  */
end_comment

begin_function
specifier|static
name|enum
name|reachable_code
name|reachable_next_level
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|,
name|tree
name|type_thrown
parameter_list|,
name|struct
name|reachable_info
modifier|*
name|info
parameter_list|)
block|{
switch|switch
condition|(
name|region
operator|->
name|type
condition|)
block|{
case|case
name|ERT_CLEANUP
case|:
comment|/* Before landing-pad generation, we model control flow 	 directly to the individual handlers.  In this way we can 	 see that catch handler types may shadow one another.  */
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_MAYBE_CAUGHT
return|;
case|case
name|ERT_TRY
case|:
block|{
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|;
name|enum
name|reachable_code
name|ret
init|=
name|RNL_NOT_CAUGHT
decl_stmt|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|catch
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|next_catch
control|)
block|{
comment|/* A catch-all handler ends the search.  */
if|if
condition|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|==
name|NULL
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
if|if
condition|(
name|type_thrown
condition|)
block|{
comment|/* If we have at least one type match, end the search.  */
name|tree
name|tp_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
for|for
control|(
init|;
name|tp_node
condition|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|tp_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|type_thrown
operator|||
operator|(
name|lang_eh_type_covers
operator|&&
call|(
modifier|*
name|lang_eh_type_covers
call|)
argument_list|(
name|type
argument_list|,
name|type_thrown
argument_list|)
operator|)
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
block|}
comment|/* If we have definitive information of a match failure, 		   the catch won't trigger.  */
if|if
condition|(
name|lang_eh_type_covers
condition|)
return|return
name|RNL_NOT_CAUGHT
return|;
block|}
comment|/* At this point, we either don't know what type is thrown or 	       don't have front-end assistance to help deciding if it is 	       covered by one of the types in the list for this region.  	       We'd then like to add this region to the list of reachable 	       handlers since it is indeed potentially reachable based on the 	       information we have.  	       Actually, this handler is for sure not reachable if all the 	       types it matches have already been caught. That is, it is only 	       potentially reachable if at least one of the types it catches 	       has not been previously caught.  */
if|if
condition|(
operator|!
name|info
condition|)
name|ret
operator|=
name|RNL_MAYBE_CAUGHT
expr_stmt|;
else|else
block|{
name|tree
name|tp_node
init|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
decl_stmt|;
name|bool
name|maybe_reachable
init|=
name|false
decl_stmt|;
comment|/* Compute the potential reachability of this handler and 		   update the list of types caught at the same time.  */
for|for
control|(
init|;
name|tp_node
condition|;
name|tp_node
operator|=
name|TREE_CHAIN
argument_list|(
name|tp_node
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|tp_node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|check_handled
argument_list|(
name|info
operator|->
name|types_caught
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|info
operator|->
name|types_caught
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|type
argument_list|,
name|info
operator|->
name|types_caught
argument_list|)
expr_stmt|;
name|maybe_reachable
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maybe_reachable
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* ??? If the catch type is a base class of every allowed 		       type, then we know we can stop the search.  */
name|ret
operator|=
name|RNL_MAYBE_CAUGHT
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
comment|/* An empty list of types definitely ends the search.  */
if|if
condition|(
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
operator|==
name|NULL_TREE
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
comment|/* Collect a list of lists of allowed types for use in detecting 	 when a catch may be transformed into a catch-all.  */
if|if
condition|(
name|info
condition|)
name|info
operator|->
name|types_allowed
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
argument_list|,
name|info
operator|->
name|types_allowed
argument_list|)
expr_stmt|;
comment|/* If we have definitive information about the type hierarchy, 	 then we can tell if the thrown type will pass through the 	 filter.  */
if|if
condition|(
name|type_thrown
operator|&&
name|lang_eh_type_covers
condition|)
block|{
if|if
condition|(
name|check_handled
argument_list|(
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|type_list
argument_list|,
name|type_thrown
argument_list|)
condition|)
return|return
name|RNL_NOT_CAUGHT
return|;
else|else
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
block|}
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_MAYBE_CAUGHT
return|;
case|case
name|ERT_CATCH
case|:
comment|/* Catch regions are handled by their controlling try region.  */
return|return
name|RNL_NOT_CAUGHT
return|;
case|case
name|ERT_MUST_NOT_THROW
case|:
comment|/* Here we end our search, since no exceptions may propagate. 	 If we've touched down at some landing pad previous, then the 	 explicit function call we generated may be used.  Otherwise 	 the call is made by the runtime.           Before inlining, do not perform this optimization.  We may 	 inline a subroutine that contains handlers, and that will 	 change the value of saw_any_handlers.  */
if|if
condition|(
operator|(
name|info
operator|&&
name|info
operator|->
name|saw_any_handlers
operator|)
operator|||
operator|!
name|cfun
operator|->
name|after_inlining
condition|)
block|{
name|add_reachable_handler
argument_list|(
name|info
argument_list|,
name|region
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|RNL_CAUGHT
return|;
block|}
else|else
return|return
name|RNL_BLOCKED
return|;
case|case
name|ERT_THROW
case|:
case|case
name|ERT_UNKNOWN
case|:
comment|/* Shouldn't see these here.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Invoke CALLBACK on each region reachable from REGION_NUMBER.  */
end_comment

begin_function
name|void
name|foreach_reachable_handler
parameter_list|(
name|int
name|region_number
parameter_list|,
name|bool
name|is_resx
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|eh_region
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|struct
name|reachable_info
name|info
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|info
operator|.
name|callback_data
operator|=
name|callback_data
expr_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_number
argument_list|)
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|is_resx
condition|)
block|{
comment|/* A RESX leaves a region instead of entering it.  Thus the 	 region itself may have been deleted out from under us.  */
if|if
condition|(
name|region
operator|==
name|NULL
condition|)
return|return;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
while|while
condition|(
name|region
condition|)
block|{
if|if
condition|(
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
operator|&
name|info
argument_list|)
operator|>=
name|RNL_CAUGHT
condition|)
break|break;
comment|/* If we have processed one cleanup, there is no point in 	 processing any more of them.  Each cleanup will have an edge 	 to the next outer cleanup region, so the flow graph will be 	 accurate.  */
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_CLEANUP
condition|)
name|region
operator|=
name|region
operator|->
name|u
operator|.
name|cleanup
operator|.
name|prev_try
expr_stmt|;
else|else
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve a list of labels of exception handlers which can be    reached by a given insn.  */
end_comment

begin_function
specifier|static
name|void
name|arh_to_landing_pad
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
modifier|*
name|p_handlers
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|p_handlers
condition|)
operator|*
name|p_handlers
operator|=
name|alloc_INSN_LIST
argument_list|(
name|region
operator|->
name|landing_pad
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arh_to_label
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
modifier|*
name|p_handlers
init|=
name|data
decl_stmt|;
operator|*
name|p_handlers
operator|=
name|alloc_INSN_LIST
argument_list|(
name|region
operator|->
name|label
argument_list|,
operator|*
name|p_handlers
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|reachable_handlers
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|bool
name|is_resx
init|=
name|false
decl_stmt|;
name|rtx
name|handlers
init|=
name|NULL
decl_stmt|;
name|int
name|region_number
decl_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RESX
condition|)
block|{
name|region_number
operator|=
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|is_resx
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|region_number
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|foreach_reachable_handler
argument_list|(
name|region_number
argument_list|,
name|is_resx
argument_list|,
operator|(
name|cfun
operator|->
name|eh
operator|->
name|built_landing_pads
condition|?
name|arh_to_landing_pad
else|:
name|arh_to_label
operator|)
argument_list|,
operator|&
name|handlers
argument_list|)
expr_stmt|;
return|return
name|handlers
return|;
block|}
end_function

begin_comment
comment|/* Determine if the given INSN can throw an exception that is caught    within the function.  */
end_comment

begin_function
name|bool
name|can_throw_internal_1
parameter_list|(
name|int
name|region_number
parameter_list|,
name|bool
name|is_resx
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_number
argument_list|)
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|is_resx
condition|)
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
elseif|else
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
comment|/* If this exception is ignored by each and every containing region,      then control passes straight out.  The runtime may handle some      regions, which also do not require processing internally.  */
for|for
control|(
init|;
name|region
condition|;
name|region
operator|=
name|region
operator|->
name|outer
control|)
block|{
name|enum
name|reachable_code
name|how
init|=
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|how
operator|==
name|RNL_BLOCKED
condition|)
return|return
name|false
return|;
if|if
condition|(
name|how
operator|!=
name|RNL_NOT_CAUGHT
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|can_throw_internal
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RESX
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
return|return
name|can_throw_internal_1
argument_list|(
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Every insn that might throw has an EH_REGION note.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|can_throw_internal_1
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if the given INSN can throw an exception that is    visible outside the function.  */
end_comment

begin_function
name|bool
name|can_throw_external_1
parameter_list|(
name|int
name|region_number
parameter_list|,
name|bool
name|is_resx
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|tree
name|type_thrown
decl_stmt|;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|region_number
argument_list|)
expr_stmt|;
name|type_thrown
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|is_resx
condition|)
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
elseif|else
if|if
condition|(
name|region
operator|->
name|type
operator|==
name|ERT_THROW
condition|)
block|{
name|type_thrown
operator|=
name|region
operator|->
name|u
operator|.
name|throw
operator|.
name|type
expr_stmt|;
name|region
operator|=
name|region
operator|->
name|outer
expr_stmt|;
block|}
comment|/* If the exception is caught or blocked by any containing region,      then it is not seen by any calling function.  */
for|for
control|(
init|;
name|region
condition|;
name|region
operator|=
name|region
operator|->
name|outer
control|)
if|if
condition|(
name|reachable_next_level
argument_list|(
name|region
argument_list|,
name|type_thrown
argument_list|,
name|NULL
argument_list|)
operator|>=
name|RNL_CAUGHT
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|can_throw_external
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RESX
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
return|return
name|can_throw_external_1
argument_list|(
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
block|{
comment|/* Calls (and trapping insns) without notes are outside any 	 exception handling region in this function.  We have to 	 assume it might throw.  Given that the front end and middle 	 ends mark known NOTHROW functions, this isn't so wildly 	 inaccurate.  */
return|return
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|can_throw_external_1
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */
end_comment

begin_function
name|unsigned
name|int
name|set_nothrow_function_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* If we don't know that this implementation of the function will      actually be used, then we must not set TREE_NOTHROW, since      callers must not assume that this function does not throw.  */
if|if
condition|(
name|DECL_REPLACEABLE_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
literal|0
return|;
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Assume cfun->all_throwers_are_sibcalls until we encounter      something that can throw an exception.  We specifically exempt      CALL_INSNs that are SIBLING_CALL_P, as these are really jumps,      and can't throw.  Most CALL_INSNs are not SIBLING_CALL_P, so this      is optimistic.  */
name|cfun
operator|->
name|all_throwers_are_sibcalls
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|can_throw_external
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|all_throwers_are_sibcalls
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|can_throw_external
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|all_throwers_are_sibcalls
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_set_nothrow_function_flags
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|set_nothrow_function_flags
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Various hooks for unwind library.  */
end_comment

begin_comment
comment|/* Do any necessary initialization to access arbitrary stack frames.    On the SPARC, this means flushing the register windows.  */
end_comment

begin_function
name|void
name|expand_builtin_unwind_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set this so all the registers get saved in our frame; we need to be      able to copy the saved values for any registers from frames we unwind.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|rtx
name|expand_builtin_eh_return_data_regno
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|which
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|iwhich
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|which
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"argument of %<__builtin_eh_return_regno%> must be constant"
argument_list|)
expr_stmt|;
return|return
name|constm1_rtx
return|;
block|}
name|iwhich
operator|=
name|tree_low_cst
argument_list|(
name|which
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iwhich
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|iwhich
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwhich
operator|==
name|INVALID_REGNUM
condition|)
return|return
name|constm1_rtx
return|;
ifdef|#
directive|ifdef
name|DWARF_FRAME_REGNUM
name|iwhich
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|iwhich
argument_list|)
expr_stmt|;
else|#
directive|else
name|iwhich
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|iwhich
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|GEN_INT
argument_list|(
name|iwhich
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value extracted from the return address register or stack slot,    return the actual address encoded in that value.  */
end_comment

begin_function
name|rtx
name|expand_builtin_extract_return_addr
parameter_list|(
name|tree
name|addr_tree
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|#
directive|else
name|addr
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* First mask out any unwanted bits.  */
ifdef|#
directive|ifdef
name|MASK_RETURN_ADDR
name|expand_and
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|MASK_RETURN_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Then adjust to find the real return address.  */
if|#
directive|if
name|defined
argument_list|(
name|RETURN_ADDR_OFFSET
argument_list|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Given an actual address in addr_tree, do any necessary encoding    and return the value to be stored in the return address register or    stack slot so the epilogue will return to that address.  */
end_comment

begin_function
name|rtx
name|expand_builtin_frob_return_addr
parameter_list|(
name|tree
name|addr_tree
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ADDR_OFFSET
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|-
name|RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Set up the epilogue with the magic bits we'll need to return to the    exception handler.  */
end_comment

begin_function
name|void
name|expand_builtin_eh_return
parameter_list|(
name|tree
name|stackadj_tree
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|handler_tree
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
name|tmp
operator|=
name|expand_expr
argument_list|(
name|stackadj_tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
condition|)
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
operator|=
name|copy_to_reg
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
condition|)
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|expand_expr
argument_list|(
name|handler_tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
condition|)
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
operator|=
name|copy_to_reg
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
condition|)
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
condition|)
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_eh_return
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|around_label
decl_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
condition|)
return|return;
name|current_function_calls_eh_return
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
name|emit_move_insn
argument_list|(
name|EH_RETURN_STACKADJ_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|around_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_label
argument_list|)
expr_stmt|;
name|clobber_return_register
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
name|emit_move_insn
argument_list|(
name|EH_RETURN_STACKADJ_RTX
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_stackadj
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_eh_return
if|if
condition|(
name|HAVE_eh_return
condition|)
name|emit_insn
argument_list|(
name|gen_eh_return
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|EH_RETURN_HANDLER_RTX
name|emit_move_insn
argument_list|(
name|EH_RETURN_HANDLER_RTX
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ehr_handler
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"__builtin_eh_return not supported on this target"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|emit_label
argument_list|(
name|around_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a ptr_mode address ADDR_TREE to a Pmode address controlled by    POINTERS_EXTEND_UNSIGNED and return it.  */
end_comment

begin_function
name|rtx
name|expand_builtin_extend_pointer
parameter_list|(
name|tree
name|addr_tree
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|extend
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|extend
operator|=
name|POINTERS_EXTEND_UNSIGNED
expr_stmt|;
else|#
directive|else
comment|/* The previous EH code did an unsigned extend by default, so we do this also      for consistency.  */
name|extend
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|convert_modes
argument_list|(
name|word_mode
argument_list|,
name|ptr_mode
argument_list|,
name|addr
argument_list|,
name|extend
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In the following functions, we represent entries in the action table    as 1-based indices.  Special cases are:  	 0:	null action record, non-null landing pad; implies cleanups 	-1:	null action record, null landing pad; implies no action 	-2:	no call-site entry; implies must_not_throw 	-3:	we have yet to process outer regions     Further, no special cases apply to the "next" field of the record.    For next, 0 means end of list.  */
end_comment

begin_struct
struct|struct
name|action_record
block|{
name|int
name|offset
decl_stmt|;
name|int
name|filter
decl_stmt|;
name|int
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|action_record_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|)
block|{
specifier|const
name|struct
name|action_record
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|action_record
operator|*
operator|)
name|pentry
decl_stmt|;
specifier|const
name|struct
name|action_record
modifier|*
name|data
init|=
operator|(
specifier|const
expr|struct
name|action_record
operator|*
operator|)
name|pdata
decl_stmt|;
return|return
name|entry
operator|->
name|filter
operator|==
name|data
operator|->
name|filter
operator|&&
name|entry
operator|->
name|next
operator|==
name|data
operator|->
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|action_record_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|pentry
parameter_list|)
block|{
specifier|const
name|struct
name|action_record
modifier|*
name|entry
init|=
operator|(
specifier|const
expr|struct
name|action_record
operator|*
operator|)
name|pentry
decl_stmt|;
return|return
name|entry
operator|->
name|next
operator|*
literal|1009
operator|+
name|entry
operator|->
name|filter
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_action_record
parameter_list|(
name|htab_t
name|ar_hash
parameter_list|,
name|int
name|filter
parameter_list|,
name|int
name|next
parameter_list|)
block|{
name|struct
name|action_record
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|tmp
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|tmp
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|action_record
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|ar_hash
argument_list|,
operator|&
name|tmp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
operator|*
name|slot
operator|)
operator|==
name|NULL
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|offset
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|new
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|next
expr_stmt|;
operator|*
name|slot
operator|=
name|new
expr_stmt|;
comment|/* The filter value goes in untouched.  The link to the next 	 record is a "self-relative" byte offset, or zero to indicate 	 that there is no next record.  So convert the absolute 1 based 	 indices we've been carrying around into a displacement.  */
name|push_sleb128
argument_list|(
operator|&
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|-=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|push_sleb128
argument_list|(
operator|&
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|new
operator|->
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_one_action_chain
parameter_list|(
name|htab_t
name|ar_hash
parameter_list|,
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|c
decl_stmt|;
name|int
name|next
decl_stmt|;
comment|/* If we've reached the top of the region chain, then we have      no actions, and require no landing pad.  */
if|if
condition|(
name|region
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|region
operator|->
name|type
condition|)
block|{
case|case
name|ERT_CLEANUP
case|:
comment|/* A cleanup adds a zero filter to the beginning of the chain, but 	 there are special cases to look out for.  If there are *only* 	 cleanups along a path, then it compresses to a zero action. 	 Further, if there are multiple cleanups along a path, we only 	 need to represent one of them, as that is enough to trigger 	 entry to the landing pad at runtime.  */
name|next
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|outer
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|outer
control|)
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|ERT_CLEANUP
condition|)
return|return
name|next
return|;
return|return
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
literal|0
argument_list|,
name|next
argument_list|)
return|;
case|case
name|ERT_TRY
case|:
comment|/* Process the associated catch regions in reverse order. 	 If there's a catch-all handler, then we don't need to 	 search outer regions.  Use a magic -3 value to record 	 that we haven't done the outer search.  */
name|next
operator|=
operator|-
literal|3
expr_stmt|;
for|for
control|(
name|c
operator|=
name|region
operator|->
name|u
operator|.
name|try
operator|.
name|last_catch
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|prev_catch
control|)
block|{
if|if
condition|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|type_list
operator|==
name|NULL
condition|)
block|{
comment|/* Retrieve the filter from the head of the filter list 		 where we have stored it (see assign_filter_values).  */
name|int
name|filter
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|=
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
name|filter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Once the outer search is done, trigger an action record for                  each filter we have.  */
name|tree
name|flt_node
decl_stmt|;
if|if
condition|(
name|next
operator|==
operator|-
literal|3
condition|)
block|{
name|next
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
expr_stmt|;
comment|/* If there is no next action, terminate the chain.  */
if|if
condition|(
name|next
operator|==
operator|-
literal|1
condition|)
name|next
operator|=
literal|0
expr_stmt|;
comment|/* If all outer actions are cleanups or must_not_throw, 		     we'll have no action record for it, since we had wanted 		     to encode these states in the call-site record directly. 		     Add a cleanup action to the chain to catch these.  */
elseif|else
if|if
condition|(
name|next
operator|<=
literal|0
condition|)
name|next
operator|=
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|flt_node
operator|=
name|c
operator|->
name|u
operator|.
name|catch
operator|.
name|filter_list
expr_stmt|;
for|for
control|(
init|;
name|flt_node
condition|;
name|flt_node
operator|=
name|TREE_CHAIN
argument_list|(
name|flt_node
argument_list|)
control|)
block|{
name|int
name|filter
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|flt_node
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|=
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
name|filter
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|next
return|;
case|case
name|ERT_ALLOWED_EXCEPTIONS
case|:
comment|/* An exception specification adds its filter to the 	 beginning of the chain.  */
name|next
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
expr_stmt|;
comment|/* If there is no next action, terminate the chain.  */
if|if
condition|(
name|next
operator|==
operator|-
literal|1
condition|)
name|next
operator|=
literal|0
expr_stmt|;
comment|/* If all outer actions are cleanups or must_not_throw, 	 we'll have no action record for it, since we had wanted 	 to encode these states in the call-site record directly. 	 Add a cleanup action to the chain to catch these.  */
elseif|else
if|if
condition|(
name|next
operator|<=
literal|0
condition|)
name|next
operator|=
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|add_action_record
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|u
operator|.
name|allowed
operator|.
name|filter
argument_list|,
name|next
argument_list|)
return|;
case|case
name|ERT_MUST_NOT_THROW
case|:
comment|/* A must-not-throw region with no inner handlers or cleanups 	 requires no call-site entry.  Note that this differs from 	 the no handler or cleanup case in that we do require an lsda 	 to be generated.  Return a magic -2 value to record this.  */
return|return
operator|-
literal|2
return|;
case|case
name|ERT_CATCH
case|:
case|case
name|ERT_THROW
case|:
comment|/* CATCH regions are handled in TRY above.  THROW regions are 	 for optimization information only and produce no output.  */
return|return
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
operator|->
name|outer
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|add_call_site
parameter_list|(
name|rtx
name|landing_pad
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|call_site_record
modifier|*
name|data
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
decl_stmt|;
name|int
name|used
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|size
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_size
decl_stmt|;
if|if
condition|(
name|used
operator|>=
name|size
condition|)
block|{
name|size
operator|=
operator|(
name|size
condition|?
name|size
operator|*
literal|2
else|:
literal|64
operator|)
expr_stmt|;
name|data
operator|=
name|ggc_realloc
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
operator|=
name|data
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_size
operator|=
name|size
expr_stmt|;
block|}
name|data
index|[
name|used
index|]
operator|.
name|landing_pad
operator|=
name|landing_pad
expr_stmt|;
name|data
index|[
name|used
index|]
operator|.
name|action
operator|=
name|action
expr_stmt|;
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
operator|=
name|used
operator|+
literal|1
expr_stmt|;
return|return
name|used
operator|+
name|call_site_base
return|;
block|}
end_function

begin_comment
comment|/* Turn REG_EH_REGION notes back into NOTE_INSN_EH_REGION notes.    The new note numbers will not refer to region numbers, but    instead to call site entries.  */
end_comment

begin_function
name|unsigned
name|int
name|convert_to_eh_region_ranges
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|iter
decl_stmt|,
name|note
decl_stmt|;
name|htab_t
name|ar_hash
decl_stmt|;
name|int
name|last_action
init|=
operator|-
literal|3
decl_stmt|;
name|rtx
name|last_action_insn
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|last_landing_pad
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|first_no_action_insn
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|call_site
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
operator|||
name|cfun
operator|->
name|eh
operator|->
name|region_tree
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|VARRAY_UCHAR_INIT
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
literal|64
argument_list|,
literal|"action_record_data"
argument_list|)
expr_stmt|;
name|ar_hash
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|action_record_hash
argument_list|,
name|action_record_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|get_insns
argument_list|()
init|;
name|iter
condition|;
name|iter
operator|=
name|NEXT_INSN
argument_list|(
name|iter
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|iter
argument_list|)
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
name|int
name|this_action
decl_stmt|;
name|rtx
name|this_landing_pad
decl_stmt|;
name|insn
operator|=
name|iter
expr_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
name|this_action
operator|=
operator|-
literal|1
expr_stmt|;
name|region
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|region
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this_action
operator|=
name|collect_one_action_chain
argument_list|(
name|ar_hash
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
comment|/* Existence of catch handlers, or must-not-throw regions 	   implies that an lsda is needed (even if empty).  */
if|if
condition|(
name|this_action
operator|!=
operator|-
literal|1
condition|)
name|cfun
operator|->
name|uses_eh_lsda
operator|=
literal|1
expr_stmt|;
comment|/* Delay creation of region notes for no-action regions 	   until we're sure that an lsda will be required.  */
elseif|else
if|if
condition|(
name|last_action
operator|==
operator|-
literal|3
condition|)
block|{
name|first_no_action_insn
operator|=
name|iter
expr_stmt|;
name|last_action
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Cleanups and handlers may share action chains but not 	   landing pads.  Collect the landing pad for this region.  */
if|if
condition|(
name|this_action
operator|>=
literal|0
condition|)
block|{
name|struct
name|eh_region
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|region
init|;
operator|!
name|o
operator|->
name|landing_pad
condition|;
name|o
operator|=
name|o
operator|->
name|outer
control|)
continue|continue;
name|this_landing_pad
operator|=
name|o
operator|->
name|landing_pad
expr_stmt|;
block|}
else|else
name|this_landing_pad
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Differing actions or landing pads implies a change in call-site 	   info, which implies some EH_REGION note should be emitted.  */
if|if
condition|(
name|last_action
operator|!=
name|this_action
operator|||
name|last_landing_pad
operator|!=
name|this_landing_pad
condition|)
block|{
comment|/* If we'd not seen a previous action (-3) or the previous 	       action was must-not-throw (-2), then we do not need an 	       end note.  */
if|if
condition|(
name|last_action
operator|>=
operator|-
literal|1
condition|)
block|{
comment|/* If we delayed the creation of the begin, do it now.  */
if|if
condition|(
name|first_no_action_insn
condition|)
block|{
name|call_site
operator|=
name|add_call_site
argument_list|(
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_EH_REGION_BEG
argument_list|,
name|first_no_action_insn
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
name|first_no_action_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_EH_REGION_END
argument_list|,
name|last_action_insn
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
block|}
comment|/* If the new action is must-not-throw, then no region notes 	       are created.  */
if|if
condition|(
name|this_action
operator|>=
operator|-
literal|1
condition|)
block|{
name|call_site
operator|=
name|add_call_site
argument_list|(
name|this_landing_pad
argument_list|,
name|this_action
operator|<
literal|0
condition|?
literal|0
else|:
name|this_action
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_EH_REGION_BEG
argument_list|,
name|iter
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
block|}
name|last_action
operator|=
name|this_action
expr_stmt|;
name|last_landing_pad
operator|=
name|this_landing_pad
expr_stmt|;
block|}
name|last_action_insn
operator|=
name|iter
expr_stmt|;
block|}
if|if
condition|(
name|last_action
operator|>=
operator|-
literal|1
operator|&&
operator|!
name|first_no_action_insn
condition|)
block|{
name|note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_EH_REGION_END
argument_list|,
name|last_action_insn
argument_list|)
expr_stmt|;
name|NOTE_EH_HANDLER
argument_list|(
name|note
argument_list|)
operator|=
name|call_site
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|ar_hash
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_convert_to_eh_region_ranges
init|=
block|{
literal|"eh-ranges"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|convert_to_eh_region_ranges
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|push_uleb128
parameter_list|(
name|varray_type
modifier|*
name|data_area
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
do|do
block|{
name|unsigned
name|char
name|byte
init|=
name|value
operator|&
literal|0x7f
decl_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
name|VARRAY_PUSH_UCHAR
argument_list|(
operator|*
name|data_area
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|value
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_sleb128
parameter_list|(
name|varray_type
modifier|*
name|data_area
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|char
name|byte
decl_stmt|;
name|int
name|more
decl_stmt|;
do|do
block|{
name|byte
operator|=
name|value
operator|&
literal|0x7f
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
name|more
operator|=
operator|!
operator|(
operator|(
name|value
operator|==
literal|0
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|value
operator|==
operator|-
literal|1
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
name|VARRAY_PUSH_UCHAR
argument_list|(
operator|*
name|data_area
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_AS_LEB128
end_ifndef

begin_function
specifier|static
name|int
name|dw2_size_of_call_site_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|size
init|=
name|n
operator|*
operator|(
literal|4
operator|+
literal|4
operator|+
literal|4
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sjlj_size_of_call_site_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|INTVAL
argument_list|(
name|cs
operator|->
name|landing_pad
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dw2_output_call_site_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|char
name|reg_start_lab
index|[
literal|32
index|]
decl_stmt|;
name|char
name|reg_end_lab
index|[
literal|32
index|]
decl_stmt|;
name|char
name|landing_pad_lab
index|[
literal|32
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|reg_start_lab
argument_list|,
literal|"LEHB"
argument_list|,
name|call_site_base
operator|+
name|i
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|reg_end_lab
argument_list|,
literal|"LEHE"
argument_list|,
name|call_site_base
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|landing_pad
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|landing_pad_lab
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|cs
operator|->
name|landing_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Perhaps use insn length scaling if the assembler supports 	 generic arithmetic.  */
comment|/* ??? Perhaps use attr_length to choose data1 or data2 instead of 	 data4 if the function is small enough.  */
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|dw2_asm_output_delta_uleb128
argument_list|(
name|reg_start_lab
argument_list|,
name|current_function_func_begin_label
argument_list|,
literal|"region %d start"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta_uleb128
argument_list|(
name|reg_end_lab
argument_list|,
name|reg_start_lab
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|landing_pad
condition|)
name|dw2_asm_output_delta_uleb128
argument_list|(
name|landing_pad_lab
argument_list|,
name|current_function_func_begin_label
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|reg_start_lab
argument_list|,
name|current_function_func_begin_label
argument_list|,
literal|"region %d start"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|reg_end_lab
argument_list|,
name|reg_start_lab
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|landing_pad
condition|)
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|landing_pad_lab
argument_list|,
name|current_function_func_begin_label
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"landing pad"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dw2_asm_output_data_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|,
literal|"action"
argument_list|)
expr_stmt|;
block|}
name|call_site_base
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sjlj_output_call_site_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
init|=
name|cfun
operator|->
name|eh
operator|->
name|call_site_data_used
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|call_site_record
modifier|*
name|cs
init|=
operator|&
name|cfun
operator|->
name|eh
operator|->
name|call_site_data
index|[
name|i
index|]
decl_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|INTVAL
argument_list|(
name|cs
operator|->
name|landing_pad
argument_list|)
argument_list|,
literal|"region %d landing pad"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|cs
operator|->
name|action
argument_list|,
literal|"action"
argument_list|)
expr_stmt|;
block|}
name|call_site_base
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_UNWIND_INFO
end_ifndef

begin_comment
comment|/* Switch to the section that should be used for exception tables.  */
end_comment

begin_function
specifier|static
name|void
name|switch_to_exception_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|exception_section
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|EH_TABLES_CAN_BE_READ_ONLY
condition|)
block|{
name|int
name|tt_format
init|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|0
argument_list|,
comment|/*global=*/
literal|1
argument_list|)
decl_stmt|;
name|flags
operator|=
operator|(
operator|(
operator|!
name|flag_pic
operator|||
operator|(
operator|(
name|tt_format
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_absptr
operator|&&
operator|(
name|tt_format
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_aligned
operator|)
operator|)
condition|?
literal|0
else|:
name|SECTION_WRITE
operator|)
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
name|exception_section
operator|=
name|get_section
argument_list|(
literal|".gcc_except_table"
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|exception_section
operator|=
name|flag_pic
condition|?
name|data_section
else|:
name|readonly_data_section
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|exception_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output a reference from an exception table to the type_info object TYPE.    TT_FORMAT and TT_FORMAT_SIZE describe the DWARF encoding method used for    the value.  */
end_comment

begin_function
specifier|static
name|void
name|output_ttype
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|tt_format
parameter_list|,
name|int
name|tt_format_size
parameter_list|)
block|{
name|rtx
name|value
decl_stmt|;
name|bool
name|public
init|=
name|true
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|value
operator|=
name|const0_rtx
expr_stmt|;
else|else
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
decl_stmt|;
name|type
operator|=
name|lookup_type_for_runtime
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|type
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
comment|/* Let cgraph know that the rtti decl is used.  Not all of the 	 paths below go through assemble_integer, which would take 	 care of this for us.  */
name|STRIP_NOPS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|node
operator|=
name|cgraph_varpool_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|public
operator|=
name|TREE_PUBLIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
block|}
comment|/* Allow the target to override the type table entry format.  */
if|if
condition|(
name|targetm
operator|.
name|asm_out
operator|.
name|ttype
argument_list|(
name|value
argument_list|)
condition|)
return|return;
if|if
condition|(
name|tt_format
operator|==
name|DW_EH_PE_absptr
operator|||
name|tt_format
operator|==
name|DW_EH_PE_aligned
condition|)
name|assemble_integer
argument_list|(
name|value
argument_list|,
name|tt_format_size
argument_list|,
name|tt_format_size
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|tt_format
argument_list|,
name|value
argument_list|,
name|public
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_function_exception_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|tt_format
decl_stmt|,
name|cs_format
decl_stmt|,
name|lp_format
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|char
name|ttype_label
index|[
literal|32
index|]
decl_stmt|;
name|char
name|cs_after_size_label
index|[
literal|32
index|]
decl_stmt|;
name|char
name|cs_end_label
index|[
literal|32
index|]
decl_stmt|;
else|#
directive|else
name|int
name|call_site_len
decl_stmt|;
endif|#
directive|endif
name|int
name|have_tt_data
decl_stmt|;
name|int
name|tt_format_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|eh_personality_libfunc
condition|)
name|assemble_external_libcall
argument_list|(
name|eh_personality_libfunc
argument_list|)
expr_stmt|;
comment|/* Not all functions need anything.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|uses_eh_lsda
condition|)
return|return;
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
comment|/* TODO: Move this into target file.  */
name|fputs
argument_list|(
literal|"\t.personality\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|eh_personality_libfunc
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\t.handlerdata\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Note that varasm still thinks we're in the function's code section.      The ".endp" directive that will immediately follow will take us back.  */
else|#
directive|else
name|switch_to_exception_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If the target wants a label to begin the table, emit it here.  */
name|targetm
operator|.
name|asm_out
operator|.
name|except_table_label
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|have_tt_data
operator|=
operator|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
operator|>
literal|0
operator|||
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* Indicate the format of the @TType entries.  */
if|if
condition|(
operator|!
name|have_tt_data
condition|)
name|tt_format
operator|=
name|DW_EH_PE_omit
expr_stmt|;
else|else
block|{
name|tt_format
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|0
argument_list|,
comment|/*global=*/
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ttype_label
argument_list|,
literal|"LLSDATT"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tt_format_size
operator|=
name|size_of_encoded_value
argument_list|(
name|tt_format
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|tt_format_size
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"LLSDA"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
comment|/* The LSDA header.  */
comment|/* Indicate the format of the landing pad start pointer.  An omitted      field implies @LPStart == @Start.  */
comment|/* Currently we always put @LPStart == @Start.  This field would      be most useful in moving the landing pads completely out of      line to another section, but it could also be used to minimize      the size of uleb128 landing pad offsets.  */
name|lp_format
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|lp_format
argument_list|,
literal|"@LPStart format (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|lp_format
argument_list|)
argument_list|)
expr_stmt|;
comment|/* @LPStart pointer would go here.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|tt_format
argument_list|,
literal|"@TType format (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|tt_format
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_AS_LEB128
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|call_site_len
operator|=
name|sjlj_size_of_call_site_table
argument_list|()
expr_stmt|;
else|else
name|call_site_len
operator|=
name|dw2_size_of_call_site_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* A pc-relative 4-byte displacement to the @TType data.  */
if|if
condition|(
name|have_tt_data
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|char
name|ttype_after_disp_label
index|[
literal|32
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ttype_after_disp_label
argument_list|,
literal|"LLSDATTD"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta_uleb128
argument_list|(
name|ttype_label
argument_list|,
name|ttype_after_disp_label
argument_list|,
literal|"@TType base offset"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|ttype_after_disp_label
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Ug.  Alignment queers things.  */
name|unsigned
name|int
name|before_disp
decl_stmt|,
name|after_disp
decl_stmt|,
name|last_disp
decl_stmt|,
name|disp
decl_stmt|;
name|before_disp
operator|=
literal|1
operator|+
literal|1
expr_stmt|;
name|after_disp
operator|=
operator|(
literal|1
operator|+
name|size_of_uleb128
argument_list|(
name|call_site_len
argument_list|)
operator|+
name|call_site_len
operator|+
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
operator|+
operator|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
operator|*
name|tt_format_size
operator|)
operator|)
expr_stmt|;
name|disp
operator|=
name|after_disp
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|disp_size
decl_stmt|,
name|pad
decl_stmt|;
name|last_disp
operator|=
name|disp
expr_stmt|;
name|disp_size
operator|=
name|size_of_uleb128
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|pad
operator|=
name|before_disp
operator|+
name|disp_size
operator|+
name|after_disp
expr_stmt|;
if|if
condition|(
name|pad
operator|%
name|tt_format_size
condition|)
name|pad
operator|=
name|tt_format_size
operator|-
operator|(
name|pad
operator|%
name|tt_format_size
operator|)
expr_stmt|;
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|disp
operator|=
name|after_disp
operator|+
name|pad
expr_stmt|;
block|}
do|while
condition|(
name|disp
operator|!=
name|last_disp
condition|)
do|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|disp
argument_list|,
literal|"@TType base offset"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Indicate the format of the call-site offsets.  */
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|cs_format
operator|=
name|DW_EH_PE_uleb128
expr_stmt|;
else|#
directive|else
name|cs_format
operator|=
name|DW_EH_PE_udata4
expr_stmt|;
endif|#
directive|endif
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|cs_format
argument_list|,
literal|"call-site format (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|cs_format
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|cs_after_size_label
argument_list|,
literal|"LLSDACSB"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|cs_end_label
argument_list|,
literal|"LLSDACSE"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta_uleb128
argument_list|(
name|cs_end_label
argument_list|,
name|cs_after_size_label
argument_list|,
literal|"Call-site table length"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cs_after_size_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|sjlj_output_call_site_table
argument_list|()
expr_stmt|;
else|else
name|dw2_output_call_site_table
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cs_end_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_asm_output_data_uleb128
argument_list|(
name|call_site_len
argument_list|,
literal|"Call-site table length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|sjlj_output_call_site_table
argument_list|()
expr_stmt|;
else|else
name|dw2_output_call_site_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ??? Decode and interpret the data for flag_debug_asm.  */
name|n
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|VARRAY_UCHAR
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|action_record_data
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|i
condition|?
name|NULL
else|:
literal|"Action record table"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_tt_data
condition|)
name|assemble_align
argument_list|(
name|tt_format_size
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|i
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|ttype_data
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|output_ttype
argument_list|(
name|type
argument_list|,
name|tt_format
argument_list|,
name|tt_format_size
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
if|if
condition|(
name|have_tt_data
condition|)
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|ttype_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ??? Decode and interpret the data for flag_debug_asm.  */
name|n
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|targetm
operator|.
name|arm_eabi_unwinder
condition|)
block|{
name|tree
name|type
init|=
name|VARRAY_TREE
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|output_ttype
argument_list|(
name|type
argument_list|,
name|tt_format
argument_list|,
name|tt_format_size
argument_list|)
expr_stmt|;
block|}
else|else
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|VARRAY_UCHAR
argument_list|(
name|cfun
operator|->
name|eh
operator|->
name|ehspec_data
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|i
condition|?
name|NULL
else|:
literal|"Exception specification table"
operator|)
argument_list|)
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_eh_throw_stmt_table
parameter_list|(
name|struct
name|function
modifier|*
name|fun
parameter_list|,
name|struct
name|htab
modifier|*
name|table
parameter_list|)
block|{
name|fun
operator|->
name|eh
operator|->
name|throw_stmt_table
operator|=
name|table
expr_stmt|;
block|}
end_function

begin_function
name|htab_t
name|get_eh_throw_stmt_table
parameter_list|(
name|struct
name|function
modifier|*
name|fun
parameter_list|)
block|{
return|return
name|fun
operator|->
name|eh
operator|->
name|throw_stmt_table
return|;
block|}
end_function

begin_comment
comment|/* Dump EH information to OUT.  */
end_comment

begin_function
name|void
name|dump_eh_tree
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|struct
name|function
modifier|*
name|fun
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|i
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|type_name
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"cleanup"
block|,
literal|"try"
block|,
literal|"catch"
block|,
literal|"allowed_exceptions"
block|,
literal|"must_not_throw"
block|,
literal|"throw"
block|}
decl_stmt|;
name|i
operator|=
name|fun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Eh tree:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  %*s %i %s"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
name|i
operator|->
name|region_number
argument_list|,
name|type_name
index|[
operator|(
name|int
operator|)
name|i
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|tree_label
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" tree_label:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|out
argument_list|,
name|i
operator|->
name|tree_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If there are sub-regions, process them.  */
if|if
condition|(
name|i
operator|->
name|inner
condition|)
name|i
operator|=
name|i
operator|->
name|inner
operator|,
name|depth
operator|++
expr_stmt|;
comment|/* If there are peers, process them.  */
elseif|else
if|if
condition|(
name|i
operator|->
name|next_peer
condition|)
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
comment|/* Otherwise, step back up the tree to the next peer.  */
else|else
block|{
do|do
block|{
name|i
operator|=
name|i
operator|->
name|outer
expr_stmt|;
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
return|return;
block|}
do|while
condition|(
name|i
operator|->
name|next_peer
operator|==
name|NULL
condition|)
do|;
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Verify some basic invariants on EH datastructures.  Could be extended to    catch more.  */
end_comment

begin_function
name|void
name|verify_eh_tree
parameter_list|(
name|struct
name|function
modifier|*
name|fun
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|i
decl_stmt|,
modifier|*
name|outer
init|=
name|NULL
decl_stmt|;
name|bool
name|err
init|=
name|false
decl_stmt|;
name|int
name|nvisited
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|fun
operator|->
name|eh
operator|->
name|region_tree
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
return|return;
for|for
control|(
name|j
operator|=
name|fun
operator|->
name|eh
operator|->
name|last_region_number
init|;
name|j
operator|>
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
operator|(
name|i
operator|=
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|j
argument_list|)
operator|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|region_number
operator|!=
name|j
condition|)
block|{
name|error
argument_list|(
literal|"region_array is corrupted for region %i"
argument_list|,
name|i
operator|->
name|region_number
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|VEC_index
argument_list|(
name|eh_region
argument_list|,
name|cfun
operator|->
name|eh
operator|->
name|region_array
argument_list|,
name|i
operator|->
name|region_number
argument_list|)
operator|!=
name|i
condition|)
block|{
name|error
argument_list|(
literal|"region_array is corrupted for region %i"
argument_list|,
name|i
operator|->
name|region_number
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|->
name|outer
operator|!=
name|outer
condition|)
block|{
name|error
argument_list|(
literal|"outer block of region %i is wrong"
argument_list|,
name|i
operator|->
name|region_number
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|->
name|may_contain_throw
operator|&&
name|outer
operator|&&
operator|!
name|outer
operator|->
name|may_contain_throw
condition|)
block|{
name|error
argument_list|(
literal|"region %i may contain throw and is contained in region that may not"
argument_list|,
name|i
operator|->
name|region_number
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"negative nesting depth of region %i"
argument_list|,
name|i
operator|->
name|region_number
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
name|nvisited
operator|++
expr_stmt|;
comment|/* If there are sub-regions, process them.  */
if|if
condition|(
name|i
operator|->
name|inner
condition|)
name|outer
operator|=
name|i
operator|,
name|i
operator|=
name|i
operator|->
name|inner
operator|,
name|depth
operator|++
expr_stmt|;
comment|/* If there are peers, process them.  */
elseif|else
if|if
condition|(
name|i
operator|->
name|next_peer
condition|)
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
comment|/* Otherwise, step back up the tree to the next peer.  */
else|else
block|{
do|do
block|{
name|i
operator|=
name|i
operator|->
name|outer
expr_stmt|;
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|depth
operator|!=
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"tree list ends on depth %i"
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
name|nvisited
condition|)
block|{
name|error
argument_list|(
literal|"array does not match the region tree"
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|dump_eh_tree
argument_list|(
name|stderr
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"verify_eh_tree failed"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|outer
operator|=
name|i
operator|->
name|outer
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|->
name|next_peer
operator|==
name|NULL
condition|)
do|;
name|i
operator|=
name|i
operator|->
name|next_peer
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize unwind_resume_libfunc.  */
end_comment

begin_function
name|void
name|default_init_unwind_resume_libfunc
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The default c++ routines aren't actually c++ specific, so use those.  */
name|unwind_resume_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"_Unwind_SjLj_Resume"
else|:
literal|"_Unwind_Resume"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_eh
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|doing_eh
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Complete generation of exception handling code.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_eh
parameter_list|(
name|void
parameter_list|)
block|{
name|cleanup_cfg
argument_list|(
name|CLEANUP_NO_INSN_DEL
argument_list|)
expr_stmt|;
name|finish_eh_generation
argument_list|()
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_NO_INSN_DEL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_rtl_eh
init|=
block|{
literal|"eh"
block|,
comment|/* name */
name|gate_handle_eh
block|,
comment|/* gate */
name|rest_of_handle_eh
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_JUMP
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'h'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-except.h"
end_include

end_unit

