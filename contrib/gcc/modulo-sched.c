begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Swing Modulo Scheduling implementation.    Copyright (C) 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Ayal Zaks and Mustafa Hagog<zaks,mustafa@il.ibm.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfghooks.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"ddg.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* This file contains the implementation of the Swing Modulo Scheduler,    described in the following references:    [1] J. Llosa, A. Gonzalez, E. Ayguade, M. Valero., and J. Eckhardt.        Lifetime--sensitive modulo scheduling in a production environment.        IEEE Trans. on Comps., 50(3), March 2001    [2] J. Llosa, A. Gonzalez, E. Ayguade, and M. Valero.        Swing Modulo Scheduling: A Lifetime Sensitive Approach.        PACT '96 , pages 80-87, October 1996 (Boston - Massachusetts - USA).     The basic structure is:    1. Build a data-dependence graph (DDG) for each loop.    2. Use the DDG to order the insns of a loop (not in topological order       necessarily, but rather) trying to place each insn after all its       predecessors _or_ after all its successors.    3. Compute MII: a lower bound on the number of cycles to schedule the loop.    4. Use the ordering to perform list-scheduling of the loop:       1. Set II = MII.  We will try to schedule the loop within II cycles.       2. Try to schedule the insns one by one according to the ordering. 	 For each insn compute an interval of cycles by considering already- 	 scheduled preds and succs (and associated latencies); try to place 	 the insn in the cycles of this window checking for potential 	 resource conflicts (using the DFA interface). 	 Note: this is different from the cycle-scheduling of schedule_insns; 	 here the insns are not scheduled monotonically top-down (nor bottom- 	 up).       3. If failed in scheduling all insns - bump II++ and try again, unless 	 II reaches an upper bound MaxII, in which case report failure.    5. If we succeeded in scheduling the loop within II cycles, we now       generate prolog and epilog, decrease the counter of the loop, and       perform modulo variable expansion for live ranges that span more than       II cycles (i.e. use register copies to prevent a def from overwriting       itself before reaching the use). */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This page defines partial-schedule structures and functions for    modulo scheduling.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|partial_schedule
modifier|*
name|partial_schedule_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|ps_insn
modifier|*
name|ps_insn_ptr
typedef|;
end_typedef

begin_comment
comment|/* The minimum (absolute) cycle that a node of ps was scheduled in.  */
end_comment

begin_define
define|#
directive|define
name|PS_MIN_CYCLE
parameter_list|(
name|ps
parameter_list|)
value|(((partial_schedule_ptr)(ps))->min_cycle)
end_define

begin_comment
comment|/* The maximum (absolute) cycle that a node of ps was scheduled in.  */
end_comment

begin_define
define|#
directive|define
name|PS_MAX_CYCLE
parameter_list|(
name|ps
parameter_list|)
value|(((partial_schedule_ptr)(ps))->max_cycle)
end_define

begin_comment
comment|/* Perform signed modulo, always returning a non-negative value.  */
end_comment

begin_define
define|#
directive|define
name|SMODULO
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) % (y)< 0 ? ((x) % (y) + (y)) : (x) % (y))
end_define

begin_comment
comment|/* The number of different iterations the nodes in ps span, assuming    the stage boundaries are placed efficiently.  */
end_comment

begin_define
define|#
directive|define
name|PS_STAGE_COUNT
parameter_list|(
name|ps
parameter_list|)
value|((PS_MAX_CYCLE (ps) - PS_MIN_CYCLE (ps) \ 			     + 1 + (ps)->ii - 1) / (ps)->ii)
end_define

begin_comment
comment|/* A single instruction in the partial schedule.  */
end_comment

begin_struct
struct|struct
name|ps_insn
block|{
comment|/* The corresponding DDG_NODE.  */
name|ddg_node_ptr
name|node
decl_stmt|;
comment|/* The (absolute) cycle in which the PS instruction is scheduled.      Same as SCHED_TIME (node).  */
name|int
name|cycle
decl_stmt|;
comment|/* The next/prev PS_INSN in the same row.  */
name|ps_insn_ptr
name|next_in_row
decl_stmt|,
name|prev_in_row
decl_stmt|;
comment|/* The number of nodes in the same row that come after this node.  */
name|int
name|row_rest_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Holds the partial schedule as an array of II rows.  Each entry of the    array points to a linked list of PS_INSNs, which represents the    instructions that are scheduled for that row.  */
end_comment

begin_struct
struct|struct
name|partial_schedule
block|{
name|int
name|ii
decl_stmt|;
comment|/* Number of rows in the partial schedule.  */
name|int
name|history
decl_stmt|;
comment|/* Threshold for conflict checking using DFA.  */
comment|/* rows[i] points to linked list of insns scheduled in row i (0<=i<ii).  */
name|ps_insn_ptr
modifier|*
name|rows
decl_stmt|;
comment|/* The earliest absolute cycle of an insn in the partial schedule.  */
name|int
name|min_cycle
decl_stmt|;
comment|/* The latest absolute cycle of an insn in the partial schedule.  */
name|int
name|max_cycle
decl_stmt|;
name|ddg_ptr
name|g
decl_stmt|;
comment|/* The DDG of the insns in the partial schedule.  */
block|}
struct|;
end_struct

begin_comment
comment|/* We use this to record all the register replacements we do in    the kernel so we can undo SMS if it is not profitable.  */
end_comment

begin_struct
struct|struct
name|undo_replace_buff_elem
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|orig_reg
decl_stmt|;
name|rtx
name|new_reg
decl_stmt|;
name|struct
name|undo_replace_buff_elem
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|partial_schedule_ptr
name|create_partial_schedule
parameter_list|(
name|int
name|ii
parameter_list|,
name|ddg_ptr
parameter_list|,
name|int
name|history
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_partial_schedule
parameter_list|(
name|partial_schedule_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_partial_schedule
parameter_list|(
name|partial_schedule_ptr
parameter_list|,
name|int
name|new_ii
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_partial_schedule
parameter_list|(
name|partial_schedule_ptr
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kernel_number_of_cycles
parameter_list|(
name|rtx
name|first_insn
parameter_list|,
name|rtx
name|last_insn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ps_insn_ptr
name|ps_add_node_check_conflicts
parameter_list|(
name|partial_schedule_ptr
parameter_list|,
name|ddg_node_ptr
name|node
parameter_list|,
name|int
name|cycle
parameter_list|,
name|sbitmap
name|must_precede
parameter_list|,
name|sbitmap
name|must_follow
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rotate_partial_schedule
parameter_list|(
name|partial_schedule_ptr
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_row_column_for_ps
parameter_list|(
name|partial_schedule_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ps_unschedule_node
parameter_list|(
name|partial_schedule_ptr
parameter_list|,
name|ddg_node_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* This page defines constants and structures for the modulo scheduling    driver.  */
end_comment

begin_comment
comment|/* As in haifa-sched.c:  */
end_comment

begin_comment
comment|/* issue_rate is the number of insns that can be scheduled in the same    machine cycle.  It can be defined in the config/mach/mach.h file,    otherwise we set it to 1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|issue_rate
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sms_order_nodes
parameter_list|(
name|ddg_ptr
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_node_sched_params
parameter_list|(
name|ddg_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|partial_schedule_ptr
name|sms_schedule_by_order
parameter_list|(
name|ddg_ptr
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|permute_partial_schedule
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|rtx
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_prolog_epilog
parameter_list|(
name|partial_schedule_ptr
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|duplicate_insns_of_cycles
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|int
name|from_stage
parameter_list|,
name|int
name|to_stage
parameter_list|,
name|int
name|is_prolog
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SCHED_ASAP
parameter_list|(
name|x
parameter_list|)
value|(((node_sched_params_ptr)(x)->aux.info)->asap)
end_define

begin_define
define|#
directive|define
name|SCHED_TIME
parameter_list|(
name|x
parameter_list|)
value|(((node_sched_params_ptr)(x)->aux.info)->time)
end_define

begin_define
define|#
directive|define
name|SCHED_FIRST_REG_MOVE
parameter_list|(
name|x
parameter_list|)
define|\
value|(((node_sched_params_ptr)(x)->aux.info)->first_reg_move)
end_define

begin_define
define|#
directive|define
name|SCHED_NREG_MOVES
parameter_list|(
name|x
parameter_list|)
define|\
value|(((node_sched_params_ptr)(x)->aux.info)->nreg_moves)
end_define

begin_define
define|#
directive|define
name|SCHED_ROW
parameter_list|(
name|x
parameter_list|)
value|(((node_sched_params_ptr)(x)->aux.info)->row)
end_define

begin_define
define|#
directive|define
name|SCHED_STAGE
parameter_list|(
name|x
parameter_list|)
value|(((node_sched_params_ptr)(x)->aux.info)->stage)
end_define

begin_define
define|#
directive|define
name|SCHED_COLUMN
parameter_list|(
name|x
parameter_list|)
value|(((node_sched_params_ptr)(x)->aux.info)->column)
end_define

begin_comment
comment|/* The scheduling parameters held for each node.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|node_sched_params
block|{
name|int
name|asap
decl_stmt|;
comment|/* A lower-bound on the absolute scheduling cycle.  */
name|int
name|time
decl_stmt|;
comment|/* The absolute scheduling cycle (time>= asap).  */
comment|/* The following field (first_reg_move) is a pointer to the first      register-move instruction added to handle the modulo-variable-expansion      of the register defined by this node.  This register-move copies the      original register defined by the node.  */
name|rtx
name|first_reg_move
decl_stmt|;
comment|/* The number of register-move instructions added, immediately preceding      first_reg_move.  */
name|int
name|nreg_moves
decl_stmt|;
name|int
name|row
decl_stmt|;
comment|/* Holds time % ii.  */
name|int
name|stage
decl_stmt|;
comment|/* Holds time / ii.  */
comment|/* The column of a node inside the ps.  If nodes u, v are on the same row,      u will precede v if column (u)< column (v).  */
name|int
name|column
decl_stmt|;
block|}
typedef|*
name|node_sched_params_ptr
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* The following three functions are copied from the current scheduler    code in order to use sched_analyze() for computing the dependencies.    They are used when initializing the sched_info structure.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sms_print_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|aligned
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"i%4d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|regset
name|cond_exec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|regset
name|used
name|ATTRIBUTE_UNUSED
parameter_list|,
name|regset
name|set
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_decl_stmt
specifier|static
name|struct
name|sched_info
name|sms_sched_info
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|sms_print_insn
block|,
name|NULL
block|,
name|compute_jump_reg_dependencies
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|NULL
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the register decremented and tested in INSN,    or zero if it is not a decrement-and-branch insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|doloop_register_get
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_doloop_end
name|rtx
name|pattern
decl_stmt|,
name|reg
decl_stmt|,
name|condition
decl_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|condition
operator|=
name|doloop_condition_get
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|condition
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return
name|reg
return|;
else|#
directive|else
return|return
name|NULL_RTX
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check if COUNT_REG is set to a constant in the PRE_HEADER block, so    that the number of iterations is a compile-time constant.  If so,    return the rtx that sets COUNT_REG to a constant, and set COUNT to    this constant.  Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|const_iteration_count
parameter_list|(
name|rtx
name|count_reg
parameter_list|,
name|basic_block
name|pre_header
parameter_list|,
name|HOST_WIDEST_INT
modifier|*
name|count
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
if|if
condition|(
operator|!
name|pre_header
condition|)
return|return
name|NULL_RTX
return|;
name|get_ebb_head_tail
argument_list|(
name|pre_header
argument_list|,
name|pre_header
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|tail
init|;
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|single_set
argument_list|(
name|insn
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|count_reg
argument_list|,
name|SET_DEST
argument_list|(
name|single_set
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|count
operator|=
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* A very simple resource-based lower bound on the initiation interval.    ??? Improve the accuracy of this bound by considering the    utilization of various units.  */
end_comment

begin_function
specifier|static
name|int
name|res_MII
parameter_list|(
name|ddg_ptr
name|g
parameter_list|)
block|{
return|return
operator|(
name|g
operator|->
name|num_nodes
operator|/
name|issue_rate
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Points to the array that contains the sched data for each node.  */
end_comment

begin_decl_stmt
specifier|static
name|node_sched_params_ptr
name|node_sched_params
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate sched_params for each node and initialize it.  Assumes that    the aux field of each node contain the asap bound (computed earlier),    and copies it into the sched_params field.  */
end_comment

begin_function
specifier|static
name|void
name|set_node_sched_params
parameter_list|(
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Allocate for each node in the DDG a place to hold the "sched_data".  */
comment|/* Initialize ASAP/ALAP/HIGHT to zero.  */
name|node_sched_params
operator|=
operator|(
name|node_sched_params_ptr
operator|)
name|xcalloc
argument_list|(
name|g
operator|->
name|num_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|node_sched_params
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the pointer of the general data of the node to point to the      appropriate sched_params structure.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* Watch out for aliasing problems?  */
name|node_sched_params
index|[
name|i
index|]
operator|.
name|asap
operator|=
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|aux
operator|.
name|count
expr_stmt|;
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|aux
operator|.
name|info
operator|=
operator|&
name|node_sched_params
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_node_sched_params
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|num_nodes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|node_sched_params_ptr
name|nsp
init|=
operator|&
name|node_sched_params
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|reg_move
init|=
name|nsp
operator|->
name|first_reg_move
decl_stmt|;
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Node %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" asap = %d:\n"
argument_list|,
name|nsp
operator|->
name|asap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" time = %d:\n"
argument_list|,
name|nsp
operator|->
name|time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" nreg_moves = %d:\n"
argument_list|,
name|nsp
operator|->
name|nreg_moves
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsp
operator|->
name|nreg_moves
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" reg_move = "
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|file
argument_list|,
name|reg_move
argument_list|)
expr_stmt|;
name|reg_move
operator|=
name|PREV_INSN
argument_list|(
name|reg_move
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Calculate an upper bound for II.  SMS should not schedule the loop if it    requires more cycles than this bound.  Currently set to the sum of the    longest latency edge for each node.  Reset based on experiments.  */
end_comment

begin_function
specifier|static
name|int
name|calculate_maxii
parameter_list|(
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|maxii
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|ddg_node_ptr
name|u
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|max_edge_latency
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|u
operator|->
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
name|max_edge_latency
operator|=
name|MAX
argument_list|(
name|max_edge_latency
argument_list|,
name|e
operator|->
name|latency
argument_list|)
expr_stmt|;
name|maxii
operator|+=
name|max_edge_latency
expr_stmt|;
block|}
return|return
name|maxii
return|;
block|}
end_function

begin_comment
comment|/*    Breaking intra-loop register anti-dependences:    Each intra-loop register anti-dependence implies a cross-iteration true    dependence of distance 1. Therefore, we can remove such false dependencies    and figure out if the partial schedule broke them by checking if (for a    true-dependence of distance 1): SCHED_TIME (def)< SCHED_TIME (use) and    if so generate a register move.   The number of such moves is equal to:               SCHED_TIME (use) - SCHED_TIME (def)       { 0 broken    nreg_moves = ----------------------------------- + 1 - {   dependence.                             ii                          { 1 if not. */
end_comment

begin_function
specifier|static
name|struct
name|undo_replace_buff_elem
modifier|*
name|generate_reg_moves
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|)
block|{
name|ddg_ptr
name|g
init|=
name|ps
operator|->
name|g
decl_stmt|;
name|int
name|ii
init|=
name|ps
operator|->
name|ii
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|undo_replace_buff_elem
modifier|*
name|reg_move_replaces
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|ddg_node_ptr
name|u
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|nreg_moves
init|=
literal|0
decl_stmt|,
name|i_reg_move
decl_stmt|;
name|sbitmap
modifier|*
name|uses_of_defs
decl_stmt|;
name|rtx
name|last_reg_move
decl_stmt|;
name|rtx
name|prev_reg
decl_stmt|,
name|old_reg
decl_stmt|;
comment|/* Compute the number of reg_moves needed for u, by looking at life 	 ranges started at u (excluding self-loops).  */
for|for
control|(
name|e
operator|=
name|u
operator|->
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
if|if
condition|(
name|e
operator|->
name|type
operator|==
name|TRUE_DEP
operator|&&
name|e
operator|->
name|dest
operator|!=
name|e
operator|->
name|src
condition|)
block|{
name|int
name|nreg_moves4e
init|=
operator|(
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|-
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|)
operator|/
name|ii
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|distance
operator|==
literal|1
condition|)
name|nreg_moves4e
operator|=
operator|(
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|-
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|+
name|ii
operator|)
operator|/
name|ii
expr_stmt|;
comment|/* If dest precedes src in the schedule of the kernel, then dest 	       will read before src writes and we can save one reg_copy.  */
if|if
condition|(
name|SCHED_ROW
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|==
name|SCHED_ROW
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|&&
name|SCHED_COLUMN
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|<
name|SCHED_COLUMN
argument_list|(
name|e
operator|->
name|src
argument_list|)
condition|)
name|nreg_moves4e
operator|--
expr_stmt|;
name|nreg_moves
operator|=
name|MAX
argument_list|(
name|nreg_moves
argument_list|,
name|nreg_moves4e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nreg_moves
operator|==
literal|0
condition|)
continue|continue;
comment|/* Every use of the register defined by node may require a different 	 copy of this register, depending on the time the use is scheduled. 	 Set a bitmap vector, telling which nodes use each copy of this 	 register.  */
name|uses_of_defs
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|nreg_moves
argument_list|,
name|g
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|uses_of_defs
argument_list|,
name|nreg_moves
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u
operator|->
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
if|if
condition|(
name|e
operator|->
name|type
operator|==
name|TRUE_DEP
operator|&&
name|e
operator|->
name|dest
operator|!=
name|e
operator|->
name|src
condition|)
block|{
name|int
name|dest_copy
init|=
operator|(
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|-
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|)
operator|/
name|ii
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|distance
operator|==
literal|1
condition|)
name|dest_copy
operator|=
operator|(
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|-
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|+
name|ii
operator|)
operator|/
name|ii
expr_stmt|;
if|if
condition|(
name|SCHED_ROW
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|==
name|SCHED_ROW
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|&&
name|SCHED_COLUMN
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|<
name|SCHED_COLUMN
argument_list|(
name|e
operator|->
name|src
argument_list|)
condition|)
name|dest_copy
operator|--
expr_stmt|;
if|if
condition|(
name|dest_copy
condition|)
name|SET_BIT
argument_list|(
name|uses_of_defs
index|[
name|dest_copy
operator|-
literal|1
index|]
argument_list|,
name|e
operator|->
name|dest
operator|->
name|cuid
argument_list|)
expr_stmt|;
block|}
comment|/* Now generate the reg_moves, attaching relevant uses to them.  */
name|SCHED_NREG_MOVES
argument_list|(
name|u
argument_list|)
operator|=
name|nreg_moves
expr_stmt|;
name|old_reg
operator|=
name|prev_reg
operator|=
name|copy_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|single_set
argument_list|(
name|u
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_reg_move
operator|=
name|u
operator|->
name|insn
expr_stmt|;
for|for
control|(
name|i_reg_move
operator|=
literal|0
init|;
name|i_reg_move
operator|<
name|nreg_moves
condition|;
name|i_reg_move
operator|++
control|)
block|{
name|unsigned
name|int
name|i_use
init|=
literal|0
decl_stmt|;
name|rtx
name|new_reg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|prev_reg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg_move
init|=
name|gen_move_insn
argument_list|(
name|new_reg
argument_list|,
name|prev_reg
argument_list|)
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|add_insn_before
argument_list|(
name|reg_move
argument_list|,
name|last_reg_move
argument_list|)
expr_stmt|;
name|last_reg_move
operator|=
name|reg_move
expr_stmt|;
if|if
condition|(
operator|!
name|SCHED_FIRST_REG_MOVE
argument_list|(
name|u
argument_list|)
condition|)
name|SCHED_FIRST_REG_MOVE
argument_list|(
name|u
argument_list|)
operator|=
name|reg_move
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|uses_of_defs[i_reg_move]
argument_list|,
literal|0
argument_list|,
argument|i_use
argument_list|,
argument|sbi
argument_list|)
block|{
name|struct
name|undo_replace_buff_elem
modifier|*
name|rep
decl_stmt|;
name|rep
operator|=
operator|(
expr|struct
name|undo_replace_buff_elem
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|undo_replace_buff_elem
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|insn
operator|=
name|g
operator|->
name|nodes
index|[
name|i_use
index|]
operator|.
name|insn
expr_stmt|;
name|rep
operator|->
name|orig_reg
operator|=
name|old_reg
expr_stmt|;
name|rep
operator|->
name|new_reg
operator|=
name|new_reg
expr_stmt|;
if|if
condition|(
operator|!
name|reg_move_replaces
condition|)
name|reg_move_replaces
operator|=
name|rep
expr_stmt|;
else|else
block|{
name|rep
operator|->
name|next
operator|=
name|reg_move_replaces
expr_stmt|;
name|reg_move_replaces
operator|=
name|rep
expr_stmt|;
block|}
name|replace_rtx
argument_list|(
name|g
operator|->
name|nodes
index|[
name|i_use
index|]
operator|.
name|insn
argument_list|,
name|old_reg
argument_list|,
name|new_reg
argument_list|)
expr_stmt|;
block|}
name|prev_reg
operator|=
name|new_reg
expr_stmt|;
block|}
name|sbitmap_vector_free
argument_list|(
name|uses_of_defs
argument_list|)
expr_stmt|;
block|}
return|return
name|reg_move_replaces
return|;
block|}
end_function

begin_comment
comment|/* We call this when we want to undo the SMS schedule for a given loop.    One of the things that we do is to delete the register moves generated    for the sake of SMS; this function deletes the register move instructions    recorded in the undo buffer.  */
end_comment

begin_function
specifier|static
name|void
name|undo_generate_reg_moves
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|struct
name|undo_replace_buff_elem
modifier|*
name|reg_move_replaces
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|ddg_node_ptr
name|u
init|=
operator|&
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|rtx
name|crr
init|=
name|SCHED_FIRST_REG_MOVE
argument_list|(
name|u
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SCHED_NREG_MOVES
argument_list|(
name|u
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|crr
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|crr
argument_list|)
expr_stmt|;
name|crr
operator|=
name|prev
expr_stmt|;
block|}
name|SCHED_FIRST_REG_MOVE
argument_list|(
name|u
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
block|}
while|while
condition|(
name|reg_move_replaces
condition|)
block|{
name|struct
name|undo_replace_buff_elem
modifier|*
name|rep
init|=
name|reg_move_replaces
decl_stmt|;
name|reg_move_replaces
operator|=
name|reg_move_replaces
operator|->
name|next
expr_stmt|;
name|replace_rtx
argument_list|(
name|rep
operator|->
name|insn
argument_list|,
name|rep
operator|->
name|new_reg
argument_list|,
name|rep
operator|->
name|orig_reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free memory allocated for the undo buffer.  */
end_comment

begin_function
specifier|static
name|void
name|free_undo_replace_buff
parameter_list|(
name|struct
name|undo_replace_buff_elem
modifier|*
name|reg_move_replaces
parameter_list|)
block|{
while|while
condition|(
name|reg_move_replaces
condition|)
block|{
name|struct
name|undo_replace_buff_elem
modifier|*
name|rep
init|=
name|reg_move_replaces
decl_stmt|;
name|reg_move_replaces
operator|=
name|reg_move_replaces
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Bump the SCHED_TIMEs of all nodes to start from zero.  Set the values    of SCHED_ROW and SCHED_STAGE.  */
end_comment

begin_function
specifier|static
name|void
name|normalize_sched_times
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ddg_ptr
name|g
init|=
name|ps
operator|->
name|g
decl_stmt|;
name|int
name|amount
init|=
name|PS_MIN_CYCLE
argument_list|(
name|ps
argument_list|)
decl_stmt|;
name|int
name|ii
init|=
name|ps
operator|->
name|ii
decl_stmt|;
comment|/* Don't include the closing branch assuming that it is the last node.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ddg_node_ptr
name|u
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|int
name|normalized_time
init|=
name|SCHED_TIME
argument_list|(
name|u
argument_list|)
operator|-
name|amount
decl_stmt|;
name|gcc_assert
argument_list|(
name|normalized_time
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|SCHED_TIME
argument_list|(
name|u
argument_list|)
operator|=
name|normalized_time
expr_stmt|;
name|SCHED_ROW
argument_list|(
name|u
argument_list|)
operator|=
name|normalized_time
operator|%
name|ii
expr_stmt|;
name|SCHED_STAGE
argument_list|(
name|u
argument_list|)
operator|=
name|normalized_time
operator|/
name|ii
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set SCHED_COLUMN of each node according to its position in PS.  */
end_comment

begin_function
specifier|static
name|void
name|set_columns_for_ps
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|)
block|{
name|int
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|ps
operator|->
name|ii
condition|;
name|row
operator|++
control|)
block|{
name|ps_insn_ptr
name|cur_insn
init|=
name|ps
operator|->
name|rows
index|[
name|row
index|]
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|cur_insn
condition|;
name|cur_insn
operator|=
name|cur_insn
operator|->
name|next_in_row
control|)
name|SCHED_COLUMN
argument_list|(
name|cur_insn
operator|->
name|node
argument_list|)
operator|=
name|column
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Permute the insns according to their order in PS, from row 0 to    row ii-1, and position them right before LAST.  This schedules    the insns of the loop kernel.  */
end_comment

begin_function
specifier|static
name|void
name|permute_partial_schedule
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|int
name|ii
init|=
name|ps
operator|->
name|ii
decl_stmt|;
name|int
name|row
decl_stmt|;
name|ps_insn_ptr
name|ps_ij
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|ii
condition|;
name|row
operator|++
control|)
for|for
control|(
name|ps_ij
operator|=
name|ps
operator|->
name|rows
index|[
name|row
index|]
init|;
name|ps_ij
condition|;
name|ps_ij
operator|=
name|ps_ij
operator|->
name|next_in_row
control|)
if|if
condition|(
name|PREV_INSN
argument_list|(
name|last
argument_list|)
operator|!=
name|ps_ij
operator|->
name|node
operator|->
name|insn
condition|)
name|reorder_insns_nobb
argument_list|(
name|ps_ij
operator|->
name|node
operator|->
name|first_note
argument_list|,
name|ps_ij
operator|->
name|node
operator|->
name|insn
argument_list|,
name|PREV_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As part of undoing SMS we return to the original ordering of the    instructions inside the loop kernel.  Given the partial schedule PS, this    function returns the ordering of the instruction according to their CUID    in the DDG (PS->G), which is the original order of the instruction before    performing SMS.  */
end_comment

begin_function
specifier|static
name|void
name|undo_permute_partial_schedule
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|last
operator|==
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|insn
operator|||
name|last
operator|==
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|first_note
condition|)
break|break;
elseif|else
if|if
condition|(
name|PREV_INSN
argument_list|(
name|last
argument_list|)
operator|!=
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|insn
condition|)
name|reorder_insns_nobb
argument_list|(
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|first_note
argument_list|,
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|PREV_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used to generate the prologue& epilogue.  Duplicate the subset of    nodes whose stages are between FROM_STAGE and TO_STAGE (inclusive    of both), together with a prefix/suffix of their reg_moves.  */
end_comment

begin_function
specifier|static
name|void
name|duplicate_insns_of_cycles
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|int
name|from_stage
parameter_list|,
name|int
name|to_stage
parameter_list|,
name|int
name|for_prolog
parameter_list|)
block|{
name|int
name|row
decl_stmt|;
name|ps_insn_ptr
name|ps_ij
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|ps
operator|->
name|ii
condition|;
name|row
operator|++
control|)
for|for
control|(
name|ps_ij
operator|=
name|ps
operator|->
name|rows
index|[
name|row
index|]
init|;
name|ps_ij
condition|;
name|ps_ij
operator|=
name|ps_ij
operator|->
name|next_in_row
control|)
block|{
name|ddg_node_ptr
name|u_node
init|=
name|ps_ij
operator|->
name|node
decl_stmt|;
name|int
name|j
decl_stmt|,
name|i_reg_moves
decl_stmt|;
name|rtx
name|reg_move
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|for_prolog
condition|)
block|{
comment|/* SCHED_STAGE (u_node)>= from_stage == 0.  Generate increasing 	       number of reg_moves starting with the second occurrence of 	       u_node, which is generated if its SCHED_STAGE<= to_stage.  */
name|i_reg_moves
operator|=
name|to_stage
operator|-
name|SCHED_STAGE
argument_list|(
name|u_node
argument_list|)
operator|+
literal|1
expr_stmt|;
name|i_reg_moves
operator|=
name|MAX
argument_list|(
name|i_reg_moves
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i_reg_moves
operator|=
name|MIN
argument_list|(
name|i_reg_moves
argument_list|,
name|SCHED_NREG_MOVES
argument_list|(
name|u_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The reg_moves start from the *first* reg_move backwards.  */
if|if
condition|(
name|i_reg_moves
condition|)
block|{
name|reg_move
operator|=
name|SCHED_FIRST_REG_MOVE
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i_reg_moves
condition|;
name|j
operator|++
control|)
name|reg_move
operator|=
name|PREV_INSN
argument_list|(
name|reg_move
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* It's for the epilog.  */
block|{
comment|/* SCHED_STAGE (u_node)<= to_stage.  Generate all reg_moves, 	       starting to decrease one stage after u_node no longer occurs; 	       that is, generate all reg_moves until 	       SCHED_STAGE (u_node) == from_stage - 1.  */
name|i_reg_moves
operator|=
name|SCHED_NREG_MOVES
argument_list|(
name|u_node
argument_list|)
operator|-
operator|(
name|from_stage
operator|-
name|SCHED_STAGE
argument_list|(
name|u_node
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|i_reg_moves
operator|=
name|MAX
argument_list|(
name|i_reg_moves
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i_reg_moves
operator|=
name|MIN
argument_list|(
name|i_reg_moves
argument_list|,
name|SCHED_NREG_MOVES
argument_list|(
name|u_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The reg_moves start from the *last* reg_move forwards.  */
if|if
condition|(
name|i_reg_moves
condition|)
block|{
name|reg_move
operator|=
name|SCHED_FIRST_REG_MOVE
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|SCHED_NREG_MOVES
argument_list|(
name|u_node
argument_list|)
condition|;
name|j
operator|++
control|)
name|reg_move
operator|=
name|PREV_INSN
argument_list|(
name|reg_move
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i_reg_moves
condition|;
name|j
operator|++
operator|,
name|reg_move
operator|=
name|NEXT_INSN
argument_list|(
name|reg_move
argument_list|)
control|)
name|emit_insn
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|reg_move
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCHED_STAGE
argument_list|(
name|u_node
argument_list|)
operator|>=
name|from_stage
operator|&&
name|SCHED_STAGE
argument_list|(
name|u_node
argument_list|)
operator|<=
name|to_stage
condition|)
name|duplicate_insn_chain
argument_list|(
name|u_node
operator|->
name|first_note
argument_list|,
name|u_node
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the instructions (including reg_moves) for prolog& epilog.  */
end_comment

begin_function
specifier|static
name|void
name|generate_prolog_epilog
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
name|count_reg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|last_stage
init|=
name|PS_STAGE_COUNT
argument_list|(
name|ps
argument_list|)
operator|-
literal|1
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Generate the prolog, inserting its insns on the loop-entry edge.  */
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|count_reg
condition|)
comment|/* Generate a subtract instruction at the beginning of the prolog to       adjust the loop count by STAGE_COUNT.  */
name|emit_insn
argument_list|(
name|gen_sub2_insn
argument_list|(
name|count_reg
argument_list|,
name|GEN_INT
argument_list|(
name|last_stage
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_stage
condition|;
name|i
operator|++
control|)
name|duplicate_insns_of_cycles
argument_list|(
name|ps
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Put the prolog ,  on the one and only entry edge.  */
name|e
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Generate the epilog, inserting its insns on the loop-exit edge.  */
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_stage
condition|;
name|i
operator|++
control|)
name|duplicate_insns_of_cycles
argument_list|(
name|ps
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|last_stage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the epilogue on the one and only one exit edge.  */
name|gcc_assert
argument_list|(
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
name|e
operator|=
name|loop
operator|->
name|single_exit
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the line note insn preceding INSN, for debugging.  Taken from    emit-rtl.c.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_line_note
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
break|break;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return true if all the BBs of the loop are empty except the    loop header.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_single_full_bb_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|bool
name|empty_bb
init|=
name|true
decl_stmt|;
if|if
condition|(
name|bbs
index|[
name|i
index|]
operator|==
name|loop
operator|->
name|header
condition|)
continue|continue;
comment|/* Make sure that basic blocks other than the header          have only notes labels or jumps.  */
name|get_ebb_head_tail
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|head
operator|!=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
condition|;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|head
argument_list|)
operator|||
name|LABEL_P
argument_list|(
name|head
argument_list|)
operator|||
operator|(
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|&&
name|JUMP_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
continue|continue;
name|empty_bb
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|empty_bb
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A simple loop from SMS point of view; it is a loop that is composed of    either a single basic block or two BBs - a header and a latch.  */
end_comment

begin_define
define|#
directive|define
name|SIMPLE_SMS_LOOP_P
parameter_list|(
name|loop
parameter_list|)
value|((loop->num_nodes< 3 ) 		    \&& (EDGE_COUNT (loop->latch->preds) == 1) \&& (EDGE_COUNT (loop->latch->succs) == 1))
end_define

begin_comment
comment|/* Return true if the loop is in its canonical form and false if not.    i.e. SIMPLE_SMS_LOOP_P and have one preheader block, and single exit.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_canon_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
if|if
condition|(
name|loop
operator|->
name|inner
operator|||
operator|!
name|loop
operator|->
name|outer
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|loop
operator|->
name|single_exit
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|rtx
name|line_note
init|=
name|find_line_note
argument_list|(
name|BB_END
argument_list|(
name|loop
operator|->
name|header
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS loop many exits "
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_note
condition|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
name|NOTE_EXPANDED_LOCATION
argument_list|(
name|xloc
argument_list|,
name|line_note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" %s %d (file, line)\n"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|SIMPLE_SMS_LOOP_P
argument_list|(
name|loop
argument_list|)
operator|&&
operator|!
name|loop_single_full_bb_p
argument_list|(
name|loop
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|rtx
name|line_note
init|=
name|find_line_note
argument_list|(
name|BB_END
argument_list|(
name|loop
operator|->
name|header
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS loop many BBs. "
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_note
condition|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
name|NOTE_EXPANDED_LOCATION
argument_list|(
name|xloc
argument_list|,
name|line_note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" %s %d (file, line)\n"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If there are more than one entry for the loop,    make it one by splitting the first entry edge and    redirecting the others to the new BB.  */
end_comment

begin_function
specifier|static
name|void
name|canon_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|i
decl_stmt|;
comment|/* Avoid annoying special cases of edges going to exit      block.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|i
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
operator|(
name|EDGE_COUNT
argument_list|(
name|e
operator|->
name|src
operator|->
name|succs
argument_list|)
operator|>
literal|1
operator|)
condition|)
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|==
name|loop
operator|->
name|header
operator|||
name|EDGE_COUNT
argument_list|(
name|loop
operator|->
name|latch
operator|->
name|succs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|i
argument_list|,
argument|loop->header->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
break|break;
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main entry point, perform SMS scheduling on the loops of the function    that consist of single basic blocks.  */
end_comment

begin_function
specifier|static
name|void
name|sms_schedule
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|passes
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|ddg_ptr
modifier|*
name|g_arr
decl_stmt|,
name|g
decl_stmt|;
name|int
modifier|*
name|node_order
decl_stmt|;
name|int
name|maxii
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num_loops
decl_stmt|;
name|partial_schedule_ptr
name|ps
decl_stmt|;
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|basic_block
name|bb
init|=
name|NULL
decl_stmt|;
comment|/* vars to the versioning only if needed*/
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|basic_block
name|condition_bb
init|=
name|NULL
decl_stmt|;
name|edge
name|latch_edge
decl_stmt|;
name|gcov_type
name|trip_count
init|=
literal|0
decl_stmt|;
name|loops
operator|=
name|loop_optimizer_init
argument_list|(
name|LOOPS_HAVE_PREHEADERS
operator||
name|LOOPS_HAVE_MARKED_SINGLE_EXITS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loops
condition|)
return|return;
comment|/* There is no loops to schedule.  */
comment|/* Initialize issue_rate.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
condition|)
block|{
name|int
name|temp
init|=
name|reload_completed
decl_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|issue_rate
operator|=
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
argument_list|()
expr_stmt|;
name|reload_completed
operator|=
name|temp
expr_stmt|;
block|}
else|else
name|issue_rate
operator|=
literal|1
expr_stmt|;
comment|/* Initialize the scheduler.  */
name|current_sched_info
operator|=
operator|&
name|sms_sched_info
expr_stmt|;
name|sched_init
argument_list|()
expr_stmt|;
comment|/* Init Data Flow analysis, to be used in interloop dep calculation.  */
name|df
operator|=
name|df_init
argument_list|(
name|DF_HARD_REGS
operator||
name|DF_EQUIV_NOTES
operator||
name|DF_SUBREGS
argument_list|)
expr_stmt|;
name|df_rd_add_problem
argument_list|(
name|df
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_ru_add_problem
argument_list|(
name|df
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_chain_add_problem
argument_list|(
name|df
argument_list|,
name|DF_DU_CHAIN
operator||
name|DF_UD_CHAIN
argument_list|)
expr_stmt|;
name|df_analyze
argument_list|(
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|df_dump
argument_list|(
name|df
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
comment|/* Allocate memory to hold the DDG array one entry for each loop.      We use loop->num as index into this array.  */
name|g_arr
operator|=
name|XCNEWVEC
argument_list|(
name|ddg_ptr
argument_list|,
name|loops
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* Build DDGs for all the relevant loops and hold them in G_ARR      indexed by the loop index.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|rtx
name|count_reg
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
comment|/* For debugging.  */
if|if
condition|(
operator|(
name|passes
operator|++
operator|>
name|MAX_SMS_LOOP_NUMBER
operator|)
operator|&&
operator|(
name|MAX_SMS_LOOP_NUMBER
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS reached MAX_PASSES... \n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|loop_canon_p
argument_list|(
name|loop
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|loop_single_full_bb_p
argument_list|(
name|loop
argument_list|)
condition|)
continue|continue;
name|bb
operator|=
name|loop
operator|->
name|header
expr_stmt|;
name|get_ebb_head_tail
argument_list|(
name|bb
argument_list|,
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|latch_edge
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|single_exit
operator|->
name|count
condition|)
name|trip_count
operator|=
name|latch_edge
operator|->
name|count
operator|/
name|loop
operator|->
name|single_exit
operator|->
name|count
expr_stmt|;
comment|/* Perfrom SMS only on loops that their average count is above threshold.  */
if|if
condition|(
name|latch_edge
operator|->
name|count
operator|&&
operator|(
name|latch_edge
operator|->
name|count
operator|<
name|loop
operator|->
name|single_exit
operator|->
name|count
operator|*
name|SMS_LOOP_AVERAGE_COUNT_THRESHOLD
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|rtx
name|line_note
init|=
name|find_line_note
argument_list|(
name|tail
argument_list|)
decl_stmt|;
if|if
condition|(
name|line_note
condition|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
name|NOTE_EXPANDED_LOCATION
argument_list|(
name|xloc
argument_list|,
name|line_note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS bb %s %d (file, line)\n"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS single-bb-loop\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS loop-count "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS trip-count "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|trip_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS profile-sum-max "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|profile_info
operator|->
name|sum_max
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* Make sure this is a doloop.  */
if|if
condition|(
operator|!
operator|(
name|count_reg
operator|=
name|doloop_register_get
argument_list|(
name|tail
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Don't handle BBs with calls or barriers, or !single_set insns.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|single_set
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|)
condition|)
break|break;
if|if
condition|(
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS loop-with-call\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS loop-with-barrier\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS loop-with-not-single-set\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|g
operator|=
name|create_ddg
argument_list|(
name|bb
argument_list|,
name|df
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS doloop\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|g_arr
index|[
name|i
index|]
operator|=
name|g
expr_stmt|;
block|}
comment|/* Release Data Flow analysis data structures.  */
name|df_finish
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df
operator|=
name|NULL
expr_stmt|;
comment|/* We don't want to perform SMS on new loops - created by versioning.  */
name|num_loops
operator|=
name|loops
operator|->
name|num
expr_stmt|;
comment|/* Go over the built DDGs and perfrom SMS for each one of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|rtx
name|count_reg
decl_stmt|,
name|count_init
decl_stmt|;
name|int
name|mii
decl_stmt|,
name|rec_mii
decl_stmt|;
name|unsigned
name|stage_count
init|=
literal|0
decl_stmt|;
name|HOST_WIDEST_INT
name|loop_count
init|=
literal|0
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|g
operator|=
name|g_arr
index|[
name|i
index|]
operator|)
condition|)
continue|continue;
if|if
condition|(
name|dump_file
condition|)
name|print_ddg
argument_list|(
name|dump_file
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|get_ebb_head_tail
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
operator|->
name|header
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|latch_edge
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|single_exit
operator|->
name|count
condition|)
name|trip_count
operator|=
name|latch_edge
operator|->
name|count
operator|/
name|loop
operator|->
name|single_exit
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|rtx
name|line_note
init|=
name|find_line_note
argument_list|(
name|tail
argument_list|)
decl_stmt|;
if|if
condition|(
name|line_note
condition|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
name|NOTE_EXPANDED_LOCATION
argument_list|(
name|xloc
argument_list|,
name|line_note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS bb %s %d (file, line)\n"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS single-bb-loop\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS loop-count "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS profile-sum-max "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|profile_info
operator|->
name|sum_max
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS doloop\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS built-ddg %d\n"
argument_list|,
name|g
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS num-loads %d\n"
argument_list|,
name|g
operator|->
name|num_loads
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS num-stores %d\n"
argument_list|,
name|g
operator|->
name|num_stores
argument_list|)
expr_stmt|;
block|}
comment|/* In case of th loop have doloop register it gets special 	 handling.  */
name|count_init
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|(
name|count_reg
operator|=
name|doloop_register_get
argument_list|(
name|tail
argument_list|)
operator|)
condition|)
block|{
name|basic_block
name|pre_header
decl_stmt|;
name|pre_header
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
expr_stmt|;
name|count_init
operator|=
name|const_iteration_count
argument_list|(
name|count_reg
argument_list|,
name|pre_header
argument_list|,
operator|&
name|loop_count
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|count_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
name|count_init
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS const-doloop "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|loop_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|node_order
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|mii
operator|=
literal|1
expr_stmt|;
comment|/* Need to pass some estimate of mii.  */
name|rec_mii
operator|=
name|sms_order_nodes
argument_list|(
name|g
argument_list|,
name|mii
argument_list|,
name|node_order
argument_list|)
expr_stmt|;
name|mii
operator|=
name|MAX
argument_list|(
name|res_MII
argument_list|(
name|g
argument_list|)
argument_list|,
name|rec_mii
argument_list|)
expr_stmt|;
name|maxii
operator|=
operator|(
name|calculate_maxii
argument_list|(
name|g
argument_list|)
operator|*
name|SMS_MAX_II_FACTOR
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS iis %d %d %d (rec_mii, mii, maxii)\n"
argument_list|,
name|rec_mii
argument_list|,
name|mii
argument_list|,
name|maxii
argument_list|)
expr_stmt|;
comment|/* After sms_order_nodes and before sms_schedule_by_order, to copy over 	 ASAP.  */
name|set_node_sched_params
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|ps
operator|=
name|sms_schedule_by_order
argument_list|(
name|g
argument_list|,
name|mii
argument_list|,
name|maxii
argument_list|,
name|node_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
name|stage_count
operator|=
name|PS_STAGE_COUNT
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* Stage count of 1 means that there is no interleaving between          iterations, let the scheduling passes do the job.  */
if|if
condition|(
name|stage_count
operator|<
literal|1
operator|||
operator|(
name|count_init
operator|&&
operator|(
name|loop_count
operator|<=
name|stage_count
operator|)
operator|)
operator|||
operator|(
name|flag_branch_probabilities
operator|&&
operator|(
name|trip_count
operator|<=
name|stage_count
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS failed... \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS sched-failed (stage-count=%d, loop-count="
argument_list|,
name|stage_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|loop_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|", trip-count="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|trip_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
name|int
name|orig_cycles
init|=
name|kernel_number_of_cycles
argument_list|(
name|BB_HEAD
argument_list|(
name|g
operator|->
name|bb
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|g
operator|->
name|bb
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|new_cycles
decl_stmt|;
name|struct
name|undo_replace_buff_elem
modifier|*
name|reg_move_replaces
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS succeeded %d %d (with ii, sc)\n"
argument_list|,
name|ps
operator|->
name|ii
argument_list|,
name|stage_count
argument_list|)
expr_stmt|;
name|print_partial_schedule
argument_list|(
name|ps
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SMS Branch (%d) will later be scheduled at cycle %d.\n"
argument_list|,
name|g
operator|->
name|closing_branch
operator|->
name|cuid
argument_list|,
name|PS_MIN_CYCLE
argument_list|(
name|ps
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set the stage boundaries.  If the DDG is built with closing_branch_deps, 	     the closing_branch was scheduled and should appear in the last (ii-1) 	     row.  Otherwise, we are free to schedule the branch, and we let nodes 	     that were scheduled at the first PS_MIN_CYCLE cycle appear in the first 	     row; this should reduce stage_count to minimum.  */
name|normalize_sched_times
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|rotate_partial_schedule
argument_list|(
name|ps
argument_list|,
name|PS_MIN_CYCLE
argument_list|(
name|ps
argument_list|)
argument_list|)
expr_stmt|;
name|set_columns_for_ps
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* Generate the kernel just to be able to measure its cycles.  */
name|permute_partial_schedule
argument_list|(
name|ps
argument_list|,
name|g
operator|->
name|closing_branch
operator|->
name|first_note
argument_list|)
expr_stmt|;
name|reg_move_replaces
operator|=
name|generate_reg_moves
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* Get the number of cycles the new kernel expect to execute in.  */
name|new_cycles
operator|=
name|kernel_number_of_cycles
argument_list|(
name|BB_HEAD
argument_list|(
name|g
operator|->
name|bb
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|g
operator|->
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get back to the original loop so we can do loop versioning.  */
name|undo_permute_partial_schedule
argument_list|(
name|ps
argument_list|,
name|g
operator|->
name|closing_branch
operator|->
name|first_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_move_replaces
condition|)
name|undo_generate_reg_moves
argument_list|(
name|ps
argument_list|,
name|reg_move_replaces
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_cycles
operator|>=
name|orig_cycles
condition|)
block|{
comment|/* SMS is not profitable so undo the permutation and reg move generation 	         and return the kernel to its original state.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Undoing SMS because it is not profitable.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canon_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* case the BCT count is not known , Do loop-versioning */
if|if
condition|(
name|count_reg
operator|&&
operator|!
name|count_init
condition|)
block|{
name|rtx
name|comp_rtx
init|=
name|gen_rtx_fmt_ee
argument_list|(
name|GT
argument_list|,
name|VOIDmode
argument_list|,
name|count_reg
argument_list|,
name|GEN_INT
argument_list|(
name|stage_count
argument_list|)
argument_list|)
decl_stmt|;
name|nloop
operator|=
name|loop_version
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|comp_rtx
argument_list|,
operator|&
name|condition_bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Set new iteration count of loop kernel.  */
if|if
condition|(
name|count_reg
operator|&&
name|count_init
condition|)
name|SET_SRC
argument_list|(
name|single_set
argument_list|(
name|count_init
argument_list|)
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|loop_count
operator|-
name|stage_count
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now apply the scheduled kernel to the RTL of the loop.  */
name|permute_partial_schedule
argument_list|(
name|ps
argument_list|,
name|g
operator|->
name|closing_branch
operator|->
name|first_note
argument_list|)
expr_stmt|;
comment|/* Mark this loop as software pipelined so the later 	      scheduling passes doesn't touch it.  */
if|if
condition|(
operator|!
name|flag_resched_modulo_sched
condition|)
name|g
operator|->
name|bb
operator|->
name|flags
operator||=
name|BB_DISABLE_SCHEDULE
expr_stmt|;
comment|/* The life-info is not valid any more.  */
name|g
operator|->
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|reg_move_replaces
operator|=
name|generate_reg_moves
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|print_node_sched_params
argument_list|(
name|dump_file
argument_list|,
name|g
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
comment|/* Generate prolog and epilog.  */
if|if
condition|(
name|count_reg
operator|&&
operator|!
name|count_init
condition|)
name|generate_prolog_epilog
argument_list|(
name|ps
argument_list|,
name|loop
argument_list|,
name|count_reg
argument_list|)
expr_stmt|;
else|else
name|generate_prolog_epilog
argument_list|(
name|ps
argument_list|,
name|loop
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|free_undo_replace_buff
argument_list|(
name|reg_move_replaces
argument_list|)
expr_stmt|;
block|}
name|free_partial_schedule
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node_sched_params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node_order
argument_list|)
expr_stmt|;
name|free_ddg
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|g_arr
argument_list|)
expr_stmt|;
comment|/* Release scheduler data, needed until now because of DFA.  */
name|sched_finish
argument_list|()
expr_stmt|;
name|loop_optimizer_finalize
argument_list|(
name|loops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The SMS scheduling algorithm itself    -----------------------------------    Input: 'O' an ordered list of insns of a loop.    Output: A scheduling of the loop - kernel, prolog, and epilogue.     'Q' is the empty Set    'PS' is the partial schedule; it holds the currently scheduled nodes with 	their cycle/slot.    'PSP' previously scheduled predecessors.    'PSS' previously scheduled successors.    't(u)' the cycle where u is scheduled.    'l(u)' is the latency of u.    'd(v,u)' is the dependence distance from v to u.    'ASAP(u)' the earliest time at which u could be scheduled as computed in 	     the node ordering phase.    'check_hardware_resources_conflicts(u, PS, c)' 			     run a trace around cycle/slot through DFA model 			     to check resource conflicts involving instruction u 			     at cycle c given the partial schedule PS.    'add_to_partial_schedule_at_time(u, PS, c)' 			     Add the node/instruction u to the partial schedule 			     PS at time c.    'calculate_register_pressure(PS)' 			     Given a schedule of instructions, calculate the register 			     pressure it implies.  One implementation could be the 			     maximum number of overlapping live ranges.    'maxRP' The maximum allowed register pressure, it is usually derived from the number 	   registers available in the hardware.     1. II = MII.    2. PS = empty list    3. for each node u in O in pre-computed order    4.   if (PSP(u) != Q&& PSS(u) == Q) then    5.     Early_start(u) = max ( t(v) + l(v) - d(v,u)*II ) over all every v in PSP(u).    6.     start = Early_start; end = Early_start + II - 1; step = 1    11.  else if (PSP(u) == Q&& PSS(u) != Q) then    12.      Late_start(u) = min ( t(v) - l(v) + d(v,u)*II ) over all every v in PSS(u).    13.     start = Late_start; end = Late_start - II + 1; step = -1    14.  else if (PSP(u) != Q&& PSS(u) != Q) then    15.     Early_start(u) = max ( t(v) + l(v) - d(v,u)*II ) over all every v in PSP(u).    16.     Late_start(u) = min ( t(v) - l(v) + d(v,u)*II ) over all every v in PSS(u).    17.     start = Early_start;    18.     end = min(Early_start + II - 1 , Late_start);    19.     step = 1    20.     else "if (PSP(u) == Q&& PSS(u) == Q)"    21.	  start = ASAP(u); end = start + II - 1; step = 1    22.  endif     23.  success = false    24.  for (c = start ; c != end ; c += step)    25.     if check_hardware_resources_conflicts(u, PS, c) then    26.       add_to_partial_schedule_at_time(u, PS, c)    27.       success = true    28.       break    29.     endif    30.  endfor    31.  if (success == false) then    32.    II = II + 1    33.    if (II> maxII) then    34.       finish - failed to schedule    35.	 endif    36.    goto 2.    37.  endif    38. endfor    39. if (calculate_register_pressure(PS)> maxRP) then    40.    goto 32.    41. endif    42. compute epilogue& prologue    43. finish - succeeded to schedule */
end_comment

begin_comment
comment|/* A limit on the number of cycles that resource conflicts can span.  ??? Should    be provided by DFA, and be dependent on the type of insn scheduled.  Currently    set to 0 to save compile time.  */
end_comment

begin_define
define|#
directive|define
name|DFA_HISTORY
value|SMS_DFA_HISTORY
end_define

begin_comment
comment|/* Given the partial schedule PS, this function calculates and returns the    cycles in which we can schedule the node with the given index I.    NOTE: Here we do the backtracking in SMS, in some special cases. We have    noticed that there are several cases in which we fail    to SMS the loop    because the sched window of a node is empty    due to tight data-deps. In    such cases we want to unschedule    some of the predecessors/successors    until we get non-empty    scheduling window.  It returns -1 if the    scheduling window is empty and zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_sched_window
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|int
modifier|*
name|nodes_order
parameter_list|,
name|int
name|i
parameter_list|,
name|sbitmap
name|sched_nodes
parameter_list|,
name|int
name|ii
parameter_list|,
name|int
modifier|*
name|start_p
parameter_list|,
name|int
modifier|*
name|step_p
parameter_list|,
name|int
modifier|*
name|end_p
parameter_list|)
block|{
name|int
name|start
decl_stmt|,
name|step
decl_stmt|,
name|end
decl_stmt|;
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|u
init|=
name|nodes_order
index|[
name|i
index|]
decl_stmt|;
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
name|sbitmap
name|psp
init|=
name|sbitmap_alloc
argument_list|(
name|ps
operator|->
name|g
operator|->
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|pss
init|=
name|sbitmap_alloc
argument_list|(
name|ps
operator|->
name|g
operator|->
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|u_node_preds
init|=
name|NODE_PREDECESSORS
argument_list|(
name|u_node
argument_list|)
decl_stmt|;
name|sbitmap
name|u_node_succs
init|=
name|NODE_SUCCESSORS
argument_list|(
name|u_node
argument_list|)
decl_stmt|;
name|int
name|psp_not_empty
decl_stmt|;
name|int
name|pss_not_empty
decl_stmt|;
comment|/* 1. compute sched window for u (start, end, step).  */
name|sbitmap_zero
argument_list|(
name|psp
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|pss
argument_list|)
expr_stmt|;
name|psp_not_empty
operator|=
name|sbitmap_a_and_b_cg
argument_list|(
name|psp
argument_list|,
name|u_node_preds
argument_list|,
name|sched_nodes
argument_list|)
expr_stmt|;
name|pss_not_empty
operator|=
name|sbitmap_a_and_b_cg
argument_list|(
name|pss
argument_list|,
name|u_node_succs
argument_list|,
name|sched_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|psp_not_empty
operator|&&
operator|!
name|pss_not_empty
condition|)
block|{
name|int
name|early_start
init|=
name|INT_MIN
decl_stmt|;
name|end
operator|=
name|INT_MAX
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|in
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_in
control|)
block|{
name|ddg_node_ptr
name|v_node
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|v_node
operator|->
name|cuid
argument_list|)
condition|)
block|{
name|int
name|node_st
init|=
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|+
name|e
operator|->
name|latency
operator|-
operator|(
name|e
operator|->
name|distance
operator|*
name|ii
operator|)
decl_stmt|;
name|early_start
operator|=
name|MAX
argument_list|(
name|early_start
argument_list|,
name|node_st
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data_type
operator|==
name|MEM_DEP
condition|)
name|end
operator|=
name|MIN
argument_list|(
name|end
argument_list|,
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|+
name|ii
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|start
operator|=
name|early_start
expr_stmt|;
name|end
operator|=
name|MIN
argument_list|(
name|end
argument_list|,
name|early_start
operator|+
name|ii
argument_list|)
expr_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|psp_not_empty
operator|&&
name|pss_not_empty
condition|)
block|{
name|int
name|late_start
init|=
name|INT_MAX
decl_stmt|;
name|end
operator|=
name|INT_MIN
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|out
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
block|{
name|ddg_node_ptr
name|v_node
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|v_node
operator|->
name|cuid
argument_list|)
condition|)
block|{
name|late_start
operator|=
name|MIN
argument_list|(
name|late_start
argument_list|,
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|-
name|e
operator|->
name|latency
operator|+
operator|(
name|e
operator|->
name|distance
operator|*
name|ii
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data_type
operator|==
name|MEM_DEP
condition|)
name|end
operator|=
name|MAX
argument_list|(
name|end
argument_list|,
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|-
name|ii
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|start
operator|=
name|late_start
expr_stmt|;
name|end
operator|=
name|MAX
argument_list|(
name|end
argument_list|,
name|late_start
operator|-
name|ii
argument_list|)
expr_stmt|;
name|step
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|psp_not_empty
operator|&&
name|pss_not_empty
condition|)
block|{
name|int
name|early_start
init|=
name|INT_MIN
decl_stmt|;
name|int
name|late_start
init|=
name|INT_MAX
decl_stmt|;
name|start
operator|=
name|INT_MIN
expr_stmt|;
name|end
operator|=
name|INT_MAX
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|in
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_in
control|)
block|{
name|ddg_node_ptr
name|v_node
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|v_node
operator|->
name|cuid
argument_list|)
condition|)
block|{
name|early_start
operator|=
name|MAX
argument_list|(
name|early_start
argument_list|,
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|+
name|e
operator|->
name|latency
operator|-
operator|(
name|e
operator|->
name|distance
operator|*
name|ii
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data_type
operator|==
name|MEM_DEP
condition|)
name|end
operator|=
name|MIN
argument_list|(
name|end
argument_list|,
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|+
name|ii
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|out
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
block|{
name|ddg_node_ptr
name|v_node
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|v_node
operator|->
name|cuid
argument_list|)
condition|)
block|{
name|late_start
operator|=
name|MIN
argument_list|(
name|late_start
argument_list|,
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|-
name|e
operator|->
name|latency
operator|+
operator|(
name|e
operator|->
name|distance
operator|*
name|ii
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data_type
operator|==
name|MEM_DEP
condition|)
name|start
operator|=
name|MAX
argument_list|(
name|start
argument_list|,
name|SCHED_TIME
argument_list|(
name|v_node
argument_list|)
operator|-
name|ii
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|start
operator|=
name|MAX
argument_list|(
name|start
argument_list|,
name|early_start
argument_list|)
expr_stmt|;
name|end
operator|=
name|MIN
argument_list|(
name|end
argument_list|,
name|MIN
argument_list|(
name|early_start
operator|+
name|ii
argument_list|,
name|late_start
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* psp is empty&& pss is empty.  */
block|{
name|start
operator|=
name|SCHED_ASAP
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|ii
expr_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|start_p
operator|=
name|start
expr_stmt|;
operator|*
name|step_p
operator|=
name|step
expr_stmt|;
operator|*
name|end_p
operator|=
name|end
expr_stmt|;
name|sbitmap_free
argument_list|(
name|psp
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|pss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|start
operator|>=
name|end
operator|&&
name|step
operator|==
literal|1
operator|)
operator|||
operator|(
name|start
operator|<=
name|end
operator|&&
name|step
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function implements the scheduling algorithm for SMS according to the    above algorithm.  */
end_comment

begin_function
specifier|static
name|partial_schedule_ptr
name|sms_schedule_by_order
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|int
name|mii
parameter_list|,
name|int
name|maxii
parameter_list|,
name|int
modifier|*
name|nodes_order
parameter_list|)
block|{
name|int
name|ii
init|=
name|mii
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|success
decl_stmt|;
name|int
name|try_again_with_larger_ii
init|=
name|true
decl_stmt|;
name|int
name|num_nodes
init|=
name|g
operator|->
name|num_nodes
decl_stmt|;
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|step
decl_stmt|;
comment|/* Place together into one struct?  */
name|sbitmap
name|sched_nodes
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|must_precede
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|must_follow
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|tobe_scheduled
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|partial_schedule_ptr
name|ps
init|=
name|create_partial_schedule
argument_list|(
name|ii
argument_list|,
name|g
argument_list|,
name|DFA_HISTORY
argument_list|)
decl_stmt|;
name|sbitmap_ones
argument_list|(
name|tobe_scheduled
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|sched_nodes
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|!
name|sbitmap_equal
argument_list|(
name|tobe_scheduled
argument_list|,
name|sched_nodes
argument_list|)
operator|||
name|try_again_with_larger_ii
operator|)
operator|&&
name|ii
operator|<
name|maxii
condition|)
block|{
name|int
name|j
decl_stmt|;
name|bool
name|unscheduled_nodes
init|=
name|false
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Starting with ii=%d\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_again_with_larger_ii
condition|)
block|{
name|try_again_with_larger_ii
operator|=
name|false
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|sched_nodes
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|u
init|=
name|nodes_order
index|[
name|i
index|]
decl_stmt|;
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
name|rtx
name|insn
init|=
name|u_node
operator|->
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|RESET_BIT
argument_list|(
name|tobe_scheduled
argument_list|,
name|u
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* Closing branch handled later.  */
block|{
name|RESET_BIT
argument_list|(
name|tobe_scheduled
argument_list|,
name|u
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|u
argument_list|)
condition|)
continue|continue;
comment|/* Try to get non-empty scheduling window.  */
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|get_sched_window
argument_list|(
name|ps
argument_list|,
name|nodes_order
argument_list|,
name|i
argument_list|,
name|sched_nodes
argument_list|,
name|ii
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|step
argument_list|,
operator|&
name|end
argument_list|)
operator|<
literal|0
operator|&&
name|j
operator|>
literal|0
condition|)
block|{
name|unscheduled_nodes
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|NODE_PREDECESSORS
argument_list|(
name|u_node
argument_list|)
argument_list|,
name|nodes_order
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|||
name|TEST_BIT
argument_list|(
name|NODE_SUCCESSORS
argument_list|(
name|u_node
argument_list|)
argument_list|,
name|nodes_order
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|ps_unschedule_node
argument_list|(
name|ps
argument_list|,
operator|&
name|ps
operator|->
name|g
operator|->
name|nodes
index|[
name|nodes_order
index|[
name|j
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|nodes_order
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|j
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
comment|/* ??? Try backtracking instead of immediately ii++?  */
name|ii
operator|++
expr_stmt|;
name|try_again_with_larger_ii
operator|=
name|true
expr_stmt|;
name|reset_partial_schedule
argument_list|(
name|ps
argument_list|,
name|ii
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 2. Try scheduling u in window.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Trying to schedule node %d in (%d .. %d) step %d\n"
argument_list|,
name|u
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|step
argument_list|)
expr_stmt|;
comment|/* use must_follow& must_precede bitmaps to determine order 	     of nodes within the cycle.  */
name|sbitmap_zero
argument_list|(
name|must_precede
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|must_follow
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|in
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_in
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|e
operator|->
name|src
operator|->
name|cuid
argument_list|)
operator|&&
name|e
operator|->
name|latency
operator|==
operator|(
name|ii
operator|*
name|e
operator|->
name|distance
operator|)
operator|&&
name|start
operator|==
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|src
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|must_precede
argument_list|,
name|e
operator|->
name|src
operator|->
name|cuid
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|out
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|e
operator|->
name|dest
operator|->
name|cuid
argument_list|)
operator|&&
name|e
operator|->
name|latency
operator|==
operator|(
name|ii
operator|*
name|e
operator|->
name|distance
operator|)
operator|&&
name|end
operator|==
name|SCHED_TIME
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|must_follow
argument_list|,
name|e
operator|->
name|dest
operator|->
name|cuid
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|step
operator|>
literal|0
operator|&&
name|start
operator|<
name|end
operator|)
operator|||
operator|(
name|step
operator|<
literal|0
operator|&&
name|start
operator|>
name|end
operator|)
condition|)
for|for
control|(
name|c
operator|=
name|start
init|;
name|c
operator|!=
name|end
condition|;
name|c
operator|+=
name|step
control|)
block|{
name|ps_insn_ptr
name|psi
decl_stmt|;
name|psi
operator|=
name|ps_add_node_check_conflicts
argument_list|(
name|ps
argument_list|,
name|u_node
argument_list|,
name|c
argument_list|,
name|must_precede
argument_list|,
name|must_follow
argument_list|)
expr_stmt|;
if|if
condition|(
name|psi
condition|)
block|{
name|SCHED_TIME
argument_list|(
name|u_node
argument_list|)
operator|=
name|c
expr_stmt|;
name|SET_BIT
argument_list|(
name|sched_nodes
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Schedule in %d\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|/* ??? Try backtracking instead of immediately ii++?  */
name|ii
operator|++
expr_stmt|;
name|try_again_with_larger_ii
operator|=
name|true
expr_stmt|;
name|reset_partial_schedule
argument_list|(
name|ps
argument_list|,
name|ii
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unscheduled_nodes
condition|)
break|break;
comment|/* ??? If (success), check register pressure estimates.  */
block|}
comment|/* Continue with next node.  */
block|}
comment|/* While try_again_with_larger_ii.  */
name|sbitmap_free
argument_list|(
name|sched_nodes
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|must_precede
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|must_follow
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|tobe_scheduled
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|>=
name|maxii
condition|)
block|{
name|free_partial_schedule
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|ps
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ps
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page implements the algorithm for ordering the nodes of a DDG    for modulo scheduling, activated through the    "int sms_order_nodes (ddg_ptr, int mii, int * result)" API.  */
end_comment

begin_define
define|#
directive|define
name|ORDER_PARAMS
parameter_list|(
name|x
parameter_list|)
value|((struct node_order_params *) (x)->aux.info)
end_define

begin_define
define|#
directive|define
name|ASAP
parameter_list|(
name|x
parameter_list|)
value|(ORDER_PARAMS ((x))->asap)
end_define

begin_define
define|#
directive|define
name|ALAP
parameter_list|(
name|x
parameter_list|)
value|(ORDER_PARAMS ((x))->alap)
end_define

begin_define
define|#
directive|define
name|HEIGHT
parameter_list|(
name|x
parameter_list|)
value|(ORDER_PARAMS ((x))->height)
end_define

begin_define
define|#
directive|define
name|MOB
parameter_list|(
name|x
parameter_list|)
value|(ALAP ((x)) - ASAP ((x)))
end_define

begin_define
define|#
directive|define
name|DEPTH
parameter_list|(
name|x
parameter_list|)
value|(ASAP ((x)))
end_define

begin_typedef
typedef|typedef
name|struct
name|node_order_params
modifier|*
name|nopa
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|order_nodes_of_sccs
parameter_list|(
name|ddg_all_sccs_ptr
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|order_nodes_in_scc
parameter_list|(
name|ddg_ptr
parameter_list|,
name|sbitmap
parameter_list|,
name|sbitmap
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|nopa
name|calculate_order_params
parameter_list|(
name|ddg_ptr
parameter_list|,
name|int
name|mii
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_max_asap
parameter_list|(
name|ddg_ptr
parameter_list|,
name|sbitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_max_hv_min_mob
parameter_list|(
name|ddg_ptr
parameter_list|,
name|sbitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_max_dv_min_mob
parameter_list|(
name|ddg_ptr
parameter_list|,
name|sbitmap
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|sms_direction
block|{
name|BOTTOMUP
block|,
name|TOPDOWN
block|}
enum|;
end_enum

begin_struct
struct|struct
name|node_order_params
block|{
name|int
name|asap
decl_stmt|;
name|int
name|alap
decl_stmt|;
name|int
name|height
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Check if NODE_ORDER contains a permutation of 0 .. NUM_NODES-1.  */
end_comment

begin_function
specifier|static
name|void
name|check_nodes_order
parameter_list|(
name|int
modifier|*
name|node_order
parameter_list|,
name|int
name|num_nodes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sbitmap
name|tmp
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|u
init|=
name|node_order
index|[
name|i
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|u
operator|<
name|num_nodes
operator|&&
name|u
operator|>=
literal|0
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Order the nodes of G for scheduling and pass the result in    NODE_ORDER.  Also set aux.count of each node to ASAP.    Return the recMII for the given DDG.  */
end_comment

begin_function
specifier|static
name|int
name|sms_order_nodes
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|int
name|mii
parameter_list|,
name|int
modifier|*
name|node_order
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|rec_mii
init|=
literal|0
decl_stmt|;
name|ddg_all_sccs_ptr
name|sccs
init|=
name|create_ddg_all_sccs
argument_list|(
name|g
argument_list|)
decl_stmt|;
name|nopa
name|nops
init|=
name|calculate_order_params
argument_list|(
name|g
argument_list|,
name|mii
argument_list|)
decl_stmt|;
name|order_nodes_of_sccs
argument_list|(
name|sccs
argument_list|,
name|node_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|sccs
operator|->
name|num_sccs
operator|>
literal|0
condition|)
comment|/* First SCC has the largest recurrence_length.  */
name|rec_mii
operator|=
name|sccs
operator|->
name|sccs
index|[
literal|0
index|]
operator|->
name|recurrence_length
expr_stmt|;
comment|/* Save ASAP before destroying node_order_params.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|ddg_node_ptr
name|v
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|v
operator|->
name|aux
operator|.
name|count
operator|=
name|ASAP
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nops
argument_list|)
expr_stmt|;
name|free_ddg_all_sccs
argument_list|(
name|sccs
argument_list|)
expr_stmt|;
name|check_nodes_order
argument_list|(
name|node_order
argument_list|,
name|g
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
return|return
name|rec_mii
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|order_nodes_of_sccs
parameter_list|(
name|ddg_all_sccs_ptr
name|all_sccs
parameter_list|,
name|int
modifier|*
name|node_order
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|;
name|ddg_ptr
name|g
init|=
name|all_sccs
operator|->
name|ddg
decl_stmt|;
name|int
name|num_nodes
init|=
name|g
operator|->
name|num_nodes
decl_stmt|;
name|sbitmap
name|prev_sccs
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|on_path
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|tmp
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|ones
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|prev_sccs
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|ones
argument_list|)
expr_stmt|;
comment|/* Perfrom the node ordering starting from the SCC with the highest recMII.      For each SCC order the nodes according to their ASAP/ALAP/HEIGHT etc.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|all_sccs
operator|->
name|num_sccs
condition|;
name|i
operator|++
control|)
block|{
name|ddg_scc_ptr
name|scc
init|=
name|all_sccs
operator|->
name|sccs
index|[
name|i
index|]
decl_stmt|;
comment|/* Add nodes on paths from previous SCCs to the current SCC.  */
name|find_nodes_on_paths
argument_list|(
name|on_path
argument_list|,
name|g
argument_list|,
name|prev_sccs
argument_list|,
name|scc
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|tmp
argument_list|,
name|scc
operator|->
name|nodes
argument_list|,
name|on_path
argument_list|)
expr_stmt|;
comment|/* Add nodes on paths from the current SCC to previous SCCs.  */
name|find_nodes_on_paths
argument_list|(
name|on_path
argument_list|,
name|g
argument_list|,
name|scc
operator|->
name|nodes
argument_list|,
name|prev_sccs
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|on_path
argument_list|)
expr_stmt|;
comment|/* Remove nodes of previous SCCs from current extended SCC.  */
name|sbitmap_difference
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|prev_sccs
argument_list|)
expr_stmt|;
name|pos
operator|=
name|order_nodes_in_scc
argument_list|(
name|g
argument_list|,
name|prev_sccs
argument_list|,
name|tmp
argument_list|,
name|node_order
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* Above call to order_nodes_in_scc updated prev_sccs |= tmp.  */
block|}
comment|/* Handle the remaining nodes that do not belong to any scc.  Each call      to order_nodes_in_scc handles a single connected component.  */
while|while
condition|(
name|pos
operator|<
name|g
operator|->
name|num_nodes
condition|)
block|{
name|sbitmap_difference
argument_list|(
name|tmp
argument_list|,
name|ones
argument_list|,
name|prev_sccs
argument_list|)
expr_stmt|;
name|pos
operator|=
name|order_nodes_in_scc
argument_list|(
name|g
argument_list|,
name|prev_sccs
argument_list|,
name|tmp
argument_list|,
name|node_order
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|prev_sccs
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|on_path
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|ones
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MII is needed if we consider backarcs (that do not close recursive cycles).  */
end_comment

begin_function
specifier|static
name|struct
name|node_order_params
modifier|*
name|calculate_order_params
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|int
name|mii
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|u
decl_stmt|;
name|int
name|max_asap
decl_stmt|;
name|int
name|num_nodes
init|=
name|g
operator|->
name|num_nodes
decl_stmt|;
name|ddg_edge_ptr
name|e
decl_stmt|;
comment|/* Allocate a place to hold ordering params for each node in the DDG.  */
name|nopa
name|node_order_params_arr
decl_stmt|;
comment|/* Initialize of ASAP/ALAP/HEIGHT to zero.  */
name|node_order_params_arr
operator|=
operator|(
name|nopa
operator|)
name|xcalloc
argument_list|(
name|num_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|node_order_params
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the aux pointer of each node to point to its order_params structure.  */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|num_nodes
condition|;
name|u
operator|++
control|)
name|g
operator|->
name|nodes
index|[
name|u
index|]
operator|.
name|aux
operator|.
name|info
operator|=
operator|&
name|node_order_params_arr
index|[
name|u
index|]
expr_stmt|;
comment|/* Disregarding a backarc from each recursive cycle to obtain a DAG,      calculate ASAP, ALAP, mobility, distance, and height for each node      in the dependence (direct acyclic) graph.  */
comment|/* We assume that the nodes in the array are in topological order.  */
name|max_asap
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|num_nodes
condition|;
name|u
operator|++
control|)
block|{
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
name|ASAP
argument_list|(
name|u_node
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|in
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_in
control|)
if|if
condition|(
name|e
operator|->
name|distance
operator|==
literal|0
condition|)
name|ASAP
argument_list|(
name|u_node
argument_list|)
operator|=
name|MAX
argument_list|(
name|ASAP
argument_list|(
name|u_node
argument_list|)
argument_list|,
name|ASAP
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|+
name|e
operator|->
name|latency
argument_list|)
expr_stmt|;
name|max_asap
operator|=
name|MAX
argument_list|(
name|max_asap
argument_list|,
name|ASAP
argument_list|(
name|u_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|u
operator|=
name|num_nodes
operator|-
literal|1
init|;
name|u
operator|>
operator|-
literal|1
condition|;
name|u
operator|--
control|)
block|{
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
name|ALAP
argument_list|(
name|u_node
argument_list|)
operator|=
name|max_asap
expr_stmt|;
name|HEIGHT
argument_list|(
name|u_node
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
if|if
condition|(
name|e
operator|->
name|distance
operator|==
literal|0
condition|)
block|{
name|ALAP
argument_list|(
name|u_node
argument_list|)
operator|=
name|MIN
argument_list|(
name|ALAP
argument_list|(
name|u_node
argument_list|)
argument_list|,
name|ALAP
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|-
name|e
operator|->
name|latency
argument_list|)
expr_stmt|;
name|HEIGHT
argument_list|(
name|u_node
argument_list|)
operator|=
name|MAX
argument_list|(
name|HEIGHT
argument_list|(
name|u_node
argument_list|)
argument_list|,
name|HEIGHT
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|+
name|e
operator|->
name|latency
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|node_order_params_arr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_max_asap
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|nodes
parameter_list|)
block|{
name|unsigned
name|int
name|u
init|=
literal|0
decl_stmt|;
name|int
name|max_asap
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|sbi
argument_list|)
block|{
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
if|if
condition|(
name|max_asap
operator|<
name|ASAP
argument_list|(
name|u_node
argument_list|)
condition|)
block|{
name|max_asap
operator|=
name|ASAP
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|result
operator|=
name|u
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_max_hv_min_mob
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|nodes
parameter_list|)
block|{
name|unsigned
name|int
name|u
init|=
literal|0
decl_stmt|;
name|int
name|max_hv
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min_mob
init|=
name|INT_MAX
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|sbi
argument_list|)
block|{
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
if|if
condition|(
name|max_hv
operator|<
name|HEIGHT
argument_list|(
name|u_node
argument_list|)
condition|)
block|{
name|max_hv
operator|=
name|HEIGHT
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|min_mob
operator|=
name|MOB
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|result
operator|=
name|u
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|max_hv
operator|==
name|HEIGHT
argument_list|(
name|u_node
argument_list|)
operator|)
operator|&&
operator|(
name|min_mob
operator|>
name|MOB
argument_list|(
name|u_node
argument_list|)
operator|)
condition|)
block|{
name|min_mob
operator|=
name|MOB
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|result
operator|=
name|u
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_max_dv_min_mob
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|nodes
parameter_list|)
block|{
name|unsigned
name|int
name|u
init|=
literal|0
decl_stmt|;
name|int
name|max_dv
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min_mob
init|=
name|INT_MAX
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|sbi
argument_list|)
block|{
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
if|if
condition|(
name|max_dv
operator|<
name|DEPTH
argument_list|(
name|u_node
argument_list|)
condition|)
block|{
name|max_dv
operator|=
name|DEPTH
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|min_mob
operator|=
name|MOB
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|result
operator|=
name|u
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|max_dv
operator|==
name|DEPTH
argument_list|(
name|u_node
argument_list|)
operator|)
operator|&&
operator|(
name|min_mob
operator|>
name|MOB
argument_list|(
name|u_node
argument_list|)
operator|)
condition|)
block|{
name|min_mob
operator|=
name|MOB
argument_list|(
name|u_node
argument_list|)
expr_stmt|;
name|result
operator|=
name|u
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Places the nodes of SCC into the NODE_ORDER array starting    at position POS, according to the SMS ordering algorithm.    NODES_ORDERED (in&out parameter) holds the bitset of all nodes in    the NODE_ORDER array, starting from position zero.  */
end_comment

begin_function
specifier|static
name|int
name|order_nodes_in_scc
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|nodes_ordered
parameter_list|,
name|sbitmap
name|scc
parameter_list|,
name|int
modifier|*
name|node_order
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|enum
name|sms_direction
name|dir
decl_stmt|;
name|int
name|num_nodes
init|=
name|g
operator|->
name|num_nodes
decl_stmt|;
name|sbitmap
name|workset
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|tmp
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|zero_bitmap
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|predecessors
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|successors
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|predecessors
argument_list|)
expr_stmt|;
name|find_predecessors
argument_list|(
name|predecessors
argument_list|,
name|g
argument_list|,
name|nodes_ordered
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|successors
argument_list|)
expr_stmt|;
name|find_successors
argument_list|(
name|successors
argument_list|,
name|g
argument_list|,
name|nodes_ordered
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbitmap_a_and_b_cg
argument_list|(
name|tmp
argument_list|,
name|predecessors
argument_list|,
name|scc
argument_list|)
condition|)
block|{
name|sbitmap_copy
argument_list|(
name|workset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dir
operator|=
name|BOTTOMUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sbitmap_a_and_b_cg
argument_list|(
name|tmp
argument_list|,
name|successors
argument_list|,
name|scc
argument_list|)
condition|)
block|{
name|sbitmap_copy
argument_list|(
name|workset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dir
operator|=
name|TOPDOWN
expr_stmt|;
block|}
else|else
block|{
name|int
name|u
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|workset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|find_max_asap
argument_list|(
name|g
argument_list|,
name|scc
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|SET_BIT
argument_list|(
name|workset
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|dir
operator|=
name|BOTTOMUP
expr_stmt|;
block|}
name|sbitmap_zero
argument_list|(
name|zero_bitmap
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|sbitmap_equal
argument_list|(
name|workset
argument_list|,
name|zero_bitmap
argument_list|)
condition|)
block|{
name|int
name|v
decl_stmt|;
name|ddg_node_ptr
name|v_node
decl_stmt|;
name|sbitmap
name|v_node_preds
decl_stmt|;
name|sbitmap
name|v_node_succs
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|TOPDOWN
condition|)
block|{
while|while
condition|(
operator|!
name|sbitmap_equal
argument_list|(
name|workset
argument_list|,
name|zero_bitmap
argument_list|)
condition|)
block|{
name|v
operator|=
name|find_max_hv_min_mob
argument_list|(
name|g
argument_list|,
name|workset
argument_list|)
expr_stmt|;
name|v_node
operator|=
operator|&
name|g
operator|->
name|nodes
index|[
name|v
index|]
expr_stmt|;
name|node_order
index|[
name|pos
operator|++
index|]
operator|=
name|v
expr_stmt|;
name|v_node_succs
operator|=
name|NODE_SUCCESSORS
argument_list|(
name|v_node
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|tmp
argument_list|,
name|v_node_succs
argument_list|,
name|scc
argument_list|)
expr_stmt|;
comment|/* Don't consider the already ordered successors again.  */
name|sbitmap_difference
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|nodes_ordered
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|workset
argument_list|,
name|workset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|workset
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|nodes_ordered
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|dir
operator|=
name|BOTTOMUP
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|predecessors
argument_list|)
expr_stmt|;
name|find_predecessors
argument_list|(
name|predecessors
argument_list|,
name|g
argument_list|,
name|nodes_ordered
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|workset
argument_list|,
name|predecessors
argument_list|,
name|scc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|sbitmap_equal
argument_list|(
name|workset
argument_list|,
name|zero_bitmap
argument_list|)
condition|)
block|{
name|v
operator|=
name|find_max_dv_min_mob
argument_list|(
name|g
argument_list|,
name|workset
argument_list|)
expr_stmt|;
name|v_node
operator|=
operator|&
name|g
operator|->
name|nodes
index|[
name|v
index|]
expr_stmt|;
name|node_order
index|[
name|pos
operator|++
index|]
operator|=
name|v
expr_stmt|;
name|v_node_preds
operator|=
name|NODE_PREDECESSORS
argument_list|(
name|v_node
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|tmp
argument_list|,
name|v_node_preds
argument_list|,
name|scc
argument_list|)
expr_stmt|;
comment|/* Don't consider the already ordered predecessors again.  */
name|sbitmap_difference
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|nodes_ordered
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|workset
argument_list|,
name|workset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|workset
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|nodes_ordered
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|dir
operator|=
name|TOPDOWN
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|successors
argument_list|)
expr_stmt|;
name|find_successors
argument_list|(
name|successors
argument_list|,
name|g
argument_list|,
name|nodes_ordered
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|workset
argument_list|,
name|successors
argument_list|,
name|scc
argument_list|)
expr_stmt|;
block|}
block|}
name|sbitmap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|workset
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|zero_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|predecessors
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|successors
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains functions for manipulating partial-schedules during    modulo scheduling.  */
end_comment

begin_comment
comment|/* Create a partial schedule and allocate a memory to hold II rows.  */
end_comment

begin_function
specifier|static
name|partial_schedule_ptr
name|create_partial_schedule
parameter_list|(
name|int
name|ii
parameter_list|,
name|ddg_ptr
name|g
parameter_list|,
name|int
name|history
parameter_list|)
block|{
name|partial_schedule_ptr
name|ps
init|=
name|XNEW
argument_list|(
expr|struct
name|partial_schedule
argument_list|)
decl_stmt|;
name|ps
operator|->
name|rows
operator|=
operator|(
name|ps_insn_ptr
operator|*
operator|)
name|xcalloc
argument_list|(
name|ii
argument_list|,
sizeof|sizeof
argument_list|(
name|ps_insn_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ii
operator|=
name|ii
expr_stmt|;
name|ps
operator|->
name|history
operator|=
name|history
expr_stmt|;
name|ps
operator|->
name|min_cycle
operator|=
name|INT_MAX
expr_stmt|;
name|ps
operator|->
name|max_cycle
operator|=
name|INT_MIN
expr_stmt|;
name|ps
operator|->
name|g
operator|=
name|g
expr_stmt|;
return|return
name|ps
return|;
block|}
end_function

begin_comment
comment|/* Free the PS_INSNs in rows array of the given partial schedule.    ??? Consider caching the PS_INSN's.  */
end_comment

begin_function
specifier|static
name|void
name|free_ps_insns
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|ii
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|ps
operator|->
name|rows
index|[
name|i
index|]
condition|)
block|{
name|ps_insn_ptr
name|ps_insn
init|=
name|ps
operator|->
name|rows
index|[
name|i
index|]
operator|->
name|next_in_row
decl_stmt|;
name|free
argument_list|(
name|ps
operator|->
name|rows
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ps
operator|->
name|rows
index|[
name|i
index|]
operator|=
name|ps_insn
expr_stmt|;
block|}
name|ps
operator|->
name|rows
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free all the memory allocated to the partial schedule.  */
end_comment

begin_function
specifier|static
name|void
name|free_partial_schedule
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ps
condition|)
return|return;
name|free_ps_insns
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
operator|->
name|rows
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the rows array with its PS_INSNs, and create a new one with    NEW_II rows.  */
end_comment

begin_function
specifier|static
name|void
name|reset_partial_schedule
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|int
name|new_ii
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ps
condition|)
return|return;
name|free_ps_insns
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ii
operator|==
name|ps
operator|->
name|ii
condition|)
return|return;
name|ps
operator|->
name|rows
operator|=
operator|(
name|ps_insn_ptr
operator|*
operator|)
name|xrealloc
argument_list|(
name|ps
operator|->
name|rows
argument_list|,
name|new_ii
operator|*
sizeof|sizeof
argument_list|(
name|ps_insn_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ps
operator|->
name|rows
argument_list|,
literal|0
argument_list|,
name|new_ii
operator|*
sizeof|sizeof
argument_list|(
name|ps_insn_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ii
operator|=
name|new_ii
expr_stmt|;
name|ps
operator|->
name|min_cycle
operator|=
name|INT_MAX
expr_stmt|;
name|ps
operator|->
name|max_cycle
operator|=
name|INT_MIN
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints the partial schedule as an ii rows array, for each rows    print the ids of the insns in it.  */
end_comment

begin_function
name|void
name|print_partial_schedule
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|FILE
modifier|*
name|dump
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|ii
condition|;
name|i
operator|++
control|)
block|{
name|ps_insn_ptr
name|ps_i
init|=
name|ps
operator|->
name|rows
index|[
name|i
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n[CYCLE %d ]: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|ps_i
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%d, "
argument_list|,
name|INSN_UID
argument_list|(
name|ps_i
operator|->
name|node
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|ps_i
operator|=
name|ps_i
operator|->
name|next_in_row
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Creates an object of PS_INSN and initializes it to the given parameters.  */
end_comment

begin_function
specifier|static
name|ps_insn_ptr
name|create_ps_insn
parameter_list|(
name|ddg_node_ptr
name|node
parameter_list|,
name|int
name|rest_count
parameter_list|,
name|int
name|cycle
parameter_list|)
block|{
name|ps_insn_ptr
name|ps_i
init|=
name|XNEW
argument_list|(
expr|struct
name|ps_insn
argument_list|)
decl_stmt|;
name|ps_i
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|ps_i
operator|->
name|next_in_row
operator|=
name|NULL
expr_stmt|;
name|ps_i
operator|->
name|prev_in_row
operator|=
name|NULL
expr_stmt|;
name|ps_i
operator|->
name|row_rest_count
operator|=
name|rest_count
expr_stmt|;
name|ps_i
operator|->
name|cycle
operator|=
name|cycle
expr_stmt|;
return|return
name|ps_i
return|;
block|}
end_function

begin_comment
comment|/* Removes the given PS_INSN from the partial schedule.  Returns false if the    node is not found in the partial schedule, else returns true.  */
end_comment

begin_function
specifier|static
name|bool
name|remove_node_from_ps
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|ps_insn_ptr
name|ps_i
parameter_list|)
block|{
name|int
name|row
decl_stmt|;
if|if
condition|(
operator|!
name|ps
operator|||
operator|!
name|ps_i
condition|)
return|return
name|false
return|;
name|row
operator|=
name|SMODULO
argument_list|(
name|ps_i
operator|->
name|cycle
argument_list|,
name|ps
operator|->
name|ii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ps_i
operator|->
name|prev_in_row
condition|)
block|{
if|if
condition|(
name|ps_i
operator|!=
name|ps
operator|->
name|rows
index|[
name|row
index|]
condition|)
return|return
name|false
return|;
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|=
name|ps_i
operator|->
name|next_in_row
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|rows
index|[
name|row
index|]
condition|)
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|->
name|prev_in_row
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ps_i
operator|->
name|prev_in_row
operator|->
name|next_in_row
operator|=
name|ps_i
operator|->
name|next_in_row
expr_stmt|;
if|if
condition|(
name|ps_i
operator|->
name|next_in_row
condition|)
name|ps_i
operator|->
name|next_in_row
operator|->
name|prev_in_row
operator|=
name|ps_i
operator|->
name|prev_in_row
expr_stmt|;
block|}
name|free
argument_list|(
name|ps_i
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Unlike what literature describes for modulo scheduling (which focuses    on VLIW machines) the order of the instructions inside a cycle is    important.  Given the bitmaps MUST_FOLLOW and MUST_PRECEDE we know    where the current instruction should go relative to the already    scheduled instructions in the given cycle.  Go over these    instructions and find the first possible column to put it in.  */
end_comment

begin_function
specifier|static
name|bool
name|ps_insn_find_column
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|ps_insn_ptr
name|ps_i
parameter_list|,
name|sbitmap
name|must_precede
parameter_list|,
name|sbitmap
name|must_follow
parameter_list|)
block|{
name|ps_insn_ptr
name|next_ps_i
decl_stmt|;
name|ps_insn_ptr
name|first_must_follow
init|=
name|NULL
decl_stmt|;
name|ps_insn_ptr
name|last_must_precede
init|=
name|NULL
decl_stmt|;
name|int
name|row
decl_stmt|;
if|if
condition|(
operator|!
name|ps_i
condition|)
return|return
name|false
return|;
name|row
operator|=
name|SMODULO
argument_list|(
name|ps_i
operator|->
name|cycle
argument_list|,
name|ps
operator|->
name|ii
argument_list|)
expr_stmt|;
comment|/* Find the first must follow and the last must precede      and insert the node immediately after the must precede      but make sure that it there is no must follow after it.  */
for|for
control|(
name|next_ps_i
operator|=
name|ps
operator|->
name|rows
index|[
name|row
index|]
init|;
name|next_ps_i
condition|;
name|next_ps_i
operator|=
name|next_ps_i
operator|->
name|next_in_row
control|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|must_follow
argument_list|,
name|next_ps_i
operator|->
name|node
operator|->
name|cuid
argument_list|)
operator|&&
operator|!
name|first_must_follow
condition|)
name|first_must_follow
operator|=
name|next_ps_i
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|must_precede
argument_list|,
name|next_ps_i
operator|->
name|node
operator|->
name|cuid
argument_list|)
condition|)
block|{
comment|/* If we have already met a node that must follow, then 	     there is no possible column.  */
if|if
condition|(
name|first_must_follow
condition|)
return|return
name|false
return|;
else|else
name|last_must_precede
operator|=
name|next_ps_i
expr_stmt|;
block|}
block|}
comment|/* Now insert the node after INSERT_AFTER_PSI.  */
if|if
condition|(
operator|!
name|last_must_precede
condition|)
block|{
name|ps_i
operator|->
name|next_in_row
operator|=
name|ps
operator|->
name|rows
index|[
name|row
index|]
expr_stmt|;
name|ps_i
operator|->
name|prev_in_row
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ps_i
operator|->
name|next_in_row
condition|)
name|ps_i
operator|->
name|next_in_row
operator|->
name|prev_in_row
operator|=
name|ps_i
expr_stmt|;
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|=
name|ps_i
expr_stmt|;
block|}
else|else
block|{
name|ps_i
operator|->
name|next_in_row
operator|=
name|last_must_precede
operator|->
name|next_in_row
expr_stmt|;
name|last_must_precede
operator|->
name|next_in_row
operator|=
name|ps_i
expr_stmt|;
name|ps_i
operator|->
name|prev_in_row
operator|=
name|last_must_precede
expr_stmt|;
if|if
condition|(
name|ps_i
operator|->
name|next_in_row
condition|)
name|ps_i
operator|->
name|next_in_row
operator|->
name|prev_in_row
operator|=
name|ps_i
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Advances the PS_INSN one column in its current row; returns false    in failure and true in success.  Bit N is set in MUST_FOLLOW if     the node with cuid N must be come after the node pointed to by     PS_I when scheduled in the same cycle.  */
end_comment

begin_function
specifier|static
name|int
name|ps_insn_advance_column
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|ps_insn_ptr
name|ps_i
parameter_list|,
name|sbitmap
name|must_follow
parameter_list|)
block|{
name|ps_insn_ptr
name|prev
decl_stmt|,
name|next
decl_stmt|;
name|int
name|row
decl_stmt|;
name|ddg_node_ptr
name|next_node
decl_stmt|;
if|if
condition|(
operator|!
name|ps
operator|||
operator|!
name|ps_i
condition|)
return|return
name|false
return|;
name|row
operator|=
name|SMODULO
argument_list|(
name|ps_i
operator|->
name|cycle
argument_list|,
name|ps
operator|->
name|ii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ps_i
operator|->
name|next_in_row
condition|)
return|return
name|false
return|;
name|next_node
operator|=
name|ps_i
operator|->
name|next_in_row
operator|->
name|node
expr_stmt|;
comment|/* Check if next_in_row is dependent on ps_i, both having same sched      times (typically ANTI_DEP).  If so, ps_i cannot skip over it.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|must_follow
argument_list|,
name|next_node
operator|->
name|cuid
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Advance PS_I over its next_in_row in the doubly linked list.  */
name|prev
operator|=
name|ps_i
operator|->
name|prev_in_row
expr_stmt|;
name|next
operator|=
name|ps_i
operator|->
name|next_in_row
expr_stmt|;
if|if
condition|(
name|ps_i
operator|==
name|ps
operator|->
name|rows
index|[
name|row
index|]
condition|)
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|=
name|next
expr_stmt|;
name|ps_i
operator|->
name|next_in_row
operator|=
name|next
operator|->
name|next_in_row
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|next_in_row
condition|)
name|next
operator|->
name|next_in_row
operator|->
name|prev_in_row
operator|=
name|ps_i
expr_stmt|;
name|next
operator|->
name|next_in_row
operator|=
name|ps_i
expr_stmt|;
name|ps_i
operator|->
name|prev_in_row
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|prev_in_row
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_in_row
operator|=
name|next
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Inserts a DDG_NODE to the given partial schedule at the given cycle.    Returns 0 if this is not possible and a PS_INSN otherwise.  Bit N is     set in MUST_PRECEDE/MUST_FOLLOW if the node with cuid N must be come     before/after (respectively) the node pointed to by PS_I when scheduled     in the same cycle.  */
end_comment

begin_function
specifier|static
name|ps_insn_ptr
name|add_node_to_ps
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|ddg_node_ptr
name|node
parameter_list|,
name|int
name|cycle
parameter_list|,
name|sbitmap
name|must_precede
parameter_list|,
name|sbitmap
name|must_follow
parameter_list|)
block|{
name|ps_insn_ptr
name|ps_i
decl_stmt|;
name|int
name|rest_count
init|=
literal|1
decl_stmt|;
name|int
name|row
init|=
name|SMODULO
argument_list|(
name|cycle
argument_list|,
name|ps
operator|->
name|ii
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|&&
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|->
name|row_rest_count
operator|>=
name|issue_rate
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ps
operator|->
name|rows
index|[
name|row
index|]
condition|)
name|rest_count
operator|+=
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|->
name|row_rest_count
expr_stmt|;
name|ps_i
operator|=
name|create_ps_insn
argument_list|(
name|node
argument_list|,
name|rest_count
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
comment|/* Finds and inserts PS_I according to MUST_FOLLOW and      MUST_PRECEDE.  */
if|if
condition|(
operator|!
name|ps_insn_find_column
argument_list|(
name|ps
argument_list|,
name|ps_i
argument_list|,
name|must_precede
argument_list|,
name|must_follow
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ps_i
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ps_i
return|;
block|}
end_function

begin_comment
comment|/* Advance time one cycle.  Assumes DFA is being used.  */
end_comment

begin_function
specifier|static
name|void
name|advance_one_cycle
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_pre_cycle_insn
condition|)
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|targetm
operator|.
name|sched
operator|.
name|dfa_pre_cycle_insn
argument_list|()
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_post_cycle_insn
condition|)
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|targetm
operator|.
name|sched
operator|.
name|dfa_post_cycle_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the kernel of a loop (from FIRST_INSN to LAST_INSN), finds    the number of cycles according to DFA that the kernel fits in,    we use this to check if we done well with SMS after we add    register moves.  In some cases register moves overhead makes    it even worse than the original loop.  We want SMS to be performed    when it gives less cycles after register moves are added.  */
end_comment

begin_function
specifier|static
name|int
name|kernel_number_of_cycles
parameter_list|(
name|rtx
name|first_insn
parameter_list|,
name|rtx
name|last_insn
parameter_list|)
block|{
name|int
name|cycles
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|can_issue_more
init|=
name|issue_rate
decl_stmt|;
name|state_reset
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first_insn
init|;
name|insn
operator|!=
name|NULL_RTX
operator|&&
name|insn
operator|!=
name|last_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
continue|continue;
comment|/* Check if there is room for the current insn.  */
if|if
condition|(
operator|!
name|can_issue_more
operator|||
name|state_dead_lock_p
argument_list|(
name|curr_state
argument_list|)
condition|)
block|{
name|cycles
operator|++
expr_stmt|;
name|advance_one_cycle
argument_list|()
expr_stmt|;
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
block|}
comment|/* Update the DFA state and return with failure if the DFA found 	   recource conflicts.  */
if|if
condition|(
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|cycles
operator|++
expr_stmt|;
name|advance_one_cycle
argument_list|()
expr_stmt|;
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
condition|)
name|can_issue_more
operator|=
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
comment|/* A naked CLOBBER or USE generates no instruction, so don't 	 let them consume issue slots.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|can_issue_more
operator|--
expr_stmt|;
block|}
return|return
name|cycles
return|;
block|}
end_function

begin_comment
comment|/* Checks if PS has resource conflicts according to DFA, starting from    FROM cycle to TO cycle; returns true if there are conflicts and false    if there are no conflicts.  Assumes DFA is being used.  */
end_comment

begin_function
specifier|static
name|int
name|ps_has_conflicts
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|int
name|cycle
decl_stmt|;
name|state_reset
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
for|for
control|(
name|cycle
operator|=
name|from
init|;
name|cycle
operator|<=
name|to
condition|;
name|cycle
operator|++
control|)
block|{
name|ps_insn_ptr
name|crr_insn
decl_stmt|;
comment|/* Holds the remaining issue slots in the current row.  */
name|int
name|can_issue_more
init|=
name|issue_rate
decl_stmt|;
comment|/* Walk through the DFA for the current row.  */
for|for
control|(
name|crr_insn
operator|=
name|ps
operator|->
name|rows
index|[
name|SMODULO
argument_list|(
name|cycle
argument_list|,
name|ps
operator|->
name|ii
argument_list|)
index|]
init|;
name|crr_insn
condition|;
name|crr_insn
operator|=
name|crr_insn
operator|->
name|next_in_row
control|)
block|{
name|rtx
name|insn
init|=
name|crr_insn
operator|->
name|node
operator|->
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Check if there is room for the current insn.  */
if|if
condition|(
operator|!
name|can_issue_more
operator|||
name|state_dead_lock_p
argument_list|(
name|curr_state
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Update the DFA state and return with failure if the DFA found 	     recource conflicts.  */
if|if
condition|(
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
condition|)
name|can_issue_more
operator|=
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
comment|/* A naked CLOBBER or USE generates no instruction, so don't 	     let them consume issue slots.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|can_issue_more
operator|--
expr_stmt|;
block|}
comment|/* Advance the DFA to the next cycle.  */
name|advance_one_cycle
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Checks if the given node causes resource conflicts when added to PS at    cycle C.  If not the node is added to PS and returned; otherwise zero    is returned.  Bit N is set in MUST_PRECEDE/MUST_FOLLOW if the node with     cuid N must be come before/after (respectively) the node pointed to by     PS_I when scheduled in the same cycle.  */
end_comment

begin_function
name|ps_insn_ptr
name|ps_add_node_check_conflicts
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|ddg_node_ptr
name|n
parameter_list|,
name|int
name|c
parameter_list|,
name|sbitmap
name|must_precede
parameter_list|,
name|sbitmap
name|must_follow
parameter_list|)
block|{
name|int
name|has_conflicts
init|=
literal|0
decl_stmt|;
name|ps_insn_ptr
name|ps_i
decl_stmt|;
comment|/* First add the node to the PS, if this succeeds check for      conflicts, trying different issue slots in the same row.  */
if|if
condition|(
operator|!
operator|(
name|ps_i
operator|=
name|add_node_to_ps
argument_list|(
name|ps
argument_list|,
name|n
argument_list|,
name|c
argument_list|,
name|must_precede
argument_list|,
name|must_follow
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Failed to insert the node at the given cycle.  */
name|has_conflicts
operator|=
name|ps_has_conflicts
argument_list|(
name|ps
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
operator|||
operator|(
name|ps
operator|->
name|history
operator|>
literal|0
operator|&&
name|ps_has_conflicts
argument_list|(
name|ps
argument_list|,
name|c
operator|-
name|ps
operator|->
name|history
argument_list|,
name|c
operator|+
name|ps
operator|->
name|history
argument_list|)
operator|)
expr_stmt|;
comment|/* Try different issue slots to find one that the given node can be      scheduled in without conflicts.  */
while|while
condition|(
name|has_conflicts
condition|)
block|{
if|if
condition|(
operator|!
name|ps_insn_advance_column
argument_list|(
name|ps
argument_list|,
name|ps_i
argument_list|,
name|must_follow
argument_list|)
condition|)
break|break;
name|has_conflicts
operator|=
name|ps_has_conflicts
argument_list|(
name|ps
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
operator|||
operator|(
name|ps
operator|->
name|history
operator|>
literal|0
operator|&&
name|ps_has_conflicts
argument_list|(
name|ps
argument_list|,
name|c
operator|-
name|ps
operator|->
name|history
argument_list|,
name|c
operator|+
name|ps
operator|->
name|history
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|has_conflicts
condition|)
block|{
name|remove_node_from_ps
argument_list|(
name|ps
argument_list|,
name|ps_i
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ps
operator|->
name|min_cycle
operator|=
name|MIN
argument_list|(
name|ps
operator|->
name|min_cycle
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ps
operator|->
name|max_cycle
operator|=
name|MAX
argument_list|(
name|ps
operator|->
name|max_cycle
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ps_i
return|;
block|}
end_function

begin_comment
comment|/* Rotate the rows of PS such that insns scheduled at time    START_CYCLE will appear in row 0.  Updates max/min_cycles.  */
end_comment

begin_function
name|void
name|rotate_partial_schedule
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|int
name|start_cycle
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|row
decl_stmt|,
name|backward_rotates
decl_stmt|;
name|int
name|last_row
init|=
name|ps
operator|->
name|ii
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|start_cycle
operator|==
literal|0
condition|)
return|return;
name|backward_rotates
operator|=
name|SMODULO
argument_list|(
name|start_cycle
argument_list|,
name|ps
operator|->
name|ii
argument_list|)
expr_stmt|;
comment|/* Revisit later and optimize this into a single loop.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|backward_rotates
condition|;
name|i
operator|++
control|)
block|{
name|ps_insn_ptr
name|first_row
init|=
name|ps
operator|->
name|rows
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|last_row
condition|;
name|row
operator|++
control|)
name|ps
operator|->
name|rows
index|[
name|row
index|]
operator|=
name|ps
operator|->
name|rows
index|[
name|row
operator|+
literal|1
index|]
expr_stmt|;
name|ps
operator|->
name|rows
index|[
name|last_row
index|]
operator|=
name|first_row
expr_stmt|;
block|}
name|ps
operator|->
name|max_cycle
operator|-=
name|start_cycle
expr_stmt|;
name|ps
operator|->
name|min_cycle
operator|-=
name|start_cycle
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the node N from the partial schedule PS; because we restart the DFA    each time we want to check for resource conflicts; this is equivalent to    unscheduling the node N.  */
end_comment

begin_function
specifier|static
name|bool
name|ps_unschedule_node
parameter_list|(
name|partial_schedule_ptr
name|ps
parameter_list|,
name|ddg_node_ptr
name|n
parameter_list|)
block|{
name|ps_insn_ptr
name|ps_i
decl_stmt|;
name|int
name|row
init|=
name|SMODULO
argument_list|(
name|SCHED_TIME
argument_list|(
name|n
argument_list|)
argument_list|,
name|ps
operator|->
name|ii
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|row
operator|>
name|ps
operator|->
name|ii
condition|)
return|return
name|false
return|;
for|for
control|(
name|ps_i
operator|=
name|ps
operator|->
name|rows
index|[
name|row
index|]
init|;
name|ps_i
operator|&&
name|ps_i
operator|->
name|node
operator|!=
name|n
condition|;
name|ps_i
operator|=
name|ps_i
operator|->
name|next_in_row
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|ps_i
condition|)
return|return
name|false
return|;
return|return
name|remove_node_from_ps
argument_list|(
name|ps
argument_list|,
name|ps_i
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_sms
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_modulo_sched
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Run instruction scheduler.  */
end_comment

begin_comment
comment|/* Perform SMS module scheduling.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_sms
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|basic_block
name|bb
decl_stmt|;
comment|/* We want to be able to create new pseudos.  */
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
comment|/* Collect loop information to be used in SMS.  */
name|cfg_layout_initialize
argument_list|(
name|CLEANUP_UPDATE_LIFE
argument_list|)
expr_stmt|;
name|sms_schedule
argument_list|()
expr_stmt|;
comment|/* Update the life information, because we add pseudos.  */
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
operator|(
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
operator||
name|PROP_KILL_DEAD_CODE
operator||
name|PROP_SCAN_DEAD_CODE
operator|)
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
comment|/* Finalize layout changes.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|bb
operator|->
name|aux
operator|=
name|bb
operator|->
name|next_bb
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INSN_SCHEDULING */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_sms
init|=
block|{
literal|"sms"
block|,
comment|/* name */
name|gate_handle_sms
block|,
comment|/* gate */
name|rest_of_handle_sms
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_SMS
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
name|TODO_dump_func
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'m'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

