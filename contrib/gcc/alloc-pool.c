begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions to support a pool of allocatable objects.    Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2003, 2004    Free Software Foundation, Inc.    Contributed by Daniel Berlin<dan@cgsoftware.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* Redefine abort to report an internal error w/o coredump, and    reporting the location of the error in the source file.  This logic    is duplicated in rtl.h and tree.h because every file that needs the    special abort includes one or both.  toplev.h gets too few files,    system.h gets too many.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|fancy_abort
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|abort
parameter_list|()
value|fancy_abort (__FILE__, __LINE__, __FUNCTION__)
end_define

begin_define
define|#
directive|define
name|align_eight
parameter_list|(
name|x
parameter_list|)
value|(((x+7)>> 3)<< 3)
end_define

begin_comment
comment|/* The internal allocation object.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|allocation_object_def
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* The ID of alloc pool which the object was allocated from.  */
name|ALLOC_POOL_ID_TYPE
name|id
decl_stmt|;
endif|#
directive|endif
union|union
block|{
comment|/* The data of the object.  */
name|char
name|data
index|[
literal|1
index|]
decl_stmt|;
comment|/* Because we want any type of data to be well aligned after the ID, 	 the following elements are here.  They are never accessed so 	 the allocated object may be even smaller than this structure.  */
name|char
modifier|*
name|align_p
decl_stmt|;
name|HOST_WIDEST_INT
name|align_i
decl_stmt|;
name|long
name|double
name|align_ld
decl_stmt|;
block|}
name|u
union|;
block|}
name|allocation_object
typedef|;
end_typedef

begin_comment
comment|/* Convert a pointer to allocation_object from a pointer to user data.  */
end_comment

begin_define
define|#
directive|define
name|ALLOCATION_OBJECT_PTR_FROM_USER_PTR
parameter_list|(
name|X
parameter_list|)
define|\
value|((allocation_object *) (((char *) (X))				\ 			   - offsetof (allocation_object, u.data)))
end_define

begin_comment
comment|/* Convert a pointer to user data from a pointer to allocation_object.  */
end_comment

begin_define
define|#
directive|define
name|USER_PTR_FROM_ALLOCATION_OBJECT_PTR
parameter_list|(
name|X
parameter_list|)
define|\
value|((void *) (((allocation_object *) (X))->u.data))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* Last used ID.  */
end_comment

begin_decl_stmt
specifier|static
name|ALLOC_POOL_ID_TYPE
name|last_id
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* Store infromation about each particular alloc_pool.  */
end_comment

begin_struct
struct|struct
name|alloc_pool_descriptor
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|allocated
decl_stmt|;
name|int
name|created
decl_stmt|;
name|int
name|peak
decl_stmt|;
name|int
name|current
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hashtable mapping alloc_pool names to descriptors.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|alloc_pool_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hashtable helpers.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_descriptor
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|alloc_pool_descriptor
modifier|*
name|d
init|=
name|p
decl_stmt|;
return|return
name|htab_hash_pointer
argument_list|(
name|d
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eq_descriptor
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|alloc_pool_descriptor
modifier|*
name|d
init|=
name|p1
decl_stmt|;
return|return
name|d
operator|->
name|name
operator|==
name|p2
return|;
block|}
end_function

begin_comment
comment|/* For given name, return descriptor, create new if needed.  */
end_comment

begin_function
specifier|static
name|struct
name|alloc_pool_descriptor
modifier|*
name|alloc_pool_descriptor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|alloc_pool_descriptor
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|alloc_pool_hash
condition|)
name|alloc_pool_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor
argument_list|,
name|eq_descriptor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|alloc_pool_descriptor
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|alloc_pool_hash
argument_list|,
name|name
argument_list|,
name|htab_hash_pointer
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
operator|*
name|slot
return|;
operator|*
name|slot
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|slot
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Create a pool of things of size SIZE, with NUM in each block we    allocate.  */
end_comment

begin_function
name|alloc_pool
name|create_alloc_pool
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
name|alloc_pool
name|pool
decl_stmt|;
name|size_t
name|pool_size
decl_stmt|,
name|header_size
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|struct
name|alloc_pool_descriptor
modifier|*
name|desc
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|name
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Make size large enough to store the list header.  */
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|alloc_pool_list
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
name|alloc_pool_list
argument_list|)
expr_stmt|;
comment|/* Now align the size to a multiple of 4.  */
name|size
operator|=
name|align_eight
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Add the aligned size of ID.  */
name|size
operator|+=
name|offsetof
argument_list|(
name|allocation_object
argument_list|,
name|u
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Um, we can't really allocate 0 elements per block.  */
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the size of the pool structure, and the name.  */
name|pool_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_pool_def
argument_list|)
expr_stmt|;
comment|/* and allocate that much memory.  */
name|pool
operator|=
name|xmalloc
argument_list|(
name|pool_size
argument_list|)
expr_stmt|;
comment|/* Now init the various pieces of our pool structure.  */
name|pool
operator|->
name|name
operator|=
comment|/*xstrdup (name)*/
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|desc
operator|=
name|alloc_pool_descriptor
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|desc
operator|->
name|created
operator|++
expr_stmt|;
endif|#
directive|endif
name|pool
operator|->
name|elt_size
operator|=
name|size
expr_stmt|;
name|pool
operator|->
name|elts_per_block
operator|=
name|num
expr_stmt|;
comment|/* List header size should be a multiple of 8.  */
name|header_size
operator|=
name|align_eight
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_pool_list_def
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|block_size
operator|=
operator|(
name|size
operator|*
name|num
operator|)
operator|+
name|header_size
expr_stmt|;
name|pool
operator|->
name|free_list
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|elts_allocated
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|elts_free
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|blocks_allocated
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|block_list
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Increase the last used ID and use it for this pool.      ID == 0 is used for free elements of pool so skip it.  */
name|last_id
operator|++
expr_stmt|;
if|if
condition|(
name|last_id
operator|==
literal|0
condition|)
name|last_id
operator|++
expr_stmt|;
name|pool
operator|->
name|id
operator|=
name|last_id
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pool
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free all memory allocated for the given memory pool.  */
end_comment

begin_function
name|void
name|free_alloc_pool
parameter_list|(
name|alloc_pool
name|pool
parameter_list|)
block|{
name|alloc_pool_list
name|block
decl_stmt|,
name|next_block
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|struct
name|alloc_pool_descriptor
modifier|*
name|desc
init|=
name|alloc_pool_descriptor
argument_list|(
name|pool
operator|->
name|name
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|pool
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Free each block allocated to the pool.  */
for|for
control|(
name|block
operator|=
name|pool
operator|->
name|block_list
init|;
name|block
operator|!=
name|NULL
condition|;
name|block
operator|=
name|next_block
control|)
block|{
name|next_block
operator|=
name|block
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|block
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|desc
operator|->
name|current
operator|-=
name|pool
operator|->
name|block_size
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Lastly, free the pool.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|memset
argument_list|(
name|pool
argument_list|,
literal|0xaf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocates one element from the pool specified.  */
end_comment

begin_function
name|void
modifier|*
name|pool_alloc
parameter_list|(
name|alloc_pool
name|pool
parameter_list|)
block|{
name|alloc_pool_list
name|header
decl_stmt|;
name|char
modifier|*
name|block
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|struct
name|alloc_pool_descriptor
modifier|*
name|desc
init|=
name|alloc_pool_descriptor
argument_list|(
name|pool
operator|->
name|name
argument_list|)
decl_stmt|;
name|desc
operator|->
name|allocated
operator|+=
name|pool
operator|->
name|elt_size
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|pool
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If there are no more free elements, make some more!.  */
if|if
condition|(
operator|!
name|pool
operator|->
name|free_list
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|alloc_pool_list
name|block_header
decl_stmt|;
comment|/* Make the block.  */
name|block
operator|=
name|xmalloc
argument_list|(
name|pool
operator|->
name|block_size
argument_list|)
expr_stmt|;
name|block_header
operator|=
operator|(
name|alloc_pool_list
operator|)
name|block
expr_stmt|;
name|block
operator|+=
name|align_eight
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_pool_list_def
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|desc
operator|->
name|current
operator|+=
name|pool
operator|->
name|block_size
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|peak
operator|<
name|desc
operator|->
name|current
condition|)
name|desc
operator|->
name|peak
operator|=
name|desc
operator|->
name|current
expr_stmt|;
endif|#
directive|endif
comment|/* Throw it on the block list.  */
name|block_header
operator|->
name|next
operator|=
name|pool
operator|->
name|block_list
expr_stmt|;
name|pool
operator|->
name|block_list
operator|=
name|block_header
expr_stmt|;
comment|/* Now put the actual block pieces onto the free list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pool
operator|->
name|elts_per_block
condition|;
name|i
operator|++
operator|,
name|block
operator|+=
name|pool
operator|->
name|elt_size
control|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Mark the element to be free.  */
operator|(
operator|(
name|allocation_object
operator|*
operator|)
name|block
operator|)
operator|->
name|id
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|header
operator|=
operator|(
name|alloc_pool_list
operator|)
name|USER_PTR_FROM_ALLOCATION_OBJECT_PTR
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|header
operator|->
name|next
operator|=
name|pool
operator|->
name|free_list
expr_stmt|;
name|pool
operator|->
name|free_list
operator|=
name|header
expr_stmt|;
block|}
comment|/* Also update the number of elements we have free/allocated, and          increment the allocated block count.  */
name|pool
operator|->
name|elts_allocated
operator|+=
name|pool
operator|->
name|elts_per_block
expr_stmt|;
name|pool
operator|->
name|elts_free
operator|+=
name|pool
operator|->
name|elts_per_block
expr_stmt|;
name|pool
operator|->
name|blocks_allocated
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Pull the first free element from the free list, and return it.  */
name|header
operator|=
name|pool
operator|->
name|free_list
expr_stmt|;
name|pool
operator|->
name|free_list
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|pool
operator|->
name|elts_free
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Set the ID for element.  */
name|ALLOCATION_OBJECT_PTR_FROM_USER_PTR
argument_list|(
name|header
argument_list|)
operator|->
name|id
operator|=
name|pool
operator|->
name|id
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|header
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Puts PTR back on POOL's free list.  */
end_comment

begin_function
name|void
name|pool_free
parameter_list|(
name|alloc_pool
name|pool
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|alloc_pool_list
name|header
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|ptr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0xaf
argument_list|,
name|pool
operator|->
name|elt_size
operator|-
name|offsetof
argument_list|(
name|allocation_object
argument_list|,
name|u
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check whether the PTR was allocated from POOL.  */
if|if
condition|(
name|pool
operator|->
name|id
operator|!=
name|ALLOCATION_OBJECT_PTR_FROM_USER_PTR
argument_list|(
name|ptr
argument_list|)
operator|->
name|id
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Mark the element to be free.  */
name|ALLOCATION_OBJECT_PTR_FROM_USER_PTR
argument_list|(
name|ptr
argument_list|)
operator|->
name|id
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* Check if we free more than we allocated, which is Bad (TM).  */
if|if
condition|(
name|pool
operator|->
name|elts_free
operator|+
literal|1
operator|>
name|pool
operator|->
name|elts_allocated
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|header
operator|=
operator|(
name|alloc_pool_list
operator|)
name|ptr
expr_stmt|;
name|header
operator|->
name|next
operator|=
name|pool
operator|->
name|free_list
expr_stmt|;
name|pool
operator|->
name|free_list
operator|=
name|header
expr_stmt|;
name|pool
operator|->
name|elts_free
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output per-alloc_pool statistics.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* Used to accumulate statistics about alloc_pool sizes.  */
end_comment

begin_struct
struct|struct
name|output_info
block|{
name|int
name|count
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called via htab_traverse.  Output alloc_pool descriptor pointed out by SLOT    and update statistics.  */
end_comment

begin_function
specifier|static
name|int
name|print_statistics
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|alloc_pool_descriptor
modifier|*
name|d
init|=
operator|(
expr|struct
name|alloc_pool_descriptor
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|output_info
modifier|*
name|i
init|=
operator|(
expr|struct
name|output_info
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|allocated
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-21s %6d %10d %10d %10d\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|created
argument_list|,
name|d
operator|->
name|allocated
argument_list|,
name|d
operator|->
name|peak
argument_list|,
name|d
operator|->
name|current
argument_list|)
expr_stmt|;
name|i
operator|->
name|size
operator|+=
name|d
operator|->
name|allocated
expr_stmt|;
name|i
operator|->
name|count
operator|+=
name|d
operator|->
name|created
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output per-alloc_pool memory usage statistics.  */
end_comment

begin_function
name|void
name|dump_alloc_pool_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|struct
name|output_info
name|info
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nAlloc-pool Kind        Pools  Allocated      Peak        Leak\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|info
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|htab_traverse
argument_list|(
name|alloc_pool_hash
argument_list|,
name|print_statistics
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %7d %10d\n"
argument_list|,
literal|"Total"
argument_list|,
name|info
operator|.
name|count
argument_list|,
name|info
operator|.
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

