begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compiler driver program that can handle many languages.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  This paragraph is here to try to keep Sun CC from dying. The number of chars here seems crucial!!!!  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* This program is the user interface to the C compiler and possibly to other compilers.  It is used because compilation is a complicated procedure which involves running several programs and passing temporary files between them, forwarding the users switches to those programs selectively, and deleting the temporary files at the end.  CC recognizes how to compile each input file by suffixes in the file names. Once it knows which kind of compilation to perform, the procedure for compilation is specified by a string called a "spec".  */
end_comment

begin_comment
comment|/* A Short Introduction to Adding a Command-Line Option.     Before adding a command-line option, consider if it is really    necessary.  Each additional command-line option adds complexity and    is difficult to remove in subsequent versions.     In the following, consider adding the command-line argument    `--bar'.     1. Each command-line option is specified in the specs file.  The    notation is described below in the comment entitled "The Specs    Language".  Read it.     2. In this file, add an entry to "option_map" equating the long    `--' argument version and any shorter, single letter version.  Read    the comments in the declaration of "struct option_map" for an    explanation.  Do not omit the first `-'.     3. Look in the "specs" file to determine which program or option    list should be given the argument, e.g., "cc1_options".  Add the    appropriate syntax for the shorter option version to the    corresponding "const char *" entry in this file.  Omit the first    `-' from the option.  For example, use `-bar', rather than `--bar'.     4. If the argument takes an argument, e.g., `--baz argument1',    modify either DEFAULT_SWITCH_TAKES_ARG or    DEFAULT_WORD_SWITCH_TAKES_ARG in this file.  Omit the first `-'    from `--baz'.     5. Document the option in this file's display_help().  If the    option is passed to a subprogram, modify its corresponding    function, e.g., cppinit.c:print_help() or toplev.c:display_help(),    instead.     6. Compile and test.  Make sure that your new specs file is being    read.  For example, use a debugger to investigate the value of    "specs_file" in main().  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGCLD
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_include
include|#
directive|include
file|"gcc.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DECL_GETRUSAGE
argument_list|)
operator|&&
operator|!
name|HAVE_DECL_GETRUSAGE
end_if

begin_decl_stmt
specifier|extern
name|int
name|getrusage
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|rusage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default there is no special suffix for target executables.  */
end_comment

begin_comment
comment|/* FIXME: when autoconf is fixed, remove the host check - dj */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TARGET_EXECUTABLE_SUFFIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HOST_EXECUTABLE_SUFFIX
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_TARGET_EXECUTABLE_SUFFIX
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|TARGET_EXECUTABLE_SUFFIX
end_undef

begin_define
define|#
directive|define
name|TARGET_EXECUTABLE_SUFFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default there is no special suffix for host executables.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_EXECUTABLE_SUFFIX
end_ifdef

begin_define
define|#
directive|define
name|HAVE_HOST_EXECUTABLE_SUFFIX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_EXECUTABLE_SUFFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, the suffix for target object files is ".o".  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OBJECT_SUFFIX
end_ifdef

begin_define
define|#
directive|define
name|HAVE_TARGET_OBJECT_SUFFIX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_OBJECT_SUFFIX
value|".o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_comment
comment|/* FIXME: the location independence code for VMS is hairier than this,    and hasn't been written.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIR_UP
end_ifndef

begin_define
define|#
directive|define
name|DIR_UP
value|".."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DIR_UP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|dir_separator_str
index|[]
init|=
block|{
name|DIR_SEPARATOR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|GET_ENV_PATH_LIST
end_ifndef

begin_define
define|#
directive|define
name|GET_ENV_PATH_LIST
parameter_list|(
name|VAR
parameter_list|,
name|NAME
parameter_list|)
value|do { (VAR) = getenv (NAME); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Most every one is fine with LIBRARY_PATH.  For some, it conflicts.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBRARY_PATH_ENV
end_ifndef

begin_define
define|#
directive|define
name|LIBRARY_PATH_ENV
value|"LIBRARY_PATH"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_KILL
end_ifndef

begin_define
define|#
directive|define
name|kill
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|raise(s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If a stage of compilation returns an exit status>= 1,    compilation of that file ceases.  */
end_comment

begin_define
define|#
directive|define
name|MIN_FATAL_STATUS
value|1
end_define

begin_comment
comment|/* Flag set by cppspec.c to 1.  */
end_comment

begin_decl_stmt
name|int
name|is_cpp_driver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to pass the greatest exit code returned by a sub-process    to the calling program.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pass_exit_codes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definition of string containing the arguments given to configure.  */
end_comment

begin_include
include|#
directive|include
file|"configargs.h"
end_include

begin_comment
comment|/* Flag saying to print the directories gcc will search through looking for    programs, libraries, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_search_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the full filename of this file    as found through our usual search mechanism.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|print_file_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* As print_file_name, but search for executable file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|print_prog_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the relative path we'd use to    find libgcc.a given the current compiler flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_multi_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the list of subdirectories and    compiler flags used to select them in a standard form.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_multi_lib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the command line options understood by gcc and its    sub-processes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_help_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should print the command and arguments */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should ONLY print the command and    arguments (like verbose_flag) without executing the command.    Displayed arguments are quoted so that the generated command    line is suitable for execution.  This is intended for use in    shell scripts to capture the driver-generated command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose_only_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating to print target specific command line options.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_help_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should report subprocess execution times    (if this is supported by the system - see pexecute.c).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|report_times
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means write "temp" files in source directory    and use the source file's name in them, and don't delete them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|save_temps_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiler version.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|compiler_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target version specified with -V */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|spec_version
init|=
name|DEFAULT_TARGET_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target machine specified with -b.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|spec_machine
init|=
name|DEFAULT_TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if cross-compiling.    When -b is used, the value comes from the `specs' file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cross_compile
init|=
literal|"1"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cross_compile
init|=
literal|"0"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
end_ifdef

begin_comment
comment|/* Information on how to alter the target name based on a command-line    switch.  The only case we support now is simply appending or deleting a    string to or from the end of the first part of the configuration name.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|modify_target
block|{
specifier|const
name|char
modifier|*
specifier|const
name|sw
decl_stmt|;
specifier|const
enum|enum
name|add_del
block|{
name|ADD
block|,
name|DELETE
block|}
name|add_del
enum|;
specifier|const
name|char
modifier|*
specifier|const
name|str
decl_stmt|;
block|}
name|modify_target
index|[]
init|=
name|MODIFY_TARGET_NAME
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of errors that have occurred; the link phase will not be    run if this is non-zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Greatest exit code of sub-processes that has been encountered up to    now.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|greatest_status
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the obstack which we use to allocate many strings.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the obstack to build an environment variable to pass to    collect2 that describes all of the relevant switches of what to    pass the compiler in building the list of pointers to constructors    and destructors.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|collect_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These structs are used to collect resource usage information for    subprocesses.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rusage
name|rus
decl_stmt|,
name|prus
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declaration for prototypes.  */
end_comment

begin_struct_decl
struct_decl|struct
name|path_prefix
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|void
name|init_spec
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|split_directories
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_split_directories
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|make_relative_prefix
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_decl_stmt
specifier|static
name|void
name|store_arg
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|load_specs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_specs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_spec
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|compiler
modifier|*
name|lookup_compiler
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_search_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putenv_from_prefixes
name|PARAMS
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|access_check
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|find_a_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|translate_options
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skip_whitespace
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_if_ordinary
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_temp_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_failure_queue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_failure_queue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_live_switch
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|handle_braces
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_collect_gcc_options
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_spec_1
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|find_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_directory
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_switches
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_all_switches
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|give_switch
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|used_arg
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_arg
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_multilib_dir
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_multilib_info
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perror_with_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pfatal_pexecute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_help
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_preprocessor_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_assembler_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_linker_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_command
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execute
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_args
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fatal_error
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_SHARED_LIBGCC
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|init_gcc_specs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|obstack
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_OBJECT_SUFFIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|convert_filename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The Specs Language  Specs are strings containing lines, each of which (if not blank) is made up of a program name, and arguments separated by spaces. The program name must be exact and start from root, since no path is searched and it is unreliable to depend on the current working directory. Redirection of input or output is not supported; the subprograms must accept filenames saying what files to read and write.  In addition, the specs can contain %-sequences to substitute variable text or for conditional text.  Here is a table of all defined %-sequences. Note that spaces are not generated automatically around the results of expanding these sequences; therefore, you can concatenate them together or with constant text in a single argument.   %%	substitute one % into the program name or argument.  %i     substitute the name of the input file being processed.  %b     substitute the basename of the input file being processed. 	This is the substring up to (and not including) the last period 	and not including the directory.  %B	same as %b, but include the file suffix (text after the last period).  %gSUFFIX 	substitute a file name that has suffix SUFFIX and is chosen 	once per compilation, and mark the argument a la %d.  To reduce 	exposure to denial-of-service attacks, the file name is now 	chosen in a way that is hard to predict even when previously 	chosen file names are known.  For example, `%g.s ... %g.o ... %g.s' 	might turn into `ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s'.  SUFFIX matches 	the regexp "[.A-Za-z]*%O"; "%O" is treated exactly as if it 	had been pre-processed.  Previously, %g was simply substituted 	with a file name chosen once per compilation, without regard 	to any appended suffix (which was therefore treated just like 	ordinary text), making such attacks more likely to succeed.  %uSUFFIX 	like %g, but generates a new temporary file name even if %uSUFFIX 	was already seen.  %USUFFIX 	substitutes the last file name generated with %uSUFFIX, generating a 	new one if there is no such last file name.  In the absence of any 	%uSUFFIX, this is just like %gSUFFIX, except they don't share 	the same suffix "space", so `%g.s ... %U.s ... %g.s ... %U.s' 	would involve the generation of two distinct file names, one 	for each `%g.s' and another for each `%U.s'.  Previously, %U was 	simply substituted with a file name chosen for the previous %u, 	without regard to any appended suffix.  %jSUFFIX         substitutes the name of the HOST_BIT_BUCKET, if any, and if it is         writable, and if save-temps is off; otherwise, substitute the name         of a temporary file, just like %u.  This temporary file is not         meant for communication between processes, but rather as a junk         disposal mechanism.  %.SUFFIX         substitutes .SUFFIX for the suffixes of a matched switch's args when         it is subsequently output with %*. SUFFIX is terminated by the next         space or %.  %d	marks the argument containing or following the %d as a 	temporary file name, so that that file will be deleted if CC exits 	successfully.  Unlike %g, this contributes no text to the argument.  %w	marks the argument containing or following the %w as the 	"output file" of this compilation.  This puts the argument 	into the sequence of arguments that %o will substitute later.  %W{...} 	like %{...} but mark last argument supplied within 	as a file to be deleted on failure.  %o	substitutes the names of all the output files, with spaces 	automatically placed around them.  You should write spaces 	around the %o as well or the results are undefined. 	%o is for use in the specs for running the linker. 	Input files whose names have no recognized suffix are not compiled 	at all, but they are included among the output files, so they will 	be linked.  %O	substitutes the suffix for object files.  Note that this is         handled specially when it immediately follows %g, %u, or %U 	(with or without a suffix argument) because of the need for 	those to form complete file names.  The handling is such that 	%O is treated exactly as if it had already been substituted, 	except that %g, %u, and %U do not currently support additional 	SUFFIX characters following %O as they would following, for 	example, `.o'.  %p	substitutes the standard macro predefinitions for the 	current target machine.  Use this when running cpp.  %P	like %p, but puts `__' before and after the name of each macro. 	(Except macros that already have __.) 	This is for ANSI C.  %I	Substitute a -iprefix option made from GCC_EXEC_PREFIX.  %s     current argument is the name of a library or startup file of some sort.         Search for that file in a standard list of directories 	and substitute the full name found.  %eSTR  Print STR as an error message.  STR is terminated by a newline.         Use this when inconsistent options are detected.  %nSTR  Print STR as an notice.  STR is terminated by a newline.  %x{OPTION}	Accumulate an option for %X.  %X	Output the accumulated linker options specified by compilations.  %Y	Output the accumulated assembler options specified by compilations.  %Z	Output the accumulated preprocessor options specified by compilations.  %v1	Substitute the major version number of GCC. 	(For version 2.5.3, this is 2.)  %v2	Substitute the minor version number of GCC. 	(For version 2.5.3, this is 5.)  %v3	Substitute the patch level number of GCC. 	(For version 2.5.3, this is 3.)  %a     process ASM_SPEC as a spec.         This allows config.h to specify part of the spec for running as.  %A	process ASM_FINAL_SPEC as a spec.  A capital A is actually 	used here.  This can be used to run a post-processor after the 	assembler has done its job.  %D	Dump out a -L option for each directory in startfile_prefixes. 	If multilib_dir is set, extra entries are generated with it affixed.  %l     process LINK_SPEC as a spec.  %L     process LIB_SPEC as a spec.  %G     process LIBGCC_SPEC as a spec.  %M     output multilib_dir with directory separators replaced with "_"; 	if multilib_dir is not set or is ".", output "".  %S     process STARTFILE_SPEC as a spec.  A capital S is actually used here.  %E     process ENDFILE_SPEC as a spec.  A capital E is actually used here.  %c	process SIGNED_CHAR_SPEC as a spec.  %C     process CPP_SPEC as a spec.  %1	process CC1_SPEC as a spec.  %2	process CC1PLUS_SPEC as a spec.  %|	output "-" if the input for the current command is coming from a pipe.  %*	substitute the variable part of a matched option.  (See below.) 	Note that each comma in the substituted string is replaced by 	a single space.  %{S}   substitutes the -S switch, if that switch was given to CC. 	If that switch was not specified, this substitutes nothing. 	Here S is a metasyntactic variable.  %{S*}  substitutes all the switches specified to CC whose names start 	with -S.  This is used for -o, -I, etc; switches that take 	arguments.  CC considers `-o foo' as being one switch whose 	name starts with `o'.  %{o*} would substitute this text, 	including the space; thus, two arguments would be generated.  %{^S*} likewise, but don't put a blank between a switch and any args.  %{S*&T*} likewise, but preserve order of S and T options (the order  	of S and T in the spec is not significant).  Can be any number  	of ampersand-separated variables; for each the wild card is  	optional.  Useful for CPP as %{D*&U*&A*}.  %{S*:X} substitutes X if one or more switches whose names start with -S are 	specified to CC.  Note that the tail part of the -S option 	(i.e. the part matched by the `*') will be substituted for each 	occurrence of %* within X.  %{<S}  remove all occurrences of -S from the command line.         Note - this option is position dependent.  % commands in the         spec string before this option will see -S, % commands in the         spec string after this option will not.  %{S:X} substitutes X, but only if the -S switch was given to CC.  %{!S:X} substitutes X, but only if the -S switch was NOT given to CC.  %{|S:X} like %{S:X}, but if no S switch, substitute `-'.  %{|!S:X} like %{!S:X}, but if there is an S switch, substitute `-'.  %{.S:X} substitutes X, but only if processing a file with suffix S.  %{!.S:X} substitutes X, but only if NOT processing a file with suffix S.  %{S|P:X} substitutes X if either -S or -P was given to CC.  This may be 	  combined with ! and . as above binding stronger than the OR.  %(Spec) processes a specification defined in a specs file as *Spec:  %[Spec] as above, but put __ around -D arguments  The conditional text X in a %{S:X} or %{!S:X} construct may contain other nested % constructs or spaces, or even newlines.  They are processed as usual, as described above.  The -O, -f, -m, and -W switches are handled specifically in these constructs.  If another value of -O or the negated form of a -f, -m, or -W switch is found later in the command line, the earlier switch value is ignored, except with {S*} where S is just one letter; this passes all matching options.  The character | at the beginning of the predicate text is used to indicate that a command should be piped to the following command, but only if -pipe is specified.  Note that it is built into CC which switches take arguments and which do not.  You might think it would be useful to generalize this to allow each compiler's spec to say which switches take arguments.  But this cannot be done in a consistent fashion.  CC cannot even decide which input files have been specified without knowing which switches take arguments, and it must know which input files to compile in order to tell which compilers to run.  CC also knows implicitly that arguments starting in `-l' are to be treated as compiler output files, and passed to the linker in their proper position among the other output files.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Define the macros used for specs %a, %l, %L, %S, %c, %C, %1.  */
end_comment

begin_comment
comment|/* config.h can define ASM_SPEC to provide extra args to the assembler    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define ASM_FINAL_SPEC to run a post processor after    the assembler has run.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_FINAL_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_FINAL_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CPP_SPEC to provide extra args to the C preprocessor    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPP_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CPP_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CC1_SPEC to provide extra args to cc1 and cc1plus    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC1_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CC1_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CC1PLUS_SPEC to provide extra args to cc1plus    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC1PLUS_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CC1PLUS_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LINK_SPEC to provide extra args to the linker    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LINK_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LIB_SPEC to override the default libraries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIB_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LIB_SPEC
value|"%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LIBGCC_SPEC to override how and when libgcc.a is    included.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBGCC_SPEC
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LINK_LIBGCC_SPECIAL
argument_list|)
operator|||
name|defined
argument_list|(
name|LINK_LIBGCC_SPECIAL_1
argument_list|)
end_if

begin_comment
comment|/* Have gcc do the search for libgcc.a.  */
end_comment

begin_define
define|#
directive|define
name|LIBGCC_SPEC
value|"libgcc.a%s"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIBGCC_SPEC
value|"-lgcc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define STARTFILE_SPEC to override the default crt0 files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STARTFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|STARTFILE_SPEC
define|\
value|"%{!shared:%{pg:gcrt0%O%s}%{!pg:%{p:mcrt0%O%s}%{!p:crt0%O%s}}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define SWITCHES_NEED_SPACES to control which options    require spaces between the option and the argument.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCHES_NEED_SPACES
end_ifndef

begin_define
define|#
directive|define
name|SWITCHES_NEED_SPACES
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define ENDFILE_SPEC to override the default crtn files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENDFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ENDFILE_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This spec is used for telling cpp whether char is signed or not.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIGNED_CHAR_SPEC
end_ifndef

begin_comment
comment|/* Use #if rather than ?:    because MIPS C compiler rejects like ?: in initializers.  */
end_comment

begin_if
if|#
directive|if
name|DEFAULT_SIGNED_CHAR
end_if

begin_define
define|#
directive|define
name|SIGNED_CHAR_SPEC
value|"%{funsigned-char:-D__CHAR_UNSIGNED__}"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIGNED_CHAR_SPEC
value|"%{!fsigned-char:-D__CHAR_UNSIGNED__}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINKER_NAME
end_ifndef

begin_define
define|#
directive|define
name|LINKER_NAME
value|"collect2"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define ASM_DEBUG_SPEC to be a spec suitable for translating '-g'    to the assembler.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_DEBUG_SPEC
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GDWARF2_DEBUG_FLAG
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GSTABS_DEBUG_FLAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
define|\
value|(PREFERRED_DEBUGGING_TYPE == DBX_DEBUG			\        ? "%{gdwarf-2*:--gdwarf2}%{!gdwarf-2*:%{g*:--gstabs}}"	\        : "%{gstabs*:--gstabs}%{!gstabs*:%{g*:--gdwarf2}}")
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GSTABS_DEBUG_FLAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
value|"%{g*:--gstabs}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GDWARF2_DEBUG_FLAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
value|"%{g*:--gdwarf2}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_DEBUG_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Here is the spec for running the linker, after compiling all files.  */
end_comment

begin_comment
comment|/* -u* was put back because both BSD and SysV seem to support it.  */
end_comment

begin_comment
comment|/* %{static:} simply prevents an error message if the target machine    doesn't handle -static.  */
end_comment

begin_comment
comment|/* We want %{T*} after %{L*} and %D so that it can be used to specify linker    scripts which exist in user specified directories, or in standard    directories.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_COMMAND_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LINK_COMMAND_SPEC
value|"\ %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\     %(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r} %{s} %{t}\     %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\     %{static:} %{L*} %(link_libgcc) %o %{!nostdlib:%{!nodefaultlibs:%G %L %G}}\     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_LIBGCC_SPEC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|LINK_LIBGCC_SPECIAL
end_ifdef

begin_comment
comment|/* Don't generate -L options for startfile prefix list.  */
end_comment

begin_define
define|#
directive|define
name|LINK_LIBGCC_SPEC
value|""
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Do generate them.  */
end_comment

begin_define
define|#
directive|define
name|LINK_LIBGCC_SPEC
value|"%D"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_debug
init|=
name|ASM_DEBUG_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_spec
init|=
name|CPP_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_predefines
init|=
name|CPP_PREDEFINES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cc1_spec
init|=
name|CC1_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cc1plus_spec
init|=
name|CC1PLUS_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|signed_char_spec
init|=
name|SIGNED_CHAR_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_spec
init|=
name|ASM_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_final_spec
init|=
name|ASM_FINAL_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_spec
init|=
name|LINK_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lib_spec
init|=
name|LIB_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|libgcc_spec
init|=
name|LIBGCC_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|endfile_spec
init|=
name|ENDFILE_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|startfile_spec
init|=
name|STARTFILE_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|switches_need_spaces
init|=
name|SWITCHES_NEED_SPACES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|linker_name_spec
init|=
name|LINKER_NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_command_spec
init|=
name|LINK_COMMAND_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_libgcc_spec
init|=
name|LINK_LIBGCC_SPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard options to cpp, cc1, and as, to reduce duplication in specs.    There should be no need to override these in target dependent files,    but we need to copy them to the specs file so that newer versions    of the GCC driver can correctly drive older tool chains with the    appropriate -B options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|trad_capable_cpp
init|=
literal|"%{traditional|ftraditional|traditional-cpp:trad}cpp0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_unique_options
init|=
literal|"%{C:%{!E:%eGNU C does not support -C without using -E}}\  %{nostdinc*} %{C} %{v} %{I*} %{P} %{$} %I\  %{MD:-M -MF %W{!o: %b.d}%W{o*:%.d%*}}\  %{MMD:-MM -MF %W{!o: %b.d}%W{o*:%.d%*}}\  %{M} %{MM} %W{MF*} %{MG} %{MP} %{MQ*} %{MT*} %{M|MD|MM|MMD:%{o*:-MQ %*}}\  %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\  %{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\  %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}}\  %{fno-inline|O0|!O*:-D__NO_INLINE__} %{ffast-math:-D__FAST_MATH__}\  %{fshort-wchar:-U__WCHAR_TYPE__ -D__WCHAR_TYPE__=short\\ unsigned\\ int}\  %{ffreestanding:-D__STDC_HOSTED__=0} %{fno-hosted:-D__STDC_HOSTED__=0}\  %{!ffreestanding:%{!fno-hosted:-D__STDC_HOSTED__=1}} %{remap}\  %{g3:-dD} %{H} %C %{D*&U*&A*} %{i*} %Z %i\  %{E:%{!M*:%W{o*}}}"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This contains cpp options which are common with cc1_options and are passed    only when preprocessing only to avoid duplication.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_options
init|=
literal|"%(cpp_unique_options) %{std*} %{d*} %{W*} %{w} %{pedantic*}\  %{fshow-column} %{fno-show-column}\  %{fleading-underscore} %{fno-leading-underscore}\  %{fno-operator-names} %{ftabstop=*}"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NB: This is shared amongst all front-ends.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cc1_options
init|=
literal|"%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\  %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\  %{g*} %{O*} %{W*} %{w} %{pedantic*} %{std*} %{ansi}\  %{traditional} %{v:-version} %{pg:-p} %{p} %{f*}\  %{Qn:-fno-ident} %{--help:--help}\  %{--target-help:--target-help}\  %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\  %{fsyntax-only:-o %j} %{-param*}"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_options
init|=
literal|"%a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|invoke_as
init|=
literal|"%{!S:-o %{|!pipe:%g.s} |\n as %(asm_options) %{!pipe:%g.s} %A }"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some compilers have limits on line lengths, and the multilib_select    and/or multilib_matches strings can be very long, so we build them at    run time.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|multilib_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_select
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_matches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_defaults
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_exclusions
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"multilib.h"
end_include

begin_comment
comment|/* Check whether a particular argument is a default argument.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MULTILIB_DEFAULTS
end_ifndef

begin_define
define|#
directive|define
name|MULTILIB_DEFAULTS
value|{ "" }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|multilib_defaults_raw
index|[]
init|=
name|MULTILIB_DEFAULTS
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|user_specs
block|{
name|struct
name|user_specs
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|user_specs
modifier|*
name|user_specs_head
decl_stmt|,
modifier|*
name|user_specs_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This defines which switch letters take arguments.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SWITCH_TAKES_ARG
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o' \    || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u' \    || (CHAR) == 'I' || (CHAR) == 'm' || (CHAR) == 'x' \    || (CHAR) == 'L' || (CHAR) == 'A' || (CHAR) == 'V' \    || (CHAR) == 'B' || (CHAR) == 'b')
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|SWITCH_TAKES_ARG
parameter_list|(
name|CHAR
parameter_list|)
value|DEFAULT_SWITCH_TAKES_ARG(CHAR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This defines which multi-letter switches take arguments.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
define|\
value|(!strcmp (STR, "Tdata") || !strcmp (STR, "Ttext")	\   || !strcmp (STR, "Tbss") || !strcmp (STR, "include")	\   || !strcmp (STR, "imacros") || !strcmp (STR, "aux-info") \   || !strcmp (STR, "idirafter") || !strcmp (STR, "iprefix") \   || !strcmp (STR, "iwithprefix") || !strcmp (STR, "iwithprefixbefore") \   || !strcmp (STR, "isystem") || !strcmp (STR, "-param") \   || !strcmp (STR, "specs") \   || !strcmp (STR, "MF") || !strcmp (STR, "MT") || !strcmp (STR, "MQ"))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|WORD_SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
value|DEFAULT_WORD_SWITCH_TAKES_ARG (STR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TARGET_EXECUTABLE_SUFFIX
end_ifdef

begin_comment
comment|/* This defines which switches stop a full compilation.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SWITCH_CURTAILS_COMPILATION
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|((CHAR) == 'c' || (CHAR) == 'S')
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCH_CURTAILS_COMPILATION
end_ifndef

begin_define
define|#
directive|define
name|SWITCH_CURTAILS_COMPILATION
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|DEFAULT_SWITCH_CURTAILS_COMPILATION(CHAR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Record the mapping from file suffixes for compilation specs.  */
end_comment

begin_struct
struct|struct
name|compiler
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* Use this compiler for input files 				   whose names end in this suffix.  */
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* To use this compiler, run this spec.  */
specifier|const
name|char
modifier|*
name|cpp_spec
decl_stmt|;
comment|/* If non-NULL, substitute this spec 				   for `%C', rather than the usual 				   cpp_spec.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Pointer to a vector of `struct compiler' that gives the spec for    compiling a file, based on its suffix.    A file that does not end in any of these suffixes will be passed    unchanged to the loader and nothing else will be done to it.     An entry containing two 0s is used to terminate the vector.     If multiple entries match a file, the last matching one is used.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|compiler
modifier|*
name|compilers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in `compilers', not counting the null terminator.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_compilers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default list of file name suffixes and their compilation specs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|compiler
name|default_compilers
index|[]
init|=
block|{
comment|/* Add lists of suffixes of known languages here.  If those languages      were not present when we built the driver, we will hit these copies      and be given a more meaningful error than "file not used since      linking is not done".  */
block|{
literal|".m"
block|,
literal|"#Objective-C"
block|,
literal|0
block|}
block|,
block|{
literal|".mi"
block|,
literal|"#Objective-C"
block|,
literal|0
block|}
block|,
block|{
literal|".cc"
block|,
literal|"#C++"
block|,
literal|0
block|}
block|,
block|{
literal|".cxx"
block|,
literal|"#C++"
block|,
literal|0
block|}
block|,
block|{
literal|".cpp"
block|,
literal|"#C++"
block|,
literal|0
block|}
block|,
block|{
literal|".cp"
block|,
literal|"#C++"
block|,
literal|0
block|}
block|,
block|{
literal|".c++"
block|,
literal|"#C++"
block|,
literal|0
block|}
block|,
block|{
literal|".C"
block|,
literal|"#C++"
block|,
literal|0
block|}
block|,
block|{
literal|".ii"
block|,
literal|"#C++"
block|,
literal|0
block|}
block|,
block|{
literal|".ads"
block|,
literal|"#Ada"
block|,
literal|0
block|}
block|,
block|{
literal|".adb"
block|,
literal|"#Ada"
block|,
literal|0
block|}
block|,
block|{
literal|".f"
block|,
literal|"#Fortran"
block|,
literal|0
block|}
block|,
block|{
literal|".for"
block|,
literal|"#Fortran"
block|,
literal|0
block|}
block|,
block|{
literal|".fpp"
block|,
literal|"#Fortran"
block|,
literal|0
block|}
block|,
block|{
literal|".F"
block|,
literal|"#Fortran"
block|,
literal|0
block|}
block|,
block|{
literal|".FOR"
block|,
literal|"#Fortran"
block|,
literal|0
block|}
block|,
block|{
literal|".FPP"
block|,
literal|"#Fortran"
block|,
literal|0
block|}
block|,
block|{
literal|".r"
block|,
literal|"#Ratfor"
block|,
literal|0
block|}
block|,
block|{
literal|".p"
block|,
literal|"#Pascal"
block|,
literal|0
block|}
block|,
block|{
literal|".pas"
block|,
literal|"#Pascal"
block|,
literal|0
block|}
block|,
block|{
literal|".ch"
block|,
literal|"#Chill"
block|,
literal|0
block|}
block|,
block|{
literal|".chi"
block|,
literal|"#Chill"
block|,
literal|0
block|}
block|,
block|{
literal|".java"
block|,
literal|"#Java"
block|,
literal|0
block|}
block|,
block|{
literal|".class"
block|,
literal|"#Java"
block|,
literal|0
block|}
block|,
block|{
literal|".zip"
block|,
literal|"#Java"
block|,
literal|0
block|}
block|,
block|{
literal|".jar"
block|,
literal|"#Java"
block|,
literal|0
block|}
block|,
comment|/* Next come the entries for C.  */
block|{
literal|".c"
block|,
literal|"@c"
block|,
literal|0
block|}
block|,
block|{
literal|"@c"
block|,
comment|/* cc1 has an integrated ISO C preprocessor.  We should invoke the       external preprocessor if -save-temps or -traditional is given.  */
literal|"%{E|M|MM:%(trad_capable_cpp) -lang-c %{ansi:-std=c89} %(cpp_options)}\       %{!E:%{!M:%{!MM:\ 	  %{save-temps:%(trad_capable_cpp) -lang-c %{ansi:-std=c89}\ 		%(cpp_options) %b.i \n\ 		    cc1 -fpreprocessed %b.i %(cc1_options)}\ 	  %{!save-temps:\ 	    %{traditional|ftraditional|traditional-cpp:\ 		tradcpp0 -lang-c %{ansi:-std=c89} %(cpp_options) %{!pipe:%g.i} |\n\ 		    cc1 -fpreprocessed %{!pipe:%g.i} %(cc1_options)}\ 	    %{!traditional:%{!ftraditional:%{!traditional-cpp:\ 		cc1 -lang-c %{ansi:-std=c89} %(cpp_unique_options) %(cc1_options)}}}}\         %{!fsyntax-only:%(invoke_as)}}}}"
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
literal|"%{!E:%e-E required when input is from standard input}\     %(trad_capable_cpp) -lang-c %{ansi:-std=c89} %(cpp_options)"
block|,
literal|0
block|}
block|,
block|{
literal|".h"
block|,
literal|"@c-header"
block|,
literal|0
block|}
block|,
block|{
literal|"@c-header"
block|,
literal|"%{!E:%ecompilation of header file requested} \     %(trad_capable_cpp) -lang-c %{ansi:-std=c89} %(cpp_options)"
block|,
literal|0
block|}
block|,
block|{
literal|".i"
block|,
literal|"@cpp-output"
block|,
literal|0
block|}
block|,
block|{
literal|"@cpp-output"
block|,
literal|"%{!M:%{!MM:%{!E:cc1 -fpreprocessed %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}}}}"
block|,
literal|0
block|}
block|,
block|{
literal|".s"
block|,
literal|"@assembler"
block|,
literal|0
block|}
block|,
block|{
literal|"@assembler"
block|,
literal|"%{!M:%{!MM:%{!E:%{!S:as %(asm_debug) %(asm_options) %i %A }}}}"
block|,
literal|0
block|}
block|,
block|{
literal|".S"
block|,
literal|"@assembler-with-cpp"
block|,
literal|0
block|}
block|,
block|{
literal|"@assembler-with-cpp"
block|,
literal|"%(trad_capable_cpp) -lang-asm %(cpp_options)\       %{!M:%{!MM:%{!E:%{!S:-o %{|!pipe:%g.s} |\n\        as %(asm_debug) %(asm_options) %{!pipe:%g.s} %A }}}}"
block|,
literal|0
block|}
block|,
include|#
directive|include
file|"specs.h"
comment|/* Mark end of table */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in default_compilers, not counting the terminator.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_default_compilers
init|=
operator|(
sizeof|sizeof
name|default_compilers
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|compiler
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the linker.    These options are accumulated by %x,    and substituted into the linker command with %X.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_linker_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|linker_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the assembler.    These options are accumulated by -Wa,    and substituted into the assembler command with %Y.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_assembler_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|assembler_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the preprocessor.    These options are accumulated by -Wp,    and substituted into the preprocessor command with %Z.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_preprocessor_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|preprocessor_options
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Define how to map long options into short ones.  */
end_comment

begin_comment
comment|/* This structure describes one mapping.  */
end_comment

begin_struct
struct|struct
name|option_map
block|{
comment|/* The long option's name.  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* The equivalent short option.  */
specifier|const
name|char
modifier|*
specifier|const
name|equivalent
decl_stmt|;
comment|/* Argument info.  A string of flag chars; NULL equals no options.      a => argument required.      o => argument optional.      j => join argument to equivalent, making one word.      * => require other text after NAME as an argument.  */
specifier|const
name|char
modifier|*
specifier|const
name|arg_info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the table of mappings.  Mappings are tried sequentially    for each option encountered; the first one that matches, wins.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option_map
name|option_map
index|[]
init|=
block|{
block|{
literal|"--all-warnings"
block|,
literal|"-Wall"
block|,
literal|0
block|}
block|,
block|{
literal|"--ansi"
block|,
literal|"-ansi"
block|,
literal|0
block|}
block|,
block|{
literal|"--assemble"
block|,
literal|"-S"
block|,
literal|0
block|}
block|,
block|{
literal|"--assert"
block|,
literal|"-A"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--classpath"
block|,
literal|"-fclasspath="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--CLASSPATH"
block|,
literal|"-fCLASSPATH="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--comments"
block|,
literal|"-C"
block|,
literal|0
block|}
block|,
block|{
literal|"--compile"
block|,
literal|"-c"
block|,
literal|0
block|}
block|,
block|{
literal|"--debug"
block|,
literal|"-g"
block|,
literal|"oj"
block|}
block|,
block|{
literal|"--define-macro"
block|,
literal|"-D"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--dependencies"
block|,
literal|"-M"
block|,
literal|0
block|}
block|,
block|{
literal|"--dump"
block|,
literal|"-d"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--dumpbase"
block|,
literal|"-dumpbase"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--entry"
block|,
literal|"-e"
block|,
literal|0
block|}
block|,
block|{
literal|"--extra-warnings"
block|,
literal|"-W"
block|,
literal|0
block|}
block|,
block|{
literal|"--for-assembler"
block|,
literal|"-Wa"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--for-linker"
block|,
literal|"-Xlinker"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--force-link"
block|,
literal|"-u"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--imacros"
block|,
literal|"-imacros"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include"
block|,
literal|"-include"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-barrier"
block|,
literal|"-I-"
block|,
literal|0
block|}
block|,
block|{
literal|"--include-directory"
block|,
literal|"-I"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--include-directory-after"
block|,
literal|"-idirafter"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-prefix"
block|,
literal|"-iprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix"
block|,
literal|"-iwithprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix-before"
block|,
literal|"-iwithprefixbefore"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix-after"
block|,
literal|"-iwithprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--language"
block|,
literal|"-x"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--library-directory"
block|,
literal|"-L"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--machine"
block|,
literal|"-m"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--machine-"
block|,
literal|"-m"
block|,
literal|"*j"
block|}
block|,
block|{
literal|"--no-line-commands"
block|,
literal|"-P"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-precompiled-includes"
block|,
literal|"-noprecomp"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-standard-includes"
block|,
literal|"-nostdinc"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-standard-libraries"
block|,
literal|"-nostdlib"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-warnings"
block|,
literal|"-w"
block|,
literal|0
block|}
block|,
block|{
literal|"--optimize"
block|,
literal|"-O"
block|,
literal|"oj"
block|}
block|,
block|{
literal|"--output"
block|,
literal|"-o"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--output-class-directory"
block|,
literal|"-foutput-class-dir="
block|,
literal|"ja"
block|}
block|,
block|{
literal|"--param"
block|,
literal|"--param"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--pedantic"
block|,
literal|"-pedantic"
block|,
literal|0
block|}
block|,
block|{
literal|"--pedantic-errors"
block|,
literal|"-pedantic-errors"
block|,
literal|0
block|}
block|,
block|{
literal|"--pipe"
block|,
literal|"-pipe"
block|,
literal|0
block|}
block|,
block|{
literal|"--prefix"
block|,
literal|"-B"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--preprocess"
block|,
literal|"-E"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-search-dirs"
block|,
literal|"-print-search-dirs"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-file-name"
block|,
literal|"-print-file-name="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--print-libgcc-file-name"
block|,
literal|"-print-libgcc-file-name"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-missing-file-dependencies"
block|,
literal|"-MG"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-multi-lib"
block|,
literal|"-print-multi-lib"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-multi-directory"
block|,
literal|"-print-multi-directory"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-prog-name"
block|,
literal|"-print-prog-name="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--profile"
block|,
literal|"-p"
block|,
literal|0
block|}
block|,
block|{
literal|"--profile-blocks"
block|,
literal|"-a"
block|,
literal|0
block|}
block|,
block|{
literal|"--quiet"
block|,
literal|"-q"
block|,
literal|0
block|}
block|,
block|{
literal|"--save-temps"
block|,
literal|"-save-temps"
block|,
literal|0
block|}
block|,
block|{
literal|"--shared"
block|,
literal|"-shared"
block|,
literal|0
block|}
block|,
block|{
literal|"--silent"
block|,
literal|"-q"
block|,
literal|0
block|}
block|,
block|{
literal|"--specs"
block|,
literal|"-specs="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--static"
block|,
literal|"-static"
block|,
literal|0
block|}
block|,
block|{
literal|"--std"
block|,
literal|"-std="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--symbolic"
block|,
literal|"-symbolic"
block|,
literal|0
block|}
block|,
block|{
literal|"--target"
block|,
literal|"-b"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--time"
block|,
literal|"-time"
block|,
literal|0
block|}
block|,
block|{
literal|"--trace-includes"
block|,
literal|"-H"
block|,
literal|0
block|}
block|,
block|{
literal|"--traditional"
block|,
literal|"-traditional"
block|,
literal|0
block|}
block|,
block|{
literal|"--traditional-cpp"
block|,
literal|"-traditional-cpp"
block|,
literal|0
block|}
block|,
block|{
literal|"--trigraphs"
block|,
literal|"-trigraphs"
block|,
literal|0
block|}
block|,
block|{
literal|"--undefine-macro"
block|,
literal|"-U"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--use-version"
block|,
literal|"-V"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--user-dependencies"
block|,
literal|"-MM"
block|,
literal|0
block|}
block|,
block|{
literal|"--verbose"
block|,
literal|"-v"
block|,
literal|0
block|}
block|,
block|{
literal|"--warn-"
block|,
literal|"-W"
block|,
literal|"*j"
block|}
block|,
block|{
literal|"--write-dependencies"
block|,
literal|"-MD"
block|,
literal|0
block|}
block|,
block|{
literal|"--write-user-dependencies"
block|,
literal|"-MMD"
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
literal|"-f"
block|,
literal|"*j"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OPTION_TRANSLATE_TABLE
end_ifdef

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|option_found
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|replacements
decl_stmt|;
block|}
name|target_option_translations
index|[]
init|=
block|{
name|TARGET_OPTION_TRANSLATE_TABLE
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate the options described by *ARGCP and *ARGVP.    Make a new vector and store it back in *ARGVP,    and store its length in *ARGVC.  */
end_comment

begin_function
specifier|static
name|void
name|translate_options
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|argc
init|=
operator|*
name|argcp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|argv
init|=
operator|*
name|argvp
decl_stmt|;
name|int
name|newvsize
init|=
operator|(
name|argc
operator|+
literal|2
operator|)
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|newv
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|newvsize
argument_list|)
decl_stmt|;
name|int
name|newindex
init|=
literal|0
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|argc
condition|)
block|{
ifdef|#
directive|ifdef
name|TARGET_OPTION_TRANSLATE_TABLE
name|int
name|tott_idx
decl_stmt|;
for|for
control|(
name|tott_idx
operator|=
literal|0
init|;
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|option_found
condition|;
name|tott_idx
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|option_found
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|spaces
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|replacements
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|' '
condition|)
name|spaces
operator|++
expr_stmt|;
block|}
name|newvsize
operator|+=
name|spaces
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|newv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|newv
argument_list|,
name|newvsize
argument_list|)
expr_stmt|;
name|sp
operator|=
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|replacements
expr_stmt|;
name|np
operator|=
name|xstrdup
argument_list|(
name|sp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|np
operator|==
literal|' '
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|0
condition|)
break|break;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|np
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|!=
literal|' '
operator|&&
operator|*
name|np
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|0
condition|)
break|break;
operator|*
name|np
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|option_found
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Translate -- options.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|size_t
name|j
decl_stmt|;
comment|/* Find a mapping that applies to this option.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|option_map
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|size_t
name|optlen
init|=
name|strlen
argument_list|(
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|size_t
name|arglen
init|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|size_t
name|complen
init|=
name|arglen
operator|>
name|optlen
condition|?
name|optlen
else|:
name|arglen
decl_stmt|;
specifier|const
name|char
modifier|*
name|arginfo
init|=
name|option_map
index|[
name|j
index|]
operator|.
name|arg_info
decl_stmt|;
if|if
condition|(
name|arginfo
operator|==
literal|0
condition|)
name|arginfo
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|complen
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arglen
operator|<
name|optlen
condition|)
block|{
name|size_t
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
name|ARRAY_SIZE
argument_list|(
name|option_map
argument_list|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
name|option_map
index|[
name|k
index|]
operator|.
name|name
argument_list|)
operator|>=
name|arglen
operator|&&
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|option_map
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|arglen
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous abbreviation %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|k
operator|!=
name|ARRAY_SIZE
argument_list|(
name|option_map
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|arglen
operator|>
name|optlen
condition|)
block|{
comment|/* If the option has an argument, accept that.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|optlen
index|]
operator|==
literal|'='
condition|)
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|optlen
operator|+
literal|1
expr_stmt|;
comment|/* If this mapping requires extra text at end of name, 			 accept that as "argument".  */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|optlen
expr_stmt|;
comment|/* Otherwise, extra text at end means mismatch. 			 Try other mappings.  */
else|else
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"incomplete `%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Handle arguments.  */
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'a'
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"missing argument to `%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'o'
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"extraneous argument to `%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Store the translation as one argv elt or as two.  */
if|if
condition|(
name|arg
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'j'
argument_list|)
operator|!=
literal|0
condition|)
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|concat
argument_list|(
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
literal|0
condition|)
block|{
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
expr_stmt|;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
else|else
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* Handle old-fashioned options--just copy them through, 	 with their arguments.  */
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
name|int
name|nskip
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
name|nskip
operator|+=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|nskip
operator|+=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
literal|'V'
operator|||
name|c
operator|==
literal|'x'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"Xlinker"
argument_list|)
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
comment|/* Watch out for an option at the end of the command line that 	     is missing arguments, and avoid skipping past the end of the 	     command line.  */
if|if
condition|(
name|nskip
operator|+
name|i
operator|>
name|argc
condition|)
name|nskip
operator|=
name|argc
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|nskip
operator|>
literal|0
condition|)
block|{
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
name|nskip
operator|--
expr_stmt|;
block|}
block|}
else|else
comment|/* Ordinary operands, or +e options.  */
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
name|newv
index|[
name|newindex
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|argvp
operator|=
name|newv
expr_stmt|;
operator|*
name|argcp
operator|=
name|newindex
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|skip_whitespace
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* A fully-blank line is a delimiter in the SPEC file and shouldn't 	 be considered whitespace.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
return|return
name|p
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Structures to keep track of prefixes to try when looking for files.  */
end_comment

begin_struct
struct|struct
name|prefix_list
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* String to prepend to the path.  */
name|struct
name|prefix_list
modifier|*
name|next
decl_stmt|;
comment|/* Next in linked list.  */
name|int
name|require_machine_suffix
decl_stmt|;
comment|/* Don't use without machine_suffix.  */
comment|/* 2 means try both machine_suffix and just_machine_suffix.  */
name|int
modifier|*
name|used_flag_ptr
decl_stmt|;
comment|/* 1 if a file was found with this prefix.  */
name|int
name|priority
decl_stmt|;
comment|/* Sort key - priority within list */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|path_prefix
block|{
name|struct
name|prefix_list
modifier|*
name|plist
decl_stmt|;
comment|/* List of prefixes to try */
name|int
name|max_len
decl_stmt|;
comment|/* Max length of a prefix in PLIST */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of this list (used in config stuff) */
block|}
struct|;
end_struct

begin_comment
comment|/* List of prefixes to try when looking for executables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|exec_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"exec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of prefixes to try when looking for startup (crt0) files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|startfile_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"startfile"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of prefixes to try when looking for include files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|include_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"include"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suffix to attach to directories searched for commands.    This looks like `MACHINE/VERSION/'.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|machine_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suffix to attach to directories searched for commands.    This is just `MACHINE/'.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|just_machine_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjusted value of GCC_EXEC_PREFIX envvar.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gcc_exec_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default prefixes to attach to command names.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_comment
comment|/* Don't use these prefixes for a cross compiler.  */
end_comment

begin_undef
undef|#
directive|undef
name|MD_EXEC_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|MD_STARTFILE_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|MD_STARTFILE_PREFIX_1
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If no prefixes defined, use the null string, which will disable them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MD_EXEC_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|MD_EXEC_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MD_STARTFILE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|MD_STARTFILE_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MD_STARTFILE_PREFIX_1
end_ifndef

begin_define
define|#
directive|define
name|MD_STARTFILE_PREFIX_1
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Supply defaults for the standard prefixes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_EXEC_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_EXEC_PREFIX
value|"/usr/local/lib/gcc-lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_STARTFILE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_STARTFILE_PREFIX
value|"/usr/local/lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TOOLDIR_BASE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|TOOLDIR_BASE_PREFIX
value|"/usr/local/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_BINDIR_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_BINDIR_PREFIX
value|"/usr/local/bin"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_exec_prefix
init|=
name|STANDARD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_exec_prefix_1
init|=
literal|"/usr/lib/gcc/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|md_exec_prefix
init|=
name|MD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|md_startfile_prefix
init|=
name|MD_STARTFILE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|md_startfile_prefix_1
init|=
name|MD_STARTFILE_PREFIX_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_startfile_prefix
init|=
name|STANDARD_STARTFILE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_startfile_prefix_1
init|=
literal|"/lib/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_startfile_prefix_2
init|=
literal|"/usr/lib/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tooldir_base_prefix
init|=
name|TOOLDIR_BASE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tooldir_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_bindir_prefix
init|=
name|STANDARD_BINDIR_PREFIX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subdirectory to use for locating libraries.  Set by    set_multilib_dir based on the compilation options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_dir
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Structure to keep track of the specs that have been defined so far.    These are accessed using %(specname) or %[specname] in a compiler    or link spec.  */
end_comment

begin_struct
struct|struct
name|spec_list
block|{
comment|/* The following 2 fields must be first */
comment|/* to allow EXTRA_SPECS to be initialized */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the spec.  */
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* available ptr if no static pointer */
comment|/* The following fields are not initialized */
comment|/* by EXTRA_SPECS */
specifier|const
name|char
modifier|*
modifier|*
name|ptr_spec
decl_stmt|;
comment|/* pointer to the spec itself.  */
name|struct
name|spec_list
modifier|*
name|next
decl_stmt|;
comment|/* Next spec in linked list.  */
name|int
name|name_len
decl_stmt|;
comment|/* length of the name */
name|int
name|alloc_p
decl_stmt|;
comment|/* whether string was allocated */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INIT_STATIC_SPEC
parameter_list|(
name|NAME
parameter_list|,
name|PTR
parameter_list|)
define|\
value|{ NAME, NULL, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, 0 }
end_define

begin_comment
comment|/* List of statically defined specs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spec_list
name|static_specs
index|[]
init|=
block|{
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm"
argument_list|,
operator|&
name|asm_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm_debug"
argument_list|,
operator|&
name|asm_debug
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm_final"
argument_list|,
operator|&
name|asm_final_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm_options"
argument_list|,
operator|&
name|asm_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"invoke_as"
argument_list|,
operator|&
name|invoke_as
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cpp"
argument_list|,
operator|&
name|cpp_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cpp_options"
argument_list|,
operator|&
name|cpp_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cpp_unique_options"
argument_list|,
operator|&
name|cpp_unique_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"trad_capable_cpp"
argument_list|,
operator|&
name|trad_capable_cpp
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cc1"
argument_list|,
operator|&
name|cc1_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cc1_options"
argument_list|,
operator|&
name|cc1_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cc1plus"
argument_list|,
operator|&
name|cc1plus_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"endfile"
argument_list|,
operator|&
name|endfile_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"link"
argument_list|,
operator|&
name|link_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"lib"
argument_list|,
operator|&
name|lib_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"libgcc"
argument_list|,
operator|&
name|libgcc_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"startfile"
argument_list|,
operator|&
name|startfile_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"switches_need_spaces"
argument_list|,
operator|&
name|switches_need_spaces
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"signed_char"
argument_list|,
operator|&
name|signed_char_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"predefines"
argument_list|,
operator|&
name|cpp_predefines
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cross_compile"
argument_list|,
operator|&
name|cross_compile
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"version"
argument_list|,
operator|&
name|compiler_version
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib"
argument_list|,
operator|&
name|multilib_select
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_defaults"
argument_list|,
operator|&
name|multilib_defaults
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_extra"
argument_list|,
operator|&
name|multilib_extra
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_matches"
argument_list|,
operator|&
name|multilib_matches
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_exclusions"
argument_list|,
operator|&
name|multilib_exclusions
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"linker"
argument_list|,
operator|&
name|linker_name_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"link_libgcc"
argument_list|,
operator|&
name|link_libgcc_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"md_exec_prefix"
argument_list|,
operator|&
name|md_exec_prefix
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"md_startfile_prefix"
argument_list|,
operator|&
name|md_startfile_prefix
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"md_startfile_prefix_1"
argument_list|,
operator|&
name|md_startfile_prefix_1
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SPECS
end_ifdef

begin_comment
comment|/* additional specs needed */
end_comment

begin_comment
comment|/* Structure to keep track of just the first two args of a spec_list.    That is all that the EXTRA_SPECS macro gives us.  */
end_comment

begin_struct
struct|struct
name|spec_list_1
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|ptr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|spec_list_1
name|extra_specs_1
index|[]
init|=
block|{
name|EXTRA_SPECS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|spec_list
modifier|*
name|extra_specs
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of dynamically allocates specs that have been defined so far.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spec_list
modifier|*
name|specs
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add appropriate libgcc specs to OBSTACK, taking into account    various permutations of -shared-libgcc, -shared, and such.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_SHARED_LIBGCC
end_ifdef

begin_function
specifier|static
name|void
name|init_gcc_specs
parameter_list|(
name|obstack
parameter_list|,
name|shared_name
parameter_list|,
name|static_name
parameter_list|,
name|eh_name
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
specifier|const
name|char
modifier|*
name|shared_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|static_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|eh_name
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If we see -shared-libgcc, then use the shared version.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%%{shared-libgcc:%s %s}"
argument_list|,
name|shared_name
argument_list|,
name|static_name
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we see -static-libgcc, then use the static version.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%%{static-libgcc:%s %s}"
argument_list|,
name|static_name
argument_list|,
name|eh_name
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise, if we see -shared, then use the shared version      if using EH registration routines or static version without      exception handling routines otherwise.  */
name|p
operator|=
literal|"%{!shared-libgcc:%{!static-libgcc:%{shared:"
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINK_EH_SPEC
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s}}}"
argument_list|,
name|static_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s}}}"
argument_list|,
name|shared_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise, use the static version.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%%{!shared-libgcc:%%{!static-libgcc:%%{!shared:%s %s}}}"
argument_list|,
name|static_name
argument_list|,
name|eh_name
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_SHARED_LIBGCC */
end_comment

begin_comment
comment|/* Initialize the specs lookup routines.  */
end_comment

begin_function
specifier|static
name|void
name|init_spec
parameter_list|()
block|{
name|struct
name|spec_list
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|sl
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|specs
condition|)
return|return;
comment|/* Already initialized.  */
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"Using built-in specs.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_SPECS
name|extra_specs
operator|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_list
argument_list|)
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|extra_specs_1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|extra_specs_1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sl
operator|=
operator|&
name|extra_specs
index|[
name|i
index|]
expr_stmt|;
name|sl
operator|->
name|name
operator|=
name|extra_specs_1
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|sl
operator|->
name|ptr
operator|=
name|extra_specs_1
index|[
name|i
index|]
operator|.
name|ptr
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|sl
operator|->
name|name_len
operator|=
name|strlen
argument_list|(
name|sl
operator|->
name|name
argument_list|)
expr_stmt|;
name|sl
operator|->
name|ptr_spec
operator|=
operator|&
name|sl
operator|->
name|ptr
expr_stmt|;
name|next
operator|=
name|sl
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|static_specs
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sl
operator|=
operator|&
name|static_specs
index|[
name|i
index|]
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|sl
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_SHARED_LIBGCC
comment|/* ??? If neither -shared-libgcc nor --static-libgcc was      seen, then we should be making an educated guess.  Some proposed      heuristics for ELF include:  	(1) If "-Wl,--export-dynamic", then it's a fair bet that the 	    program will be doing dynamic loading, which will likely 	    need the shared libgcc.  	(2) If "-ldl", then it's also a fair bet that we're doing 	    dynamic loading.  	(3) For each ET_DYN we're linking against (either through -lfoo 	    or /some/path/foo.so), check to see whether it or one of 	    its dependencies depends on a shared libgcc.  	(4) If "-shared"  	    If the runtime is fixed to look for program headers instead 	    of calling __register_frame_info at all, for each object, 	    use the shared libgcc if any EH symbol referenced.  	    If crtstuff is fixed to not invoke __register_frame_info 	    automatically, for each object, use the shared libgcc if 	    any non-empty unwind section found.       Doing any of this probably requires invoking an external program to      do the actual object file scanning.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|libgcc_spec
decl_stmt|;
name|int
name|in_sep
init|=
literal|1
decl_stmt|;
comment|/* Transform the extant libgcc_spec into one that uses the shared libgcc        when given the proper command line arguments.  */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|in_sep
operator|&&
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-lgcc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|init_gcc_specs
argument_list|(
operator|&
name|obstack
argument_list|,
ifdef|#
directive|ifdef
name|NO_SHARED_LIBGCC_MULTILIB
literal|"-lgcc_s"
else|#
directive|else
literal|"-lgcc_s%M"
endif|#
directive|endif
argument_list|,
literal|"-lgcc"
argument_list|,
literal|"-lgcc_eh"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
name|in_sep
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_sep
operator|&&
operator|*
name|p
operator|==
literal|'l'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"libgcc.a%s"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Ug.  We don't know shared library extensions.  Hope that 	       systems that use this form don't do shared libraries.  */
name|init_gcc_specs
argument_list|(
operator|&
name|obstack
argument_list|,
ifdef|#
directive|ifdef
name|NO_SHARED_LIBGCC_MULTILIB
literal|"-lgcc_s"
else|#
directive|else
literal|"-lgcc_s%M"
endif|#
directive|endif
argument_list|,
literal|"libgcc.a%s"
argument_list|,
literal|"libgcc_eh.a%s"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|10
expr_stmt|;
name|in_sep
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|in_sep
operator|=
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|libgcc_spec
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_AS_TRADITIONAL_FORMAT
comment|/* Prepend "--traditional-format" to whatever asm_spec we had before.  */
block|{
specifier|static
specifier|const
name|char
name|tf
index|[]
init|=
literal|"--traditional-format "
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|tf
argument_list|,
sizeof|sizeof
argument_list|(
name|tf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|asm_spec
argument_list|,
name|strlen
argument_list|(
name|asm_spec
argument_list|)
argument_list|)
expr_stmt|;
name|asm_spec
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LINK_EH_SPEC
comment|/* Prepend LINK_EH_SPEC to whatever link_spec we had before.  */
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|LINK_EH_SPEC
argument_list|,
sizeof|sizeof
argument_list|(
name|LINK_EH_SPEC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|link_spec
argument_list|,
name|strlen
argument_list|(
name|link_spec
argument_list|)
argument_list|)
expr_stmt|;
name|link_spec
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|specs
operator|=
name|sl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is    removed; If the spec starts with a + then SPEC is added to the end of the    current spec.  */
end_comment

begin_function
specifier|static
name|void
name|set_spec
parameter_list|(
name|name
parameter_list|,
name|spec
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
block|{
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_spec
decl_stmt|;
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If this is the first call, initialize the statically allocated specs.  */
if|if
condition|(
operator|!
name|specs
condition|)
block|{
name|struct
name|spec_list
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|static_specs
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sl
operator|=
operator|&
name|static_specs
index|[
name|i
index|]
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|sl
expr_stmt|;
block|}
name|specs
operator|=
name|sl
expr_stmt|;
block|}
comment|/* See if the spec already exists.  */
for|for
control|(
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|name_len
operator|==
name|sl
operator|->
name|name_len
operator|&&
operator|!
name|strcmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|sl
condition|)
block|{
comment|/* Not found - make it.  */
name|sl
operator|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_list
argument_list|)
argument_list|)
expr_stmt|;
name|sl
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sl
operator|->
name|name_len
operator|=
name|name_len
expr_stmt|;
name|sl
operator|->
name|ptr_spec
operator|=
operator|&
name|sl
operator|->
name|ptr
expr_stmt|;
name|sl
operator|->
name|alloc_p
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
operator|=
literal|""
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|specs
expr_stmt|;
name|specs
operator|=
name|sl
expr_stmt|;
block|}
name|old_spec
operator|=
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
expr_stmt|;
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
operator|=
operator|(
operator|(
name|spec
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|spec
index|[
literal|1
index|]
argument_list|)
operator|)
condition|?
name|concat
argument_list|(
name|old_spec
argument_list|,
name|spec
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
else|:
name|xstrdup
argument_list|(
name|spec
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPECS
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"Setting spec %s to '%s'\n\n"
argument_list|,
name|name
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Free the old spec.  */
if|if
condition|(
name|old_spec
operator|&&
name|sl
operator|->
name|alloc_p
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|old_spec
argument_list|)
expr_stmt|;
name|sl
operator|->
name|alloc_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Accumulate a command (program name and args), and run it.  */
end_comment

begin_comment
comment|/* Vector of pointers to arguments in the current line of specifications.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|argbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated in argbuf.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argbuf_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in argbuf currently in use (containing args).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argbuf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the list of suffixes and codes (%g/%u/%U/%j) and the associated    temp file.  If the HOST_BIT_BUCKET is used for %j, no entry is made for    it here.  */
end_comment

begin_struct
specifier|static
struct|struct
name|temp_name
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* suffix associated with the code.  */
name|int
name|length
decl_stmt|;
comment|/* strlen (suffix).  */
name|int
name|unique
decl_stmt|;
comment|/* Indicates whether %g or %u/%U was used.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* associated filename.  */
name|int
name|filename_length
decl_stmt|;
comment|/* strlen (filename).  */
name|struct
name|temp_name
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|temp_names
struct|;
end_struct

begin_comment
comment|/* Number of commands executed so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|execution_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of commands that exited with a signal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|signal_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name with which this program was invoked.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|programname
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Clear out the vector of arguments (after a command is executed).  */
end_comment

begin_function
specifier|static
name|void
name|clear_args
parameter_list|()
block|{
name|argbuf_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add one argument to the vector at the end.    This is done when a space is seen or at the end of the line.    If DELETE_ALWAYS is nonzero, the arg is a filename     and the file should be deleted eventually.    If DELETE_FAILURE is nonzero, the arg is a filename     and the file should be deleted if this compilation fails.  */
end_comment

begin_function
specifier|static
name|void
name|store_arg
parameter_list|(
name|arg
parameter_list|,
name|delete_always
parameter_list|,
name|delete_failure
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|delete_always
decl_stmt|,
name|delete_failure
decl_stmt|;
block|{
if|if
condition|(
name|argbuf_index
operator|+
literal|1
operator|==
name|argbuf_length
condition|)
name|argbuf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|argbuf
argument_list|,
operator|(
name|argbuf_length
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argbuf
index|[
name|argbuf_index
operator|++
index|]
operator|=
name|arg
expr_stmt|;
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delete_always
operator|||
name|delete_failure
condition|)
name|record_temp_file
argument_list|(
name|arg
argument_list|,
name|delete_always
argument_list|,
name|delete_failure
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load specs from a file name named FILENAME, replacing occurrences of    various different types of line-endings, \r\n, \n\r and just \r, with    a single \n.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|load_specs
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|desc
decl_stmt|;
name|int
name|readlen
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|buffer_p
decl_stmt|;
name|char
modifier|*
name|specs
decl_stmt|;
name|char
modifier|*
name|specs_p
decl_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"Reading specs from %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Open and stat the file.  */
name|desc
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Read contents of file into BUFFER.  */
name|buffer
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|readlen
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|statbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|buffer
index|[
name|readlen
index|]
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|specs
operator|=
name|xmalloc
argument_list|(
name|readlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|specs_p
operator|=
name|specs
expr_stmt|;
for|for
control|(
name|buffer_p
operator|=
name|buffer
init|;
name|buffer_p
operator|&&
operator|*
name|buffer_p
condition|;
name|buffer_p
operator|++
control|)
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|char
name|c
init|=
operator|*
name|buffer_p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|buffer_p
operator|>
name|buffer
operator|&&
operator|*
operator|(
name|buffer_p
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
comment|/* \n\r */
name|skip
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|buffer_p
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
comment|/* \r\n */
name|skip
operator|=
literal|1
expr_stmt|;
else|else
comment|/* \r */
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
operator|*
name|specs_p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|specs_p
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|specs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read compilation specs from a file named FILENAME,    replacing the default ones.     A suffix which starts with `*' is a definition for    one of the machine-specific sub-specs.  The "suffix" should be    *asm, *cc1, *cpp, *link, *startfile, *signed_char, etc.    The corresponding spec is stored in asm_spec, etc.,    rather than in the `compilers' vector.     Anything invalid in the file is a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|read_specs
parameter_list|(
name|filename
parameter_list|,
name|main_p
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|main_p
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|buffer
operator|=
name|load_specs
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Scan BUFFER for specs, putting them in the vector.  */
name|p
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|spec
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
comment|/* Advance P in BUFFER to the next nonblank nocomment line.  */
name|p
operator|=
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
comment|/* Is this a special command that starts with '%'? */
comment|/* Don't allow this for the main specs file, since it would 	 encourage people to overwrite it.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&&
operator|!
name|main_p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip '\n'.  */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
literal|"%include"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"%include"
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|p1
index|[
sizeof|sizeof
expr|"%include"
operator|-
literal|1
expr|]
operator|==
literal|' '
operator|||
name|p1
index|[
sizeof|sizeof
expr|"%include"
operator|-
literal|1
expr|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|char
modifier|*
name|new_filename
decl_stmt|;
name|p1
operator|+=
sizeof|sizeof
argument_list|(
literal|"%include"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
literal|'<'
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'>'
condition|)
name|fatal
argument_list|(
literal|"specs %%include syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
index|[
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_filename
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|p1
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
name|read_specs
argument_list|(
name|new_filename
condition|?
name|new_filename
else|:
name|p1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
literal|"%include_noerr"
argument_list|,
sizeof|sizeof
expr|"%include_noerr"
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|p1
index|[
sizeof|sizeof
expr|"%include_noerr"
operator|-
literal|1
expr|]
operator|==
literal|' '
operator|||
name|p1
index|[
sizeof|sizeof
expr|"%include_noerr"
operator|-
literal|1
expr|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|char
modifier|*
name|new_filename
decl_stmt|;
name|p1
operator|+=
sizeof|sizeof
expr|"%include_noerr"
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
literal|'<'
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'>'
condition|)
name|fatal
argument_list|(
literal|"specs %%include syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
index|[
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_filename
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|p1
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_filename
condition|)
name|read_specs
argument_list|(
name|new_filename
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"could not find specs file %s\n"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
literal|"%rename"
argument_list|,
sizeof|sizeof
expr|"%rename"
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|p1
index|[
sizeof|sizeof
expr|"%rename"
operator|-
literal|1
expr|]
operator|==
literal|' '
operator|||
name|p1
index|[
sizeof|sizeof
expr|"%rename"
operator|-
literal|1
expr|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|int
name|name_len
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
comment|/* Get original name */
name|p1
operator|+=
sizeof|sizeof
expr|"%rename"
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p1
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p2
argument_list|)
condition|)
name|p2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p2
operator|!=
literal|' '
operator|&&
operator|*
name|p2
operator|!=
literal|'\t'
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p2
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|name_len
operator|=
name|p2
operator|-
name|p1
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|==
literal|' '
operator|||
operator|*
name|p2
operator|==
literal|'\t'
condition|)
name|p2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p2
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p2
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get new spec name.  */
name|p3
operator|=
name|p2
expr_stmt|;
while|while
condition|(
operator|*
name|p3
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p3
argument_list|)
condition|)
name|p3
operator|++
expr_stmt|;
if|if
condition|(
name|p3
operator|!=
name|p
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p3
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p3
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|name_len
operator|==
name|sl
operator|->
name|name_len
operator|&&
operator|!
name|strcmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|p1
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|sl
condition|)
name|fatal
argument_list|(
literal|"specs %s spec was not found to be renamed"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|notice
argument_list|(
literal|"rename spec %s to %s\n"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPECS
name|notice
argument_list|(
literal|"spec is '%s'\n\n"
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|set_spec
argument_list|(
name|p2
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl
operator|->
name|alloc_p
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
operator|=
literal|""
expr_stmt|;
name|sl
operator|->
name|alloc_p
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
name|fatal
argument_list|(
literal|"specs unknown %% command after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find the colon that should end the suffix.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|':'
operator|&&
operator|*
name|p1
operator|!=
literal|'\n'
condition|)
name|p1
operator|++
expr_stmt|;
comment|/* The colon shouldn't be missing.  */
if|if
condition|(
operator|*
name|p1
operator|!=
literal|':'
condition|)
name|fatal
argument_list|(
literal|"specs file malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip back over trailing whitespace.  */
name|p2
operator|=
name|p1
expr_stmt|;
while|while
condition|(
name|p2
operator|>
name|buffer
operator|&&
operator|(
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p2
operator|--
expr_stmt|;
comment|/* Copy the suffix to a string.  */
name|suffix
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|p2
operator|-
name|p
argument_list|)
expr_stmt|;
comment|/* Find the next line.  */
name|p
operator|=
name|skip_whitespace
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"specs file malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
comment|/* Find next blank line or end of string.  */
while|while
condition|(
operator|*
name|p1
operator|&&
operator|!
operator|(
operator|*
name|p1
operator|==
literal|'\n'
operator|&&
operator|(
name|p1
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
name|p1
operator|++
expr_stmt|;
comment|/* Specs end at the blank line and do not include the newline.  */
name|spec
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
comment|/* Delete backslash-newline sequences from the spec.  */
name|in
operator|=
name|spec
expr_stmt|;
name|out
operator|=
name|spec
expr_stmt|;
while|while
condition|(
operator|*
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
while|while
condition|(
operator|*
name|in
operator|&&
operator|*
name|in
operator|!=
literal|'\n'
condition|)
name|in
operator|++
expr_stmt|;
else|else
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|suffix
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
literal|"*link_command"
argument_list|)
condition|)
name|link_command_spec
operator|=
name|spec
expr_stmt|;
else|else
name|set_spec
argument_list|(
name|suffix
operator|+
literal|1
argument_list|,
name|spec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add this pair to the vector.  */
name|compilers
operator|=
operator|(
operator|(
expr|struct
name|compiler
operator|*
operator|)
name|xrealloc
argument_list|(
name|compilers
argument_list|,
operator|(
name|n_compilers
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|compiler
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|suffix
operator|=
name|suffix
expr_stmt|;
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|spec
operator|=
name|spec
expr_stmt|;
name|n_compilers
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|compilers
index|[
name|n_compilers
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|compilers
index|[
name|n_compilers
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|suffix
operator|==
literal|0
condition|)
name|link_command_spec
operator|=
name|spec
expr_stmt|;
block|}
if|if
condition|(
name|link_command_spec
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"spec file has no spec for linking"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the names of temporary files we tell compilers to write,    and delete them at the end of the run.  */
end_comment

begin_comment
comment|/* This is the common prefix we use to make temp file names.    It is chosen once for each run of this program.    It is substituted into a spec by %g or %j.    Thus, all temp file names contain this prefix.    In practice, all temp file names start with this prefix.     This prefix comes from the envvar TMPDIR if it is defined;    otherwise, from the P_tmpdir macro if that is defined;    otherwise, in /usr/tmp or /tmp;    or finally the current directory if all else fails.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the prefix.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|temp_filename_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the list of temporary files to delete.  */
end_comment

begin_struct
struct|struct
name|temp_file
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|temp_file
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Queue of files to delete on success or failure of compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|temp_file
modifier|*
name|always_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of files to delete on failure of compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|temp_file
modifier|*
name|failure_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record FILENAME as a file to be deleted automatically.    ALWAYS_DELETE nonzero means delete it if all compilation succeeds;    otherwise delete it in any case.    FAIL_DELETE nonzero means delete it if a compilation step fails;    otherwise delete it in any case.  */
end_comment

begin_function
name|void
name|record_temp_file
parameter_list|(
name|filename
parameter_list|,
name|always_delete
parameter_list|,
name|fail_delete
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|always_delete
decl_stmt|;
name|int
name|fail_delete
decl_stmt|;
block|{
name|char
modifier|*
specifier|const
name|name
init|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|always_delete
condition|)
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already1
goto|;
name|temp
operator|=
operator|(
expr|struct
name|temp_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_file
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|always_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|always_delete_queue
operator|=
name|temp
expr_stmt|;
name|already1
label|:
empty_stmt|;
block|}
if|if
condition|(
name|fail_delete
condition|)
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already2
goto|;
name|temp
operator|=
operator|(
expr|struct
name|temp_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_file
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|failure_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|failure_delete_queue
operator|=
name|temp
expr_stmt|;
name|already2
label|:
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all the temporary files whose names we previously recorded.  */
end_comment

begin_function
specifier|static
name|void
name|delete_if_ordinary
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"Delete %s? (y or n) "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|'y'
operator|||
name|i
operator|==
literal|'Y'
condition|)
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|verbose_flag
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_temp_files
parameter_list|()
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
name|delete_if_ordinary
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|always_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files to be deleted on error.  */
end_comment

begin_function
specifier|static
name|void
name|delete_failure_queue
parameter_list|()
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
name|delete_if_ordinary
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_failure_queue
parameter_list|()
block|{
name|failure_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a list of search directories from PATHS.    PREFIX is a string to prepend to the list.    If CHECK_DIR_P is non-zero we ensure the directory exists.    This is used mostly by putenv_from_prefixes so we use `collect_obstack'.    It is also used by the --print-search-dirs flag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_search_list
parameter_list|(
name|paths
parameter_list|,
name|prefix
parameter_list|,
name|check_dir_p
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|paths
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|check_dir_p
decl_stmt|;
block|{
name|int
name|suffix_len
init|=
operator|(
name|machine_suffix
operator|)
condition|?
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|just_suffix_len
init|=
operator|(
name|just_machine_suffix
operator|)
condition|?
name|strlen
argument_list|(
name|just_machine_suffix
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|first_time
init|=
name|TRUE
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pprefix
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
for|for
control|(
name|pprefix
operator|=
name|paths
operator|->
name|plist
init|;
name|pprefix
operator|!=
literal|0
condition|;
name|pprefix
operator|=
name|pprefix
operator|->
name|next
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|pprefix
operator|->
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|machine_suffix
operator|&&
operator|(
operator|!
name|check_dir_p
operator|||
name|is_directory
argument_list|(
name|pprefix
operator|->
name|prefix
argument_list|,
name|machine_suffix
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|pprefix
operator|->
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|machine_suffix
argument_list|,
name|suffix_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|just_machine_suffix
operator|&&
name|pprefix
operator|->
name|require_machine_suffix
operator|==
literal|2
operator|&&
operator|(
operator|!
name|check_dir_p
operator|||
name|is_directory
argument_list|(
name|pprefix
operator|->
name|prefix
argument_list|,
name|just_machine_suffix
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|pprefix
operator|->
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|just_machine_suffix
argument_list|,
name|just_suffix_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pprefix
operator|->
name|require_machine_suffix
condition|)
block|{
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|pprefix
operator|->
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
operator|&
name|collect_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables    for collect.  */
end_comment

begin_function
specifier|static
name|void
name|putenv_from_prefixes
parameter_list|(
name|paths
parameter_list|,
name|env_var
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|paths
decl_stmt|;
specifier|const
name|char
modifier|*
name|env_var
decl_stmt|;
block|{
name|putenv
argument_list|(
name|build_search_list
argument_list|(
name|paths
argument_list|,
name|env_var
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_comment
comment|/* FIXME: the location independence code for VMS is hairier than this,    and hasn't been written.  */
end_comment

begin_comment
comment|/* Split a filename into component directories.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|split_directories
parameter_list|(
name|name
parameter_list|,
name|ptr_num_dirs
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|ptr_num_dirs
decl_stmt|;
block|{
name|int
name|num_dirs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* Count the number of directories.  Special case MSDOS disk names as part      of the initial directory.  */
name|p
operator|=
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|num_dirs
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_DOS_BASED_FILE_SYSTEM */
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|num_dirs
operator|++
expr_stmt|;
while|while
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
name|dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_dirs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* Now copy the directory parts.  */
name|num_dirs
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|dirs
index|[
name|num_dirs
operator|++
index|]
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_DOS_BASED_FILE_SYSTEM */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
while|while
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|dirs
index|[
name|num_dirs
operator|++
index|]
operator|=
name|save_string
argument_list|(
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|-
literal|1
operator|-
name|q
operator|>
literal|0
condition|)
name|dirs
index|[
name|num_dirs
operator|++
index|]
operator|=
name|save_string
argument_list|(
name|q
argument_list|,
name|p
operator|-
literal|1
operator|-
name|q
argument_list|)
expr_stmt|;
name|dirs
index|[
name|num_dirs
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ptr_num_dirs
condition|)
operator|*
name|ptr_num_dirs
operator|=
name|num_dirs
expr_stmt|;
return|return
name|dirs
return|;
block|}
end_function

begin_comment
comment|/* Release storage held by split directories.  */
end_comment

begin_function
specifier|static
name|void
name|free_split_directories
parameter_list|(
name|dirs
parameter_list|)
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|dirs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dirs
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given three strings PROGNAME, BIN_PREFIX, PREFIX, return a string that gets    to PREFIX starting with the directory portion of PROGNAME and a relative    pathname of the difference between BIN_PREFIX and PREFIX.     For example, if BIN_PREFIX is /alpha/beta/gamma/gcc/delta, PREFIX is    /alpha/beta/gamma/omega/, and PROGNAME is /red/green/blue/gcc, then this    function will return /red/green/blue/../omega.     If no relative prefix can be found, return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_relative_prefix
parameter_list|(
name|progname
parameter_list|,
name|bin_prefix
parameter_list|,
name|prefix
parameter_list|)
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
specifier|const
name|char
modifier|*
name|bin_prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|prog_dirs
decl_stmt|,
modifier|*
modifier|*
name|bin_dirs
decl_stmt|,
modifier|*
modifier|*
name|prefix_dirs
decl_stmt|;
name|int
name|prog_num
decl_stmt|,
name|bin_num
decl_stmt|,
name|prefix_num
decl_stmt|,
name|std_loc_p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|common
decl_stmt|;
name|prog_dirs
operator|=
name|split_directories
argument_list|(
name|progname
argument_list|,
operator|&
name|prog_num
argument_list|)
expr_stmt|;
name|bin_dirs
operator|=
name|split_directories
argument_list|(
name|bin_prefix
argument_list|,
operator|&
name|bin_num
argument_list|)
expr_stmt|;
comment|/* If there is no full pathname, try to find the program by checking in each      of the directories specified in the PATH environment variable.  */
if|if
condition|(
name|prog_num
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|GET_ENV_PATH_LIST
argument_list|(
name|temp
argument_list|,
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|,
modifier|*
name|nstore
decl_stmt|;
name|size_t
name|prefixlen
init|=
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|prefixlen
operator|<
literal|2
condition|)
name|prefixlen
operator|=
literal|2
expr_stmt|;
name|nstore
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|prefixlen
operator|+
name|strlen
argument_list|(
name|progname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
block|{
name|nstore
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|nstore
index|[
literal|1
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|strcat
argument_list|(
name|nstore
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|nstore
argument_list|,
name|X_OK
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_HOST_EXECUTABLE_SUFFIX
operator|||
operator|!
name|access
argument_list|(
name|strcat
argument_list|(
name|nstore
argument_list|,
name|HOST_EXECUTABLE_SUFFIX
argument_list|)
argument_list|,
name|X_OK
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|progname
operator|=
name|nstore
expr_stmt|;
name|prog_dirs
operator|=
name|split_directories
argument_list|(
name|progname
argument_list|,
operator|&
name|prog_num
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove the program name from comparison of directory names.  */
name|prog_num
operator|--
expr_stmt|;
comment|/* Determine if the compiler is installed in the standard location, and if      so, we don't need to specify relative directories.  Also, if argv[0]      doesn't contain any directory specifiers, there is not much we can do.  */
name|std_loc_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prog_num
operator|==
name|bin_num
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bin_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prog_dirs
index|[
name|i
index|]
argument_list|,
name|bin_dirs
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|prog_num
operator|<=
literal|0
operator|||
name|i
operator|==
name|bin_num
condition|)
block|{
name|std_loc_p
operator|=
literal|1
expr_stmt|;
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|bin_dirs
argument_list|)
expr_stmt|;
name|prog_dirs
operator|=
name|bin_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|prefix_dirs
operator|=
name|split_directories
argument_list|(
name|prefix
argument_list|,
operator|&
name|prefix_num
argument_list|)
expr_stmt|;
comment|/* Find how many directories are in common between bin_prefix& prefix.  */
name|n
operator|=
operator|(
name|prefix_num
operator|<
name|bin_num
operator|)
condition|?
name|prefix_num
else|:
name|bin_num
expr_stmt|;
for|for
control|(
name|common
operator|=
literal|0
init|;
name|common
operator|<
name|n
condition|;
name|common
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bin_dirs
index|[
name|common
index|]
argument_list|,
name|prefix_dirs
index|[
name|common
index|]
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If there are no common directories, there can be no relative prefix.  */
if|if
condition|(
name|common
operator|==
literal|0
condition|)
block|{
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|bin_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|prefix_dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Build up the pathnames in argv[0].  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prog_num
condition|;
name|i
operator|++
control|)
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|prog_dirs
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|prog_dirs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now build up the ..'s.  */
for|for
control|(
name|i
operator|=
name|common
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|DIR_UP
argument_list|,
sizeof|sizeof
argument_list|(
name|DIR_UP
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/* Put in directories to move over to prefix.  */
for|for
control|(
name|i
operator|=
name|common
init|;
name|i
operator|<
name|prefix_num
condition|;
name|i
operator|++
control|)
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|prefix_dirs
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|prefix_dirs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|bin_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|prefix_dirs
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Check whether NAME can be accessed in MODE.  This is like access,    except that it never considers directories to be executable.  */
end_comment

begin_function
specifier|static
name|int
name|access_check
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|X_OK
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|access
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Search for NAME using the prefix list PREFIXES.  MODE is passed to    access to check permissions.    Return 0 if not found, otherwise return its name, allocated with malloc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
name|pprefix
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|file_suffix
init|=
operator|(
operator|(
name|mode
operator|&
name|X_OK
operator|)
operator|!=
literal|0
condition|?
name|HOST_EXECUTABLE_SUFFIX
else|:
literal|""
operator|)
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
name|int
name|len
init|=
name|pprefix
operator|->
name|max_len
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|file_suffix
argument_list|)
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_ASSEMBLER
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"as"
argument_list|)
operator|&&
name|access
argument_list|(
name|DEFAULT_ASSEMBLER
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
name|DEFAULT_ASSEMBLER
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEFAULT_LINKER
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ld"
argument_list|)
operator|&&
name|access
argument_list|(
name|DEFAULT_LINKER
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
name|DEFAULT_LINKER
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|machine_suffix
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Determine the filename to execute (special case for absolute paths).  */
if|if
condition|(
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
else|else
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
comment|/* Some systems have a suffix for executable files. 	       So try appending that first.  */
if|if
condition|(
name|file_suffix
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|file_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* Now try just the name.  */
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* Certain prefixes are tried with just the machine type, 	   not the version.  This is used for finding as, ld, etc.  */
if|if
condition|(
name|just_machine_suffix
operator|&&
name|pl
operator|->
name|require_machine_suffix
operator|==
literal|2
condition|)
block|{
comment|/* Some systems have a suffix for executable files. 	       So try appending that first.  */
if|if
condition|(
name|file_suffix
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|just_machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|file_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|just_machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* Certain prefixes can't be used without the machine suffix 	   when the machine or version is explicitly specified.  */
if|if
condition|(
operator|!
name|pl
operator|->
name|require_machine_suffix
condition|)
block|{
comment|/* Some systems have a suffix for executable files. 	       So try appending that first.  */
if|if
condition|(
name|file_suffix
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|file_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Ranking of prefixes in the sort list. -B prefixes are put before    all others.  */
end_comment

begin_enum
enum|enum
name|path_prefix_priority
block|{
name|PREFIX_PRIORITY_B_OPT
block|,
name|PREFIX_PRIORITY_LAST
block|}
enum|;
end_enum

begin_comment
comment|/* Add an entry for PREFIX in PLIST.  The PLIST is kept in assending    order according to PRIORITY.  Within each PRIORITY, new entries are    appended.     If WARN is nonzero, we will warn if no file is found    through this prefix.  WARN should point to an int    which will be set to 1 if this entry is used.     COMPONENT is the value to be passed to update_path.     REQUIRE_MACHINE_SUFFIX is 1 if this prefix can't be used without    the complete value of machine_suffix.    2 means try both machine_suffix and just_machine_suffix.  */
end_comment

begin_function
specifier|static
name|void
name|add_prefix
parameter_list|(
name|pprefix
parameter_list|,
name|prefix
parameter_list|,
name|component
parameter_list|,
name|priority
parameter_list|,
name|require_machine_suffix
parameter_list|,
name|warn
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
comment|/* enum prefix_priority */
name|int
name|priority
decl_stmt|;
name|int
name|require_machine_suffix
decl_stmt|;
name|int
modifier|*
name|warn
decl_stmt|;
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|prev
operator|=
operator|&
name|pprefix
operator|->
name|plist
init|;
operator|(
operator|*
name|prev
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|prev
operator|)
operator|->
name|priority
operator|<=
name|priority
condition|;
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
control|)
empty_stmt|;
comment|/* Keep track of the longest prefix */
name|prefix
operator|=
name|update_path
argument_list|(
name|prefix
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pprefix
operator|->
name|max_len
condition|)
name|pprefix
operator|->
name|max_len
operator|=
name|len
expr_stmt|;
name|pl
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|prefix_list
argument_list|)
argument_list|)
expr_stmt|;
name|pl
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
name|pl
operator|->
name|require_machine_suffix
operator|=
name|require_machine_suffix
expr_stmt|;
name|pl
operator|->
name|used_flag_ptr
operator|=
name|warn
expr_stmt|;
name|pl
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
if|if
condition|(
name|warn
condition|)
operator|*
name|warn
operator|=
literal|0
expr_stmt|;
comment|/* Insert after PREV */
name|pl
operator|->
name|next
operator|=
operator|(
operator|*
name|prev
operator|)
expr_stmt|;
operator|(
operator|*
name|prev
operator|)
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute the command specified by the arguments on the current line of spec.    When using pipes, this includes several piped-together commands    with `|' between them.     Return 0 if successful, -1 if failed.  */
end_comment

begin_function
specifier|static
name|int
name|execute
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_commands
decl_stmt|;
comment|/* # of command.  */
name|char
modifier|*
name|string
decl_stmt|;
struct|struct
name|command
block|{
specifier|const
name|char
modifier|*
name|prog
decl_stmt|;
comment|/* program name.  */
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* vector of args.  */
name|int
name|pid
decl_stmt|;
comment|/* pid of process for this command.  */
block|}
struct|;
name|struct
name|command
modifier|*
name|commands
decl_stmt|;
comment|/* each command buffer with above info.  */
comment|/* Count # of piped commands.  */
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
name|n_commands
operator|++
expr_stmt|;
comment|/* Get storage for each command.  */
name|commands
operator|=
operator|(
expr|struct
name|command
operator|*
operator|)
name|alloca
argument_list|(
name|n_commands
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split argbuf into its separate piped processes,      and record info about each one.      Also search for the programs that are to be run.  */
name|commands
index|[
literal|0
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
comment|/* first command.  */
name|commands
index|[
literal|0
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|commands
index|[
literal|0
index|]
operator|.
name|prog
argument_list|,
name|X_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
literal|0
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* each command.  */
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
name|fatal
argument_list|(
literal|"-pipe not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* termination of command args.  */
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|string
operator|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
argument_list|,
name|X_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
name|n_commands
operator|++
expr_stmt|;
block|}
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If -v, print what we are about to do, and maybe query.  */
if|if
condition|(
name|verbose_flag
condition|)
block|{
comment|/* For help listings, put a blank line between sub-processes.  */
if|if
condition|(
name|print_help_list
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Print each piped command as a separate line.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|j
decl_stmt|;
if|if
condition|(
name|verbose_only_flag
condition|)
block|{
for|for
control|(
name|j
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
init|;
operator|*
name|j
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" \""
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|j
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|p
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|j
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
init|;
operator|*
name|j
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|j
argument_list|)
expr_stmt|;
comment|/* Print a pipe symbol after all but the last command.  */
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|n_commands
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" |"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose_only_flag
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|notice
argument_list|(
literal|"\nGo ahead? (y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'y'
operator|&&
name|i
operator|!=
literal|'Y'
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* Run each piped subprocess.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|errmsg_fmt
decl_stmt|,
modifier|*
name|errmsg_arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
init|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
index|[
literal|0
index|]
decl_stmt|;
comment|/* For some bizarre reason, the second argument of execvp() is 	 char *const *, not const char *const *.  */
name|commands
index|[
name|i
index|]
operator|.
name|pid
operator|=
name|pexecute
argument_list|(
name|string
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|commands
index|[
name|i
index|]
operator|.
name|argv
argument_list|,
name|programname
argument_list|,
name|temp_filename
argument_list|,
operator|&
name|errmsg_fmt
argument_list|,
operator|&
name|errmsg_arg
argument_list|,
operator|(
operator|(
name|i
operator|==
literal|0
condition|?
name|PEXECUTE_FIRST
else|:
literal|0
operator|)
operator||
operator|(
name|i
operator|+
literal|1
operator|==
name|n_commands
condition|?
name|PEXECUTE_LAST
else|:
literal|0
operator|)
operator||
operator|(
name|string
operator|==
name|commands
index|[
name|i
index|]
operator|.
name|prog
condition|?
name|PEXECUTE_SEARCH
else|:
literal|0
operator|)
operator||
operator|(
name|verbose_flag
condition|?
name|PEXECUTE_VERBOSE
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commands
index|[
name|i
index|]
operator|.
name|pid
operator|==
operator|-
literal|1
condition|)
name|pfatal_pexecute
argument_list|(
name|errmsg_fmt
argument_list|,
name|errmsg_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|commands
index|[
name|i
index|]
operator|.
name|prog
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|string
argument_list|)
expr_stmt|;
block|}
name|execution_count
operator|++
expr_stmt|;
comment|/* Wait for all the subprocesses to finish.      We don't care what order they finish in;      we know that N_COMMANDS waits will get them all.      Ignore subprocesses that we don't know about,      since they can be spawned by the process that exec'ed us.  */
block|{
name|int
name|ret_code
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
name|struct
name|timeval
name|d
decl_stmt|;
name|double
name|ut
init|=
literal|0.0
decl_stmt|,
name|st
init|=
literal|0.0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|pwait
argument_list|(
name|commands
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
if|if
condition|(
name|report_times
condition|)
block|{
comment|/* getrusage returns the total resource usage of all children 	       up to now.  Copy the previous values into prus, get the 	       current statistics, then take the difference.  */
name|prus
operator|=
name|rus
expr_stmt|;
name|getrusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|rus
argument_list|)
expr_stmt|;
name|d
operator|.
name|tv_sec
operator|=
name|rus
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|-
name|prus
operator|.
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
name|d
operator|.
name|tv_usec
operator|=
name|rus
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|-
name|prus
operator|.
name|ru_utime
operator|.
name|tv_usec
expr_stmt|;
name|ut
operator|=
operator|(
name|double
operator|)
name|d
operator|.
name|tv_sec
operator|+
operator|(
name|double
operator|)
name|d
operator|.
name|tv_usec
operator|/
literal|1.0e6
expr_stmt|;
name|d
operator|.
name|tv_sec
operator|=
name|rus
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|-
name|prus
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|d
operator|.
name|tv_usec
operator|=
name|rus
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|-
name|prus
operator|.
name|ru_stime
operator|.
name|tv_usec
expr_stmt|;
name|st
operator|=
operator|(
name|double
operator|)
name|d
operator|.
name|tv_sec
operator|+
operator|(
name|double
operator|)
name|d
operator|.
name|tv_usec
operator|/
literal|1.0e6
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_commands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|commands
index|[
name|j
index|]
operator|.
name|pid
operator|==
name|pid
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* SIGPIPE is a special case.  It happens in -pipe mode 		     when the compiler dies before the preprocessor is 		     done, or the assembler dies before the compiler is 		     done.  There's generally been an error already, and 		     this is just fallout.  So don't generate another error 		     unless we would otherwise have succeeded.  */
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGPIPE
operator|&&
operator|(
name|signal_count
operator|||
name|greatest_status
operator|>=
name|MIN_FATAL_STATUS
operator|)
condition|)
empty_stmt|;
else|else
endif|#
directive|endif
name|fatal
argument_list|(
literal|"\ Internal error: %s (program %s)\n\ Please submit a full bug report.\n\ See %s for instructions."
argument_list|,
name|strsignal
argument_list|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
argument_list|,
name|commands
index|[
name|j
index|]
operator|.
name|prog
argument_list|,
name|GCCBUGURL
argument_list|)
expr_stmt|;
name|signal_count
operator|++
expr_stmt|;
name|ret_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>=
name|MIN_FATAL_STATUS
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>
name|greatest_status
condition|)
name|greatest_status
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|ret_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
if|if
condition|(
name|report_times
operator|&&
name|ut
operator|+
name|st
operator|!=
literal|0
condition|)
name|notice
argument_list|(
literal|"# %s %.2f %.2f\n"
argument_list|,
name|commands
index|[
name|j
index|]
operator|.
name|prog
argument_list|,
name|ut
argument_list|,
name|st
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
return|return
name|ret_code
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the switches given to us    and make a vector describing them.    The elements of the vector are strings, one per switch given.    If a switch uses following arguments, then the `part1' field    is the switch itself and the `args' field    is a null-terminated vector containing the following arguments.    The `live_cond' field is:    0 when initialized    1 if the switch is true in a conditional spec,    -1 if false (overridden by a later switch)    -2 if this switch should be ignored (used in %{<S})    The `validated' field is nonzero if any spec has looked at this switch;    if it remains zero at the end of the run, it must be meaningless.  */
end_comment

begin_define
define|#
directive|define
name|SWITCH_OK
value|0
end_define

begin_define
define|#
directive|define
name|SWITCH_FALSE
value|-1
end_define

begin_define
define|#
directive|define
name|SWITCH_IGNORE
value|-2
end_define

begin_define
define|#
directive|define
name|SWITCH_LIVE
value|1
end_define

begin_struct
struct|struct
name|switchstr
block|{
specifier|const
name|char
modifier|*
name|part1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|live_cond
decl_stmt|;
name|unsigned
name|char
name|validated
decl_stmt|;
name|unsigned
name|char
name|ordering
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|switchstr
modifier|*
name|switches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_switches
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|infile
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Also a vector of input files specified.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|infile
modifier|*
name|infiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts the number of libraries added by lang_specific_driver, so that    we can tell if there were any user supplied any files or libraries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|added_libraries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And a vector of corresponding output files is made up later.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|outfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to track if none of the -B paths are used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_B
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to track if standard path isn't used and -b or -V is specified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_std
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Gives value to pass as "warn" to add_prefix for standard prefixes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|warn_std_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<objformat.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|OBJFMT_UNKNOWN
block|,
name|OBJFMT_AOUT
block|,
name|OBJFMT_ELF
block|}
name|objf_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|objf_t
name|objformat
init|=
name|OBJFMT_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_OBJECT_SUFFIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
end_if

begin_comment
comment|/* Convert NAME to a new name if it is the standard suffix.  DO_EXE    is true if we should look for an executable suffix.  DO_OBJ    is true if we should look for an object suffix.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|convert_filename
parameter_list|(
name|name
parameter_list|,
name|do_exe
parameter_list|,
name|do_obj
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|do_exe
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|do_obj
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|int
name|len
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TARGET_OBJECT_SUFFIX
comment|/* Convert x.o to x.obj if TARGET_OBJECT_SUFFIX is ".obj".  */
if|if
condition|(
name|do_obj
operator|&&
name|len
operator|>
literal|2
operator|&&
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|name
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
comment|/* If there is no filetype, make it the executable suffix (which includes      the ".").  But don't get confused if we have just "-o".  */
if|if
condition|(
operator|!
name|do_exe
operator|||
name|TARGET_EXECUTABLE_SUFFIX
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|len
operator|==
literal|2
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
return|return
name|name
return|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
return|return
name|name
return|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|TARGET_EXECUTABLE_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|TARGET_EXECUTABLE_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Display the command line switches accepted by gcc.  */
end_comment

begin_function
specifier|static
name|void
name|display_help
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [options] file...\n"
argument_list|)
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"Options:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -pass-exit-codes         Exit with highest error code from a phase\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  --help                   Display this information\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  --target-help            Display target specific command line options\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose_flag
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  (Use '-v --help' to display command line options of sub-processes)\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -dumpspecs               Display all of the built in spec strings\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -dumpversion             Display the version of the compiler\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -dumpmachine             Display the compiler's target processor\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-search-dirs       Display the directories in the compiler's search path\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-libgcc-file-name  Display the name of the compiler's companion library\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-file-name=<lib>   Display the full path to library<lib>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-prog-name=<prog>  Display the full path to compiler component<prog>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-multi-directory   Display the root directory for versions of libgcc\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -print-multi-lib         Display the mapping between command line options and\n\                            multiple library search directories\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Wa,<options>            Pass comma-separated<options> on to the assembler\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Wp,<options>            Pass comma-separated<options> on to the preprocessor\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Wl,<options>            Pass comma-separated<options> on to the linker\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Xlinker<arg>           Pass<arg> on to the linker\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -save-temps              Do not delete intermediate files\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -pipe                    Use pipes rather than intermediate files\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -time                    Time the execution of each subprocess\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -specs=<file>            Override built-in specs with the contents of<file>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -std=<standard>          Assume that the input sources are for<standard>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -B<directory>           Add<directory> to the compiler's search paths\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -b<machine>             Run gcc for target<machine>, if installed\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -V<version>             Run gcc version number<version>, if installed\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -v                       Display the programs invoked by the compiler\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -###                     Like -v but options quoted and commands not executed\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -E                       Preprocess only; do not compile, assemble or link\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -S                       Compile only; do not assemble or link\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -c                       Compile and assemble, but do not link\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -o<file>                Place the output into<file>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -x<language>            Specify the language of the following input files\n\                            Permissable languages include: c c++ assembler none\n\                            'none' means revert to the default behavior of\n\                            guessing the language based on the file's extension\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \nOptions starting with -g, -f, -m, -O, -W, or --param are automatically\n\  passed on to the various sub-processes invoked by %s.  In order to pass\n\  other options on to these processes the -W<letter> options must be used.\n\ "
argument_list|)
argument_list|,
name|programname
argument_list|)
expr_stmt|;
comment|/* The rest of the options are displayed by invocations of the various      sub-processes.  */
block|}
end_function

begin_function
specifier|static
name|void
name|add_preprocessor_option
parameter_list|(
name|option
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|n_preprocessor_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|preprocessor_options
condition|)
name|preprocessor_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_preprocessor_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|preprocessor_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|preprocessor_options
argument_list|,
name|n_preprocessor_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|preprocessor_options
index|[
name|n_preprocessor_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|option
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_assembler_option
parameter_list|(
name|option
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|n_assembler_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|assembler_options
condition|)
name|assembler_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_assembler_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assembler_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|assembler_options
argument_list|,
name|n_assembler_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|assembler_options
index|[
name|n_assembler_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|option
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_linker_option
parameter_list|(
name|option
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|n_linker_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|linker_options
condition|)
name|linker_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_linker_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|linker_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|linker_options
argument_list|,
name|n_linker_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|linker_options
index|[
name|n_linker_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|option
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the vector `switches' and its contents.    Store its length in `n_switches'.  */
end_comment

begin_function
specifier|static
name|void
name|process_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|temp1
decl_stmt|;
specifier|const
name|char
modifier|*
name|spec_lang
init|=
literal|0
decl_stmt|;
name|int
name|last_language_n_infiles
decl_stmt|;
name|int
name|have_c
init|=
literal|0
decl_stmt|;
name|int
name|have_o
init|=
literal|0
decl_stmt|;
name|int
name|lang_n_infiles
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
name|int
name|is_modify_target_name
decl_stmt|;
name|int
name|j
decl_stmt|;
endif|#
directive|endif
name|GET_ENV_PATH_LIST
argument_list|(
name|gcc_exec_prefix
argument_list|,
literal|"GCC_EXEC_PREFIX"
argument_list|)
expr_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
name|added_libraries
operator|=
literal|0
expr_stmt|;
comment|/* Figure compiler version from version string.  */
name|compiler_version
operator|=
name|temp1
operator|=
name|xstrdup
argument_list|(
name|version_string
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|temp1
condition|;
operator|++
name|temp1
control|)
block|{
if|if
condition|(
operator|*
name|temp1
operator|==
literal|' '
condition|)
block|{
operator|*
name|temp1
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,      see if we can create it from the pathname specified in argv[0].  */
ifndef|#
directive|ifndef
name|VMS
comment|/* FIXME: make_relative_prefix doesn't yet work for VMS.  */
if|if
condition|(
operator|!
name|gcc_exec_prefix
condition|)
block|{
name|gcc_exec_prefix
operator|=
name|make_relative_prefix
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|standard_bindir_prefix
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcc_exec_prefix
condition|)
name|putenv
argument_list|(
name|concat
argument_list|(
literal|"GCC_EXEC_PREFIX="
argument_list|,
name|gcc_exec_prefix
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|gcc_exec_prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
literal|"/lib/gcc-lib/"
argument_list|)
operator|-
literal|1
operator|&&
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|gcc_exec_prefix
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|gcc_exec_prefix
operator|+
name|len
operator|-
sizeof|sizeof
argument_list|(
literal|"/lib/gcc-lib/"
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|temp
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|temp
operator|+
literal|1
argument_list|,
literal|"lib"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|temp
index|[
literal|4
index|]
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|temp
operator|+
literal|5
argument_list|,
literal|"gcc-lib"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|-=
sizeof|sizeof
argument_list|(
literal|"/lib/gcc-lib/"
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|set_std_prefix
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|gcc_exec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|gcc_exec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* COMPILER_PATH and LIBRARY_PATH have values      that are lists of directory names with colons.  */
name|GET_ENV_PATH_LIST
argument_list|(
name|temp
argument_list|,
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
specifier|const
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|nstore
argument_list|,
literal|0
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|concat
argument_list|(
name|nstore
argument_list|,
literal|"include"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|0
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
name|GET_ENV_PATH_LIST
argument_list|(
name|temp
argument_list|,
name|LIBRARY_PATH_ENV
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
specifier|const
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|nstore
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Use LPATH like LIBRARY_PATH (for the CMU build program).  */
name|GET_ENV_PATH_LIST
argument_list|(
name|temp
argument_list|,
literal|"LPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|*
name|cross_compile
operator|==
literal|'0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|nstore
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|getobjformat
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
operator|&
name|argc
argument_list|,
name|argv
argument_list|)
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"aout"
argument_list|)
operator|==
literal|0
condition|)
name|objformat
operator|=
name|OBJFMT_AOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"elf"
argument_list|)
operator|==
literal|0
condition|)
name|objformat
operator|=
name|OBJFMT_ELF
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized object format: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Options specified as if they appeared on the command line.  */
name|temp
operator|=
name|getenv
argument_list|(
literal|"GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|optc
init|=
literal|1
decl_stmt|;
name|int
name|new_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
name|char
modifier|*
name|envopts
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|temp
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|envopts
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|envopts
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|isspace
argument_list|(
name|envopts
index|[
name|i
index|]
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|isspace
argument_list|(
name|envopts
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
name|optc
operator|++
expr_stmt|;
name|new_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|optc
operator|+
name|argc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|new_argc
operator|=
literal|1
init|;
name|new_argc
operator|<=
name|optc
condition|;
name|new_argc
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|envopts
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|envopts
operator|+
name|i
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
name|envopts
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|envopts
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|)
condition|)
name|i
operator|++
expr_stmt|;
name|envopts
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|argv
operator|=
name|new_argv
expr_stmt|;
name|argc
operator|=
name|new_argc
expr_stmt|;
block|}
comment|/* Convert new-style -- options to old-style.  */
name|translate_options
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* Do language-specific adjustment/addition of flags.  */
name|lang_specific_driver
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
operator|&
name|added_libraries
argument_list|)
expr_stmt|;
comment|/* Scan argv twice.  Here, the first time, just count how many switches      there will be in their vector, and how many input files in theirs.      Also parse any switches that determine the configuration name, such as -b.      Here we also parse the switches that cc itself uses (e.g. -v).  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpspecs"
argument_list|)
condition|)
block|{
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
name|init_spec
argument_list|()
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"*%s:\n%s\n\n"
argument_list|,
name|sl
operator|->
name|name
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_command_spec
condition|)
name|printf
argument_list|(
literal|"*link_command:\n%s\n\n"
argument_list|,
name|link_command_spec
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpversion"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|spec_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpmachine"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|spec_machine
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fversion"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* translate_options () has turned --version into -fversion.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s (GCC) %s\n"
argument_list|)
argument_list|,
name|programname
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"Copyright (C) 2002 Free Software Foundation, Inc.\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"This is free software; see the source for copying conditions.  There is NO\n\ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fhelp"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* translate_options () has turned --help into -fhelp.  */
name|print_help_list
operator|=
literal|1
expr_stmt|;
comment|/* We will be passing a dummy file on to the sub-processes.  */
name|n_infiles
operator|++
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
comment|/* CPP driver cannot obtain switch from cc1_options.  */
if|if
condition|(
name|is_cpp_driver
condition|)
name|add_preprocessor_option
argument_list|(
literal|"--help"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|add_assembler_option
argument_list|(
literal|"--help"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|add_linker_option
argument_list|(
literal|"--help"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ftarget-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* translate_options() has turned --target-help into -ftarget-help.  */
name|target_help_flag
operator|=
literal|1
expr_stmt|;
comment|/* We will be passing a dummy file on to the sub-processes.  */
name|n_infiles
operator|++
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
comment|/* CPP driver cannot obtain switch from cc1_options.  */
if|if
condition|(
name|is_cpp_driver
condition|)
name|add_preprocessor_option
argument_list|(
literal|"--target-help"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|add_assembler_option
argument_list|(
literal|"--target-help"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|add_linker_option
argument_list|(
literal|"--target-help"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pass-exit-codes"
argument_list|)
condition|)
block|{
name|pass_exit_codes
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-search-dirs"
argument_list|)
condition|)
name|print_search_dirs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-libgcc-file-name"
argument_list|)
condition|)
name|print_file_name
operator|=
literal|"libgcc.a"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-file-name="
argument_list|,
literal|17
argument_list|)
condition|)
name|print_file_name
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-prog-name="
argument_list|,
literal|17
argument_list|)
condition|)
name|print_prog_name
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-lib"
argument_list|)
condition|)
name|print_multi_lib
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-directory"
argument_list|)
condition|)
name|print_multi_directory
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wa,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Pass the rest of this option to the assembler.  */
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|add_assembler_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|add_assembler_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wp,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Pass the rest of this option to the preprocessor.  */
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|add_preprocessor_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|add_preprocessor_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
comment|/* The +e options to the C++ front-end.  */
name|n_switches
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wl,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Split the argument at commas.  */
for|for
control|(
name|j
operator|=
literal|3
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|n_infiles
operator|+=
operator|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xlinker"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-Xlinker' is missing"
argument_list|)
expr_stmt|;
name|n_infiles
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-l' is missing"
argument_list|)
expr_stmt|;
name|n_infiles
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|n_infiles
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-save-temps"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|save_temps_flag
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|user_specs
modifier|*
name|user
init|=
operator|(
expr|struct
name|user_specs
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|user_specs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-specs' is missing"
argument_list|)
expr_stmt|;
name|user
operator|->
name|next
operator|=
operator|(
expr|struct
name|user_specs
operator|*
operator|)
literal|0
expr_stmt|;
name|user
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|user_specs_tail
condition|)
name|user_specs_tail
operator|->
name|next
operator|=
name|user
expr_stmt|;
else|else
name|user_specs_head
operator|=
name|user
expr_stmt|;
name|user_specs_tail
operator|=
name|user
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|user_specs
modifier|*
name|user
init|=
operator|(
expr|struct
name|user_specs
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|user_specs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|7
condition|)
name|fatal
argument_list|(
literal|"argument to `-specs=' is missing"
argument_list|)
expr_stmt|;
name|user
operator|->
name|next
operator|=
operator|(
expr|struct
name|user_specs
operator|*
operator|)
literal|0
expr_stmt|;
name|user
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|7
expr_stmt|;
if|if
condition|(
name|user_specs_tail
condition|)
name|user_specs_tail
operator|->
name|next
operator|=
name|user
expr_stmt|;
else|else
name|user_specs_head
operator|=
name|user
expr_stmt|;
name|user_specs_tail
operator|=
name|user
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-time"
argument_list|)
operator|==
literal|0
condition|)
name|report_times
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-###"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is similar to -v except that there is no execution 	     of the commands and the echoed arguments are quoted.  It 	     is intended for use in shell scripts to capture the 	     driver-generated command line.  */
name|verbose_only_flag
operator|++
expr_stmt|;
name|verbose_flag
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|n_switches
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-b' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|spec_machine
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|spec_machine
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|warn_std_ptr
operator|=
operator|&
name|warn_std
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
block|{
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-B' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|value
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|value
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Catch the case where the user has forgotten to append a 		   directory separator to the path.  Note, they may be using 		   -B to add an executable name prefix, eg "i386-elf-", in 		   order to distinguish between multiple installations of 		   GCC in the same directory.  Hence we must check to see 		   if appending a directory separator actually makes a 		   valid directory name.  */
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|value
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|is_directory
argument_list|(
name|value
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|tmp
index|[
name|len
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|tmp
index|[
operator|++
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* As a kludge, if the arg is "[foo/]stageN/", just 		   add "[foo/]include" to the include prefix.  */
if|if
condition|(
operator|(
name|len
operator|==
literal|7
operator|||
operator|(
name|len
operator|>
literal|7
operator|&&
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|value
index|[
name|len
operator|-
literal|8
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|value
operator|+
name|len
operator|-
literal|7
argument_list|,
literal|"stage"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIGIT
argument_list|(
name|value
index|[
name|len
operator|-
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|value
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|7
condition|)
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
literal|"include"
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|string
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|string
argument_list|,
name|value
argument_list|,
name|len
operator|-
literal|7
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|string
operator|+
name|len
operator|-
literal|7
argument_list|,
literal|"include"
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|string
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
operator|&
name|warn_B
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
operator|&
name|warn_B
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|concat
argument_list|(
name|value
argument_list|,
literal|"include"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* Print our subcommands and print versions.  */
name|n_switches
operator|++
expr_stmt|;
comment|/* If they do anything other than exactly `-v', don't set 		 verbose_flag; rather, continue on to give the error.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
break|break;
name|verbose_flag
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|n_switches
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-V' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|spec_version
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|spec_version
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|compiler_version
operator|=
name|spec_version
expr_stmt|;
name|warn_std_ptr
operator|=
operator|&
name|warn_std
expr_stmt|;
comment|/* Validate the version number.  Use the same checks 		 done when inserting it into a spec.  		 The format of the version string is 		 ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */
block|{
specifier|const
name|char
modifier|*
name|v
init|=
name|compiler_version
decl_stmt|;
comment|/* Ignore leading non-digits.  i.e. "foo-" in "foo-2.7.2".  */
while|while
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|compiler_version
operator|&&
name|v
index|[
operator|-
literal|1
index|]
operator|!=
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"invalid version number format"
argument_list|)
expr_stmt|;
comment|/* Set V after the first period.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|!=
literal|'.'
condition|)
name|fatal
argument_list|(
literal|"invalid version number format"
argument_list|)
expr_stmt|;
name|v
operator|++
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|!=
literal|0
operator|&&
operator|*
name|v
operator|!=
literal|' '
operator|&&
operator|*
name|v
operator|!=
literal|'.'
operator|&&
operator|*
name|v
operator|!=
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"invalid version number format"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'c'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|have_c
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
break|break;
block|}
goto|goto
name|normal_switch
goto|;
case|case
literal|'o'
case|:
name|have_o
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
if|if
condition|(
operator|!
name|have_c
condition|)
block|{
name|int
name|skip
decl_stmt|;
comment|/* Forward scan, just in case -S or -c is specified 		     after -o.  */
name|int
name|j
init|=
name|i
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
operator|++
name|j
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|argc
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|j
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|SWITCH_CURTAILS_COMPILATION
argument_list|(
name|argv
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
operator|&&
name|argv
index|[
name|j
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|have_c
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|skip
operator|=
name|SWITCH_TAKES_ARG
argument_list|(
name|argv
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|j
operator|+=
name|skip
operator|-
operator|(
name|argv
index|[
name|j
index|]
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|skip
operator|=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|argv
index|[
name|j
index|]
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|j
operator|+=
name|skip
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TARGET_OBJECT_SUFFIX
argument_list|)
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|convert_filename
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|!
name|have_c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|argv
index|[
name|i
index|]
operator|=
name|convert_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|have_c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|normal_switch
goto|;
default|default:
name|normal_switch
label|:
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
name|is_modify_target_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|modify_target
operator|/
sizeof|sizeof
name|modify_target
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modify_target
index|[
name|j
index|]
operator|.
name|sw
argument_list|)
condition|)
block|{
name|char
modifier|*
name|new_name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|)
operator|+
name|strlen
argument_list|(
name|spec_machine
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|made_addition
init|=
literal|0
decl_stmt|;
name|is_modify_target_name
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|spec_machine
operator|,
name|q
operator|=
name|new_name
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|modify_target
index|[
name|j
index|]
operator|.
name|add_del
operator|==
name|DELETE
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|q
argument_list|,
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|strlen
argument_list|(
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|)
argument_list|)
operator|)
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|modify_target
index|[
name|j
index|]
operator|.
name|add_del
operator|==
name|ADD
operator|&&
operator|!
name|made_addition
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|r
operator|=
name|modify_target
index|[
name|j
index|]
operator|.
name|str
init|;
operator|*
name|r
operator|!=
literal|0
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
name|made_addition
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|spec_machine
operator|=
name|new_name
expr_stmt|;
block|}
if|if
condition|(
name|is_modify_target_name
condition|)
break|break;
endif|#
directive|endif
name|n_switches
operator|++
expr_stmt|;
if|if
condition|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
name|i
operator|+=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|i
operator|+=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|n_infiles
operator|++
expr_stmt|;
name|lang_n_infiles
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_c
operator|&&
name|have_o
operator|&&
name|lang_n_infiles
operator|>
literal|1
condition|)
name|fatal
argument_list|(
literal|"cannot specify -o with -c or -S and multiple compilations"
argument_list|)
expr_stmt|;
comment|/* Set up the search paths before we go looking for config files.  */
comment|/* These come before the md prefixes so that we will find gcc's subcommands      (such as cpp) rather than those of the host system.  */
comment|/* Use 2 as fourth arg meaning try just the machine as a suffix,      as well as trying the machine and the version.  */
ifdef|#
directive|ifdef
name|FREEBSD_NATIVE
switch|switch
condition|(
name|objformat
condition|)
block|{
case|case
name|OBJFMT_AOUT
case|:
name|n_switches
operator|++
expr_stmt|;
comment|/* add implied -maout */
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|PREFIX
literal|"/libexec/aout/"
argument_list|,
literal|"BINUTILS"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJFMT_ELF
case|:
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|PREFIX
literal|"/libexec/elf/"
argument_list|,
literal|"BINUTILS"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJFMT_UNKNOWN
case|:
name|fatal
argument_list|(
literal|"object format unknown"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
ifndef|#
directive|ifndef
name|OS2
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|1
argument_list|,
name|warn_std_ptr
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|2
argument_list|,
name|warn_std_ptr
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix_1
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|2
argument_list|,
name|warn_std_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_exec_prefix
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|1
argument_list|,
name|warn_std_ptr
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_exec_prefix_1
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|1
argument_list|,
name|warn_std_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not FREEBSD_NATIVE */
name|tooldir_prefix
operator|=
name|concat
argument_list|(
name|tooldir_base_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If tooldir is relative, base it on exec_prefixes.  A relative      tooldir lets us move the installed tree as a unit.       If GCC_EXEC_PREFIX is defined, then we want to add two relative      directories, so that we can search both the user specified directory      and the standard place.  */
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|tooldir_prefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|char
modifier|*
name|gcc_exec_tooldir_prefix
init|=
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|tooldir_prefix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|concat
argument_list|(
name|gcc_exec_tooldir_prefix
argument_list|,
literal|"bin"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|gcc_exec_tooldir_prefix
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|tooldir_prefix
operator|=
name|concat
argument_list|(
name|standard_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|tooldir_prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|concat
argument_list|(
name|tooldir_prefix
argument_list|,
literal|"bin"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|tooldir_prefix
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
comment|/* More prefixes are enabled in main, after we read the specs file      and determine whether this is cross-compilation or not.  */
comment|/* Then create the space for the vectors and scan again.  */
name|switches
operator|=
operator|(
operator|(
expr|struct
name|switchstr
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_switches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|switchstr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|infiles
operator|=
operator|(
expr|struct
name|infile
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_infiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
name|last_language_n_infiles
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This, time, copy the text of each switch and store a pointer      to the copy in the vector of switches.      Store all the infiles in their vector.  */
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
switch|switch
condition|(
name|objformat
condition|)
block|{
case|case
name|OBJFMT_AOUT
case|:
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|"maout"
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
name|putenv
argument_list|(
literal|"OBJFORMAT=aout"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJFMT_ELF
case|:
name|putenv
argument_list|(
literal|"OBJFORMAT=elf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJFMT_UNKNOWN
case|:
name|fatal
argument_list|(
literal|"object format unknown"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* Just skip the switches that were handled by the preceding loop.  */
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
name|is_modify_target_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|modify_target
operator|/
sizeof|sizeof
name|modify_target
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modify_target
index|[
name|j
index|]
operator|.
name|sw
argument_list|)
condition|)
name|is_modify_target_name
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_modify_target_name
condition|)
empty_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wa,"
argument_list|,
literal|4
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wp,"
argument_list|,
literal|4
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pass-exit-codes"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-search-dirs"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-libgcc-file-name"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-file-name="
argument_list|,
literal|17
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-prog-name="
argument_list|,
literal|17
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-lib"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-directory"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ftarget-help"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fhelp"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Compensate for the +e options to the C++ front-end; 	     they're there simply for cfront call-compatibility.  We do 	     some magic in default_compilers to pass them down properly. 	     Note we deliberately start at the `+' here, to avoid passing 	     -e0 or -e1 down into the linker.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wl,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|save_string
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xlinker"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* POSIX allows separation of -l and the lib arg; 	     canonicalize by concatenating -l with its arg */
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-time"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|save_temps_flag
operator|||
name|report_times
operator|)
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pipe"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* -save-temps overrides -pipe, so that temp files are produced */
if|if
condition|(
name|save_temps_flag
condition|)
name|error
argument_list|(
literal|"warning: -pipe ignored because -save-temps specified"
argument_list|)
expr_stmt|;
comment|/* -time overrides -pipe because we can't get correct stats when 	     multiple children are running at once.  */
elseif|else
if|if
condition|(
name|report_times
condition|)
name|error
argument_list|(
literal|"warning: -pipe ignored because -time specified"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-###"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-x' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|spec_lang
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|spec_lang
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spec_lang
argument_list|,
literal|"none"
argument_list|)
condition|)
comment|/* Suppress the warning if -xnone comes after the last input 		   file, because alternate command interfaces like g++ might 		   find it useful to place -xnone after each input file.  */
name|spec_lang
operator|=
literal|0
expr_stmt|;
else|else
name|last_language_n_infiles
operator|=
name|n_infiles
expr_stmt|;
continue|continue;
block|}
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
name|p
expr_stmt|;
comment|/* Deal with option arguments in separate argv elements.  */
if|if
condition|(
operator|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|n_args
init|=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_args
operator|==
literal|0
condition|)
block|{
comment|/* Count only the option arguments in separate argv elements.  */
name|n_args
operator|=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
name|n_args
operator|>=
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-%s' is missing"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_args
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|n_args
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
comment|/* Null-terminate the vector.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|switches_need_spaces
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* On some systems, ld cannot handle some options without 		 a space.  So split the option from its argument.  */
name|char
modifier|*
name|part1
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|part1
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|part1
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
name|part1
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|ordering
operator|=
literal|0
expr_stmt|;
comment|/* These are always valid, since gcc.c itself understands it.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"save-temps"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"static-libgcc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"shared-libgcc"
argument_list|)
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|char
name|ch
init|=
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'V'
operator|||
name|ch
operator|==
literal|'b'
operator|||
name|ch
operator|==
literal|'B'
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
name|n_switches
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_TARGET_OBJECT_SUFFIX
name|argv
index|[
name|i
index|]
operator|=
name|convert_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|access
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|F_OK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
name|access
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|F_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
name|spec_lang
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|n_infiles
operator|==
name|last_language_n_infiles
operator|&&
name|spec_lang
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"warning: `-x %s' after last input file has no effect"
argument_list|,
name|spec_lang
argument_list|)
expr_stmt|;
comment|/* Ensure we only invoke each subprocess once.  */
if|if
condition|(
name|target_help_flag
operator|||
name|print_help_list
condition|)
block|{
name|n_infiles
operator|=
literal|1
expr_stmt|;
comment|/* Create a dummy input file, so that we can pass --target-help on to 	 the various sub-processes.  */
name|infiles
index|[
literal|0
index|]
operator|.
name|language
operator|=
literal|"c"
expr_stmt|;
name|infiles
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|"help-dummy"
expr_stmt|;
if|if
condition|(
name|target_help_flag
condition|)
block|{
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|"--target-help"
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|print_help_list
condition|)
block|{
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|"--help"
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
block|}
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store switches not filtered out by %{<S} in spec in COLLECT_GCC_OPTIONS    and place that in the environment.  */
end_comment

begin_function
specifier|static
name|void
name|set_collect_gcc_options
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|first_time
decl_stmt|;
comment|/* Build COLLECT_GCC_OPTIONS to have all of the options specified to      the compiler.  */
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"COLLECT_GCC_OPTIONS="
argument_list|,
sizeof|sizeof
argument_list|(
literal|"COLLECT_GCC_OPTIONS="
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
comment|/* Ignore elided switches.  */
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|live_cond
operator|==
name|SWITCH_IGNORE
condition|)
continue|continue;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'-"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
name|switches
index|[
name|i
index|]
operator|.
name|part1
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'\\''"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|q
operator|=
operator|++
name|p
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|switches
index|[
name|i
index|]
operator|.
name|args
init|;
name|args
operator|&&
operator|*
name|args
condition|;
name|args
operator|++
control|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|" '"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
operator|*
name|args
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'\\''"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|q
operator|=
operator|++
name|p
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|collect_obstack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a spec string, accumulating and running commands.  */
end_comment

begin_comment
comment|/* These variables describe the input file name.    input_file_number is the index on outfiles of this file,    so that the output file name can be stored for later use by %o.    input_basename is the start of the part of the input file    sans all directory names, and basename_length is the number    of characters starting there excluding the suffix .c or whatever.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_file_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|input_filename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|basename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|suffixed_basename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_basename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_suffix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stat
name|input_stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_stat_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiler used to process the current input file.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|compiler
modifier|*
name|input_file_compiler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are variables used within do_spec and do_spec_1.  */
end_comment

begin_comment
comment|/* Nonzero if an arg has been started and not yet terminated    (with space, tab or newline).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arg_going
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %d or %g has been seen; the next arg to be terminated    is a temporary file name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delete_this_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %w has been seen; the next arg to be terminated    is the output file name of this compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_is_output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %s has been seen; the next arg to be terminated    is the name of a library file and we should try the standard    search dirs for it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_is_library_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that the input of this command is coming from a pipe.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_from_pipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonnull means substitute this for any suffix when outputting a switches    arguments.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|suffix_subst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process the spec SPEC and run the commands specified therein.    Returns 0 if the spec is successfully processed; -1 if failed.  */
end_comment

begin_function
name|int
name|do_spec
parameter_list|(
name|spec
parameter_list|)
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
name|input_from_pipe
operator|=
literal|0
expr_stmt|;
name|suffix_subst
operator|=
name|NULL
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Force out any unfinished command.      If -pipe, this forces out the last command if it ended in `|'.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
name|argbuf_index
operator|--
expr_stmt|;
name|set_collect_gcc_options
argument_list|()
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
name|value
operator|=
name|execute
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Process the sub-spec SPEC as a portion of a larger spec.    This is like processing a whole spec except that we do    not initialize at the beginning and we do not supply a    newline by default at the end.    INSWITCH nonzero means don't process %-sequences in SPEC;    in this case, % is treated as an ordinary character.    This is used while substituting switches.    INSWITCH nonzero also causes SPC not to terminate an argument.     Value is zero unless a line was finished    and the command on that line reported an error.  */
end_comment

begin_function
specifier|static
name|int
name|do_spec_1
parameter_list|(
name|spec
parameter_list|,
name|inswitch
parameter_list|,
name|soft_matched_part
parameter_list|)
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
name|int
name|inswitch
decl_stmt|;
specifier|const
name|char
modifier|*
name|soft_matched_part
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|spec
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|value
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
comment|/* If substituting a switch, treat all chars like letters.        Otherwise, NL, SPC, TAB and % are special.  */
switch|switch
condition|(
name|inswitch
condition|?
literal|'a'
else|:
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* End of line: finish any pending argument, 	   then run the pending command if one has been started.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
name|arg_going
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
literal|"pipe"
argument_list|)
condition|)
break|break;
comment|/* A `|' before the newline means use a pipe here, 	       but only if -pipe was specified. 	       Otherwise, execute now and don't pass the `|' as an arg.  */
if|if
condition|(
name|i
operator|<
name|n_switches
condition|)
block|{
name|input_from_pipe
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|i
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|argbuf_index
operator|--
expr_stmt|;
block|}
name|set_collect_gcc_options
argument_list|()
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|execute
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
condition|)
return|return
name|value
return|;
block|}
comment|/* Reinitialize for a new command, and for a new argument.  */
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
name|input_from_pipe
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* End any pending argument.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Use pipe */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
comment|/* Space or tab ends an argument if one is pending.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Reinitialize for a new argument.  */
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|fatal
argument_list|(
literal|"invalid specification!  Bug in cc"
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_basename
argument_list|,
name|basename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_basename
argument_list|,
name|suffixed_basename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete_this_arg
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* Dump out the directories specified with LIBRARY_PATH, 	     followed by the absolute directories 	     that we search for startfiles.  */
case|case
literal|'D'
case|:
block|{
name|struct
name|prefix_list
modifier|*
name|pl
init|=
name|startfile_prefixes
operator|.
name|plist
decl_stmt|;
name|size_t
name|bufsize
init|=
literal|100
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|RELATIVE_PREFIX_NOT_LINKDIR
comment|/* Used on systems which record the specified -L dirs 		     and use them to search for dynamic linking.  */
comment|/* Relative directories always come from -B, 		     and it is better not to use them for searching 		     at run time.  In particular, stage1 loses.  */
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Try subdirectory if there is one.  */
if|if
condition|(
name|multilib_dir
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|>=
name|bufsize
condition|)
name|bufsize
operator|=
operator|(
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_directory
argument_list|(
name|buffer
argument_list|,
name|multilib_dir
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_spec_1
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|multilib_dir
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pl
operator|->
name|require_machine_suffix
condition|)
block|{
if|if
condition|(
name|is_directory
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
name|multilib_dir
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_spec_1
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|multilib_dir
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|machine_suffix
condition|)
block|{
if|if
condition|(
name|is_directory
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
name|machine_suffix
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_spec_1
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Remove slash from machine_suffix.  */
if|if
condition|(
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|>=
name|bufsize
condition|)
name|bufsize
operator|=
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|idx
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
argument_list|)
condition|)
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|do_spec_1
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pl
operator|->
name|require_machine_suffix
condition|)
block|{
if|if
condition|(
name|is_directory
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove slash from pl->prefix.  */
if|if
condition|(
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|>=
name|bufsize
condition|)
name|bufsize
operator|=
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|idx
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
argument_list|)
condition|)
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|do_spec_1
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* %efoo means report an error with `foo' as error message 	       and don't execute any more commands for this file.  */
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|q
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* %nfoo means report an notice with `foo' on stderr.  */
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|q
index|]
operator|=
literal|0
expr_stmt|;
name|notice
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'j'
case|:
block|{
name|struct
name|stat
name|st
decl_stmt|;
comment|/* If save_temps_flag is off, and the HOST_BIT_BUCKET is defined, 		 and it is not a directory, and it is writable, use it. 		 Otherwise, fall through and treat this like any other 		 temporary file.  */
if|if
condition|(
operator|(
operator|!
name|save_temps_flag
operator|)
operator|&&
operator|(
name|stat
argument_list|(
name|HOST_BIT_BUCKET
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|)
operator|&&
operator|(
name|access
argument_list|(
name|HOST_BIT_BUCKET
argument_list|,
name|W_OK
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|HOST_BIT_BUCKET
argument_list|,
name|strlen
argument_list|(
name|HOST_BIT_BUCKET
argument_list|)
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
case|case
literal|'g'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
block|{
name|struct
name|temp_name
modifier|*
name|t
decl_stmt|;
name|int
name|suffix_length
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|saved_suffix
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|suffix_length
operator|=
name|p
operator|-
name|suffix
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* We don't support extra suffix characters after %O.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|suffix_length
operator|==
literal|0
condition|)
name|suffix
operator|=
name|TARGET_OBJECT_SUFFIX
expr_stmt|;
else|else
block|{
name|saved_suffix
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|suffix_length
operator|+
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|saved_suffix
argument_list|,
name|suffix
argument_list|,
name|suffix_length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|saved_suffix
operator|+
name|suffix_length
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|)
expr_stmt|;
block|}
name|suffix_length
operator|+=
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
expr_stmt|;
block|}
comment|/* If the input_filename has the same suffix specified 		   for the %g, %u, or %U, and -save-temps is specified, 		   we could end up using that file as an intermediate 		   thus clobbering the user's source file (.e.g., 		   gcc -save-temps foo.s would clobber foo.s with the 		   output of cpp0).  So check for this condition and 		   generate a temp file as the intermediate.  */
if|if
condition|(
name|save_temps_flag
condition|)
block|{
name|temp_filename_length
operator|=
name|basename_length
operator|+
name|suffix_length
expr_stmt|;
name|temp_filename
operator|=
name|alloca
argument_list|(
name|temp_filename_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp_filename
argument_list|,
name|input_basename
argument_list|,
name|basename_length
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp_filename
operator|+
name|basename_length
argument_list|,
name|suffix
argument_list|,
name|suffix_length
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|temp_filename
operator|+
name|temp_filename_length
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|temp_filename
argument_list|,
name|input_filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|st_temp
decl_stmt|;
comment|/* Note, set_input() resets input_stat_set to 0.  */
if|if
condition|(
name|input_stat_set
operator|==
literal|0
condition|)
block|{
name|input_stat_set
operator|=
name|stat
argument_list|(
name|input_filename
argument_list|,
operator|&
name|input_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_stat_set
operator|>=
literal|0
condition|)
name|input_stat_set
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we have the stat for the input_filename 		      	   and we can do the stat for the temp_filename 		      	   then the they could still refer to the same 		      	   file if st_dev/st_ino's are the same.  */
if|if
condition|(
name|input_stat_set
operator|!=
literal|1
operator|||
name|stat
argument_list|(
name|temp_filename
argument_list|,
operator|&
name|st_temp
argument_list|)
operator|<
literal|0
operator|||
name|input_stat
operator|.
name|st_dev
operator|!=
name|st_temp
operator|.
name|st_dev
operator|||
name|input_stat
operator|.
name|st_ino
operator|!=
name|st_temp
operator|.
name|st_ino
condition|)
block|{
name|temp_filename
operator|=
name|save_string
argument_list|(
name|temp_filename
argument_list|,
name|temp_filename_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|temp_filename
argument_list|,
name|temp_filename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* See if we already have an association of %g/%u/%U and 		   suffix.  */
for|for
control|(
name|t
operator|=
name|temp_names
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|length
operator|==
name|suffix_length
operator|&&
name|strncmp
argument_list|(
name|t
operator|->
name|suffix
argument_list|,
name|suffix
argument_list|,
name|suffix_length
argument_list|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|unique
operator|==
operator|(
name|c
operator|!=
literal|'g'
operator|)
condition|)
break|break;
comment|/* Make a new association if needed.  %u and %j 		   require one.  */
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'j'
condition|)
block|{
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
operator|(
expr|struct
name|temp_name
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|temp_names
expr_stmt|;
name|temp_names
operator|=
name|t
expr_stmt|;
block|}
name|t
operator|->
name|length
operator|=
name|suffix_length
expr_stmt|;
if|if
condition|(
name|saved_suffix
condition|)
block|{
name|t
operator|->
name|suffix
operator|=
name|saved_suffix
expr_stmt|;
name|saved_suffix
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|t
operator|->
name|suffix
operator|=
name|save_string
argument_list|(
name|suffix
argument_list|,
name|suffix_length
argument_list|)
expr_stmt|;
name|t
operator|->
name|unique
operator|=
operator|(
name|c
operator|!=
literal|'g'
operator|)
expr_stmt|;
name|temp_filename
operator|=
name|make_temp_file
argument_list|(
name|t
operator|->
name|suffix
argument_list|)
expr_stmt|;
name|temp_filename_length
operator|=
name|strlen
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|temp_filename
expr_stmt|;
name|t
operator|->
name|filename_length
operator|=
name|temp_filename_length
expr_stmt|;
block|}
if|if
condition|(
name|saved_suffix
condition|)
name|free
argument_list|(
name|saved_suffix
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|t
operator|->
name|filename
argument_list|,
name|t
operator|->
name|filename_length
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|1
expr_stmt|;
block|}
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_filename
argument_list|,
name|input_filename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
block|{
name|struct
name|prefix_list
modifier|*
name|pl
init|=
name|include_prefixes
operator|.
name|plist
decl_stmt|;
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-iprefix"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|gcc_exec_prefix
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
name|do_spec_1
argument_list|(
literal|"-isystem"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'o'
case|:
block|{
name|int
name|max
init|=
name|n_infiles
decl_stmt|;
name|max
operator|+=
name|lang_specific_extra_outfiles
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|outfiles
index|[
name|i
index|]
condition|)
name|store_arg
argument_list|(
name|outfiles
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'O'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|this_is_library_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|this_is_output_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
block|{
name|int
name|cur_index
init|=
name|argbuf_index
decl_stmt|;
comment|/* Handle the {...} following the %W.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
name|handle_braces
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If any args were output, mark the last one for deletion 		 on failure.  */
if|if
condition|(
name|argbuf_index
operator|!=
name|cur_index
condition|)
name|record_temp_file
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* %x{OPTION} records OPTION for %X to output.  */
case|case
literal|'x'
case|:
block|{
specifier|const
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Skip past the option value and make a copy.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
name|string
operator|=
name|save_string
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
name|p
operator|-
name|p1
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* See if we already recorded this option.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_linker_options
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|string
argument_list|,
name|linker_options
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This option is new; add it.  */
name|add_linker_option
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using %x.  */
case|case
literal|'X'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_linker_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|linker_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using -Wa,.  */
case|case
literal|'Y'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_assembler_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|assembler_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using -Wp,.  */
case|case
literal|'Z'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_preprocessor_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|preprocessor_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Here are digits and numbers that just process 	       a certain constant string as a spec.  */
case|case
literal|'1'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|cc1_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'2'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|cc1plus_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'a'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|asm_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'A'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|asm_final_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'c'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|signed_char_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'C'
case|:
block|{
specifier|const
name|char
modifier|*
specifier|const
name|spec
init|=
operator|(
name|input_file_compiler
operator|->
name|cpp_spec
condition|?
name|input_file_compiler
operator|->
name|cpp_spec
else|:
name|cpp_spec
operator|)
decl_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
break|break;
case|case
literal|'E'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|endfile_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'l'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|link_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'L'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|lib_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'G'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|libgcc_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|multilib_dir
operator|&&
name|strcmp
argument_list|(
name|multilib_dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|multilib_dir
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|obstack
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|obstack
argument_list|)
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|multilib_dir
init|;
operator|*
name|q
condition|;
operator|++
name|q
operator|,
operator|++
name|p
control|)
operator|*
name|p
operator|=
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|q
argument_list|)
condition|?
literal|'_'
else|:
operator|*
name|q
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|cpp_predefines
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|y
decl_stmt|;
comment|/* Copy all of the -D options in CPP_PREDEFINES into BUF.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* Copy the whole option.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy other options.  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
break|break;
case|case
literal|'P'
case|:
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|cpp_predefines
argument_list|)
operator|*
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|y
decl_stmt|;
comment|/* Copy all of CPP_PREDEFINES into BUF, 		 but force them all into the reserved name space if they 		 aren't already there.  The reserved name space is all 		 identifiers beginning with two underscores or with one 		 underscore and a capital letter.  We do the forcing by 		 adding up to two underscores to the beginning and end 		 of each symbol. e.g. mips, _mips, mips_, and _mips_ all 		 become __mips__.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|int
name|flag
init|=
literal|0
decl_stmt|;
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|!=
literal|'_'
operator|||
operator|(
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
operator|!=
literal|'_'
operator|&&
operator|!
name|ISUPPER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Stick __ at front of macro name.  */
if|if
condition|(
operator|*
name|y
operator|!=
literal|'_'
condition|)
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
comment|/* Arrange to stick __ at the end as well.  */
name|flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Copy the macro name.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|'='
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
name|x
index|[
operator|-
literal|1
index|]
operator|!=
literal|'_'
condition|)
block|{
if|if
condition|(
name|x
index|[
operator|-
literal|2
index|]
operator|!=
literal|'_'
condition|)
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
block|}
comment|/* Copy the value given, if any.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy -A options  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Copy all of CPP_PREDEFINES into BUF, 		 but put __ after every -D.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|y
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|!=
literal|'_'
operator|||
operator|(
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
operator|!=
literal|'_'
operator|&&
operator|!
name|ISUPPER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Stick -D__ at front of macro name.  */
operator|*
name|x
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'D'
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|!=
literal|'_'
condition|)
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
comment|/* Copy the macro name.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|'='
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Copy the value given, if any.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Do not copy this macro - we have just done it before */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
name|y
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy -A options.  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Copy all of the -A options in CPP_PREDEFINES into BUF.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-A"
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* Copy the whole option.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy other options.  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
break|break;
case|case
literal|'S'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|startfile_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
comment|/* Here we define characters other than letters and digits.  */
case|case
literal|'{'
case|:
name|p
operator|=
name|handle_braces
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'%'
case|:
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
block|{
name|unsigned
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
index|[
name|len
index|]
operator|&&
name|p
index|[
name|len
index|]
operator|!=
literal|' '
operator|&&
name|p
index|[
name|len
index|]
operator|!=
literal|'%'
condition|)
name|len
operator|++
expr_stmt|;
name|suffix_subst
operator|=
name|save_string
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|soft_matched_part
condition|)
block|{
name|do_spec_1
argument_list|(
name|soft_matched_part
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Catch the case where a spec string contains something like 		 '%{foo:%*}'.  ie there is no * in the pattern on the left 		 hand side of the :.  */
name|error
argument_list|(
literal|"spec failure: '%%*' has not been initialized by pattern match"
argument_list|)
expr_stmt|;
break|break;
comment|/* Process a string found as the value of a spec given by name. 	       This feature allows individual machine descriptions 	       to add and use their own specs. 	       %[...] modifies -D options the way %P does; 	       %(...) uses the spec unmodified.  */
case|case
literal|'['
case|:
name|error
argument_list|(
literal|"warning: use of obsolete %%[ operator in specs"
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|p
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* The string after the S/P is the name of a spec that is to be 		 processed.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|')'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* See if it's in the list.  */
for|for
control|(
name|len
operator|=
name|p
operator|-
name|name
operator|,
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|sl
operator|->
name|name_len
operator|==
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|name
operator|=
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPECS
name|notice
argument_list|(
literal|"Processing spec %c%s%c, which is '%s'\n"
argument_list|,
name|c
argument_list|,
name|sl
operator|->
name|name
argument_list|,
operator|(
name|c
operator|==
literal|'('
operator|)
condition|?
literal|')'
else|:
literal|']'
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|sl
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|value
operator|=
name|do_spec_1
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
else|else
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|*
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|y
init|=
name|name
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
comment|/* Copy all of NAME into BUF, but put __ after 			 every -D and at the end of each arg.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
name|y
operator|+=
literal|2
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&&
operator|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
operator|||
operator|*
name|y
operator|==
literal|'='
operator|||
operator|*
name|y
operator|==
literal|'}'
operator|||
operator|*
name|y
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|y
operator|==
literal|0
condition|)
break|break;
else|else
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
block|}
comment|/* Discard the closing paren or bracket.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
block|{
name|int
name|c1
init|=
operator|*
name|p
operator|++
decl_stmt|;
comment|/* Select first or second version number.  */
specifier|const
name|char
modifier|*
name|v
init|=
name|compiler_version
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
specifier|static
specifier|const
name|char
name|zeroc
init|=
literal|'0'
decl_stmt|;
comment|/* The format of the version string is 		 ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */
comment|/* Ignore leading non-digits.  i.e. "foo-" in "foo-2.7.2".  */
while|while
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|compiler_version
operator|&&
name|v
index|[
operator|-
literal|1
index|]
operator|!=
literal|'-'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If desired, advance to second version number.  */
if|if
condition|(
name|c1
operator|>=
literal|'2'
condition|)
block|{
comment|/* Set V after the first period.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|!=
literal|'.'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
comment|/* If desired, advance to third version number.                  But don't complain if it's not present */
if|if
condition|(
name|c1
operator|==
literal|'3'
condition|)
block|{
comment|/* Set V after the second period.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|v
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|v
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|v
operator|!=
literal|'.'
operator|)
operator|&&
operator|(
operator|*
name|v
operator|!=
literal|'-'
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|!=
literal|0
condition|)
name|v
operator|++
expr_stmt|;
block|}
comment|/* Set Q at the next period or at the end.  */
name|q
operator|=
name|v
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
name|q
operator|>
name|v
operator|&&
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'.'
operator|&&
operator|*
name|q
operator|!=
literal|'-'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|>
name|v
condition|)
comment|/* Put that part into the command.  */
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|v
argument_list|,
name|q
operator|-
name|v
argument_list|)
expr_stmt|;
else|else
comment|/* Default to "0" */
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
operator|&
name|zeroc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|input_from_pipe
condition|)
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"spec failure: unrecognized spec option '%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash: treat next character as ordinary.  */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* fall through */
default|default:
comment|/* Ordinary character: put it into the current argument.  */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
block|}
comment|/* End of string.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if we call do_spec_1 and that returns -1.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|handle_braces
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filter
decl_stmt|,
modifier|*
name|body
init|=
name|NULL
decl_stmt|,
modifier|*
name|endbody
init|=
name|NULL
decl_stmt|;
name|int
name|pipe_p
init|=
literal|0
decl_stmt|;
name|int
name|true_once
init|=
literal|0
decl_stmt|;
comment|/* If, in %{a|b:d}, at least one of a,b was seen.  */
name|int
name|negate
decl_stmt|;
name|int
name|suffix
decl_stmt|;
name|int
name|include_blanks
init|=
literal|1
decl_stmt|;
name|int
name|elide_switch
init|=
literal|0
decl_stmt|;
name|int
name|ordered
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
block|{
comment|/* A '^' after the open-brace means to not give blanks before args.  */
name|include_blanks
operator|=
literal|0
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
block|{
comment|/* A `|' after the open-brace means, 	 if the test fails, output a single minus sign rather than nothing. 	 This is used in %{|!pipe:...}.  */
name|pipe_p
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
comment|/* A `<' after the open-brace means that the switch should be 	 removed from the command-line.  */
name|elide_switch
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|next_member
label|:
name|negate
operator|=
name|suffix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
comment|/* A `!' after the open-brace negates the condition:        succeed if the specified switch is not present.  */
name|negate
operator|=
literal|1
operator|,
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
comment|/* A `.' after the open-brace means test against the current suffix.  */
block|{
if|if
condition|(
name|pipe_p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|elide_switch
operator|&&
operator|(
name|negate
operator|||
name|pipe_p
operator|||
name|suffix
operator|)
condition|)
block|{
comment|/* It doesn't make sense to mix elision with other flags.  We 	 could fatal() here, but the standard seems to be to abort.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|next_ampersand
label|:
name|filter
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
operator|&&
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|'&'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
operator|&&
operator|(
name|pipe_p
operator|||
name|ordered
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|body
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
operator|&&
operator|*
name|p
operator|!=
literal|'&'
condition|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|++
operator|!=
literal|':'
condition|)
continue|continue;
name|body
operator|=
name|q
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"mismatched braces in specs"
argument_list|)
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|endbody
operator|=
name|q
expr_stmt|;
block|}
else|else
name|body
operator|=
name|p
operator|,
name|endbody
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|suffix
condition|)
block|{
name|int
name|found
init|=
operator|(
name|input_suffix
operator|!=
literal|0
operator|&&
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|input_suffix
argument_list|)
operator|==
call|(
name|long
call|)
argument_list|(
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|input_suffix
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|body
index|[
literal|0
index|]
operator|==
literal|'}'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|negate
operator|!=
name|found
operator|&&
name|do_spec_1
argument_list|(
name|save_string
argument_list|(
name|body
argument_list|,
name|endbody
operator|-
name|body
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'}'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'&'
operator|)
condition|)
block|{
comment|/* Substitute all matching switches as separate args.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
literal|1
operator|-
name|filter
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|p
operator|-
literal|1
operator|-
name|filter
argument_list|)
condition|)
block|{
if|if
condition|(
name|elide_switch
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_IGNORE
expr_stmt|;
name|switches
index|[
name|i
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ordered
operator|=
literal|1
operator|,
name|switches
index|[
name|i
index|]
operator|.
name|ordering
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Test for presence of the specified switch.  */
name|int
name|i
decl_stmt|;
name|int
name|present
init|=
literal|0
decl_stmt|;
comment|/* If name specified ends in *, as in {x*:...}, 	 check for %* and handle that case.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|&&
operator|!
name|negate
condition|)
block|{
name|int
name|substitution
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
init|=
name|body
decl_stmt|;
comment|/* First see whether we have %*.  */
name|substitution
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|<
name|endbody
condition|)
block|{
if|if
condition|(
operator|*
name|r
operator|==
literal|'%'
operator|&&
name|r
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|substitution
operator|=
literal|1
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
comment|/* If we do, handle that case.  */
if|if
condition|(
name|substitution
condition|)
block|{
comment|/* Substitute all matching switches as separate args. 		 But do this by substituting for %* 		 in the text that follows the colon.  */
name|unsigned
name|hard_match_len
init|=
name|p
operator|-
name|filter
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|save_string
argument_list|(
name|body
argument_list|,
name|endbody
operator|-
name|body
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|hard_match_len
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|hard_match_len
index|]
argument_list|)
expr_stmt|;
comment|/* Pass any arguments this switch has.  */
name|give_switch
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|suffix_subst
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We didn't match.  Try again.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'|'
condition|)
goto|goto
name|next_member
goto|;
return|return
name|endbody
return|;
block|}
block|}
comment|/* If name specified ends in *, as in {x*:...}, 	 check for presence of any switch name starting with x.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|hard_match_len
init|=
name|p
operator|-
name|filter
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|hard_match_len
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|hard_match_len
argument_list|)
condition|)
block|{
name|present
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Otherwise, check for presence of exact name specified.  */
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|p
operator|-
name|filter
index|]
operator|==
literal|0
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|present
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If it is as desired (present for %{s...}, absent for %{!s...}) 	 then substitute either the switch or the specified 	 conditional text.  */
if|if
condition|(
name|present
operator|!=
name|negate
condition|)
block|{
if|if
condition|(
name|elide_switch
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_IGNORE
expr_stmt|;
name|switches
index|[
name|i
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ordered
operator|||
operator|*
name|p
operator|==
literal|'&'
condition|)
name|ordered
operator|=
literal|1
operator|,
name|switches
index|[
name|i
index|]
operator|.
name|ordering
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
name|give_switch
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
name|include_blanks
argument_list|)
expr_stmt|;
else|else
comment|/* Even if many alternatives are matched, only output once.  */
name|true_once
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pipe_p
condition|)
block|{
comment|/* Here if a %{|...} conditional fails: output a minus sign, 	     which means "standard output" or "standard input".  */
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|endbody
return|;
block|}
block|}
comment|/* We didn't match; try again.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'|'
condition|)
goto|goto
name|next_member
goto|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
name|body
operator|=
literal|0
expr_stmt|;
goto|goto
name|next_ampersand
goto|;
block|}
if|if
condition|(
name|ordered
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Doing this set of switches later preserves their command-line 	 ordering.  This is needed for e.g. -U, -D and -A.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|ordering
operator|==
literal|1
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|ordering
operator|=
literal|0
expr_stmt|;
name|give_switch
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
name|include_blanks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the spec just once, regardless of match count.  */
elseif|else
if|if
condition|(
name|true_once
condition|)
block|{
if|if
condition|(
name|do_spec_1
argument_list|(
name|save_string
argument_list|(
name|body
argument_list|,
name|endbody
operator|-
name|body
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
name|endbody
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch    on the command line.  PREFIX_LENGTH is the length of XXX in an {XXX*}    spec, or -1 if either exact match or %* is used.     A -O switch is obsoleted by a later -O switch.  A -f, -m, or -W switch    whose value does not begin with "no-" is obsoleted by the same value    with the "no-", similarly for a switch with the "no-" prefix.  */
end_comment

begin_function
specifier|static
name|int
name|check_live_switch
parameter_list|(
name|switchnum
parameter_list|,
name|prefix_length
parameter_list|)
name|int
name|switchnum
decl_stmt|;
name|int
name|prefix_length
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|switches
index|[
name|switchnum
index|]
operator|.
name|part1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* In the common case of {<at-most-one-letter>*}, a negating      switch would always match, so ignore that case.  We will just      send the conflicting switches to the compiler phase.  */
if|if
condition|(
name|prefix_length
operator|>=
literal|0
operator|&&
name|prefix_length
operator|<=
literal|1
condition|)
return|return
literal|1
return|;
comment|/* If we already processed this switch and determined if it was      live or not, return our past determination.  */
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|!=
literal|0
condition|)
return|return
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|>
literal|0
return|;
comment|/* Now search for duplicate in a manner that depends on the name.  */
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'O'
case|:
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
literal|'O'
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'W'
case|:
case|case
literal|'f'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* We have Xno-YYY, search for XYYY.  */
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|1
index|]
argument_list|,
operator|&
name|name
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* We have XYYY, search for Xno-YYY.  */
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|3
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|4
index|]
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
break|break;
block|}
comment|/* Otherwise the switch is live.  */
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_LIVE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pass a switch to the current accumulating command    in the same form that we received it.    SWITCHNUM identifies the switch; it is an index into    the vector of switches gcc received, which is `switches'.    This cannot fail since it never finishes a command line.     If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.     If INCLUDE_BLANKS is nonzero, then we include blanks before each argument    of the switch.  */
end_comment

begin_function
specifier|static
name|void
name|give_switch
parameter_list|(
name|switchnum
parameter_list|,
name|omit_first_word
parameter_list|,
name|include_blanks
parameter_list|)
name|int
name|switchnum
decl_stmt|;
name|int
name|omit_first_word
decl_stmt|;
name|int
name|include_blanks
decl_stmt|;
block|{
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|==
name|SWITCH_IGNORE
condition|)
return|return;
if|if
condition|(
operator|!
name|omit_first_word
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|part1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|args
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|switches
index|[
name|switchnum
index|]
operator|.
name|args
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|include_blanks
condition|)
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix_subst
condition|)
block|{
name|unsigned
name|length
init|=
name|strlen
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|--
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|arg
index|[
name|length
index|]
argument_list|)
condition|)
if|if
condition|(
name|arg
index|[
name|length
index|]
operator|==
literal|'.'
condition|)
block|{
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|dot
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|do_spec_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
condition|)
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
name|length
index|]
operator|=
literal|'.'
expr_stmt|;
name|do_spec_1
argument_list|(
name|suffix_subst
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|do_spec_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search for a file named NAME trying various prefixes including the    user's -B prefix and some standard ones.    Return the absolute file name found.  If nothing is found, return NAME.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|newname
decl_stmt|;
comment|/* Try multilib_dir if it is defined.  */
if|if
condition|(
name|multilib_dir
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|try
init|=
name|ACONCAT
argument_list|(
operator|(
name|multilib_dir
expr|,
name|dir_separator_str
expr|,
name|name
expr|,
name|NULL
operator|)
argument_list|)
decl_stmt|;
name|newname
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|try
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
comment|/* If we don't find it in the multi library dir, then fall 	 through and look for it in the normal places.  */
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
return|return
name|newname
return|;
block|}
name|newname
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|name
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
return|return
name|newname
condition|?
name|newname
else|:
name|name
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a directory exists.  If LINKER, return 0 for    certain fixed names not needed by the linker.  If not LINKER, it is    only important to return 0 if the host machine has a small ARG_MAX    limit.  */
end_comment

begin_function
specifier|static
name|int
name|is_directory
parameter_list|(
name|path1
parameter_list|,
name|path2
parameter_list|,
name|linker
parameter_list|)
specifier|const
name|char
modifier|*
name|path1
decl_stmt|;
specifier|const
name|char
modifier|*
name|path2
decl_stmt|;
name|int
name|linker
decl_stmt|;
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|path1
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|strlen
argument_list|(
name|path2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|path
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|len1
operator|+
name|len2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL_ARG_MAX
if|if
condition|(
operator|!
name|linker
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* Construct the path from the two parts.  Ensure the string ends with "/.".      The resulting path will be a directory even if the given path is a      symbolic link.  */
name|memcpy
argument_list|(
name|path
argument_list|,
name|path1
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|len1
argument_list|,
name|path2
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|cp
operator|=
name|path
operator|+
name|len1
operator|+
name|len2
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
name|DIR_SEPARATOR
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
comment|/* Exclude directories that the linker is known to search.  */
if|if
condition|(
name|linker
operator|&&
operator|(
operator|(
name|cp
operator|-
name|path
operator|==
literal|6
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|concat
argument_list|(
name|dir_separator_str
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
literal|"."
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|cp
operator|-
name|path
operator|==
literal|10
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|concat
argument_list|(
name|dir_separator_str
argument_list|,
literal|"usr"
argument_list|,
name|dir_separator_str
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
literal|"."
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
return|return
operator|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set up the various global variables to indicate that we're processing    the input file named FILENAME.  */
end_comment

begin_function
name|void
name|set_input
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|input_filename
operator|=
name|filename
expr_stmt|;
name|input_filename_length
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|input_basename
operator|=
name|input_filename
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* Skip drive name so 'x:foo' is handled properly.  */
if|if
condition|(
name|input_basename
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|input_basename
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|input_basename
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|input_basename
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Find a suffix starting with the last period,      and set basename_length to exclude that suffix.  */
name|basename_length
operator|=
name|strlen
argument_list|(
name|input_basename
argument_list|)
expr_stmt|;
name|suffixed_basename_length
operator|=
name|basename_length
expr_stmt|;
name|p
operator|=
name|input_basename
operator|+
name|basename_length
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|input_basename
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
operator|!=
name|input_basename
condition|)
block|{
name|basename_length
operator|=
name|p
operator|-
name|input_basename
expr_stmt|;
name|input_suffix
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|input_suffix
operator|=
literal|""
expr_stmt|;
comment|/* If a spec for 'g', 'u', or 'U' is seen with -save-temps then      we will need to do a stat on the input_filename.  The      INPUT_STAT_SET signals that the stat is needed.  */
name|input_stat_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* On fatal signals, delete all the temporary files.  */
end_comment

begin_function
specifier|static
name|void
name|fatal_error
parameter_list|(
name|signum
parameter_list|)
name|int
name|signum
decl_stmt|;
block|{
name|signal
argument_list|(
name|signum
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
comment|/* Get the same signal again, this time not handled,      so its normal effect occurs.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|linker_was_run
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|explicit_link_files
decl_stmt|;
name|char
modifier|*
name|specs_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|user_specs
modifier|*
name|uptr
decl_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
name|programname
operator|=
name|p
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|programname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GCC_DRIVER_HOST_INITIALIZATION
comment|/* Perform host dependent initialization when needed.  */
name|GCC_DRIVER_HOST_INITIALIZATION
expr_stmt|;
endif|#
directive|endif
name|gcc_init_libintl
argument_list|()
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* We *MUST* set SIGCHLD to SIG_DFL so that the wait4() call will      receive the signal.  A different setting is inheritable */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argbuf_length
operator|=
literal|10
expr_stmt|;
name|argbuf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argbuf_length
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
comment|/* Build multilib_select, et. al from the separate lines that make up each      multilib selection.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|q
init|=
name|multilib_raw
decl_stmt|;
name|int
name|need_space
decl_stmt|;
name|obstack_init
argument_list|(
operator|&
name|multilib_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_select
operator|=
name|obstack_finish
argument_list|(
operator|&
name|multilib_obstack
argument_list|)
expr_stmt|;
name|q
operator|=
name|multilib_matches_raw
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_matches
operator|=
name|obstack_finish
argument_list|(
operator|&
name|multilib_obstack
argument_list|)
expr_stmt|;
name|q
operator|=
name|multilib_exclusions_raw
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_exclusions
operator|=
name|obstack_finish
argument_list|(
operator|&
name|multilib_obstack
argument_list|)
expr_stmt|;
name|need_space
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|multilib_defaults_raw
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_space
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|multilib_defaults_raw
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|multilib_defaults_raw
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|need_space
operator|=
name|TRUE
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_defaults
operator|=
name|obstack_finish
argument_list|(
operator|&
name|multilib_obstack
argument_list|)
expr_stmt|;
block|}
comment|/* Set up to remember the pathname of gcc and any options      needed for collect.  We use argv[0] instead of programname because      we need the complete pathname.  */
name|obstack_init
argument_list|(
operator|&
name|collect_obstack
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"COLLECT_GCC="
argument_list|,
sizeof|sizeof
argument_list|(
literal|"COLLECT_GCC="
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|collect_obstack
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_ENVIRONMENT
comment|/* Set up any other necessary machine specific environment variables.  */
name|putenv
argument_list|(
name|INIT_ENVIRONMENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make a table of what switches there are (switches, n_switches).      Make a table of specified input files (infiles, n_infiles).      Decode switches that are handled locally.  */
name|process_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Initialize the vector of specs to just the default.      This means one element containing 0s, as a terminator.  */
name|compilers
operator|=
operator|(
expr|struct
name|compiler
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|default_compilers
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|compilers
argument_list|,
operator|(
name|char
operator|*
operator|)
name|default_compilers
argument_list|,
sizeof|sizeof
name|default_compilers
argument_list|)
expr_stmt|;
name|n_compilers
operator|=
name|n_default_compilers
expr_stmt|;
comment|/* Read specs from a file if there is one.  */
ifdef|#
directive|ifdef
name|FREEBSD_NATIVE
name|just_machine_suffix
operator|=
literal|""
expr_stmt|;
else|#
directive|else
comment|/* FREEBSD_NATIVE */
name|machine_suffix
operator|=
name|concat
argument_list|(
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|just_machine_suffix
operator|=
name|concat
argument_list|(
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
name|specs_file
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|"specs"
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
comment|/* Read the specs file unless it is a default one.  */
if|if
condition|(
name|specs_file
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|specs_file
argument_list|,
literal|"specs"
argument_list|)
condition|)
name|read_specs
argument_list|(
name|specs_file
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|init_spec
argument_list|()
expr_stmt|;
comment|/* We need to check standard_exec_prefix/just_machine_suffix/specs      for any override of as, ld and libraries.  */
name|specs_file
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|standard_exec_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|just_machine_suffix
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"specs"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|specs_file
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|specs_file
argument_list|,
name|just_machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|specs_file
argument_list|,
literal|"specs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|specs_file
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|read_specs
argument_list|(
name|specs_file
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If not cross-compiling, look for startfiles in the standard places.  */
if|if
condition|(
operator|*
name|cross_compile
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
name|md_exec_prefix
condition|)
block|{
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|md_exec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_exec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|md_startfile_prefix
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_startfile_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|md_startfile_prefix_1
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_startfile_prefix_1
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If standard_startfile_prefix is relative, base it on 	 standard_exec_prefix.  This lets us move the installed tree 	 as a unit.  If GCC_EXEC_PREFIX is defined, base 	 standard_startfile_prefix on that as well.  */
if|if
condition|(
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|standard_startfile_prefix
argument_list|)
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gcc_exec_prefix
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|standard_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix_1
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix_2
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not FREEBSD_NATIVE */
if|#
directive|if
literal|0
comment|/* Can cause surprises, and one can use -B./ instead.  */
block|add_prefix (&startfile_prefixes, "./", NULL, 		  PREFIX_PRIORITY_LAST, 1, NULL);
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|standard_startfile_prefix
argument_list|)
operator|&&
name|gcc_exec_prefix
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Process any user specified specs in the order given on the command      line.  */
for|for
control|(
name|uptr
operator|=
name|user_specs_head
init|;
name|uptr
condition|;
name|uptr
operator|=
name|uptr
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|filename
init|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|uptr
operator|->
name|filename
argument_list|,
name|R_OK
argument_list|)
decl_stmt|;
name|read_specs
argument_list|(
name|filename
condition|?
name|filename
else|:
name|uptr
operator|->
name|filename
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a GCC_EXEC_PREFIX envvar, modify it for cpp's sake.  */
if|if
condition|(
name|gcc_exec_prefix
condition|)
name|gcc_exec_prefix
operator|=
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now we have the specs.      Set the `valid' bits for switches that match anything in any spec.  */
name|validate_all_switches
argument_list|()
expr_stmt|;
comment|/* Now that we have the switches and the specs, set      the subdirectory based on the options.  */
name|set_multilib_dir
argument_list|()
expr_stmt|;
comment|/* Warn about any switches that no pass was interested in.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|switches
index|[
name|i
index|]
operator|.
name|validated
condition|)
name|error
argument_list|(
literal|"unrecognized option `-%s'"
argument_list|,
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
expr_stmt|;
comment|/* Obey some of the options.  */
if|if
condition|(
name|print_search_dirs
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"install: %s%s\n"
argument_list|)
argument_list|,
name|standard_exec_prefix
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"programs: %s\n"
argument_list|)
argument_list|,
name|build_search_list
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"libraries: %s\n"
argument_list|)
argument_list|,
name|build_search_list
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_file_name
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|find_file
argument_list|(
name|print_file_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_prog_name
condition|)
block|{
name|char
modifier|*
name|newname
init|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|print_prog_name
argument_list|,
name|X_OK
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
name|newname
condition|?
name|newname
else|:
name|print_prog_name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_multi_lib
condition|)
block|{
name|print_multilib_info
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_multi_directory
condition|)
block|{
if|if
condition|(
name|multilib_dir
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|multilib_dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|target_help_flag
condition|)
block|{
comment|/* Print if any target specific options.  */
comment|/* We do not exit here. Instead we have created a fake input file          called 'target-dummy' which needs to be compiled, and we pass this          on to the various sub-processes, along with the --target-help          switch.  */
block|}
if|if
condition|(
name|print_help_list
condition|)
block|{
name|display_help
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|verbose_flag
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nFor bug reporting instructions, please see:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s.\n"
argument_list|,
name|GCCBUGURL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* We do not exit here.  Instead we have created a fake input file 	 called 'help-dummy' which needs to be compiled, and we pass this 	 on the various sub-processes, along with the --help switch.  */
block|}
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|thrmod
decl_stmt|;
name|notice
argument_list|(
literal|"Configured with: %s\n"
argument_list|,
name|configuration_arguments
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_MODEL_SPEC
comment|/* We could have defined THREAD_MODEL_SPEC to "%*" by default, 	 but there's no point in doing all this processing just to get 	 thread_model back.  */
name|obstack_init
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|THREAD_MODEL_SPEC
argument_list|,
literal|0
argument_list|,
name|thread_model
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|thrmod
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
else|#
directive|else
name|thrmod
operator|=
name|thread_model
expr_stmt|;
endif|#
directive|endif
name|notice
argument_list|(
literal|"Thread model: %s\n"
argument_list|,
name|thrmod
argument_list|)
expr_stmt|;
comment|/* compiler_version is truncated at the first space when initialized 	 from version string, so truncate version_string at the first space 	 before comparing.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|version_string
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|version_string
index|[
name|n
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|version_string
argument_list|,
name|compiler_version
argument_list|,
name|n
argument_list|)
operator|&&
name|compiler_version
index|[
name|n
index|]
operator|==
literal|0
condition|)
name|notice
argument_list|(
literal|"gcc version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"gcc driver version %s executing gcc version %s\n"
argument_list|,
name|version_string
argument_list|,
name|compiler_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_infiles
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n_infiles
operator|==
name|added_libraries
condition|)
name|fatal
argument_list|(
literal|"No input files specified"
argument_list|)
expr_stmt|;
comment|/* Make a place to record the compiler output file names      that correspond to the input files.  */
name|i
operator|=
name|n_infiles
expr_stmt|;
name|i
operator|+=
name|lang_specific_extra_outfiles
expr_stmt|;
name|outfiles
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record which files were specified explicitly as link input.  */
name|explicit_link_files
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|n_infiles
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_file_error
init|=
literal|0
decl_stmt|;
comment|/* Tell do_spec what to substitute for %i.  */
name|input_file_number
operator|=
name|i
expr_stmt|;
name|set_input
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Use the same thing in %o, unless cp->spec says otherwise.  */
name|outfiles
index|[
name|i
index|]
operator|=
name|input_filename
expr_stmt|;
comment|/* Figure out which compiler from the file's suffix.  */
name|input_file_compiler
operator|=
name|lookup_compiler
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|input_filename_length
argument_list|,
name|infiles
index|[
name|i
index|]
operator|.
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file_compiler
condition|)
block|{
comment|/* Ok, we found an applicable compiler.  Run its spec.  */
if|if
condition|(
name|input_file_compiler
operator|->
name|spec
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|error
argument_list|(
literal|"%s: %s compiler not installed on this system"
argument_list|,
name|input_filename
argument_list|,
operator|&
name|input_file_compiler
operator|->
name|spec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|this_file_error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|do_spec
argument_list|(
name|input_file_compiler
operator|->
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|this_file_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this file's name does not contain a recognized suffix, 	 record it as explicit linker input.  */
else|else
name|explicit_link_files
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Clear the delete-on-failure queue, deleting the files in it 	 if this compilation failed.  */
if|if
condition|(
name|this_file_error
condition|)
block|{
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
comment|/* If this compilation succeeded, don't delete those files later.  */
name|clear_failure_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Reset the output file name to the first input file name, for use      with %b in LINK_SPEC on a target that prefers not to emit a.out      by default.  */
if|if
condition|(
name|n_infiles
operator|>
literal|0
condition|)
name|set_input
argument_list|(
name|infiles
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_count
operator|==
literal|0
condition|)
block|{
comment|/* Make sure INPUT_FILE_NUMBER points to first available open 	 slot.  */
name|input_file_number
operator|=
name|n_infiles
expr_stmt|;
if|if
condition|(
name|lang_specific_pre_link
argument_list|()
condition|)
name|error_count
operator|++
expr_stmt|;
block|}
comment|/* Run ld to link all the compiler output files.  */
if|if
condition|(
name|error_count
operator|==
literal|0
condition|)
block|{
name|int
name|tmp
init|=
name|execution_count
decl_stmt|;
comment|/* We'll use ld if we can't find collect2.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|linker_name_spec
argument_list|,
literal|"collect2"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"collect2"
argument_list|,
name|X_OK
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|linker_name_spec
operator|=
literal|"ld"
expr_stmt|;
block|}
comment|/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables 	 for collect.  */
name|putenv_from_prefixes
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
name|putenv_from_prefixes
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|LIBRARY_PATH_ENV
argument_list|)
expr_stmt|;
name|value
operator|=
name|do_spec
argument_list|(
name|link_command_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|error_count
operator|=
literal|1
expr_stmt|;
name|linker_was_run
operator|=
operator|(
name|tmp
operator|!=
name|execution_count
operator|)
expr_stmt|;
block|}
comment|/* If options said don't run linker,      complain about input files to be given to the linker.  */
if|if
condition|(
operator|!
name|linker_was_run
operator|&&
name|error_count
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|explicit_link_files
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"%s: linker input file unused because linking not done"
argument_list|,
name|outfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Delete some or all of the temporary files we made.  */
if|if
condition|(
name|error_count
condition|)
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_help_list
condition|)
block|{
name|printf
argument_list|(
operator|(
literal|"\nFor bug reporting instructions, please see:\n"
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|GCCBUGURL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|signal_count
operator|!=
literal|0
condition|?
literal|2
else|:
name|error_count
operator|>
literal|0
condition|?
operator|(
name|pass_exit_codes
condition|?
name|greatest_status
else|:
literal|1
operator|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the proper compilation spec for the file name NAME,    whose length is LENGTH.  LANGUAGE is the specified language,    or 0 if this file is to be passed to the linker.  */
end_comment

begin_function
specifier|static
name|struct
name|compiler
modifier|*
name|lookup_compiler
parameter_list|(
name|name
parameter_list|,
name|length
parameter_list|,
name|language
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
block|{
name|struct
name|compiler
modifier|*
name|cp
decl_stmt|;
comment|/* If this was specified by the user to be a linker input, indicate that.  */
if|if
condition|(
name|language
operator|!=
literal|0
operator|&&
name|language
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, look for the language, if one is spec'd.  */
if|if
condition|(
name|language
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
if|if
condition|(
name|cp
operator|->
name|suffix
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
operator|+
literal|1
argument_list|,
name|language
argument_list|)
condition|)
return|return
name|cp
return|;
name|error
argument_list|(
literal|"language %s not recognized"
argument_list|,
name|language
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Look for a suffix.  */
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
block|{
if|if
condition|(
comment|/* The suffix `-' matches only the file name `-'.  */
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"-"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
operator|<
name|length
comment|/* See if the suffix matches the end of NAME.  */
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_DOS_BASED_FILE_SYSTEM
argument_list|)
comment|/* look again, but case-insensitively this time.  */
if|if
condition|(
name|cp
operator|<
name|compilers
condition|)
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
block|{
if|if
condition|(
comment|/* The suffix `-' matches only the file name `-'.  */
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"-"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
operator|<
name|length
comment|/* See if the suffix matches the end of NAME.  */
operator|&&
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|||
operator|!
name|strpbrk
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|)
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|cp
operator|>=
name|compilers
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|spec
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
comment|/* A non-alias entry: return it.  */
return|return
name|cp
return|;
comment|/* An alias entry maps a suffix to a language. 	 Search for the language; pass 0 for NAME and LENGTH 	 to avoid infinite recursion if language not found.  */
return|return
name|lookup_compiler
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|cp
operator|->
name|spec
operator|+
literal|1
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfatal_pexecute
parameter_list|(
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|)
specifier|const
name|char
modifier|*
name|errmsg_fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg_arg
decl_stmt|;
block|{
if|if
condition|(
name|errmsg_arg
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* Space for trailing '\0' is in %s.  */
name|char
modifier|*
name|msg
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|errmsg_fmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|errmsg_arg
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
name|errmsg_fmt
argument_list|,
name|errmsg_arg
argument_list|)
expr_stmt|;
name|errmsg_fmt
operator|=
name|msg
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
name|pfatal_with_name
argument_list|(
name|errmsg_fmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an error message and exit */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"internal gcc abort"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an error message and exit */
end_comment

begin_decl_stmt
name|void
name|fatal
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_all_switches
parameter_list|()
block|{
name|struct
name|compiler
modifier|*
name|comp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|spec
decl_stmt|;
for|for
control|(
name|comp
operator|=
name|compilers
init|;
name|comp
operator|->
name|spec
condition|;
name|comp
operator|++
control|)
block|{
name|p
operator|=
name|comp
operator|->
name|spec
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Look through the linked list of specs read from the specs file.  */
for|for
control|(
name|spec
operator|=
name|specs
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
block|{
name|p
operator|=
operator|*
operator|(
name|spec
operator|->
name|ptr_spec
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|link_command_spec
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at the switch-name that comes after START    and mark as valid all supplied switches that match it.  */
end_comment

begin_function
specifier|static
name|void
name|validate_switches
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|filter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|suffix
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
operator|++
name|p
expr_stmt|;
name|next_member
label|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
operator|++
name|p
expr_stmt|;
name|suffix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|suffix
operator|=
literal|1
operator|,
operator|++
name|p
expr_stmt|;
name|filter
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
operator|&&
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|'&'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|suffix
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
comment|/* Mark all matching switches as valid.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
operator|-
literal|1
argument_list|)
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark an exact matching switch as valid.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|p
operator|-
name|filter
index|]
operator|==
literal|0
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'|'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'&'
condition|)
goto|goto
name|next_member
goto|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether a particular argument was used.  The first time we    canonicalize the switches to keep only the ones we care about.  */
end_comment

begin_function
specifier|static
name|int
name|used_arg
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
struct|struct
name|mswitchstr
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|replace
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|rep_len
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|mswitchstr
modifier|*
name|mswitches
decl_stmt|;
specifier|static
name|int
name|n_mswitches
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|mswitches
condition|)
block|{
name|struct
name|mswitchstr
modifier|*
name|matches
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Break multilib_matches into the component strings of string          and replacement string.  */
for|for
control|(
name|q
operator|=
name|multilib_matches
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|';'
condition|)
name|cnt
operator|++
expr_stmt|;
name|matches
operator|=
operator|(
expr|struct
name|mswitchstr
operator|*
operator|)
name|alloca
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mswitchstr
argument_list|)
operator|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|multilib_matches
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
name|matches
index|[
name|i
index|]
operator|.
name|str
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|matches
index|[
name|i
index|]
operator|.
name|len
operator|=
name|q
operator|-
name|matches
index|[
name|i
index|]
operator|.
name|str
expr_stmt|;
name|matches
index|[
name|i
index|]
operator|.
name|replace
operator|=
operator|++
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
name|abort
argument_list|()
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|matches
index|[
name|i
index|]
operator|.
name|rep_len
operator|=
name|q
operator|-
name|matches
index|[
name|i
index|]
operator|.
name|replace
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|';'
condition|)
name|q
operator|++
expr_stmt|;
block|}
comment|/* Now build a list of the replacement string for switches that we care 	 about.  Make sure we allocate at least one entry.  This prevents 	 xmalloc from calling fatal, and prevents us from re-executing this 	 block of code.  */
name|mswitches
operator|=
operator|(
expr|struct
name|mswitchstr
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mswitchstr
argument_list|)
operator|)
operator|*
operator|(
name|n_switches
condition|?
name|n_switches
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
name|int
name|xlen
init|=
name|strlen
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|xlen
operator|==
name|matches
index|[
name|j
index|]
operator|.
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|matches
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|xlen
argument_list|)
condition|)
block|{
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|str
operator|=
name|matches
index|[
name|j
index|]
operator|.
name|replace
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|len
operator|=
name|matches
index|[
name|j
index|]
operator|.
name|rep_len
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|replace
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|rep_len
operator|=
literal|0
expr_stmt|;
name|n_mswitches
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_mswitches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|len
operator|==
name|mswitches
index|[
name|i
index|]
operator|.
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|mswitches
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|default_arg
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
for|for
control|(
name|start
operator|=
name|multilib_defaults
init|;
operator|*
name|start
operator|!=
literal|'\0'
condition|;
name|start
operator|=
name|end
operator|+
literal|1
control|)
block|{
while|while
condition|(
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'\0'
condition|)
break|break;
for|for
control|(
name|end
operator|=
name|start
operator|+
literal|1
init|;
operator|*
name|end
operator|!=
literal|' '
operator|&&
operator|*
name|end
operator|!=
literal|'\t'
operator|&&
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|end
operator|-
name|start
operator|)
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Work out the subdirectory to use based on the options. The format of    multilib_select is a list of elements. Each element is a subdirectory    name followed by a list of options followed by a semicolon. The format    of multilib_exclusions is the same, but without the preceding    directory. First gcc will check the exclusions, if none of the options    beginning with an exclamation point are present, and all of the other    options are present, then we will ignore this completely. Passing    that, gcc will consider each multilib_select in turn using the same    rules for matching the options. If a match is found, that subdirectory    will be used.  */
end_comment

begin_function
specifier|static
name|void
name|set_multilib_dir
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|this_path_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_path
decl_stmt|,
modifier|*
name|this_arg
decl_stmt|;
name|int
name|not_arg
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|p
operator|=
name|multilib_exclusions
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Check the arguments.  */
name|ok
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|this_arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|this_arg
operator|!=
literal|'!'
condition|)
name|not_arg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|not_arg
operator|=
literal|1
expr_stmt|;
operator|++
name|this_arg
expr_stmt|;
block|}
name|ok
operator|=
name|used_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_arg
condition|)
name|ok
operator|=
operator|!
name|ok
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
return|return;
operator|++
name|p
expr_stmt|;
block|}
name|p
operator|=
name|multilib_select
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Get the initial path.  */
name|this_path
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|this_path_len
operator|=
name|p
operator|-
name|this_path
expr_stmt|;
comment|/* Check the arguments.  */
name|ok
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|this_arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|this_arg
operator|!=
literal|'!'
condition|)
name|not_arg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|not_arg
operator|=
literal|1
expr_stmt|;
operator|++
name|this_arg
expr_stmt|;
block|}
comment|/* If this is a default argument, we can just ignore it. 	     This is true even if this_arg begins with '!'.  Beginning 	     with '!' does not mean that this argument is necessarily 	     inappropriate for this library: it merely means that 	     there is a more specific library which uses this 	     argument.  If this argument is a default, we need not 	     consider that more specific library.  */
if|if
condition|(
operator|!
name|default_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
condition|)
block|{
name|ok
operator|=
name|used_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_arg
condition|)
name|ok
operator|=
operator|!
name|ok
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|this_path_len
operator|!=
literal|1
operator|||
name|this_path
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
name|char
modifier|*
name|new_multilib_dir
init|=
name|xmalloc
argument_list|(
name|this_path_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|new_multilib_dir
argument_list|,
name|this_path
argument_list|,
name|this_path_len
argument_list|)
expr_stmt|;
name|new_multilib_dir
index|[
name|this_path_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|multilib_dir
operator|=
name|new_multilib_dir
expr_stmt|;
block|}
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out the multiple library subdirectory selection    information.  This prints out a series of lines.  Each line looks    like SUBDIRECTORY;@OPTION@OPTION, with as many options as is    required.  Only the desired options are printed out, the negative    matches.  The options are print without a leading dash.  There are    no spaces to make it easy to use the information in the shell.    Each subdirectory is printed only once.  This assumes the ordering    generated by the genmultilib script. Also, we leave out ones that match    the exclusions.  */
end_comment

begin_function
specifier|static
name|void
name|print_multilib_info
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|multilib_select
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_path
init|=
literal|0
decl_stmt|,
modifier|*
name|this_path
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|unsigned
name|int
name|last_path_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Get the initial path.  */
name|this_path
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
comment|/* Check for matches with the multilib_exclusions. We don't bother          with the '!' in either list. If any of the exclusion rules match          all of its options with the select rule, we skip it.  */
block|{
specifier|const
name|char
modifier|*
name|e
init|=
name|multilib_exclusions
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_arg
decl_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|m
init|=
literal|1
decl_stmt|;
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|e
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|e
expr_stmt|;
continue|continue;
block|}
comment|/* Check the arguments.  */
while|while
condition|(
operator|*
name|e
operator|!=
literal|';'
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|mp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
operator|++
name|e
expr_stmt|;
continue|continue;
block|}
name|this_arg
operator|=
name|e
expr_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|' '
operator|&&
operator|*
name|e
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|e
expr_stmt|;
block|}
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|len
init|=
name|e
operator|-
name|this_arg
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arg
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
name|this_arg
argument_list|,
operator|(
name|len
operator|<
name|q
operator|-
name|arg
operator|)
condition|?
name|q
operator|-
name|arg
else|:
name|len
argument_list|)
operator|||
name|default_arg
argument_list|(
name|this_arg
argument_list|,
name|e
operator|-
name|this_arg
argument_list|)
condition|)
block|{
name|mp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mp
condition|)
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
literal|' '
condition|)
operator|++
name|e
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|e
operator|!=
literal|'\0'
condition|)
operator|++
name|e
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|/* If this is a duplicate, skip it.  */
name|skip
operator|=
operator|(
name|last_path
operator|!=
literal|0
operator|&&
call|(
name|unsigned
name|int
call|)
argument_list|(
name|p
operator|-
name|this_path
argument_list|)
operator|==
name|last_path_len
operator|&&
operator|!
name|strncmp
argument_list|(
name|last_path
argument_list|,
name|this_path
argument_list|,
name|last_path_len
argument_list|)
operator|)
expr_stmt|;
name|last_path
operator|=
name|this_path
expr_stmt|;
name|last_path_len
operator|=
name|p
operator|-
name|this_path
expr_stmt|;
block|}
comment|/* If this directory requires any default arguments, we can skip 	 it.  We will already have printed a directory identical to 	 this one which does not require that default argument.  */
if|if
condition|(
operator|!
name|skip
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'!'
condition|)
name|arg
operator|=
name|NULL
expr_stmt|;
else|else
name|arg
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|default_arg
argument_list|(
name|arg
argument_list|,
name|q
operator|-
name|arg
argument_list|)
condition|)
block|{
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
operator|++
name|q
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|last_path
init|;
name|p1
operator|<
name|p
condition|;
name|p1
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|int
name|use_arg
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|use_arg
operator|=
operator|*
name|p
operator|!=
literal|'!'
expr_stmt|;
if|if
condition|(
name|use_arg
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_arg
condition|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|/* If there are extra options, print them now.  */
if|if
condition|(
name|multilib_extra
operator|&&
operator|*
name|multilib_extra
condition|)
block|{
name|int
name|print_at
init|=
name|TRUE
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|multilib_extra
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
name|print_at
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_at
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
name|print_at
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function

end_unit

