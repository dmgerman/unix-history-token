begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compiler driver program that can handle many languages.    Copyright (C) 1987, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  This paragraph is here to try to keep Sun CC from dying. The number of chars here seems crucial!!!!  */
end_comment

begin_comment
comment|/* This program is the user interface to the C compiler and possibly to other compilers.  It is used because compilation is a complicated procedure which involves running several programs and passing temporary files between them, forwarding the users switches to those programs selectively, and deleting the temporary files at the end.  CC recognizes how to compile each input file by suffixes in the file names. Once it knows which kind of compilation to perform, the procedure for compilation is specified by a string called a "spec".  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* May get R_OK, etc. on some systems.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_function_decl
name|int
name|__spawnv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__spawnvp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Include multi-lib information.  */
end_comment

begin_include
include|#
directive|include
file|"multilib.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff) != 0&& ((S)& 0xff) != 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|S
parameter_list|)
value|((S)& 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WEXITSTATUS
end_ifndef

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff00)>> 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add prototype support.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PROTO
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|PROTO
parameter_list|(
name|ARGS
parameter_list|)
value|ARGS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROTO
parameter_list|(
name|ARGS
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VPROTO
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|PVPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|ARGS
end_define

begin_define
define|#
directive|define
name|VPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|ARGS
end_define

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|va_list
parameter_list|,
name|var
parameter_list|)
value|va_start(va_list,var)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PVPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|()
end_define

begin_define
define|#
directive|define
name|VPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|(va_alist) va_dcl
end_define

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|va_list
parameter_list|,
name|var
parameter_list|)
value|va_start(va_list)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a generic NULL if one hasn't already been defined.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define O_RDONLY if the system hasn't defined it for us. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GENERIC_PTR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|GENERIC_PTR
value|void *
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GENERIC_PTR
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL_PTR
end_ifndef

begin_define
define|#
directive|define
name|NULL_PTR
value|((GENERIC_PTR)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_comment
comment|/* On MSDOS, write temp files in current dir    because there's no place else we can expect to use.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|P_tmpdir
end_ifndef

begin_define
define|#
directive|define
name|P_tmpdir
value|"."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Test if something is a normal file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Test if something is a directory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default there is no special suffix for executables.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXECUTABLE_SUFFIX
end_ifndef

begin_define
define|#
directive|define
name|EXECUTABLE_SUFFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, the suffix for object files is ".o". */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_SUFFIX
end_ifdef

begin_define
define|#
directive|define
name|HAVE_OBJECT_SUFFIX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OBJECT_SUFFIX
value|".o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, colon separates directories in a path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIR_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIR_SEPARATOR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|dir_separator_str
index|[]
init|=
block|{
name|DIR_SEPARATOR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRERROR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|bsd4_4
argument_list|)
end_if

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|execv
argument_list|()
decl_stmt|,
name|execvp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a stage of compilation returns an exit status>= 1,    compilation of that file ceases.  */
end_comment

begin_define
define|#
directive|define
name|MIN_FATAL_STATUS
value|1
end_define

begin_comment
comment|/* Flag saying to print the directories gcc will search through looking for    programs, libraries, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_search_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the full filename of this file    as found through our usual search mechanism.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|print_file_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* As print_file_name, but search for executable file. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|print_prog_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the relative path we'd use to    find libgcc.a given the current compiler flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_multi_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the list of subdirectories and    compiler flags used to select them in a standard form.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_multi_lib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should print the command and arguments */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means write "temp" files in source directory    and use the source file's name in them, and don't delete them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|save_temps_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiler version.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|compiler_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target version specified with -V */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|spec_version
init|=
name|DEFAULT_TARGET_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target machine specified with -b.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|spec_machine
init|=
name|DEFAULT_TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if cross-compiling.    When -b is used, the value comes from the `specs' file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|cross_compile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|cross_compile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of errors that have occurred; the link phase will not be    run if this is non-zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the obstack which we use to allocate many strings.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the obstack to build an environment variable to pass to    collect2 that describes all of the relevant switches of what to    pass the compiler in building the list of pointers to constructors    and destructors.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|collect_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration for prototypes.  */
end_comment

begin_struct_decl
struct_decl|struct
name|path_prefix
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|void
name|set_spec
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|compiler
modifier|*
name|lookup_compiler
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_search_list
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putenv_from_prefixes
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|find_a_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_prefix
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skip_whitespace
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_temp_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_if_ordinary
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_temp_files
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_failure_queue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_failure_queue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|choose_temp_base_try
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_temp_base
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_live_switch
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|handle_braces
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_string
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|concat
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|concat3
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|concat4
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|concat6
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|\
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_spec
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_spec_1
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|find_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_directory
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_switches
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_all_switches
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|give_switch
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|used_arg
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_arg
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_multilib_dir
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_multilib_info
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pfatal_with_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perror_with_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perror_exec
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|PVPROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We must not provide any prototype here, even if ANSI C.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fatal
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Specs are strings containing lines, each of which (if not blank) is made up of a program name, and arguments separated by spaces. The program name must be exact and start from root, since no path is searched and it is unreliable to depend on the current working directory. Redirection of input or output is not supported; the subprograms must accept filenames saying what files to read and write.  In addition, the specs can contain %-sequences to substitute variable text or for conditional text.  Here is a table of all defined %-sequences. Note that spaces are not generated automatically around the results of expanding these sequences; therefore, you can concatenate them together or with constant text in a single argument.   %%	substitute one % into the program name or argument.  %i     substitute the name of the input file being processed.  %b     substitute the basename of the input file being processed. 	This is the substring up to (and not including) the last period 	and not including the directory.  %g     substitute the temporary-file-name-base.  This is a string chosen 	once per compilation.  Different temporary file names are made by 	concatenation of constant strings on the end, as in `%g.s'. 	%g also has the same effect of %d.  %u	like %g, but make the temporary file name unique.  %U	returns the last file name generated with %u.  %d	marks the argument containing or following the %d as a 	temporary file name, so that that file will be deleted if CC exits 	successfully.  Unlike %g, this contributes no text to the argument.  %w	marks the argument containing or following the %w as the 	"output file" of this compilation.  This puts the argument 	into the sequence of arguments that %o will substitute later.  %W{...} 	like %{...} but mark last argument supplied within 	as a file to be deleted on failure.  %o	substitutes the names of all the output files, with spaces 	automatically placed around them.  You should write spaces 	around the %o as well or the results are undefined. 	%o is for use in the specs for running the linker. 	Input files whose names have no recognized suffix are not compiled 	at all, but they are included among the output files, so they will 	be linked.  %O	substitutes the suffix for object files.  %p	substitutes the standard macro predefinitions for the 	current target machine.  Use this when running cpp.  %P	like %p, but puts `__' before and after the name of each macro. 	(Except macros that already have __.) 	This is for ANSI C.  %I	Substitute a -iprefix option made from GCC_EXEC_PREFIX.  %s     current argument is the name of a library or startup file of some sort.         Search for that file in a standard list of directories 	and substitute the full name found.  %eSTR  Print STR as an error message.  STR is terminated by a newline.         Use this when inconsistent options are detected.  %x{OPTION}	Accumulate an option for %X.  %X	Output the accumulated linker options specified by compilations.  %Y	Output the accumulated assembler options specified by compilations.  %Z	Output the accumulated preprocessor options specified by compilations.  %v1	Substitute the major version number of GCC. 	(For version 2.5.n, this is 2.)  %v2	Substitute the minor version number of GCC. 	(For version 2.5.n, this is 5.)  %a     process ASM_SPEC as a spec.         This allows config.h to specify part of the spec for running as.  %A	process ASM_FINAL_SPEC as a spec.  A capital A is actually 	used here.  This can be used to run a post-processor after the 	assembler has done it's job.  %D	Dump out a -L option for each directory in startfile_prefixes. 	If multilib_dir is set, extra entries are generated with it affixed.  %l     process LINK_SPEC as a spec.  %L     process LIB_SPEC as a spec.  %G     process LIBGCC_SPEC as a spec.  %S     process STARTFILE_SPEC as a spec.  A capital S is actually used here.  %E     process ENDFILE_SPEC as a spec.  A capital E is actually used here.  %c	process SIGNED_CHAR_SPEC as a spec.  %C     process CPP_SPEC as a spec.  A capital C is actually used here.  %1	process CC1_SPEC as a spec.  %2	process CC1PLUS_SPEC as a spec.  %|	output "-" if the input for the current command is coming from a pipe.  %*	substitute the variable part of a matched option.  (See below.) 	Note that each comma in the substituted string is replaced by 	a single space.  %{S}   substitutes the -S switch, if that switch was given to CC. 	If that switch was not specified, this substitutes nothing. 	Here S is a metasyntactic variable.  %{S*}  substitutes all the switches specified to CC whose names start 	with -S.  This is used for -o, -D, -I, etc; switches that take 	arguments.  CC considers `-o foo' as being one switch whose 	name starts with `o'.  %{o*} would substitute this text, 	including the space; thus, two arguments would be generated.  %{S*:X} substitutes X if one or more switches whose names start with -S are 	specified to CC.  Note that the tail part of the -S option 	(i.e. the part matched by the `*') will be substituted for each 	occurrence of %* within X.  %{S:X} substitutes X, but only if the -S switch was given to CC.  %{!S:X} substitutes X, but only if the -S switch was NOT given to CC.  %{|S:X} like %{S:X}, but if no S switch, substitute `-'.  %{|!S:X} like %{!S:X}, but if there is an S switch, substitute `-'.  %{.S:X} substitutes X, but only if processing a file with suffix S.  %{!.S:X} substitutes X, but only if NOT processing a file with suffix S.  %(Spec) processes a specification defined in a specs file as *Spec:  %[Spec] as above, but put __ around -D arguments  The conditional text X in a %{S:X} or %{!S:X} construct may contain other nested % constructs or spaces, or even newlines.  They are processed as usual, as described above.  The -O, -f, -m, and -W switches are handled specifically in these constructs.  If another value of -O or the negated form of a -f, -m, or -W switch is found later in the command line, the earlier switch value is ignored, except with {S*} where S is just one letter; this passes all matching options.  The character | is used to indicate that a command should be piped to the following command, but only if -pipe is specified.  Note that it is built into CC which switches take arguments and which do not.  You might think it would be useful to generalize this to allow each compiler's spec to say which switches take arguments.  But this cannot be done in a consistent fashion.  CC cannot even decide which input files have been specified without knowing which switches take arguments, and it must know which input files to compile in order to tell which compilers to run.  CC also knows implicitly that arguments starting in `-l' are to be treated as compiler output files, and passed to the linker in their proper position among the other output files.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Define the macros used for specs %a, %l, %L, %S, %c, %C, %1.  */
end_comment

begin_comment
comment|/* config.h can define ASM_SPEC to provide extra args to the assembler    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define ASM_FINAL_SPEC to run a post processor after    the assembler has run.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_FINAL_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_FINAL_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CPP_SPEC to provide extra args to the C preprocessor    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPP_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CPP_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CC1_SPEC to provide extra args to cc1 and cc1plus    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC1_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CC1_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CC1PLUS_SPEC to provide extra args to cc1plus    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC1PLUS_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CC1PLUS_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LINK_SPEC to provide extra args to the linker    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LINK_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LIB_SPEC to override the default libraries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIB_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LIB_SPEC
value|"%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LIBGCC_SPEC to override how and when libgcc.a is    included.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBGCC_SPEC
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LINK_LIBGCC_SPECIAL
argument_list|)
operator|||
name|defined
argument_list|(
name|LINK_LIBGCC_SPECIAL_1
argument_list|)
end_if

begin_comment
comment|/* Have gcc do the search for libgcc.a.  */
end_comment

begin_define
define|#
directive|define
name|LIBGCC_SPEC
value|"%{!shared:libgcc.a%s}"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIBGCC_SPEC
value|"%{!shared:-lgcc}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define STARTFILE_SPEC to override the default crt0 files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STARTFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|STARTFILE_SPEC
define|\
value|"%{!shared:%{pg:gcrt0%O%s}%{!pg:%{p:mcrt0%O%s}%{!p:crt0%O%s}}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define SWITCHES_NEED_SPACES to control passing -o and -L.    Make the string nonempty to require spaces there.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCHES_NEED_SPACES
end_ifndef

begin_define
define|#
directive|define
name|SWITCHES_NEED_SPACES
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define ENDFILE_SPEC to override the default crtn files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENDFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ENDFILE_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This spec is used for telling cpp whether char is signed or not.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIGNED_CHAR_SPEC
end_ifndef

begin_comment
comment|/* Use #if rather than ?:    because MIPS C compiler rejects like ?: in initializers.  */
end_comment

begin_if
if|#
directive|if
name|DEFAULT_SIGNED_CHAR
end_if

begin_define
define|#
directive|define
name|SIGNED_CHAR_SPEC
value|"%{funsigned-char:-D__CHAR_UNSIGNED__}"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIGNED_CHAR_SPEC
value|"%{!fsigned-char:-D__CHAR_UNSIGNED__}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTILIB_SELECT comes from multilib.h.  It gives a    string interpreted by set_multilib_dir to select a library    subdirectory based on the compiler options.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MULTILIB_SELECT
end_ifndef

begin_define
define|#
directive|define
name|MULTILIB_SELECT
value|". ;"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cpp_spec
init|=
name|CPP_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cpp_predefines
init|=
name|CPP_PREDEFINES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cc1_spec
init|=
name|CC1_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cc1plus_spec
init|=
name|CC1PLUS_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|signed_char_spec
init|=
name|SIGNED_CHAR_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|asm_spec
init|=
name|ASM_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|asm_final_spec
init|=
name|ASM_FINAL_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|link_spec
init|=
name|LINK_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lib_spec
init|=
name|LIB_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|libgcc_spec
init|=
name|LIBGCC_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|endfile_spec
init|=
name|ENDFILE_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|startfile_spec
init|=
name|STARTFILE_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|switches_need_spaces
init|=
name|SWITCHES_NEED_SPACES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|multilib_select
init|=
name|MULTILIB_SELECT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This defines which switch letters take arguments.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|SWITCH_TAKES_ARG
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o' \    || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u' \    || (CHAR) == 'I' || (CHAR) == 'm' || (CHAR) == 'x' \    || (CHAR) == 'L' || (CHAR) == 'A')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This defines which multi-letter switches take arguments.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
define|\
value|(!strcmp (STR, "Tdata") || !strcmp (STR, "Ttext")	\   || !strcmp (STR, "Tbss") || !strcmp (STR, "include")	\   || !strcmp (STR, "imacros") || !strcmp (STR, "aux-info") \   || !strcmp (STR, "idirafter") || !strcmp (STR, "iprefix") \   || !strcmp (STR, "iwithprefix") || !strcmp (STR, "iwithprefixbefore") \   || !strcmp (STR, "isystem"))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|WORD_SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
value|DEFAULT_WORD_SWITCH_TAKES_ARG (STR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Record the mapping from file suffixes for compilation specs.  */
end_comment

begin_struct
struct|struct
name|compiler
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* Use this compiler for input files 				   whose names end in this suffix.  */
name|char
modifier|*
name|spec
index|[
literal|4
index|]
decl_stmt|;
comment|/* To use this compiler, concatenate these 				   specs and pass to do_spec.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Pointer to a vector of `struct compiler' that gives the spec for    compiling a file, based on its suffix.    A file that does not end in any of these suffixes will be passed    unchanged to the loader and nothing else will be done to it.     An entry containing two 0s is used to terminate the vector.     If multiple entries match a file, the last matching one is used.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|compiler
modifier|*
name|compilers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in `compilers', not counting the null terminator.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_compilers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default list of file name suffixes and their compilation specs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|compiler
name|default_compilers
index|[]
init|=
block|{
block|{
literal|".c"
block|,
literal|"@c"
block|}
block|,
block|{
literal|"@c"
block|,
literal|"cpp -lang-c%{ansi:89} %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %I\ 	%{C:%{!E:%eGNU C does not support -C without using -E}}\ 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\         -undef -D__GNUC__=%v1 -D__GNUC_MINOR__=%v2\ 	%{ansi:-trigraphs -$ -D__STRICT_ANSI__}\ 	%{!undef:%{!ansi:%p} %P} %{trigraphs} \         %c %{O*:%{!O0:-D__OPTIMIZE__}} %{traditional} %{ftraditional:-traditional}\         %{traditional-cpp:-traditional}\ 	%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\         %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\n"
block|,
literal|"%{!M:%{!MM:%{!E:cc1 %{!pipe:%g.i} %1 \ 		   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*} %{a}\ 		   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} \ 		   %{traditional} %{v:-version} %{pg:-p} %{p} %{f*}\ 		   %{aux-info*}\ 		   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\ 		   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\n\               %{!S:as %a %Y\ 		      %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\                       %{!pipe:%g.s} %A\n }}}}"
block|}
block|,
block|{
literal|"-"
block|,
literal|"%{E:cpp -lang-c%{ansi:89} %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %I\ 	%{C:%{!E:%eGNU C does not support -C without using -E}}\ 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\         -undef -D__GNUC__=%v1 -D__GNUC_MINOR__=%v2\ 	%{ansi:-trigraphs -$ -D__STRICT_ANSI__}\ 	%{!undef:%{!ansi:%p} %P} %{trigraphs}\         %c %{O*:%{!O0:-D__OPTIMIZE__}} %{traditional} %{ftraditional:-traditional}\         %{traditional-cpp:-traditional}\ 	%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\         %i %W{o*}}\     %{!E:%e-E required when input is from standard input}"
block|}
block|,
block|{
literal|".m"
block|,
literal|"@objective-c"
block|}
block|,
block|{
literal|"@objective-c"
block|,
literal|"cpp -lang-objc %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %I\ 	%{C:%{!E:%eGNU C does not support -C without using -E}}\ 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\         -undef -D__OBJC__ -D__GNUC__=%v1 -D__GNUC_MINOR__=%v2\ 	 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\ 	%{!undef:%{!ansi:%p} %P} %{trigraphs}\         %c %{O*:%{!O0:-D__OPTIMIZE__}} %{traditional} %{ftraditional:-traditional}\         %{traditional-cpp:-traditional}\ 	%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\         %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\n"
block|,
literal|"%{!M:%{!MM:%{!E:cc1obj %{!pipe:%g.i} %1 \ 		   %{!Q:-quiet} -dumpbase %b.m %{d*} %{m*} %{a}\ 		   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} \ 		   %{traditional} %{v:-version} %{pg:-p} %{p} %{f*} \     		   -lang-objc %{gen-decls} \ 		   %{aux-info*}\ 		   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\ 		   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\n\               %{!S:as %a %Y\ 		      %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\                       %{!pipe:%g.s} %A\n }}}}"
block|}
block|,
block|{
literal|".h"
block|,
literal|"@c-header"
block|}
block|,
block|{
literal|"@c-header"
block|,
literal|"%{!E:%eCompilation of header file requested} \     cpp %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %I\ 	%{C:%{!E:%eGNU C does not support -C without using -E}}\ 	 %{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\         -undef -D__GNUC__=%v1 -D__GNUC_MINOR__=%v2\ 	 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\ 	%{!undef:%{!ansi:%p} %P} %{trigraphs}\         %c %{O*:%{!O0:-D__OPTIMIZE__}} %{traditional} %{ftraditional:-traditional}\         %{traditional-cpp:-traditional}\ 	%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\         %i %W{o*}"
block|}
block|,
block|{
literal|".i"
block|,
literal|"@cpp-output"
block|}
block|,
block|{
literal|"@cpp-output"
block|,
literal|"%{!M:%{!MM:%{!E:cc1 %i %1 %{!Q:-quiet} %{d*} %{m*} %{a}\ 			%{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\ 			%{traditional} %{v:-version} %{pg:-p} %{p} %{f*}\ 			%{aux-info*}\ 			%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\ 			%{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\n\ 		     %{!S:as %a %Y\ 			     %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\ 			     %{!pipe:%g.s} %A\n }}}}"
block|}
block|,
block|{
literal|".s"
block|,
literal|"@assembler"
block|}
block|,
block|{
literal|"@assembler"
block|,
literal|"%{!M:%{!MM:%{!E:%{!S:as %a %Y\ 		            %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\ 			    %i %A\n }}}}"
block|}
block|,
block|{
literal|".S"
block|,
literal|"@assembler-with-cpp"
block|}
block|,
block|{
literal|"@assembler-with-cpp"
block|,
literal|"cpp -lang-asm %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %I\ 	%{C:%{!E:%eGNU C does not support -C without using -E}}\ 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG} %{trigraphs}\         -undef -$ %{!undef:%p %P} -D__ASSEMBLER__ \         %c %{O*:%{!O0:-D__OPTIMIZE__}} %{traditional} %{ftraditional:-traditional}\         %{traditional-cpp:-traditional}\ 	%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\         %i %{!M:%{!MM:%{!E:%{!pipe:%g.s}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\n"
block|,
literal|"%{!M:%{!MM:%{!E:%{!S:as %a %Y\                     %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\ 		    %{!pipe:%g.s} %A\n }}}}"
block|}
block|,
include|#
directive|include
file|"specs.h"
comment|/* Mark end of table */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in default_compilers, not counting the terminator.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_default_compilers
init|=
operator|(
sizeof|sizeof
name|default_compilers
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|compiler
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is the spec for running the linker, after compiling all files.  */
end_comment

begin_comment
comment|/* -u* was put back because both BSD and SysV seem to support it.  */
end_comment

begin_comment
comment|/* %{static:} simply prevents an error message if the target machine    doesn't handle -static.  */
end_comment

begin_comment
comment|/* We want %{T*} after %{L*} and %D so that it can be used to specify linker    scripts which exist in user specified directories, or in standard    directories.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LINK_LIBGCC_SPECIAL
end_ifdef

begin_comment
comment|/* Don't generate -L options.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|link_command_spec
init|=
literal|"\ %{!fsyntax-only: \  %{!c:%{!M:%{!MM:%{!E:%{!S:ld %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \ 			%{r} %{s} %{t} %{u*} %{x} %{z} %{Z}\ 			%{!A:%{!nostdlib:%{!nostartfiles:%S}}}\ 			%{static:} %{L*} %{T*} %o\ 			%{!nostdlib:%{!nodefaultlibs:%G %L %G}}\ 			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\n }}}}}}"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Use -L.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|link_command_spec
init|=
literal|"\ %{!fsyntax-only: \  %{!c:%{!M:%{!MM:%{!E:%{!S:ld %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \ 			%{r} %{s} %{t} %{u*} %{x} %{z} %{Z}\ 			%{!A:%{!nostdlib:%{!nostartfiles:%S}}}\ 			%{static:} %{L*} %D %{T*} %o\ 			%{!nostdlib:%{!nodefaultlibs:%G %L %G}}\ 			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\n }}}}}}"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A vector of options to give to the linker.    These options are accumulated by %x,    and substituted into the linker command with %X.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_linker_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|linker_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the assembler.    These options are accumulated by -Wa,    and substituted into the assembler command with %Y.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_assembler_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|assembler_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the preprocessor.    These options are accumulated by -Wp,    and substituted into the preprocessor command with %Z.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_preprocessor_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|preprocessor_options
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Define how to map long options into short ones.  */
end_comment

begin_comment
comment|/* This structure describes one mapping.  */
end_comment

begin_struct
struct|struct
name|option_map
block|{
comment|/* The long option's name.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent short option.  */
name|char
modifier|*
name|equivalent
decl_stmt|;
comment|/* Argument info.  A string of flag chars; NULL equals no options.      a => argument required.      o => argument optional.      j => join argument to equivalent, making one word.      * => require other text after NAME as an argument.  */
name|char
modifier|*
name|arg_info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the table of mappings.  Mappings are tried sequentially    for each option encountered; the first one that matches, wins.  */
end_comment

begin_decl_stmt
name|struct
name|option_map
name|option_map
index|[]
init|=
block|{
block|{
literal|"--all-warnings"
block|,
literal|"-Wall"
block|,
literal|0
block|}
block|,
block|{
literal|"--ansi"
block|,
literal|"-ansi"
block|,
literal|0
block|}
block|,
block|{
literal|"--assemble"
block|,
literal|"-S"
block|,
literal|0
block|}
block|,
block|{
literal|"--assert"
block|,
literal|"-A"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--comments"
block|,
literal|"-C"
block|,
literal|0
block|}
block|,
block|{
literal|"--compile"
block|,
literal|"-c"
block|,
literal|0
block|}
block|,
block|{
literal|"--debug"
block|,
literal|"-g"
block|,
literal|"oj"
block|}
block|,
block|{
literal|"--define-macro"
block|,
literal|"-D"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--dependencies"
block|,
literal|"-M"
block|,
literal|0
block|}
block|,
block|{
literal|"--dump"
block|,
literal|"-d"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--dumpbase"
block|,
literal|"-dumpbase"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--entry"
block|,
literal|"-e"
block|,
literal|0
block|}
block|,
block|{
literal|"--extra-warnings"
block|,
literal|"-W"
block|,
literal|0
block|}
block|,
block|{
literal|"--for-assembler"
block|,
literal|"-Wa"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--for-linker"
block|,
literal|"-Xlinker"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--force-link"
block|,
literal|"-u"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--imacros"
block|,
literal|"-imacros"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include"
block|,
literal|"-include"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-barrier"
block|,
literal|"-I-"
block|,
literal|0
block|}
block|,
block|{
literal|"--include-directory"
block|,
literal|"-I"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-directory-after"
block|,
literal|"-idirafter"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-prefix"
block|,
literal|"-iprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix"
block|,
literal|"-iwithprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix-before"
block|,
literal|"-iwithprefixbefore"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix-after"
block|,
literal|"-iwithprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--language"
block|,
literal|"-x"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--library-directory"
block|,
literal|"-L"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--machine"
block|,
literal|"-m"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--machine-"
block|,
literal|"-m"
block|,
literal|"*j"
block|}
block|,
block|{
literal|"--no-line-commands"
block|,
literal|"-P"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-precompiled-includes"
block|,
literal|"-noprecomp"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-standard-includes"
block|,
literal|"-nostdinc"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-standard-libraries"
block|,
literal|"-nostdlib"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-warnings"
block|,
literal|"-w"
block|,
literal|0
block|}
block|,
block|{
literal|"--optimize"
block|,
literal|"-O"
block|,
literal|"oj"
block|}
block|,
block|{
literal|"--output"
block|,
literal|"-o"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--pedantic"
block|,
literal|"-pedantic"
block|,
literal|0
block|}
block|,
block|{
literal|"--pedantic-errors"
block|,
literal|"-pedantic-errors"
block|,
literal|0
block|}
block|,
block|{
literal|"--pipe"
block|,
literal|"-pipe"
block|,
literal|0
block|}
block|,
block|{
literal|"--prefix"
block|,
literal|"-B"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--preprocess"
block|,
literal|"-E"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-search-dirs"
block|,
literal|"-print-search-dirs"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-file-name"
block|,
literal|"-print-file-name="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--print-libgcc-file-name"
block|,
literal|"-print-libgcc-file-name"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-missing-file-dependencies"
block|,
literal|"-MG"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-multi-lib"
block|,
literal|"-print-multi-lib"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-multi-directory"
block|,
literal|"-print-multi-directory"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-prog-name"
block|,
literal|"-print-prog-name="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--profile"
block|,
literal|"-p"
block|,
literal|0
block|}
block|,
block|{
literal|"--profile-blocks"
block|,
literal|"-a"
block|,
literal|0
block|}
block|,
block|{
literal|"--quiet"
block|,
literal|"-q"
block|,
literal|0
block|}
block|,
block|{
literal|"--save-temps"
block|,
literal|"-save-temps"
block|,
literal|0
block|}
block|,
block|{
literal|"--shared"
block|,
literal|"-shared"
block|,
literal|0
block|}
block|,
block|{
literal|"--silent"
block|,
literal|"-q"
block|,
literal|0
block|}
block|,
block|{
literal|"--static"
block|,
literal|"-static"
block|,
literal|0
block|}
block|,
block|{
literal|"--symbolic"
block|,
literal|"-symbolic"
block|,
literal|0
block|}
block|,
block|{
literal|"--target"
block|,
literal|"-b"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--trace-includes"
block|,
literal|"-H"
block|,
literal|0
block|}
block|,
block|{
literal|"--traditional"
block|,
literal|"-traditional"
block|,
literal|0
block|}
block|,
block|{
literal|"--traditional-cpp"
block|,
literal|"-traditional-cpp"
block|,
literal|0
block|}
block|,
block|{
literal|"--trigraphs"
block|,
literal|"-trigraphs"
block|,
literal|0
block|}
block|,
block|{
literal|"--undefine-macro"
block|,
literal|"-U"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--use-version"
block|,
literal|"-V"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--user-dependencies"
block|,
literal|"-MM"
block|,
literal|0
block|}
block|,
block|{
literal|"--verbose"
block|,
literal|"-v"
block|,
literal|0
block|}
block|,
block|{
literal|"--version"
block|,
literal|"-dumpversion"
block|,
literal|0
block|}
block|,
block|{
literal|"--warn-"
block|,
literal|"-W"
block|,
literal|"*j"
block|}
block|,
block|{
literal|"--write-dependencies"
block|,
literal|"-MD"
block|,
literal|0
block|}
block|,
block|{
literal|"--write-user-dependencies"
block|,
literal|"-MMD"
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
literal|"-f"
block|,
literal|"*j"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Translate the options described by *ARGCP and *ARGVP.    Make a new vector and store it back in *ARGVP,    and store its length in *ARGVC.  */
end_comment

begin_function
specifier|static
name|void
name|translate_options
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|argc
init|=
operator|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
operator|*
name|argvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|newv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|argc
operator|+
literal|2
operator|)
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|newindex
init|=
literal|0
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|argc
condition|)
block|{
comment|/* Translate -- options.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* Find a mapping that applies to this option.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|option_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|option_map
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|optlen
init|=
name|strlen
argument_list|(
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|int
name|arglen
init|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|complen
init|=
name|arglen
operator|>
name|optlen
condition|?
name|optlen
else|:
name|arglen
decl_stmt|;
name|char
modifier|*
name|arginfo
init|=
name|option_map
index|[
name|j
index|]
operator|.
name|arg_info
decl_stmt|;
if|if
condition|(
name|arginfo
operator|==
literal|0
condition|)
name|arginfo
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|complen
argument_list|)
condition|)
block|{
name|char
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arglen
operator|<
name|optlen
condition|)
block|{
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
sizeof|sizeof
argument_list|(
name|option_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|option_map
index|[
literal|0
index|]
argument_list|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
name|option_map
index|[
name|k
index|]
operator|.
name|name
argument_list|)
operator|>=
name|arglen
operator|&&
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|option_map
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|arglen
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Ambiguous abbreviation %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|k
operator|!=
sizeof|sizeof
argument_list|(
name|option_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|option_map
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|arglen
operator|>
name|optlen
condition|)
block|{
comment|/* If the option has an argument, accept that.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|optlen
index|]
operator|==
literal|'='
condition|)
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|optlen
operator|+
literal|1
expr_stmt|;
comment|/* If this mapping requires extra text at end of name, 			 accept that as "argument".  */
elseif|else
if|if
condition|(
name|index
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|optlen
expr_stmt|;
comment|/* Otherwise, extra text at end means mismatch. 			 Try other mappings.  */
else|else
continue|continue;
block|}
elseif|else
if|if
condition|(
name|index
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Incomplete `%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Handle arguments.  */
if|if
condition|(
name|index
argument_list|(
name|arginfo
argument_list|,
literal|'a'
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"Missing argument to `%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|index
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|index
argument_list|(
name|arginfo
argument_list|,
literal|'o'
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Extraneous argument to `%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Store the translation as one argv elt or as two.  */
if|if
condition|(
name|arg
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|arginfo
argument_list|,
literal|'j'
argument_list|)
operator|!=
literal|0
condition|)
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|concat
argument_list|(
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
literal|0
condition|)
block|{
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
expr_stmt|;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
else|else
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* Handle old-fashioned options--just copy them through, 	 with their arguments.  */
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
name|int
name|nskip
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
name|nskip
operator|+=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|nskip
operator|+=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
literal|'V'
operator|||
name|c
operator|==
literal|'x'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"Xlinker"
argument_list|)
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
comment|/* Watch out for an option at the end of the command line that 	     is missing arguments, and avoid skipping past the end of the 	     command line.  */
if|if
condition|(
name|nskip
operator|+
name|i
operator|>
name|argc
condition|)
name|nskip
operator|=
name|argc
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|nskip
operator|>
literal|0
condition|)
block|{
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
name|nskip
operator|--
expr_stmt|;
block|}
block|}
else|else
comment|/* Ordinary operands, or +e options.  */
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
name|newv
index|[
name|newindex
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|argvp
operator|=
name|newv
expr_stmt|;
operator|*
name|argcp
operator|=
name|newindex
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|my_strerror
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_STRERROR
return|return
name|strerror
argument_list|(
name|e
argument_list|)
return|;
else|#
directive|else
specifier|static
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|e
operator|>
literal|0
operator|&&
name|e
operator|<
name|sys_nerr
condition|)
return|return
name|sys_errlist
index|[
name|e
index|]
return|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Unknown error %d"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read compilation specs from a file named FILENAME,    replacing the default ones.     A suffix which starts with `*' is a definition for    one of the machine-specific sub-specs.  The "suffix" should be    *asm, *cc1, *cpp, *link, *startfile, *signed_char, etc.    The corresponding spec is stored in asm_spec, etc.,    rather than in the `compilers' vector.     Anything invalid in the file is a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|read_specs
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|desc
decl_stmt|;
name|int
name|readlen
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reading specs from %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Open and stat the file.  */
name|desc
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Read contents of file into BUFFER.  */
name|buffer
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|readlen
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|statbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|buffer
index|[
name|readlen
index|]
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/* Scan BUFFER for specs, putting them in the vector.  */
name|p
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|spec
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
comment|/* Advance P in BUFFER to the next nonblank nocomment line.  */
name|p
operator|=
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
comment|/* Find the colon that should end the suffix.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|':'
operator|&&
operator|*
name|p1
operator|!=
literal|'\n'
condition|)
name|p1
operator|++
expr_stmt|;
comment|/* The colon shouldn't be missing.  */
if|if
condition|(
operator|*
name|p1
operator|!=
literal|':'
condition|)
name|fatal
argument_list|(
literal|"specs file malformed after %d characters"
argument_list|,
name|p1
operator|-
name|buffer
argument_list|)
expr_stmt|;
comment|/* Skip back over trailing whitespace.  */
name|p2
operator|=
name|p1
expr_stmt|;
while|while
condition|(
name|p2
operator|>
name|buffer
operator|&&
operator|(
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p2
operator|--
expr_stmt|;
comment|/* Copy the suffix to a string.  */
name|suffix
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|p2
operator|-
name|p
argument_list|)
expr_stmt|;
comment|/* Find the next line.  */
name|p
operator|=
name|skip_whitespace
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"specs file malformed after %d characters"
argument_list|,
name|p
operator|-
name|buffer
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
comment|/* Find next blank line.  */
while|while
condition|(
operator|*
name|p1
operator|&&
operator|!
operator|(
operator|*
name|p1
operator|==
literal|'\n'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
name|p1
operator|++
expr_stmt|;
comment|/* Specs end at the blank line and do not include the newline.  */
name|spec
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
comment|/* Delete backslash-newline sequences from the spec.  */
name|in
operator|=
name|spec
expr_stmt|;
name|out
operator|=
name|spec
expr_stmt|;
while|while
condition|(
operator|*
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|in
operator|&&
operator|*
name|in
operator|!=
literal|'\n'
condition|)
name|in
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|suffix
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
literal|"*link_command"
argument_list|)
condition|)
name|link_command_spec
operator|=
name|spec
expr_stmt|;
else|else
name|set_spec
argument_list|(
name|suffix
operator|+
literal|1
argument_list|,
name|spec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add this pair to the vector.  */
name|compilers
operator|=
operator|(
operator|(
expr|struct
name|compiler
operator|*
operator|)
name|xrealloc
argument_list|(
name|compilers
argument_list|,
operator|(
name|n_compilers
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|compiler
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|suffix
operator|=
name|suffix
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|spec
argument_list|,
sizeof|sizeof
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|spec
argument_list|)
expr_stmt|;
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|spec
index|[
literal|0
index|]
operator|=
name|spec
expr_stmt|;
name|n_compilers
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|compilers
index|[
name|n_compilers
index|]
argument_list|,
sizeof|sizeof
name|compilers
index|[
name|n_compilers
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|suffix
operator|==
literal|0
condition|)
name|link_command_spec
operator|=
name|spec
expr_stmt|;
block|}
if|if
condition|(
name|link_command_spec
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"spec file has no spec for linking"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|skip_whitespace
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* A fully-blank line is a delimiter in the SPEC file and shouldn't 	 be considered whitespace.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
return|return
name|p
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure to keep track of the specs that have been defined so far.  These    are accessed using %(specname) or %[specname] in a compiler or link spec. */
end_comment

begin_struct
struct|struct
name|spec_list
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of the spec. */
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* The spec itself. */
name|struct
name|spec_list
modifier|*
name|next
decl_stmt|;
comment|/* Next spec in linked list. */
block|}
struct|;
end_struct

begin_comment
comment|/* List of specs that have been defined so far. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spec_list
modifier|*
name|specs
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is    removed; If the spec starts with a + then SPEC is added to the end of the    current spec. */
end_comment

begin_function
specifier|static
name|void
name|set_spec
parameter_list|(
name|name
parameter_list|,
name|spec
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|spec
decl_stmt|;
block|{
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
name|char
modifier|*
name|old_spec
decl_stmt|;
comment|/* See if the spec already exists */
for|for
control|(
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|sl
condition|)
block|{
comment|/* Not found - make it */
name|sl
operator|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_list
argument_list|)
argument_list|)
expr_stmt|;
name|sl
operator|->
name|name
operator|=
name|save_string
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sl
operator|->
name|spec
operator|=
name|save_string
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|specs
expr_stmt|;
name|specs
operator|=
name|sl
expr_stmt|;
block|}
name|old_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|spec
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|isspace
argument_list|(
name|spec
index|[
literal|1
index|]
argument_list|)
condition|)
name|sl
operator|->
name|spec
operator|=
name|concat
argument_list|(
name|old_spec
argument_list|,
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sl
operator|->
name|spec
operator|=
name|save_string
argument_list|(
name|spec
argument_list|,
name|strlen
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"asm"
argument_list|)
condition|)
name|asm_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"asm_final"
argument_list|)
condition|)
name|asm_final_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"cc1"
argument_list|)
condition|)
name|cc1_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"cc1plus"
argument_list|)
condition|)
name|cc1plus_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"cpp"
argument_list|)
condition|)
name|cpp_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"endfile"
argument_list|)
condition|)
name|endfile_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"lib"
argument_list|)
condition|)
name|lib_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"libgcc"
argument_list|)
condition|)
name|libgcc_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"link"
argument_list|)
condition|)
name|link_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"predefines"
argument_list|)
condition|)
name|cpp_predefines
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed_char"
argument_list|)
condition|)
name|signed_char_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"startfile"
argument_list|)
condition|)
name|startfile_spec
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"switches_need_spaces"
argument_list|)
condition|)
name|switches_need_spaces
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"cross_compile"
argument_list|)
condition|)
name|cross_compile
operator|=
name|atoi
argument_list|(
name|sl
operator|->
name|spec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"multilib"
argument_list|)
condition|)
name|multilib_select
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
comment|/* Free the old spec */
if|if
condition|(
name|old_spec
condition|)
name|free
argument_list|(
name|old_spec
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Accumulate a command (program name and args), and run it.  */
end_comment

begin_comment
comment|/* Vector of pointers to arguments in the current line of specifications.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated in argbuf.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argbuf_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in argbuf currently in use (containing args).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argbuf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the list of suffixes and codes (%g/%u/%U) and the associated    temp file.  Used only if MKTEMP_EACH_FILE.  */
end_comment

begin_struct
specifier|static
struct|struct
name|temp_name
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* suffix associated with the code.  */
name|int
name|length
decl_stmt|;
comment|/* strlen (suffix).  */
name|int
name|unique
decl_stmt|;
comment|/* Indicates whether %g or %u/%U was used.  */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* associated filename.  */
name|int
name|filename_length
decl_stmt|;
comment|/* strlen (filename).  */
name|struct
name|temp_name
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|temp_names
struct|;
end_struct

begin_comment
comment|/* Number of commands executed so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|execution_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of commands that exited with a signal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|signal_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name with which this program was invoked.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|programname
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Structures to keep track of prefixes to try when looking for files. */
end_comment

begin_struct
struct|struct
name|prefix_list
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* String to prepend to the path. */
name|struct
name|prefix_list
modifier|*
name|next
decl_stmt|;
comment|/* Next in linked list. */
name|int
name|require_machine_suffix
decl_stmt|;
comment|/* Don't use without machine_suffix.  */
comment|/* 2 means try both machine_suffix and just_machine_suffix.  */
name|int
modifier|*
name|used_flag_ptr
decl_stmt|;
comment|/* 1 if a file was found with this prefix.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|path_prefix
block|{
name|struct
name|prefix_list
modifier|*
name|plist
decl_stmt|;
comment|/* List of prefixes to try */
name|int
name|max_len
decl_stmt|;
comment|/* Max length of a prefix in PLIST */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of this list (used in config stuff) */
block|}
struct|;
end_struct

begin_comment
comment|/* List of prefixes to try when looking for executables. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|exec_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"exec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of prefixes to try when looking for startup (crt0) files. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|startfile_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"startfile"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of prefixes to try when looking for include files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|include_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"include"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suffix to attach to directories searched for commands.    This looks like `MACHINE/VERSION/'.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|machine_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suffix to attach to directories searched for commands.    This is just `MACHINE/'.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|just_machine_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjusted value of GCC_EXEC_PREFIX envvar.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gcc_exec_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default prefixes to attach to command names.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_comment
comment|/* Don't use these prefixes for a cross compiler.  */
end_comment

begin_undef
undef|#
directive|undef
name|MD_EXEC_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|MD_STARTFILE_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|MD_STARTFILE_PREFIX_1
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_EXEC_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_EXEC_PREFIX
value|"/usr/local/lib/gcc-lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined STANDARD_EXEC_PREFIX */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|standard_exec_prefix
init|=
name|STANDARD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|standard_exec_prefix_1
init|=
literal|"/usr/lib/gcc/"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MD_EXEC_PREFIX
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|md_exec_prefix
init|=
name|MD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_STARTFILE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_STARTFILE_PREFIX
value|"/usr/local/lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined STANDARD_STARTFILE_PREFIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MD_STARTFILE_PREFIX
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|md_startfile_prefix
init|=
name|MD_STARTFILE_PREFIX
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MD_STARTFILE_PREFIX_1
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|md_startfile_prefix_1
init|=
name|MD_STARTFILE_PREFIX_1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|standard_startfile_prefix
init|=
name|STANDARD_STARTFILE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|standard_startfile_prefix_1
init|=
literal|"/lib/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|standard_startfile_prefix_2
init|=
literal|"/usr/lib/"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TOOLDIR_BASE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|TOOLDIR_BASE_PREFIX
value|"/usr/local/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tooldir_base_prefix
init|=
name|TOOLDIR_BASE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tooldir_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subdirectory to use for locating libraries.  Set by    set_multilib_dir based on the compilation options.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|multilib_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear out the vector of arguments (after a command is executed).  */
end_comment

begin_function
specifier|static
name|void
name|clear_args
parameter_list|()
block|{
name|argbuf_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add one argument to the vector at the end.    This is done when a space is seen or at the end of the line.    If DELETE_ALWAYS is nonzero, the arg is a filename     and the file should be deleted eventually.    If DELETE_FAILURE is nonzero, the arg is a filename     and the file should be deleted if this compilation fails.  */
end_comment

begin_function
specifier|static
name|void
name|store_arg
parameter_list|(
name|arg
parameter_list|,
name|delete_always
parameter_list|,
name|delete_failure
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|delete_always
decl_stmt|,
name|delete_failure
decl_stmt|;
block|{
if|if
condition|(
name|argbuf_index
operator|+
literal|1
operator|==
name|argbuf_length
condition|)
block|{
name|argbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|argbuf
argument_list|,
operator|(
name|argbuf_length
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argbuf
index|[
name|argbuf_index
operator|++
index|]
operator|=
name|arg
expr_stmt|;
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delete_always
operator|||
name|delete_failure
condition|)
name|record_temp_file
argument_list|(
name|arg
argument_list|,
name|delete_always
argument_list|,
name|delete_failure
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the names of temporary files we tell compilers to write,    and delete them at the end of the run.  */
end_comment

begin_comment
comment|/* This is the common prefix we use to make temp file names.    It is chosen once for each run of this program.    It is substituted into a spec by %g.    Thus, all temp file names contain this prefix.    In practice, all temp file names start with this prefix.     This prefix comes from the envvar TMPDIR if it is defined;    otherwise, from the P_tmpdir macro if that is defined;    otherwise, in /usr/tmp or /tmp.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the prefix.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|temp_filename_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the list of temporary files to delete.  */
end_comment

begin_struct
struct|struct
name|temp_file
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|temp_file
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Queue of files to delete on success or failure of compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|temp_file
modifier|*
name|always_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of files to delete on failure of compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|temp_file
modifier|*
name|failure_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record FILENAME as a file to be deleted automatically.    ALWAYS_DELETE nonzero means delete it if all compilation succeeds;    otherwise delete it in any case.    FAIL_DELETE nonzero means delete it if a compilation step fails;    otherwise delete it in any case.  */
end_comment

begin_function
specifier|static
name|void
name|record_temp_file
parameter_list|(
name|filename
parameter_list|,
name|always_delete
parameter_list|,
name|fail_delete
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|always_delete
decl_stmt|;
name|int
name|fail_delete
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|always_delete
condition|)
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already1
goto|;
name|temp
operator|=
operator|(
expr|struct
name|temp_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_file
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|always_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|always_delete_queue
operator|=
name|temp
expr_stmt|;
name|already1
label|:
empty_stmt|;
block|}
if|if
condition|(
name|fail_delete
condition|)
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already2
goto|;
name|temp
operator|=
operator|(
expr|struct
name|temp_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_file
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|failure_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|failure_delete_queue
operator|=
name|temp
expr_stmt|;
name|already2
label|:
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all the temporary files whose names we previously recorded.  */
end_comment

begin_function
specifier|static
name|void
name|delete_if_ordinary
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"Delete %s? (y or n) "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|'y'
operator|||
name|i
operator|==
literal|'Y'
condition|)
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|verbose_flag
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_temp_files
parameter_list|()
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
name|delete_if_ordinary
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|always_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files to be deleted on error.  */
end_comment

begin_function
specifier|static
name|void
name|delete_failure_queue
parameter_list|()
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
name|delete_if_ordinary
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_failure_queue
parameter_list|()
block|{
name|failure_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a string to use as the base of all temporary file names.    It is substituted for %g.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|choose_temp_base_try
parameter_list|(
name|try
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|try
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
block|{
name|char
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|base
condition|)
name|rv
operator|=
name|base
expr_stmt|;
elseif|else
if|if
condition|(
name|try
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|access
argument_list|(
name|try
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
else|else
name|rv
operator|=
name|try
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|choose_temp_base
parameter_list|()
block|{
name|char
modifier|*
name|base
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|P_tmpdir
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|P_tmpdir
argument_list|,
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|concat4
argument_list|(
name|dir_separator_str
argument_list|,
literal|"usr"
argument_list|,
name|dir_separator_str
argument_list|,
literal|"tmp"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|concat
argument_list|(
name|dir_separator_str
argument_list|,
literal|"tmp"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* If all else fails, use the current directory! */
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|base
operator|=
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|temp_filename
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
name|strlen
argument_list|(
name|concat
argument_list|(
name|dir_separator_str
argument_list|,
literal|"ccXXXXXX"
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|temp_filename
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|temp_filename
index|[
name|len
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
name|temp_filename
index|[
name|len
operator|++
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
operator|+
name|len
argument_list|,
literal|"ccXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|temp_filename_length
operator|=
name|strlen
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_filename_length
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to add variables to the environment.  We do this to pass    the pathname of the gcc driver, and the directories search to the    collect2 program, which is being run as ld.  This way, we can be    sure of executing the right compiler when collect2 wants to build    constructors and destructors.  Since the environment variables we    use come from an obstack, we don't have to worry about allocating    space for them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PUTENV
end_ifndef

begin_function
name|void
name|putenv
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|VMS
comment|/* nor about VMS */
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_environ
init|=
name|environ
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|num_envs
init|=
literal|0
decl_stmt|;
name|int
name|name_len
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'='
condition|)
name|name_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ch
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Search for replacing an existing environment variable, and      count the number of total environment variables.  */
for|for
control|(
name|envp
operator|=
name|old_environ
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
block|{
name|num_envs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
operator|*
name|envp
argument_list|,
name|name_len
argument_list|)
condition|)
block|{
operator|*
name|envp
operator|=
name|str
expr_stmt|;
return|return;
block|}
block|}
comment|/* Add a new environment variable */
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_envs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
operator|*
name|environ
operator|=
name|str
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old_environ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|environ
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_envs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PUTENV */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Build a list of search directories from PATHS.    PREFIX is a string to prepend to the list.    If CHECK_DIR_P is non-zero we ensure the directory exists.    This is used mostly by putenv_from_prefixes so we use `collect_obstack'.    It is also used by the --print-search-dirs flag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_search_list
parameter_list|(
name|paths
parameter_list|,
name|prefix
parameter_list|,
name|check_dir_p
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|paths
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|check_dir_p
decl_stmt|;
block|{
name|int
name|suffix_len
init|=
operator|(
name|machine_suffix
operator|)
condition|?
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|just_suffix_len
init|=
operator|(
name|just_machine_suffix
operator|)
condition|?
name|strlen
argument_list|(
name|just_machine_suffix
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|first_time
init|=
name|TRUE
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pprefix
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pprefix
operator|=
name|paths
operator|->
name|plist
init|;
name|pprefix
operator|!=
literal|0
condition|;
name|pprefix
operator|=
name|pprefix
operator|->
name|next
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|pprefix
operator|->
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|machine_suffix
operator|&&
operator|(
operator|!
name|check_dir_p
operator|||
name|is_directory
argument_list|(
name|pprefix
operator|->
name|prefix
argument_list|,
name|machine_suffix
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|pprefix
operator|->
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|machine_suffix
argument_list|,
name|suffix_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|just_machine_suffix
operator|&&
name|pprefix
operator|->
name|require_machine_suffix
operator|==
literal|2
operator|&&
operator|(
operator|!
name|check_dir_p
operator|||
name|is_directory
argument_list|(
name|pprefix
operator|->
name|prefix
argument_list|,
name|just_machine_suffix
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|pprefix
operator|->
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|just_machine_suffix
argument_list|,
name|just_suffix_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pprefix
operator|->
name|require_machine_suffix
condition|)
block|{
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|pprefix
operator|->
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
operator|&
name|collect_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables for collect.  */
end_comment

begin_function
specifier|static
name|void
name|putenv_from_prefixes
parameter_list|(
name|paths
parameter_list|,
name|env_var
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|paths
decl_stmt|;
name|char
modifier|*
name|env_var
decl_stmt|;
block|{
name|putenv
argument_list|(
name|build_search_list
argument_list|(
name|paths
argument_list|,
name|env_var
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search for NAME using the prefix list PREFIXES.  MODE is passed to    access to check permissions.    Return 0 if not found, otherwise return its name, allocated with malloc. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
name|pprefix
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|file_suffix
init|=
operator|(
operator|(
name|mode
operator|&
name|X_OK
operator|)
operator|!=
literal|0
condition|?
name|EXECUTABLE_SUFFIX
else|:
literal|""
operator|)
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
name|int
name|len
init|=
name|pprefix
operator|->
name|max_len
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|file_suffix
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|machine_suffix
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Determine the filename to execute (special case for absolute paths).  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
operator|||
operator|*
name|name
operator|==
name|DIR_SEPARATOR
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
else|else
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
comment|/* Some systems have a suffix for executable files. 	       So try appending that first.  */
if|if
condition|(
name|file_suffix
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|file_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* Now try just the name.  */
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* Certain prefixes are tried with just the machine type, 	   not the version.  This is used for finding as, ld, etc.  */
if|if
condition|(
name|just_machine_suffix
operator|&&
name|pl
operator|->
name|require_machine_suffix
operator|==
literal|2
condition|)
block|{
comment|/* Some systems have a suffix for executable files. 	       So try appending that first.  */
if|if
condition|(
name|file_suffix
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|just_machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|file_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|just_machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* Certain prefixes can't be used without the machine suffix 	   when the machine or version is explicitly specified.  */
if|if
condition|(
operator|!
name|pl
operator|->
name|require_machine_suffix
condition|)
block|{
comment|/* Some systems have a suffix for executable files. 	       So try appending that first.  */
if|if
condition|(
name|file_suffix
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|file_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
condition|)
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry for PREFIX in PLIST.  If FIRST is set, it goes    at the start of the list, otherwise it goes at the end.     If WARN is nonzero, we will warn if no file is found    through this prefix.  WARN should point to an int    which will be set to 1 if this entry is used.     REQUIRE_MACHINE_SUFFIX is 1 if this prefix can't be used without    the complete value of machine_suffix.    2 means try both machine_suffix and just_machine_suffix.  */
end_comment

begin_function
specifier|static
name|void
name|add_prefix
parameter_list|(
name|pprefix
parameter_list|,
name|prefix
parameter_list|,
name|first
parameter_list|,
name|require_machine_suffix
parameter_list|,
name|warn
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|require_machine_suffix
decl_stmt|;
name|int
modifier|*
name|warn
decl_stmt|;
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
name|pprefix
operator|->
name|plist
condition|)
block|{
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
operator|->
name|next
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
empty_stmt|;
name|prev
operator|=
operator|&
name|pl
operator|->
name|next
expr_stmt|;
block|}
else|else
name|prev
operator|=
operator|&
name|pprefix
operator|->
name|plist
expr_stmt|;
comment|/* Keep track of the longest prefix */
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pprefix
operator|->
name|max_len
condition|)
name|pprefix
operator|->
name|max_len
operator|=
name|len
expr_stmt|;
name|pl
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|prefix_list
argument_list|)
argument_list|)
expr_stmt|;
name|pl
operator|->
name|prefix
operator|=
name|save_string
argument_list|(
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pl
operator|->
name|require_machine_suffix
operator|=
name|require_machine_suffix
expr_stmt|;
name|pl
operator|->
name|used_flag_ptr
operator|=
name|warn
expr_stmt|;
if|if
condition|(
name|warn
condition|)
operator|*
name|warn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|prev
condition|)
name|pl
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
else|else
name|pl
operator|->
name|next
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|prev
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print warnings for any prefixes in the list PPREFIX that were not used.  */
end_comment

begin_function
specifier|static
name|void
name|unused_prefix_warnings
parameter_list|(
name|pprefix
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
block|{
name|struct
name|prefix_list
modifier|*
name|pl
init|=
name|pprefix
operator|->
name|plist
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|used_flag_ptr
operator|!=
literal|0
operator|&&
operator|!
operator|*
name|pl
operator|->
name|used_flag_ptr
condition|)
block|{
name|error
argument_list|(
literal|"file path prefix `%s' never used"
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
comment|/* Prevent duplicate warnings.  */
operator|*
name|pl
operator|->
name|used_flag_ptr
operator|=
literal|1
expr_stmt|;
block|}
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get rid of all prefixes built up so far in *PLISTP. */
end_comment

begin_function
specifier|static
name|void
name|free_path_prefix
parameter_list|(
name|pprefix
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
block|{
name|struct
name|prefix_list
modifier|*
name|pl
init|=
name|pprefix
operator|->
name|plist
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|temp
operator|=
name|pl
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
name|pprefix
operator|->
name|plist
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* stdin file number.  */
end_comment

begin_define
define|#
directive|define
name|STDIN_FILE_NO
value|0
end_define

begin_comment
comment|/* stdout file number.  */
end_comment

begin_define
define|#
directive|define
name|STDOUT_FILE_NO
value|1
end_define

begin_comment
comment|/* value of `pipe': port index for reading.  */
end_comment

begin_define
define|#
directive|define
name|READ_PORT
value|0
end_define

begin_comment
comment|/* value of `pipe': port index for writing.  */
end_comment

begin_define
define|#
directive|define
name|WRITE_PORT
value|1
end_define

begin_comment
comment|/* Pipe waiting from last process, to be used as input for the next one.    Value is STDIN_FILE_NO if no pipe is waiting    (i.e. the next command is the first of a group).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_pipe_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fork one piped subcommand.  FUNC is the system call to use    (either execv or execvp).  ARGV is the arg vector to use.    NOT_LAST is nonzero if this is not the last subcommand    (i.e. its output should be piped to the next one.)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_function
specifier|static
name|int
name|pexecute
parameter_list|(
name|search_flag
parameter_list|,
name|program
parameter_list|,
name|argv
parameter_list|,
name|not_last
parameter_list|)
name|int
name|search_flag
decl_stmt|;
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|int
name|not_last
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__GO32__
name|int
name|i
init|=
operator|(
name|search_flag
condition|?
name|spawnv
else|:
name|spawnvp
operator|)
operator|(
literal|1
expr|,
name|program
expr|,
name|argv
operator|)
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|scmd
decl_stmt|,
modifier|*
name|rf
decl_stmt|;
name|FILE
modifier|*
name|argfile
decl_stmt|;
name|int
name|i
decl_stmt|,
name|el
init|=
name|search_flag
condition|?
literal|0
else|:
literal|4
decl_stmt|;
name|scmd
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|program
argument_list|)
operator|+
name|strlen
argument_list|(
name|temp_filename
argument_list|)
operator|+
literal|6
operator|+
name|el
argument_list|)
expr_stmt|;
name|rf
operator|=
name|scmd
operator|+
name|strlen
argument_list|(
name|program
argument_list|)
operator|+
literal|2
operator|+
name|el
expr_stmt|;
name|sprintf
argument_list|(
name|scmd
argument_list|,
literal|"%s%s @%s.gp"
argument_list|,
name|program
argument_list|,
operator|(
name|search_flag
condition|?
literal|""
else|:
literal|".exe"
operator|)
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|argfile
operator|=
name|fopen
argument_list|(
name|rf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argfile
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|rf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|'\''
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|argfile
argument_list|)
expr_stmt|;
name|i
operator|=
name|system
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|rf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_exec
argument_list|(
name|program
argument_list|)
expr_stmt|;
return|return
name|MIN_FATAL_STATUS
operator|<<
literal|8
return|;
block|}
return|return
name|i
operator|<<
literal|8
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_function
specifier|static
name|int
name|pexecute
parameter_list|(
name|search_flag
parameter_list|,
name|program
parameter_list|,
name|argv
parameter_list|,
name|not_last
parameter_list|)
name|int
name|search_flag
decl_stmt|;
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|int
name|not_last
decl_stmt|;
block|{
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
init|=
operator|(
name|search_flag
condition|?
name|execv
operator|:
name|execvp
init|)
function_decl|;
name|int
name|pid
decl_stmt|;
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|input_desc
init|=
name|last_pipe_input
decl_stmt|;
name|int
name|output_desc
init|=
name|STDOUT_FILE_NO
decl_stmt|;
name|int
name|retries
decl_stmt|,
name|sleep_interval
decl_stmt|;
comment|/* If this isn't the last process, make a pipe for its output,      and record it as waiting to be the input to the next process.  */
if|if
condition|(
name|not_last
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pdes
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|output_desc
operator|=
name|pdes
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|last_pipe_input
operator|=
name|pdes
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
else|else
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
comment|/* Fork a subprocess; wait and retry if it fails.  */
name|sleep_interval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|retries
operator|=
literal|0
init|;
name|retries
operator|<
literal|4
condition|;
name|retries
operator|++
control|)
block|{
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|>=
literal|0
condition|)
break|break;
name|sleep
argument_list|(
name|sleep_interval
argument_list|)
expr_stmt|;
name|sleep_interval
operator|*=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
ifdef|#
directive|ifdef
name|vfork
name|pfatal_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
else|#
directive|else
name|pfatal_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTREACHED */
return|return
literal|0
return|;
case|case
literal|0
case|:
comment|/* child */
comment|/* Move the input and output pipes into place, if nec.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
block|}
comment|/* Close the parent's descs that aren't wanted here.  */
if|if
condition|(
name|last_pipe_input
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|last_pipe_input
argument_list|)
expr_stmt|;
comment|/* Exec the program.  */
call|(
modifier|*
name|func
call|)
argument_list|(
name|program
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|perror_exec
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
default|default:
comment|/* In the parent, after forking. 	 Close the descriptors that we made for this child.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
comment|/* Return child's process number.  */
return|return
name|pid
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __MSDOS__ and not OS2 and not _WIN32 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OS2
argument_list|)
end_if

begin_function
specifier|static
name|int
name|pexecute
parameter_list|(
name|search_flag
parameter_list|,
name|program
parameter_list|,
name|argv
parameter_list|,
name|not_last
parameter_list|)
name|int
name|search_flag
decl_stmt|;
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|int
name|not_last
decl_stmt|;
block|{
return|return
operator|(
name|search_flag
condition|?
name|spawnv
else|:
name|spawnvp
operator|)
operator|(
literal|1
operator|,
name|program
operator|,
name|argv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_function
specifier|static
name|int
name|pexecute
parameter_list|(
name|search_flag
parameter_list|,
name|program
parameter_list|,
name|argv
parameter_list|,
name|not_last
parameter_list|)
name|int
name|search_flag
decl_stmt|;
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|int
name|not_last
decl_stmt|;
block|{
return|return
operator|(
name|search_flag
condition|?
name|__spawnv
else|:
name|__spawnvp
operator|)
operator|(
literal|1
operator|,
name|program
operator|,
name|argv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Execute the command specified by the arguments on the current line of spec.    When using pipes, this includes several piped-together commands    with `|' between them.     Return 0 if successful, -1 if failed.  */
end_comment

begin_function
specifier|static
name|int
name|execute
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_commands
decl_stmt|;
comment|/* # of command.  */
name|char
modifier|*
name|string
decl_stmt|;
struct|struct
name|command
block|{
name|char
modifier|*
name|prog
decl_stmt|;
comment|/* program name.  */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* vector of args.  */
name|int
name|pid
decl_stmt|;
comment|/* pid of process for this command.  */
block|}
struct|;
name|struct
name|command
modifier|*
name|commands
decl_stmt|;
comment|/* each command buffer with above info.  */
comment|/* Count # of piped commands.  */
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
name|n_commands
operator|++
expr_stmt|;
comment|/* Get storage for each command.  */
name|commands
operator|=
operator|(
expr|struct
name|command
operator|*
operator|)
name|alloca
argument_list|(
name|n_commands
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split argbuf into its separate piped processes,      and record info about each one.      Also search for the programs that are to be run.  */
name|commands
index|[
literal|0
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
comment|/* first command.  */
name|commands
index|[
literal|0
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|commands
index|[
literal|0
index|]
operator|.
name|prog
argument_list|,
name|X_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
literal|0
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* each command.  */
ifdef|#
directive|ifdef
name|__MSDOS__
name|fatal
argument_list|(
literal|"-pipe not supported under MS-DOS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* termination of command args.  */
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|string
operator|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
argument_list|,
name|X_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
name|n_commands
operator|++
expr_stmt|;
block|}
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If -v, print what we are about to do, and maybe query.  */
if|if
condition|(
name|verbose_flag
condition|)
block|{
comment|/* Print each piped command as a separate line.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
init|;
operator|*
name|j
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|j
argument_list|)
expr_stmt|;
comment|/* Print a pipe symbol after all but the last command.  */
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|n_commands
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" |"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nGo ahead? (y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'y'
operator|&&
name|i
operator|!=
literal|'Y'
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* Run each piped subprocess.  */
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|string
init|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|commands
index|[
name|i
index|]
operator|.
name|pid
operator|=
name|pexecute
argument_list|(
name|string
operator|!=
name|commands
index|[
name|i
index|]
operator|.
name|prog
argument_list|,
name|string
argument_list|,
name|commands
index|[
name|i
index|]
operator|.
name|argv
argument_list|,
name|i
operator|+
literal|1
operator|<
name|n_commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|commands
index|[
name|i
index|]
operator|.
name|prog
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|execution_count
operator|++
expr_stmt|;
comment|/* Wait for all the subprocesses to finish.      We don't care what order they finish in;      we know that N_COMMANDS waits will get them all.      Ignore subprocesses that we don't know about,      since they can be spawned by the process that exec'ed us.  */
block|{
name|int
name|ret_code
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
name|status
operator|=
name|pid
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|pid
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_WIN32
name|pid
operator|=
name|cwait
argument_list|(
operator|&
name|status
argument_list|,
name|commands
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
name|WAIT_CHILD
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_commands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|commands
index|[
name|j
index|]
operator|.
name|pid
operator|==
name|pid
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|fatal
argument_list|(
literal|"Internal compiler error: program %s got fatal signal %d"
argument_list|,
name|commands
index|[
name|j
index|]
operator|.
name|prog
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|signal_count
operator|++
expr_stmt|;
name|ret_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>=
name|MIN_FATAL_STATUS
condition|)
name|ret_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|ret_code
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the switches given to us    and make a vector describing them.    The elements of the vector are strings, one per switch given.    If a switch uses following arguments, then the `part1' field    is the switch itself and the `args' field    is a null-terminated vector containing the following arguments.    The `live_cond' field is 1 if the switch is true in a conditional spec,    -1 if false (overridden by a later switch), and is initialized to zero.    The `valid' field is nonzero if any spec has looked at this switch;    if it remains zero at the end of the run, it must be meaningless.  */
end_comment

begin_struct
struct|struct
name|switchstr
block|{
name|char
modifier|*
name|part1
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|live_cond
decl_stmt|;
name|int
name|valid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|switchstr
modifier|*
name|switches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_switches
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|infile
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|language
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|objformat_aout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Also a vector of input files specified.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|infile
modifier|*
name|infiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And a vector of corresponding output files is made up later.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|outfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create the vector `switches' and its contents.    Store its length in `n_switches'.  */
end_comment

begin_function
specifier|static
name|void
name|process_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|spec_lang
init|=
literal|0
decl_stmt|;
name|int
name|last_language_n_infiles
decl_stmt|;
name|gcc_exec_prefix
operator|=
name|getenv
argument_list|(
literal|"GCC_EXEC_PREFIX"
argument_list|)
expr_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
comment|/* Figure compiler version from version string.  */
name|compiler_version
operator|=
name|save_string
argument_list|(
name|version_string
argument_list|,
name|strlen
argument_list|(
name|version_string
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|compiler_version
init|;
operator|*
name|temp
condition|;
operator|++
name|temp
control|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
literal|' '
condition|)
block|{
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* Set up the default search paths.  */
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|gcc_exec_prefix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|gcc_exec_prefix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
comment|/* COMPILER_PATH and LIBRARY_PATH have values      that are lists of directory names with colons.  */
name|temp
operator|=
name|getenv
argument_list|(
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|nstore
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|getenv
argument_list|(
literal|"LIBRARY_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|!
name|cross_compile
condition|)
block|{
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|nstore
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Use LPATH like LIBRARY_PATH (for the CMU build program).  */
name|temp
operator|=
name|getenv
argument_list|(
literal|"LPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|!
name|cross_compile
condition|)
block|{
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|nstore
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
block|{
comment|/* first hint is /etc/objformat */
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
literal|"/etc/objformat"
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|buf
index|[
literal|1023
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"OBJFORMAT=aout"
argument_list|)
operator|==
literal|0
condition|)
name|objformat_aout
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"OBJFORMAT=elf"
argument_list|)
operator|==
literal|0
condition|)
name|objformat_aout
operator|=
literal|0
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized line in /etc/objformat: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* but the user $OBJFORMAT overrides system default */
name|temp
operator|=
name|getenv
argument_list|(
literal|"OBJFORMAT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"aout"
argument_list|)
operator|==
literal|0
condition|)
name|objformat_aout
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"elf"
argument_list|)
operator|==
literal|0
condition|)
name|objformat_aout
operator|=
literal|0
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized value of $OBJFORMAT: %s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Convert new-style -- options to old-style.  */
name|translate_options
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* Scan argv twice.  Here, the first time, just count how many switches      there will be in their vector, and how many input files in theirs.      Here we also parse the switches that cc itself uses (e.g. -v).  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
comment|/* .. and command line args override all */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-aout"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|objformat_aout
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-elf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|objformat_aout
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpspecs"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"*asm:\n%s\n\n"
argument_list|,
name|asm_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*asm_final:\n%s\n\n"
argument_list|,
name|asm_final_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*cpp:\n%s\n\n"
argument_list|,
name|cpp_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*cc1:\n%s\n\n"
argument_list|,
name|cc1_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*cc1plus:\n%s\n\n"
argument_list|,
name|cc1plus_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*endfile:\n%s\n\n"
argument_list|,
name|endfile_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*link:\n%s\n\n"
argument_list|,
name|link_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*lib:\n%s\n\n"
argument_list|,
name|lib_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*libgcc:\n%s\n\n"
argument_list|,
name|libgcc_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*startfile:\n%s\n\n"
argument_list|,
name|startfile_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*switches_need_spaces:\n%s\n\n"
argument_list|,
name|switches_need_spaces
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*signed_char:\n%s\n\n"
argument_list|,
name|signed_char_spec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*predefines:\n%s\n\n"
argument_list|,
name|cpp_predefines
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*cross_compile:\n%d\n\n"
argument_list|,
name|cross_compile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*multilib:\n%s\n\n"
argument_list|,
name|multilib_select
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpversion"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpmachine"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|spec_machine
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-search-dirs"
argument_list|)
condition|)
name|print_search_dirs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-libgcc-file-name"
argument_list|)
condition|)
name|print_file_name
operator|=
literal|"libgcc.a"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-file-name="
argument_list|,
literal|17
argument_list|)
condition|)
name|print_file_name
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-prog-name="
argument_list|,
literal|17
argument_list|)
condition|)
name|print_prog_name
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-lib"
argument_list|)
condition|)
name|print_multi_lib
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-directory"
argument_list|)
condition|)
name|print_multi_directory
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wa,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Pass the rest of this option to the assembler.  */
name|n_assembler_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|assembler_options
condition|)
name|assembler_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_assembler_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assembler_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|assembler_options
argument_list|,
name|n_assembler_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|assembler_options
index|[
name|n_assembler_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|n_assembler_options
operator|++
expr_stmt|;
name|assembler_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|assembler_options
argument_list|,
name|n_assembler_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|assembler_options
index|[
name|n_assembler_options
operator|-
literal|1
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wp,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Pass the rest of this option to the preprocessor.  */
name|n_preprocessor_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|preprocessor_options
condition|)
name|preprocessor_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_preprocessor_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|preprocessor_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|preprocessor_options
argument_list|,
name|n_preprocessor_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|preprocessor_options
index|[
name|n_preprocessor_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|n_preprocessor_options
operator|++
expr_stmt|;
name|preprocessor_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|preprocessor_options
argument_list|,
name|n_preprocessor_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|preprocessor_options
index|[
name|n_preprocessor_options
operator|-
literal|1
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
comment|/* The +e options to the C++ front-end.  */
name|n_switches
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wl,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Split the argument at commas.  */
for|for
control|(
name|j
operator|=
literal|3
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|n_infiles
operator|+=
operator|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xlinker"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-Xlinker' is missing"
argument_list|)
expr_stmt|;
name|n_infiles
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|n_infiles
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-b' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|spec_machine
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|spec_machine
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
block|{
name|int
modifier|*
name|temp
init|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-B' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|value
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|value
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|value
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|value
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|concat
argument_list|(
name|value
argument_list|,
literal|"include"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* As a kludge, if the arg is "[foo/]stageN/", just add 		   "[foo/]include" to the include prefix.  */
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|7
operator|||
operator|(
name|len
operator|>
literal|7
operator|&&
operator|(
name|value
index|[
name|len
operator|-
literal|8
index|]
operator|==
literal|'/'
operator|||
name|value
index|[
name|len
operator|-
literal|8
index|]
operator|==
name|DIR_SEPARATOR
operator|)
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|value
operator|+
name|len
operator|-
literal|7
argument_list|,
literal|"stage"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|value
index|[
name|len
operator|-
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|value
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|value
index|[
name|len
operator|-
literal|1
index|]
operator|==
name|DIR_SEPARATOR
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|7
condition|)
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
literal|"include"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|string
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|string
argument_list|,
name|value
argument_list|,
name|len
operator|-
literal|7
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"include"
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|string
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* Print our subcommands and print versions.  */
name|n_switches
operator|++
expr_stmt|;
comment|/* If they do anything other than exactly `-v', don't set 		 verbose_flag; rather, continue on to give the error.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
break|break;
name|verbose_flag
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-V' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|spec_version
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|spec_version
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|compiler_version
operator|=
name|spec_version
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"save-temps"
argument_list|)
condition|)
block|{
name|save_temps_flag
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
break|break;
block|}
default|default:
name|n_switches
operator|++
expr_stmt|;
if|if
condition|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
name|i
operator|+=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|i
operator|+=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|n_infiles
operator|++
expr_stmt|;
block|}
comment|/* Set up the search paths before we go looking for config files.  */
comment|/* These come before the md prefixes so that we will find gcc's subcommands      (such as cpp) rather than those of the host system.  */
comment|/* Use 2 as fourth arg meaning try just the machine as a suffix,      as well as trying the machine and the version.  */
ifdef|#
directive|ifdef
name|FREEBSD_NATIVE
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
name|objformat_aout
condition|)
block|{
name|n_switches
operator|++
expr_stmt|;
comment|/* add implied -maout */
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"/usr/libexec/aout/"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
else|else
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"/usr/libexec/elf/"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"/usr/libexec/"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"/usr/bin/"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|"/usr/libdata/gcc/"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not FREEBSD_NATIVE */
ifndef|#
directive|ifndef
name|OS2
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix_1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_exec_prefix
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_exec_prefix_1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
name|tooldir_prefix
operator|=
name|concat3
argument_list|(
name|tooldir_base_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|)
expr_stmt|;
comment|/* If tooldir is relative, base it on exec_prefixes.  A relative      tooldir lets us move the installed tree as a unit.       If GCC_EXEC_PREFIX is defined, then we want to add two relative      directories, so that we can search both the user specified directory      and the standard place.  */
if|if
condition|(
operator|*
name|tooldir_prefix
operator|!=
literal|'/'
operator|&&
operator|*
name|tooldir_prefix
operator|!=
name|DIR_SEPARATOR
condition|)
block|{
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|char
modifier|*
name|gcc_exec_tooldir_prefix
init|=
name|concat6
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|tooldir_prefix
argument_list|)
decl_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|concat3
argument_list|(
name|gcc_exec_tooldir_prefix
argument_list|,
literal|"bin"
argument_list|,
name|dir_separator_str
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat3
argument_list|(
name|gcc_exec_tooldir_prefix
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|tooldir_prefix
operator|=
name|concat6
argument_list|(
name|standard_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|tooldir_prefix
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|concat3
argument_list|(
name|tooldir_prefix
argument_list|,
literal|"bin"
argument_list|,
name|dir_separator_str
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat3
argument_list|(
name|tooldir_prefix
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
comment|/* More prefixes are enabled in main, after we read the specs file      and determine whether this is cross-compilation or not.  */
comment|/* Then create the space for the vectors and scan again.  */
name|switches
operator|=
operator|(
operator|(
expr|struct
name|switchstr
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_switches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|switchstr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|infiles
operator|=
operator|(
expr|struct
name|infile
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_infiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
name|last_language_n_infiles
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This, time, copy the text of each switch and store a pointer      to the copy in the vector of switches.      Store all the infiles in their vector.  */
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
name|objformat_aout
operator|==
literal|1
condition|)
block|{
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|"maout"
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
name|putenv
argument_list|(
literal|"OBJFORMAT=aout"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putenv
argument_list|(
literal|"OBJFORMAT=elf"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* Just skip the switches that were handled by the preceding loop.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wa,"
argument_list|,
literal|4
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wp,"
argument_list|,
literal|4
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-search-dirs"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-libgcc-file-name"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-file-name="
argument_list|,
literal|17
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-prog-name="
argument_list|,
literal|17
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-lib"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-directory"
argument_list|)
condition|)
empty_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_NATIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-aout"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-elf"
argument_list|)
condition|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Compensate for the +e options to the C++ front-end; 	     they're there simply for cfront call-compatibility.  We do 	     some magic in default_compilers to pass them down properly. 	     Note we deliberately start at the `+' here, to avoid passing 	     -e0 or -e1 down into the linker.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wl,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|save_string
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xlinker"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
literal|'V'
condition|)
block|{
comment|/* Skip a separate arg, if any.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-x' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|spec_lang
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|spec_lang
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spec_lang
argument_list|,
literal|"none"
argument_list|)
condition|)
comment|/* Suppress the warning if -xnone comes after the last input 		   file, because alternate command interfaces like g++ might 		   find it useful to place -xnone after each input file.  */
name|spec_lang
operator|=
literal|0
expr_stmt|;
else|else
name|last_language_n_infiles
operator|=
name|n_infiles
expr_stmt|;
continue|continue;
block|}
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
name|p
expr_stmt|;
comment|/* Deal with option arguments in separate argv elements.  */
if|if
condition|(
operator|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|n_args
init|=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_args
operator|==
literal|0
condition|)
block|{
comment|/* Count only the option arguments in separate argv elements.  */
name|n_args
operator|=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
name|n_args
operator|>=
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to `-%s' is missing"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_args
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|n_args
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
comment|/* Null-terminate the vector.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|switches_need_spaces
operator|!=
literal|0
operator|&&
operator|(
name|c
operator|==
literal|'o'
operator|||
name|c
operator|==
literal|'L'
operator|)
condition|)
block|{
comment|/* On some systems, ld cannot handle -o or -L without space. 		 So split the -o or -L from its argument.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
operator|(
name|c
operator|==
literal|'o'
condition|?
literal|"o"
else|:
literal|"L"
operator|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
comment|/* This is always valid, since gcc.c itself understands it.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"save-temps"
argument_list|)
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_OBJECT_SUFFIX
comment|/* Convert x.o to x.obj if OBJECT_SUFFIX is ".obj".  */
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|>
literal|2
operator|&&
name|argv
index|[
name|i
index|]
index|[
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|argv
index|[
name|i
index|]
index|[
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|-
literal|2
condition|;
name|j
operator|++
control|)
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|OBJECT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
name|access
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|R_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
name|spec_lang
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|n_infiles
operator|==
name|last_language_n_infiles
operator|&&
name|spec_lang
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Warning: `-x %s' after last input file has no effect"
argument_list|,
name|spec_lang
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a spec string, accumulating and running commands.  */
end_comment

begin_comment
comment|/* These variables describe the input file name.    input_file_number is the index on outfiles of this file,    so that the output file name can be stored for later use by %o.    input_basename is the start of the part of the input file    sans all directory names, and basename_length is the number    of characters starting there excluding the suffix .c or whatever.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_file_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_filename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|basename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_basename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_suffix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are variables used within do_spec and do_spec_1.  */
end_comment

begin_comment
comment|/* Nonzero if an arg has been started and not yet terminated    (with space, tab or newline).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arg_going
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %d or %g has been seen; the next arg to be terminated    is a temporary file name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delete_this_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %w has been seen; the next arg to be terminated    is the output file name of this compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_is_output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %s has been seen; the next arg to be terminated    is the name of a library file and we should try the standard    search dirs for it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_is_library_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that the input of this command is coming from a pipe.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_from_pipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process the spec SPEC and run the commands specified therein.    Returns 0 if the spec is successfully processed; -1 if failed.  */
end_comment

begin_function
specifier|static
name|int
name|do_spec
parameter_list|(
name|spec
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
name|input_from_pipe
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Force out any unfinished command.      If -pipe, this forces out the last command if it ended in `|'.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
name|argbuf_index
operator|--
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
name|value
operator|=
name|execute
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Process the sub-spec SPEC as a portion of a larger spec.    This is like processing a whole spec except that we do    not initialize at the beginning and we do not supply a    newline by default at the end.    INSWITCH nonzero means don't process %-sequences in SPEC;    in this case, % is treated as an ordinary character.    This is used while substituting switches.    INSWITCH nonzero also causes SPC not to terminate an argument.     Value is zero unless a line was finished    and the command on that line reported an error.  */
end_comment

begin_function
specifier|static
name|int
name|do_spec_1
parameter_list|(
name|spec
parameter_list|,
name|inswitch
parameter_list|,
name|soft_matched_part
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|;
name|int
name|inswitch
decl_stmt|;
name|char
modifier|*
name|soft_matched_part
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|spec
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|value
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
comment|/* If substituting a switch, treat all chars like letters.        Otherwise, NL, SPC, TAB and % are special.  */
switch|switch
condition|(
name|inswitch
condition|?
literal|'a'
else|:
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* End of line: finish any pending argument, 	   then run the pending command if one has been started.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
name|arg_going
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
literal|"pipe"
argument_list|)
condition|)
break|break;
comment|/* A `|' before the newline means use a pipe here, 	       but only if -pipe was specified. 	       Otherwise, execute now and don't pass the `|' as an arg.  */
if|if
condition|(
name|i
operator|<
name|n_switches
condition|)
block|{
name|input_from_pipe
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|argbuf_index
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|execute
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
condition|)
return|return
name|value
return|;
block|}
comment|/* Reinitialize for a new command, and for a new argument.  */
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
name|input_from_pipe
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* End any pending argument.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Use pipe */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
comment|/* Space or tab ends an argument if one is pending.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Reinitialize for a new argument.  */
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|fatal
argument_list|(
literal|"Invalid specification!  Bug in cc."
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_basename
argument_list|,
name|basename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete_this_arg
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* Dump out the directories specified with LIBRARY_PATH, 	     followed by the absolute directories 	     that we search for startfiles.  */
case|case
literal|'D'
case|:
block|{
name|struct
name|prefix_list
modifier|*
name|pl
init|=
name|startfile_prefixes
operator|.
name|plist
decl_stmt|;
name|int
name|bufsize
init|=
literal|100
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|RELATIVE_PREFIX_NOT_LINKDIR
comment|/* Used on systems which record the specified -L dirs 		     and use them to search for dynamic linking.  */
comment|/* Relative directories always come from -B, 		     and it is better not to use them for searching 		     at run time.  In particular, stage1 loses  */
if|if
condition|(
name|pl
operator|->
name|prefix
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|pl
operator|->
name|prefix
index|[
literal|0
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Try subdirectory if there is one.  */
if|if
condition|(
name|multilib_dir
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|>=
name|bufsize
condition|)
name|bufsize
operator|=
operator|(
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_directory
argument_list|(
name|buffer
argument_list|,
name|multilib_dir
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_spec_1
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|multilib_dir
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pl
operator|->
name|require_machine_suffix
condition|)
block|{
if|if
condition|(
name|is_directory
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
name|multilib_dir
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_spec_1
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|multilib_dir
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|machine_suffix
condition|)
block|{
if|if
condition|(
name|is_directory
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
name|machine_suffix
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_spec_1
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Remove slash from machine_suffix.  */
if|if
condition|(
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|>=
name|bufsize
condition|)
name|bufsize
operator|=
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|idx
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|==
name|DIR_SEPARATOR
condition|)
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|do_spec_1
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pl
operator|->
name|require_machine_suffix
condition|)
block|{
if|if
condition|(
name|is_directory
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-L"
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE_AFTER_L_OPTION
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove slash from pl->prefix.  */
if|if
condition|(
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|>=
name|bufsize
condition|)
name|bufsize
operator|=
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|idx
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|==
name|DIR_SEPARATOR
condition|)
name|buffer
index|[
name|idx
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|do_spec_1
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* {...:%efoo} means report an error with `foo' as error message 	       and don't execute any more commands for this file.  */
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|q
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
literal|'g'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|save_temps_flag
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_basename
argument_list|,
name|basename_length
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MKTEMP_EACH_FILE
comment|/* ??? This has a problem: the total number of 		   values mktemp can return is limited. 		   That matters for the names of object files. 		   In 2.4, do something about that.  */
name|struct
name|temp_name
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|suffix
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'O'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* See if we already have an association of %g/%u/%U and 		   suffix.  */
for|for
control|(
name|t
operator|=
name|temp_names
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|length
operator|==
name|p
operator|-
name|suffix
operator|&&
name|strncmp
argument_list|(
name|t
operator|->
name|suffix
argument_list|,
name|suffix
argument_list|,
name|p
operator|-
name|suffix
argument_list|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|unique
operator|==
operator|(
name|c
operator|!=
literal|'g'
operator|)
condition|)
break|break;
comment|/* Make a new association if needed.  %u requires one.  */
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|c
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
operator|(
expr|struct
name|temp_name
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|temp_names
expr_stmt|;
name|temp_names
operator|=
name|t
expr_stmt|;
block|}
name|t
operator|->
name|length
operator|=
name|p
operator|-
name|suffix
expr_stmt|;
name|t
operator|->
name|suffix
operator|=
name|save_string
argument_list|(
name|suffix
argument_list|,
name|p
operator|-
name|suffix
argument_list|)
expr_stmt|;
name|t
operator|->
name|unique
operator|=
operator|(
name|c
operator|!=
literal|'g'
operator|)
expr_stmt|;
name|choose_temp_base
argument_list|()
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|temp_filename
expr_stmt|;
name|t
operator|->
name|filename_length
operator|=
name|temp_filename_length
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|t
operator|->
name|filename
argument_list|,
name|t
operator|->
name|filename_length
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|temp_filename
argument_list|,
name|temp_filename_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
block|{
specifier|static
name|int
name|unique
decl_stmt|;
name|char
name|buff
index|[
literal|9
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
name|unique
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d"
argument_list|,
name|unique
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|delete_this_arg
operator|=
literal|1
expr_stmt|;
block|}
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_filename
argument_list|,
name|input_filename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
block|{
name|struct
name|prefix_list
modifier|*
name|pl
init|=
name|include_prefixes
operator|.
name|plist
decl_stmt|;
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-iprefix"
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|gcc_exec_prefix
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
name|do_spec_1
argument_list|(
literal|"-isystem"
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'o'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
name|store_arg
argument_list|(
name|outfiles
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|OBJECT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|this_is_library_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|this_is_output_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
block|{
name|int
name|index
init|=
name|argbuf_index
decl_stmt|;
comment|/* Handle the {...} following the %W.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
name|handle_braces
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If any args were output, mark the last one for deletion 		 on failure.  */
if|if
condition|(
name|argbuf_index
operator|!=
name|index
condition|)
name|record_temp_file
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* %x{OPTION} records OPTION for %X to output.  */
case|case
literal|'x'
case|:
block|{
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Skip past the option value and make a copy.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
name|string
operator|=
name|save_string
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
name|p
operator|-
name|p1
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* See if we already recorded this option.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_linker_options
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|string
argument_list|,
name|linker_options
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This option is new; add it.  */
name|n_linker_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|linker_options
condition|)
name|linker_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_linker_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|linker_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|linker_options
argument_list|,
name|n_linker_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|linker_options
index|[
name|n_linker_options
operator|-
literal|1
index|]
operator|=
name|string
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using %x.  */
case|case
literal|'X'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_linker_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|linker_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using -Wa,.  */
case|case
literal|'Y'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_assembler_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|assembler_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using -Wp,.  */
case|case
literal|'Z'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_preprocessor_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|preprocessor_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Here are digits and numbers that just process 	       a certain constant string as a spec.  */
case|case
literal|'1'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|cc1_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'2'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|cc1plus_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'a'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|asm_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'A'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|asm_final_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'c'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|signed_char_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'C'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|cpp_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'E'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|endfile_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'l'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|link_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'L'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|lib_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'G'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|libgcc_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'p'
case|:
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|cpp_predefines
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
name|char
modifier|*
name|y
decl_stmt|;
comment|/* Copy all of the -D options in CPP_PREDEFINES into BUF.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* Copy the whole option.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy other options.  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
break|break;
case|case
literal|'P'
case|:
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|cpp_predefines
argument_list|)
operator|*
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
name|char
modifier|*
name|y
decl_stmt|;
comment|/* Copy all of CPP_PREDEFINES into BUF, 		 but put __ after every -D and at the end of each arg.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|int
name|flag
init|=
literal|0
decl_stmt|;
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|!=
literal|'_'
operator|||
operator|(
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
operator|!=
literal|'_'
operator|&&
operator|!
name|isupper
argument_list|(
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Stick __ at front of macro name.  */
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
comment|/* Arrange to stick __ at the end as well.  */
name|flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Copy the macro name.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|'='
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
comment|/* Copy the value given, if any.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy -A options  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Copy all of CPP_PREDEFINES into BUF, 		 but put __ after every -D.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|y
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|!=
literal|'_'
operator|||
operator|(
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
operator|!=
literal|'_'
operator|&&
operator|!
name|isupper
argument_list|(
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Stick -D__ at front of macro name.  */
operator|*
name|x
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
comment|/* Copy the macro name.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|'='
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Copy the value given, if any.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Do not copy this macro - we have just done it before */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
name|y
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy -A options  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Copy all of the -A options in CPP_PREDEFINES into BUF.  */
name|y
operator|=
name|cpp_predefines
expr_stmt|;
while|while
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-A"
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* Copy the whole option.  */
while|while
condition|(
operator|*
name|y
operator|&&
operator|*
name|y
operator|!=
literal|' '
operator|&&
operator|*
name|y
operator|!=
literal|'\t'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
condition|)
comment|/* Copy whitespace to the result.  */
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
comment|/* Don't copy other options.  */
else|else
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
break|break;
case|case
literal|'S'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|startfile_spec
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
comment|/* Here we define characters other than letters and digits.  */
case|case
literal|'{'
case|:
name|p
operator|=
name|handle_braces
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'%'
case|:
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|do_spec_1
argument_list|(
name|soft_matched_part
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
comment|/* Process a string found as the value of a spec given by name. 	       This feature allows individual machine descriptions 	       to add and use their own specs. 	       %[...] modifies -D options the way %P does; 	       %(...) uses the spec unmodified.  */
case|case
literal|'('
case|:
case|case
literal|'['
case|:
block|{
name|char
modifier|*
name|name
init|=
name|p
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* The string after the S/P is the name of a spec that is to be 		 processed. */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|')'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* See if it's in the list */
for|for
control|(
name|len
operator|=
name|p
operator|-
name|name
operator|,
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|sl
operator|->
name|name
index|[
name|len
index|]
condition|)
block|{
name|name
operator|=
name|sl
operator|->
name|spec
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sl
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|value
operator|=
name|do_spec_1
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
else|else
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|*
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
name|char
modifier|*
name|y
init|=
name|name
decl_stmt|;
comment|/* Copy all of NAME into BUF, but put __ after 			 every -D and at the end of each arg,  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
name|y
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|0
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|==
literal|0
condition|)
break|break;
else|else
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
block|}
comment|/* Discard the closing paren or bracket.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
block|{
name|int
name|c1
init|=
operator|*
name|p
operator|++
decl_stmt|;
comment|/* Select first or second version number.  */
name|char
modifier|*
name|v
init|=
name|compiler_version
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* If desired, advance to second version number.  */
if|if
condition|(
name|c1
operator|==
literal|'2'
condition|)
block|{
comment|/* Set P after the first period.  */
while|while
condition|(
operator|*
name|v
operator|!=
literal|0
operator|&&
operator|*
name|v
operator|!=
literal|' '
operator|&&
operator|*
name|v
operator|!=
literal|'.'
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|'.'
condition|)
name|v
operator|++
expr_stmt|;
block|}
comment|/* Set Q at the next period or at the end.  */
name|q
operator|=
name|v
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'.'
condition|)
name|q
operator|++
expr_stmt|;
comment|/* Empty string means zero.  */
if|if
condition|(
name|p
operator|==
name|q
condition|)
block|{
name|v
operator|=
literal|"0"
expr_stmt|;
name|q
operator|=
name|v
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Put that part into the command.  */
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|v
argument_list|,
name|q
operator|-
name|v
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|input_from_pipe
condition|)
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash: treat next character as ordinary.  */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* fall through */
default|default:
comment|/* Ordinary character: put it into the current argument.  */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* End of string */
block|}
end_function

begin_comment
comment|/* Return 0 if we call do_spec_1 and that returns -1.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_braces
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
name|int
name|pipe
init|=
literal|0
decl_stmt|;
name|int
name|negate
init|=
literal|0
decl_stmt|;
name|int
name|suffix
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
comment|/* A `|' after the open-brace means,        if the test fails, output a single minus sign rather than nothing.        This is used in %{|!pipe:...}.  */
name|pipe
operator|=
literal|1
operator|,
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
comment|/* A `!' after the open-brace negates the condition:        succeed if the specified switch is not present.  */
name|negate
operator|=
literal|1
operator|,
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
comment|/* A `.' after the open-brace means test against the current suffix.  */
block|{
if|if
condition|(
name|pipe
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|filter
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
block|{
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
else|else
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|suffix
condition|)
block|{
name|int
name|found
init|=
operator|(
name|input_suffix
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|input_suffix
argument_list|)
operator|==
name|p
operator|-
name|filter
operator|&&
name|strncmp
argument_list|(
name|input_suffix
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'}'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|negate
operator|!=
name|found
operator|&&
name|do_spec_1
argument_list|(
name|save_string
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|q
operator|-
name|p
operator|-
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|q
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'}'
condition|)
block|{
comment|/* Substitute all matching switches as separate args.  */
specifier|register
name|int
name|i
decl_stmt|;
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|p
operator|-
name|filter
argument_list|)
condition|)
name|give_switch
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Test for presence of the specified switch.  */
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|present
init|=
literal|0
decl_stmt|;
comment|/* If name specified ends in *, as in {x*:...}, 	 check for %* and handle that case.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|&&
operator|!
name|negate
condition|)
block|{
name|int
name|substitution
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|p
decl_stmt|;
comment|/* First see whether we have %*.  */
name|substitution
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|<
name|q
condition|)
block|{
if|if
condition|(
operator|*
name|r
operator|==
literal|'%'
operator|&&
name|r
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|substitution
operator|=
literal|1
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
comment|/* If we do, handle that case.  */
if|if
condition|(
name|substitution
condition|)
block|{
comment|/* Substitute all matching switches as separate args. 		 But do this by substituting for %* 		 in the text that follows the colon.  */
name|unsigned
name|hard_match_len
init|=
name|p
operator|-
name|filter
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|save_string
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|q
operator|-
name|p
operator|-
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|hard_match_len
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|do_spec_1
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|hard_match_len
index|]
argument_list|)
expr_stmt|;
comment|/* Pass any arguments this switch has.  */
name|give_switch
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
block|}
comment|/* If name specified ends in *, as in {x*:...}, 	 check for presence of any switch name starting with x.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|hard_match_len
init|=
name|p
operator|-
name|filter
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|hard_match_len
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|hard_match_len
argument_list|)
condition|)
block|{
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise, check for presence of exact name specified.  */
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|p
operator|-
name|filter
index|]
operator|==
literal|0
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|present
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If it is as desired (present for %{s...}, absent for %{-s...}) 	 then substitute either the switch or the specified 	 conditional text.  */
if|if
condition|(
name|present
operator|!=
name|negate
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|give_switch
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_spec_1
argument_list|(
name|save_string
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|q
operator|-
name|p
operator|-
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pipe
condition|)
block|{
comment|/* Here if a %{|...} conditional fails: output a minus sign, 	     which means "standard output" or "standard input".  */
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|q
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch    on the command line.  PREFIX_LENGTH is the length of XXX in an {XXX*}    spec, or -1 if either exact match or %* is used.     A -O switch is obsoleted by a later -O switch.  A -f, -m, or -W switch    whose value does not begin with "no-" is obsoleted by the same value    with the "no-", similarly for a switch with the "no-" prefix.  */
end_comment

begin_function
specifier|static
name|int
name|check_live_switch
parameter_list|(
name|switchnum
parameter_list|,
name|prefix_length
parameter_list|)
name|int
name|switchnum
decl_stmt|;
name|int
name|prefix_length
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|switches
index|[
name|switchnum
index|]
operator|.
name|part1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* In the common case of {<at-most-one-letter>*}, a negating      switch would always match, so ignore that case.  We will just      send the conflicting switches to the compiler phase.  */
if|if
condition|(
name|prefix_length
operator|>=
literal|0
operator|&&
name|prefix_length
operator|<=
literal|1
condition|)
return|return
literal|1
return|;
comment|/* If we already processed this switch and determined if it was      live or not, return our past determination.  */
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|!=
literal|0
condition|)
return|return
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|>
literal|0
return|;
comment|/* Now search for duplicate in a manner that depends on the name.  */
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'O'
case|:
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
literal|'O'
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'W'
case|:
case|case
literal|'f'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* We have Xno-YYY, search for XYYY. */
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|1
index|]
argument_list|,
operator|&
name|name
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* We have XYYY, search for Xno-YYY.  */
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|3
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|4
index|]
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
break|break;
block|}
comment|/* Otherwise the switch is live.  */
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pass a switch to the current accumulating command    in the same form that we received it.    SWITCHNUM identifies the switch; it is an index into    the vector of switches gcc received, which is `switches'.    This cannot fail since it never finishes a command line.     If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */
end_comment

begin_function
specifier|static
name|void
name|give_switch
parameter_list|(
name|switchnum
parameter_list|,
name|omit_first_word
parameter_list|)
name|int
name|switchnum
decl_stmt|;
name|int
name|omit_first_word
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|omit_first_word
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|part1
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|args
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|switches
index|[
name|switchnum
index|]
operator|.
name|args
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
name|switches
index|[
name|switchnum
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search for a file named NAME trying various prefixes including the    user's -B prefix and some standard ones.    Return the absolute file name found.  If nothing is found, return NAME.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|newname
decl_stmt|;
comment|/* Try multilib_dir if it is defined.  */
if|if
condition|(
name|multilib_dir
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|try
decl_stmt|;
name|try
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|multilib_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|try
argument_list|,
name|multilib_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|try
argument_list|,
name|dir_separator_str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|try
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newname
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|try
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
comment|/* If we don't find it in the multi library dir, then fall 	 through and look for it in the normal places.  */
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
return|return
name|newname
return|;
block|}
name|newname
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|name
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
return|return
name|newname
condition|?
name|newname
else|:
name|name
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a directory exists.  If LINKER, return 0 for    certain fixed names not needed by the linker.  If not LINKER, it is    only important to return 0 if the host machine has a small ARG_MAX    limit.  */
end_comment

begin_function
specifier|static
name|int
name|is_directory
parameter_list|(
name|path1
parameter_list|,
name|path2
parameter_list|,
name|linker
parameter_list|)
name|char
modifier|*
name|path1
decl_stmt|;
name|char
modifier|*
name|path2
decl_stmt|;
name|int
name|linker
decl_stmt|;
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|path1
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|strlen
argument_list|(
name|path2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|path
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|len1
operator|+
name|len2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL_ARG_MAX
if|if
condition|(
operator|!
name|linker
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* Construct the path from the two parts.  Ensure the string ends with "/.".      The resulting path will be a directory even if the given path is a      symbolic link.  */
name|bcopy
argument_list|(
name|path1
argument_list|,
name|path
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|path2
argument_list|,
name|path
operator|+
name|len1
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|cp
operator|=
name|path
operator|+
name|len1
operator|+
name|len2
expr_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
operator|*
name|cp
operator|++
operator|=
name|DIR_SEPARATOR
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Exclude directories that the linker is known to search.  */
if|if
condition|(
name|linker
operator|&&
operator|(
operator|(
name|cp
operator|-
name|path
operator|==
literal|6
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|concat4
argument_list|(
name|dir_separator_str
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
literal|"."
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|cp
operator|-
name|path
operator|==
literal|10
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|concat6
argument_list|(
name|dir_separator_str
argument_list|,
literal|"usr"
argument_list|,
name|dir_separator_str
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
literal|"."
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* On fatal signals, delete all the temporary files.  */
end_comment

begin_function
specifier|static
name|void
name|fatal_error
parameter_list|(
name|signum
parameter_list|)
name|int
name|signum
decl_stmt|;
block|{
name|signal
argument_list|(
name|signum
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
comment|/* Get the same signal again, this time not handled,      so its normal effect occurs.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|linker_was_run
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|explicit_link_files
decl_stmt|;
name|char
modifier|*
name|specs_file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
operator|--
name|p
expr_stmt|;
name|programname
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argbuf_length
operator|=
literal|10
expr_stmt|;
name|argbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argbuf_length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
comment|/* Set up to remember the pathname of gcc and any options      needed for collect.  We use argv[0] instead of programname because      we need the complete pathname.  */
name|obstack_init
argument_list|(
operator|&
name|collect_obstack
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"COLLECT_GCC="
argument_list|,
sizeof|sizeof
argument_list|(
literal|"COLLECT_GCC="
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|collect_obstack
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_ENVIRONMENT
comment|/* Set up any other necessary machine specific environment variables.  */
name|putenv
argument_list|(
name|INIT_ENVIRONMENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Choose directory for temp files.  */
name|choose_temp_base
argument_list|()
expr_stmt|;
comment|/* Make a table of what switches there are (switches, n_switches).      Make a table of specified input files (infiles, n_infiles).      Decode switches that are handled locally.  */
name|process_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Initialize the vector of specs to just the default.      This means one element containing 0s, as a terminator.  */
name|compilers
operator|=
operator|(
expr|struct
name|compiler
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|default_compilers
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|default_compilers
argument_list|,
operator|(
name|char
operator|*
operator|)
name|compilers
argument_list|,
sizeof|sizeof
name|default_compilers
argument_list|)
expr_stmt|;
name|n_compilers
operator|=
name|n_default_compilers
expr_stmt|;
comment|/* Read specs from a file if there is one.  */
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|machine_suffix
operator|=
name|concat4
argument_list|(
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|)
expr_stmt|;
name|just_machine_suffix
operator|=
name|concat
argument_list|(
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|specs_file
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|"specs"
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
comment|/* Read the specs file unless it is a default one.  */
if|if
condition|(
name|specs_file
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|specs_file
argument_list|,
literal|"specs"
argument_list|)
condition|)
name|read_specs
argument_list|(
name|specs_file
argument_list|)
expr_stmt|;
comment|/* If not cross-compiling, look for startfiles in the standard places.  */
comment|/* The fact that these are done here, after reading the specs file,      means that it cannot be found in these directories.      But that's okay.  It should never be there anyway.  */
if|if
condition|(
operator|!
name|cross_compile
condition|)
block|{
ifdef|#
directive|ifdef
name|MD_EXEC_PREFIX
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|md_exec_prefix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_exec_prefix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD_STARTFILE_PREFIX
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_startfile_prefix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD_STARTFILE_PREFIX_1
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_startfile_prefix_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If standard_startfile_prefix is relative, base it on 	 standard_exec_prefix.  This lets us move the installed tree 	 as a unit.  If GCC_EXEC_PREFIX is defined, base 	 standard_startfile_prefix on that as well.  */
if|if
condition|(
operator|*
name|standard_startfile_prefix
operator|==
literal|'/'
operator|||
operator|*
name|standard_startfile_prefix
operator|==
name|DIR_SEPARATOR
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gcc_exec_prefix
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat3
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat3
argument_list|(
name|standard_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix_2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Can cause surprises, and one can use -B./ instead.  */
block|add_prefix (&startfile_prefixes, "./", 0, 1, NULL_PTR);
endif|#
directive|endif
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
block|}
else|else
block|{
if|if
condition|(
operator|*
name|standard_startfile_prefix
operator|!=
name|DIR_SEPARATOR
operator|&&
name|gcc_exec_prefix
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat3
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a GCC_EXEC_PREFIX envvar, modify it for cpp's sake.  */
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|gcc_exec_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|spec_version
argument_list|)
operator|+
name|strlen
argument_list|(
name|spec_machine
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|gcc_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|spec_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|dir_separator_str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|spec_version
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|dir_separator_str
argument_list|)
expr_stmt|;
name|gcc_exec_prefix
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Now we have the specs.      Set the `valid' bits for switches that match anything in any spec.  */
name|validate_all_switches
argument_list|()
expr_stmt|;
comment|/* Now that we have the switches and the specs, set      the subdirectory based on the options.  */
name|set_multilib_dir
argument_list|()
expr_stmt|;
comment|/* Warn about any switches that no pass was interested in.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|switches
index|[
name|i
index|]
operator|.
name|valid
condition|)
name|error
argument_list|(
literal|"unrecognized option `-%s'"
argument_list|,
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
expr_stmt|;
comment|/* Obey some of the options.  */
if|if
condition|(
name|print_search_dirs
condition|)
block|{
name|printf
argument_list|(
literal|"install: %s%s\n"
argument_list|,
name|standard_exec_prefix
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"programs: %s\n"
argument_list|,
name|build_search_list
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"libraries: %s\n"
argument_list|,
name|build_search_list
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_file_name
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|find_file
argument_list|(
name|print_file_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_prog_name
condition|)
block|{
name|char
modifier|*
name|newname
init|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|print_prog_name
argument_list|,
name|X_OK
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
name|newname
condition|?
name|newname
else|:
name|print_prog_name
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_multi_lib
condition|)
block|{
name|print_multilib_info
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_multi_directory
condition|)
block|{
if|if
condition|(
name|multilib_dir
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|multilib_dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_flag
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|version_string
argument_list|,
name|compiler_version
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gcc version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gcc driver version %s executing gcc version %s\n"
argument_list|,
name|version_string
argument_list|,
name|compiler_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_infiles
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_infiles
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"No input files specified"
argument_list|)
expr_stmt|;
comment|/* Make a place to record the compiler output file names      that correspond to the input files.  */
name|outfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_infiles
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outfiles
argument_list|,
name|n_infiles
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record which files were specified explicitly as link input.  */
name|explicit_link_files
operator|=
name|xmalloc
argument_list|(
name|n_infiles
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|explicit_link_files
argument_list|,
name|n_infiles
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|compiler
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
name|int
name|this_file_error
init|=
literal|0
decl_stmt|;
comment|/* Tell do_spec what to substitute for %i.  */
name|input_filename
operator|=
name|infiles
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|input_filename_length
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|input_file_number
operator|=
name|i
expr_stmt|;
comment|/* Use the same thing in %o, unless cp->spec says otherwise.  */
name|outfiles
index|[
name|i
index|]
operator|=
name|input_filename
expr_stmt|;
comment|/* Figure out which compiler from the file's suffix.  */
name|cp
operator|=
name|lookup_compiler
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|input_filename_length
argument_list|,
name|infiles
index|[
name|i
index|]
operator|.
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
comment|/* Ok, we found an applicable compiler.  Run its spec.  */
comment|/* First say how much of input_filename to substitute for %b  */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|input_basename
operator|=
name|input_filename
expr_stmt|;
for|for
control|(
name|p
operator|=
name|input_filename
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|||
operator|*
name|p
operator|==
name|DIR_SEPARATOR
condition|)
name|input_basename
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Find a suffix starting with the last period, 	     and set basename_length to exclude that suffix.  */
name|basename_length
operator|=
name|strlen
argument_list|(
name|input_basename
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_basename
operator|+
name|basename_length
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|input_basename
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
operator|!=
name|input_basename
condition|)
block|{
name|basename_length
operator|=
name|p
operator|-
name|input_basename
expr_stmt|;
name|input_suffix
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|input_suffix
operator|=
literal|""
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|cp
operator|->
name|spec
operator|/
sizeof|sizeof
name|cp
operator|->
name|spec
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cp
operator|->
name|spec
index|[
name|j
index|]
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|cp
operator|->
name|spec
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|cp
operator|->
name|spec
operator|/
sizeof|sizeof
name|cp
operator|->
name|spec
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cp
operator|->
name|spec
index|[
name|j
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|p
operator|+
name|len
argument_list|,
name|cp
operator|->
name|spec
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|cp
operator|->
name|spec
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|do_spec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|this_file_error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this file's name does not contain a recognized suffix, 	 record it as explicit linker input.  */
else|else
name|explicit_link_files
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Clear the delete-on-failure queue, deleting the files in it 	 if this compilation failed.  */
if|if
condition|(
name|this_file_error
condition|)
block|{
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
comment|/* If this compilation succeeded, don't delete those files later.  */
name|clear_failure_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Run ld to link all the compiler output files.  */
if|if
condition|(
name|error_count
operator|==
literal|0
condition|)
block|{
name|int
name|tmp
init|=
name|execution_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|first_time
decl_stmt|;
comment|/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables 	 for collect.  */
name|putenv_from_prefixes
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"COMPILER_PATH="
argument_list|)
expr_stmt|;
name|putenv_from_prefixes
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|"LIBRARY_PATH="
argument_list|)
expr_stmt|;
comment|/* Build COLLECT_GCC_OPTIONS to have all of the options specified to 	 the compiler.  */
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"COLLECT_GCC_OPTIONS="
argument_list|,
sizeof|sizeof
argument_list|(
literal|"COLLECT_GCC_OPTIONS="
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|strlen
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|switches
index|[
name|i
index|]
operator|.
name|args
init|;
name|args
operator|&&
operator|*
name|args
condition|;
name|args
operator|++
control|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
operator|*
name|args
argument_list|,
name|strlen
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|collect_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|do_spec
argument_list|(
name|link_command_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|error_count
operator|=
literal|1
expr_stmt|;
name|linker_was_run
operator|=
operator|(
name|tmp
operator|!=
name|execution_count
operator|)
expr_stmt|;
block|}
comment|/* Warn if a -B option was specified but the prefix was never used.  */
name|unused_prefix_warnings
argument_list|(
operator|&
name|exec_prefixes
argument_list|)
expr_stmt|;
name|unused_prefix_warnings
argument_list|(
operator|&
name|startfile_prefixes
argument_list|)
expr_stmt|;
comment|/* If options said don't run linker,      complain about input files to be given to the linker.  */
if|if
condition|(
operator|!
name|linker_was_run
operator|&&
name|error_count
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|explicit_link_files
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"%s: linker input file unused since linking not done"
argument_list|,
name|outfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Delete some or all of the temporary files we made.  */
if|if
condition|(
name|error_count
condition|)
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|error_count
operator|>
literal|0
condition|?
operator|(
name|signal_count
condition|?
literal|2
else|:
literal|1
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the proper compilation spec for the file name NAME,    whose length is LENGTH.  LANGUAGE is the specified language,    or 0 if none specified.  */
end_comment

begin_function
specifier|static
name|struct
name|compiler
modifier|*
name|lookup_compiler
parameter_list|(
name|name
parameter_list|,
name|length
parameter_list|,
name|language
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|language
decl_stmt|;
block|{
name|struct
name|compiler
modifier|*
name|cp
decl_stmt|;
comment|/* Look for the language, if one is spec'd.  */
if|if
condition|(
name|language
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
block|{
if|if
condition|(
name|language
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|suffix
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
operator|+
literal|1
argument_list|,
name|language
argument_list|)
condition|)
return|return
name|cp
return|;
block|}
block|}
name|error
argument_list|(
literal|"language %s not recognized"
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a suffix.  */
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
block|{
if|if
condition|(
comment|/* The suffix `-' matches only the file name `-'.  */
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"-"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
operator|<
name|length
comment|/* See if the suffix matches the end of NAME.  */
ifdef|#
directive|ifdef
name|OS2
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|||
operator|!
name|strpbrk
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
else|#
directive|else
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
block|)
block|)
endif|#
directive|endif
block|{
if|if
condition|(
name|cp
operator|->
name|spec
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|struct
name|compiler
modifier|*
name|new
decl_stmt|;
comment|/* An alias entry maps a suffix to a language. 		 Search for the language; pass 0 for NAME and LENGTH 		 to avoid infinite recursion if language not found. 		 Construct the new compiler spec.  */
name|language
operator|=
name|cp
operator|->
name|spec
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|compiler
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|suffix
operator|=
name|cp
operator|->
name|suffix
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lookup_compiler
argument_list|(
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|language
argument_list|)
operator|->
name|spec
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new
operator|->
name|spec
argument_list|,
sizeof|sizeof
name|new
operator|->
name|spec
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
comment|/* A non-alias entry: return it.  */
return|return
name|cp
return|;
block|}
end_function

begin_expr_stmt
unit|}    return
literal|0
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_expr_stmt
unit|char
operator|*
name|xmalloc
argument_list|(
argument|size
argument_list|)
name|unsigned
name|size
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2 */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|concat3
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
return|return
name|concat
argument_list|(
name|concat
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
argument_list|,
name|s3
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|concat4
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|,
name|s4
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|,
modifier|*
name|s4
decl_stmt|;
end_function

begin_block
block|{
return|return
name|concat
argument_list|(
name|concat
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
argument_list|,
name|concat
argument_list|(
name|s3
argument_list|,
name|s4
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|concat6
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|,
name|s4
parameter_list|,
name|s5
parameter_list|,
name|s6
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|,
modifier|*
name|s4
decl_stmt|,
modifier|*
name|s5
decl_stmt|,
modifier|*
name|s6
decl_stmt|;
end_function

begin_block
block|{
return|return
name|concat3
argument_list|(
name|concat
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
argument_list|,
name|concat
argument_list|(
name|s3
argument_list|,
name|s4
argument_list|)
argument_list|,
name|concat
argument_list|(
name|s5
argument_list|,
name|s6
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|result
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"%s: "
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open `%s'"
expr_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"%s: "
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open `%s'"
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_exec
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"installation problem, cannot exec `%s': "
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"installation problem, cannot exec `%s'"
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
end_ifdef

begin_comment
comment|/* Output an error message and exit */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_all_switches
parameter_list|()
block|{
name|struct
name|compiler
modifier|*
name|comp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|spec
decl_stmt|;
for|for
control|(
name|comp
operator|=
name|compilers
init|;
name|comp
operator|->
name|spec
index|[
literal|0
index|]
condition|;
name|comp
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|comp
operator|->
name|spec
operator|/
sizeof|sizeof
name|comp
operator|->
name|spec
index|[
literal|0
index|]
operator|&&
name|comp
operator|->
name|spec
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|comp
operator|->
name|spec
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* look through the linked list of extra specs read from the specs file */
for|for
control|(
name|spec
operator|=
name|specs
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
block|{
name|p
operator|=
name|spec
operator|->
name|spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|link_command_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now notice switches mentioned in the machine-specific specs.  */
name|p
operator|=
name|asm_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|asm_final_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|cpp_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|signed_char_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|cc1_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|cc1plus_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|link_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|lib_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|libgcc_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|startfile_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at the switch-name that comes after START    and mark as valid all supplied switches that match it.  */
end_comment

begin_function
specifier|static
name|void
name|validate_switches
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|suffix
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|suffix
operator|=
literal|1
operator|,
operator|++
name|p
expr_stmt|;
name|filter
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|suffix
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
comment|/* Mark all matching switches as valid.  */
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark an exact matching switch as valid.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|p
operator|-
name|filter
index|]
operator|==
literal|0
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether a particular argument was used.  */
end_comment

begin_function
specifier|static
name|int
name|used_arg
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|&&
name|strlen
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
operator|==
name|len
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether a particular argument is a default argument.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MULTILIB_DEFAULTS
end_ifndef

begin_define
define|#
directive|define
name|MULTILIB_DEFAULTS
value|{ NULL }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|multilib_defaults
index|[]
init|=
name|MULTILIB_DEFAULTS
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|default_arg
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|count
init|=
sizeof|sizeof
name|multilib_defaults
operator|/
sizeof|sizeof
name|multilib_defaults
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|multilib_defaults
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|multilib_defaults
index|[
name|i
index|]
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|multilib_defaults
index|[
name|i
index|]
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Work out the subdirectory to use based on the    options.  The format of multilib_select is a list of elements.    Each element is a subdirectory name followed by a list of options    followed by a semicolon.  gcc will consider each line in turn.  If    none of the options beginning with an exclamation point are    present, and all of the other options are present, that    subdirectory will be used.  */
end_comment

begin_function
specifier|static
name|void
name|set_multilib_dir
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|multilib_select
decl_stmt|;
name|int
name|this_path_len
decl_stmt|;
name|char
modifier|*
name|this_path
decl_stmt|,
modifier|*
name|this_arg
decl_stmt|;
name|int
name|not_arg
decl_stmt|;
name|int
name|ok
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Get the initial path.  */
name|this_path
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|this_path_len
operator|=
name|p
operator|-
name|this_path
expr_stmt|;
comment|/* Check the arguments.  */
name|ok
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|this_arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|this_arg
operator|!=
literal|'!'
condition|)
name|not_arg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|not_arg
operator|=
literal|1
expr_stmt|;
operator|++
name|this_arg
expr_stmt|;
block|}
comment|/* If this is a default argument, we can just ignore it. 	     This is true even if this_arg begins with '!'.  Beginning 	     with '!' does not mean that this argument is necessarily 	     inappropriate for this library: it merely means that 	     there is a more specific library which uses this 	     argument.  If this argument is a default, we need not 	     consider that more specific library.  */
if|if
condition|(
operator|!
name|default_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
condition|)
block|{
name|ok
operator|=
name|used_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_arg
condition|)
name|ok
operator|=
operator|!
name|ok
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|this_path_len
operator|!=
literal|1
operator|||
name|this_path
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
name|multilib_dir
operator|=
name|xmalloc
argument_list|(
name|this_path_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|multilib_dir
argument_list|,
name|this_path
argument_list|,
name|this_path_len
argument_list|)
expr_stmt|;
name|multilib_dir
index|[
name|this_path_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out the multiple library subdirectory selection    information.  This prints out a series of lines.  Each line looks    like SUBDIRECTORY;@OPTION@OPTION, with as many options as is    required.  Only the desired options are printed out, the negative    matches.  The options are print without a leading dash.  There are    no spaces to make it easy to use the information in the shell.    Each subdirectory is printed only once.  This assumes the ordering    generated by the genmultilib script.  */
end_comment

begin_function
specifier|static
name|void
name|print_multilib_info
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|multilib_select
decl_stmt|;
name|char
modifier|*
name|last_path
init|=
literal|0
decl_stmt|,
modifier|*
name|this_path
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|int
name|last_path_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Get the initial path.  */
name|this_path
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
comment|/* If this is a duplicate, skip it.  */
name|skip
operator|=
operator|(
name|last_path
operator|!=
literal|0
operator|&&
name|p
operator|-
name|this_path
operator|==
name|last_path_len
operator|&&
operator|!
name|strncmp
argument_list|(
name|last_path
argument_list|,
name|this_path
argument_list|,
name|last_path_len
argument_list|)
operator|)
expr_stmt|;
name|last_path
operator|=
name|this_path
expr_stmt|;
name|last_path_len
operator|=
name|p
operator|-
name|this_path
expr_stmt|;
comment|/* If this directory requires any default arguments, we can skip 	 it.  We will already have printed a directory identical to 	 this one which does not require that default argument.  */
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'!'
condition|)
name|arg
operator|=
name|NULL
expr_stmt|;
else|else
name|arg
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|default_arg
argument_list|(
name|arg
argument_list|,
name|q
operator|-
name|arg
argument_list|)
condition|)
block|{
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
operator|++
name|q
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|last_path
init|;
name|p1
operator|<
name|p
condition|;
name|p1
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|int
name|use_arg
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|use_arg
operator|=
operator|*
name|p
operator|!=
literal|'!'
expr_stmt|;
if|if
condition|(
name|use_arg
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_arg
condition|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function

end_unit

