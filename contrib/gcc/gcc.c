begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compiler driver program that can handle many languages.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,    Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  This paragraph is here to try to keep Sun CC from dying. The number of chars here seems crucial!!!!  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* This program is the user interface to the C compiler and possibly to other compilers.  It is used because compilation is a complicated procedure which involves running several programs and passing temporary files between them, forwarding the users switches to those programs selectively, and deleting the temporary files at the end.  CC recognizes how to compile each input file by suffixes in the file names. Once it knows which kind of compilation to perform, the procedure for compilation is specified by a string called a "spec".  */
end_comment

begin_comment
comment|/* A Short Introduction to Adding a Command-Line Option.     Before adding a command-line option, consider if it is really    necessary.  Each additional command-line option adds complexity and    is difficult to remove in subsequent versions.     In the following, consider adding the command-line argument    `--bar'.     1. Each command-line option is specified in the specs file.  The    notation is described below in the comment entitled "The Specs    Language".  Read it.     2. In this file, add an entry to "option_map" equating the long    `--' argument version and any shorter, single letter version.  Read    the comments in the declaration of "struct option_map" for an    explanation.  Do not omit the first `-'.     3. Look in the "specs" file to determine which program or option    list should be given the argument, e.g., "cc1_options".  Add the    appropriate syntax for the shorter option version to the    corresponding "const char *" entry in this file.  Omit the first    `-' from the option.  For example, use `-bar', rather than `--bar'.     4. If the argument takes an argument, e.g., `--baz argument1',    modify either DEFAULT_SWITCH_TAKES_ARG or    DEFAULT_WORD_SWITCH_TAKES_ARG in gcc.h.  Omit the first `-'    from `--baz'.     5. Document the option in this file's display_help().  If the    option is passed to a subprogram, modify its corresponding    function, e.g., cppinit.c:print_help() or toplev.c:display_help(),    instead.     6. Compile and test.  Make sure that your new specs file is being    read.  For example, use a debugger to investigate the value of    "specs_file" in main().  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"multilib.h"
end_include

begin_comment
comment|/* before tm.h */
end_comment

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGCLD
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xregex.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_include
include|#
directive|include
file|"gcc.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_comment
comment|/* By default there is no special suffix for target executables.  */
end_comment

begin_comment
comment|/* FIXME: when autoconf is fixed, remove the host check - dj */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TARGET_EXECUTABLE_SUFFIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HOST_EXECUTABLE_SUFFIX
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_TARGET_EXECUTABLE_SUFFIX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default there is no special suffix for host executables.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_EXECUTABLE_SUFFIX
end_ifdef

begin_define
define|#
directive|define
name|HAVE_HOST_EXECUTABLE_SUFFIX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_EXECUTABLE_SUFFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, the suffix for target object files is ".o".  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OBJECT_SUFFIX
end_ifdef

begin_define
define|#
directive|define
name|HAVE_TARGET_OBJECT_SUFFIX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_OBJECT_SUFFIX
value|".o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|dir_separator_str
index|[]
init|=
block|{
name|DIR_SEPARATOR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Most every one is fine with LIBRARY_PATH.  For some, it conflicts.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBRARY_PATH_ENV
end_ifndef

begin_define
define|#
directive|define
name|LIBRARY_PATH_ENV
value|"LIBRARY_PATH"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_KILL
end_ifndef

begin_define
define|#
directive|define
name|kill
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|raise(s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If a stage of compilation returns an exit status>= 1,    compilation of that file ceases.  */
end_comment

begin_define
define|#
directive|define
name|MIN_FATAL_STATUS
value|1
end_define

begin_comment
comment|/* Flag set by cppspec.c to 1.  */
end_comment

begin_decl_stmt
name|int
name|is_cpp_driver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to pass the greatest exit code returned by a sub-process    to the calling program.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pass_exit_codes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definition of string containing the arguments given to configure.  */
end_comment

begin_include
include|#
directive|include
file|"configargs.h"
end_include

begin_comment
comment|/* Flag saying to print the directories gcc will search through looking for    programs, libraries, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_search_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the full filename of this file    as found through our usual search mechanism.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|print_file_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* As print_file_name, but search for executable file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|print_prog_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the relative path we'd use to    find libgcc.a given the current compiler flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_multi_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the relative path we'd use to    find OS libraries given the current compiler flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_multi_os_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the list of subdirectories and    compiler flags used to select them in a standard form.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_multi_lib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying to print the command line options understood by gcc and its    sub-processes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_help_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should print the command and arguments */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should ONLY print the command and    arguments (like verbose_flag) without executing the command.    Displayed arguments are quoted so that the generated command    line is suitable for execution.  This is intended for use in    shell scripts to capture the driver-generated command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose_only_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating to print target specific command line options.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_help_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should report subprocess execution times    (if this is supported by the system - see pexecute.c).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|report_times
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means place this string before uses of /, so that include    and library files can be found in an alternate location.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_SYSTEM_ROOT
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|target_system_root
init|=
name|TARGET_SYSTEM_ROOT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|target_system_root
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means pass the updated target_system_root to the compiler.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_system_root_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means append this string to target_system_root.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|target_sysroot_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means append this string to target_system_root for headers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|target_sysroot_hdrs_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means write "temp" files in source directory    and use the source file's name in them, and don't delete them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|save_temps_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means pass multiple source files to the compiler at one time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use pipes to communicate between subprocesses.    Overridden by either of the above two flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_pipes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiler version.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|compiler_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target version specified with -V */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|spec_version
init|=
name|DEFAULT_TARGET_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target machine specified with -b.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|spec_machine
init|=
name|DEFAULT_TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if cross-compiling.    When -b is used, the value comes from the `specs' file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cross_compile
init|=
literal|"1"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cross_compile
init|=
literal|"0"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
end_ifdef

begin_comment
comment|/* Information on how to alter the target name based on a command-line    switch.  The only case we support now is simply appending or deleting a    string to or from the end of the first part of the configuration name.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|modify_target
block|{
specifier|const
name|char
modifier|*
specifier|const
name|sw
decl_stmt|;
specifier|const
enum|enum
name|add_del
block|{
name|ADD
block|,
name|DELETE
block|}
name|add_del
enum|;
specifier|const
name|char
modifier|*
specifier|const
name|str
decl_stmt|;
block|}
name|modify_target
index|[]
init|=
name|MODIFY_TARGET_NAME
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of errors that have occurred; the link phase will not be    run if this is nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Greatest exit code of sub-processes that has been encountered up to    now.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|greatest_status
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the obstack which we use to allocate many strings.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the obstack to build an environment variable to pass to    collect2 that describes all of the relevant switches of what to    pass the compiler in building the list of pointers to constructors    and destructors.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|collect_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration for prototypes.  */
end_comment

begin_struct_decl
struct_decl|struct
name|path_prefix
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|prefix_list
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|init_spec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_arg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|load_specs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_specs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_spec
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|compiler
modifier|*
name|lookup_compiler
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_search_list
parameter_list|(
specifier|const
name|struct
name|path_prefix
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|putenv_from_prefixes
parameter_list|(
specifier|const
name|struct
name|path_prefix
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|access_check
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
specifier|const
name|struct
name|path_prefix
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_prefix
parameter_list|(
name|struct
name|path_prefix
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_sysrooted_prefix
parameter_list|(
name|struct
name|path_prefix
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|translate_options
parameter_list|(
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|skip_whitespace
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_if_ordinary
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_temp_files
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_failure_queue
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_failure_queue
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_live_switch
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|handle_braces
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|input_suffix_matches
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|switch_matches
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mark_matching_switches
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|process_marked_switches
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|process_brace_body
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|spec_function
modifier|*
name|lookup_spec_function
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eval_spec_function
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|handle_spec_function
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_collect_gcc_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_spec_1
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_spec_2
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_option_spec
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_self_spec
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|find_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_directory
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|validate_switches
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_all_switches
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|validate_switches_from_spec
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|give_switch
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|used_arg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|default_arg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_multilib_dir
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_multilib_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|perror_with_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|fatal_ice
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|display_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_preprocessor_option
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_assembler_option
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_linker_option
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_command
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|execute
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_args
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_args
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fatal_error
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_SHARED_LIBGCC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REAL_LIBGCC_SPEC
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|init_gcc_specs
parameter_list|(
name|struct
name|obstack
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_OBJECT_SUFFIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|convert_filename
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|if_exists_spec_function
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|if_exists_else_spec_function
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|replace_outfile_spec_function
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|version_compare_spec_function
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|include_spec_function
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* The Specs Language  Specs are strings containing lines, each of which (if not blank) is made up of a program name, and arguments separated by spaces. The program name must be exact and start from root, since no path is searched and it is unreliable to depend on the current working directory. Redirection of input or output is not supported; the subprograms must accept filenames saying what files to read and write.  In addition, the specs can contain %-sequences to substitute variable text or for conditional text.  Here is a table of all defined %-sequences. Note that spaces are not generated automatically around the results of expanding these sequences; therefore, you can concatenate them together or with constant text in a single argument.   %%	substitute one % into the program name or argument.  %i     substitute the name of the input file being processed.  %b     substitute the basename of the input file being processed. 	This is the substring up to (and not including) the last period 	and not including the directory.  %B	same as %b, but include the file suffix (text after the last period).  %gSUFFIX 	substitute a file name that has suffix SUFFIX and is chosen 	once per compilation, and mark the argument a la %d.  To reduce 	exposure to denial-of-service attacks, the file name is now 	chosen in a way that is hard to predict even when previously 	chosen file names are known.  For example, `%g.s ... %g.o ... %g.s' 	might turn into `ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s'.  SUFFIX matches 	the regexp "[.0-9A-Za-z]*%O"; "%O" is treated exactly as if it 	had been pre-processed.  Previously, %g was simply substituted 	with a file name chosen once per compilation, without regard 	to any appended suffix (which was therefore treated just like 	ordinary text), making such attacks more likely to succeed.  %|SUFFIX 	like %g, but if -pipe is in effect, expands simply to "-".  %mSUFFIX         like %g, but if -pipe is in effect, expands to nothing.  (We have both 	%| and %m to accommodate differences between system assemblers; see 	the AS_NEEDS_DASH_FOR_PIPED_INPUT target macro.)  %uSUFFIX 	like %g, but generates a new temporary file name even if %uSUFFIX 	was already seen.  %USUFFIX 	substitutes the last file name generated with %uSUFFIX, generating a 	new one if there is no such last file name.  In the absence of any 	%uSUFFIX, this is just like %gSUFFIX, except they don't share 	the same suffix "space", so `%g.s ... %U.s ... %g.s ... %U.s' 	would involve the generation of two distinct file names, one 	for each `%g.s' and another for each `%U.s'.  Previously, %U was 	simply substituted with a file name chosen for the previous %u, 	without regard to any appended suffix.  %jSUFFIX         substitutes the name of the HOST_BIT_BUCKET, if any, and if it is         writable, and if save-temps is off; otherwise, substitute the name         of a temporary file, just like %u.  This temporary file is not         meant for communication between processes, but rather as a junk         disposal mechanism.  %.SUFFIX         substitutes .SUFFIX for the suffixes of a matched switch's args when         it is subsequently output with %*. SUFFIX is terminated by the next         space or %.  %d	marks the argument containing or following the %d as a 	temporary file name, so that that file will be deleted if CC exits 	successfully.  Unlike %g, this contributes no text to the argument.  %w	marks the argument containing or following the %w as the 	"output file" of this compilation.  This puts the argument 	into the sequence of arguments that %o will substitute later.  %V	indicates that this compilation produces no "output file".  %W{...} 	like %{...} but mark last argument supplied within 	as a file to be deleted on failure.  %o	substitutes the names of all the output files, with spaces 	automatically placed around them.  You should write spaces 	around the %o as well or the results are undefined. 	%o is for use in the specs for running the linker. 	Input files whose names have no recognized suffix are not compiled 	at all, but they are included among the output files, so they will 	be linked.  %O	substitutes the suffix for object files.  Note that this is         handled specially when it immediately follows %g, %u, or %U 	(with or without a suffix argument) because of the need for 	those to form complete file names.  The handling is such that 	%O is treated exactly as if it had already been substituted, 	except that %g, %u, and %U do not currently support additional 	SUFFIX characters following %O as they would following, for 	example, `.o'.  %I	Substitute any of -iprefix (made from GCC_EXEC_PREFIX), -isysroot 	(made from TARGET_SYSTEM_ROOT), -isystem (made from COMPILER_PATH 	and -B options) and -imultilib as necessary.  %s     current argument is the name of a library or startup file of some sort.         Search for that file in a standard list of directories 	and substitute the full name found.  %eSTR  Print STR as an error message.  STR is terminated by a newline.         Use this when inconsistent options are detected.  %nSTR  Print STR as a notice.  STR is terminated by a newline.  %x{OPTION}	Accumulate an option for %X.  %X	Output the accumulated linker options specified by compilations.  %Y	Output the accumulated assembler options specified by compilations.  %Z	Output the accumulated preprocessor options specified by compilations.  %a     process ASM_SPEC as a spec.         This allows config.h to specify part of the spec for running as.  %A	process ASM_FINAL_SPEC as a spec.  A capital A is actually 	used here.  This can be used to run a post-processor after the 	assembler has done its job.  %D	Dump out a -L option for each directory in startfile_prefixes. 	If multilib_dir is set, extra entries are generated with it affixed.  %l     process LINK_SPEC as a spec.  %L     process LIB_SPEC as a spec.  %G     process LIBGCC_SPEC as a spec.  %R     Output the concatenation of target_system_root and         target_sysroot_suffix.  %S     process STARTFILE_SPEC as a spec.  A capital S is actually used here.  %E     process ENDFILE_SPEC as a spec.  A capital E is actually used here.  %C     process CPP_SPEC as a spec.  %1	process CC1_SPEC as a spec.  %2	process CC1PLUS_SPEC as a spec.  %*	substitute the variable part of a matched option.  (See below.) 	Note that each comma in the substituted string is replaced by 	a single space.  %<S    remove all occurrences of -S from the command line.         Note - this command is position dependent.  % commands in the         spec string before this one will see -S, % commands in the         spec string after this one will not.  %<S*	remove all occurrences of all switches beginning with -S from the         command line.  %:function(args) 	Call the named function FUNCTION, passing it ARGS.  ARGS is 	first processed as a nested spec string, then split into an 	argument vector in the usual fashion.  The function returns 	a string which is processed as if it had appeared literally 	as part of the current spec.  %{S}   substitutes the -S switch, if that switch was given to CC. 	If that switch was not specified, this substitutes nothing. 	Here S is a metasyntactic variable.  %{S*}  substitutes all the switches specified to CC whose names start 	with -S.  This is used for -o, -I, etc; switches that take 	arguments.  CC considers `-o foo' as being one switch whose 	name starts with `o'.  %{o*} would substitute this text, 	including the space; thus, two arguments would be generated.  %{S*&T*} likewise, but preserve order of S and T options (the order 	of S and T in the spec is not significant).  Can be any number 	of ampersand-separated variables; for each the wild card is 	optional.  Useful for CPP as %{D*&U*&A*}.   %{S:X}   substitutes X, if the -S switch was given to CC.  %{!S:X}  substitutes X, if the -S switch was NOT given to CC.  %{S*:X}  substitutes X if one or more switches whose names start           with -S was given to CC.  Normally X is substituted only           once, no matter how many such switches appeared.  However,           if %* appears somewhere in X, then X will be substituted           once for each matching switch, with the %* replaced by the           part of that switch that matched the '*'.  %{.S:X}  substitutes X, if processing a file with suffix S.  %{!.S:X} substitutes X, if NOT processing a file with suffix S.   %{S|T:X} substitutes X if either -S or -T was given to CC.  This may be 	  combined with !, ., and * as above binding stronger than the OR. 	  If %* appears in X, all of the alternatives must be starred, and 	  only the first matching alternative is substituted.  %{S:X;   if S was given to CC, substitutes X;    T:Y;   else if T was given to CC, substitutes Y;     :D}   else substitutes D.  There can be as many clauses as you need.           This may be combined with ., !, |, and * as above.   %(Spec) processes a specification defined in a specs file as *Spec:  %[Spec] as above, but put __ around -D arguments  The conditional text X in a %{S:X} or similar construct may contain other nested % constructs or spaces, or even newlines.  They are processed as usual, as described above.  Trailing white space in X is ignored.  White space may also appear anywhere on the left side of the colon in these constructs, except between . or * and the corresponding word.  The -O, -f, -m, and -W switches are handled specifically in these constructs.  If another value of -O or the negated form of a -f, -m, or -W switch is found later in the command line, the earlier switch value is ignored, except with {S*} where S is just one letter; this passes all matching options.  The character | at the beginning of the predicate text is used to indicate that a command should be piped to the following command, but only if -pipe is specified.  Note that it is built into CC which switches take arguments and which do not.  You might think it would be useful to generalize this to allow each compiler's spec to say which switches take arguments.  But this cannot be done in a consistent fashion.  CC cannot even decide which input files have been specified without knowing which switches take arguments, and it must know which input files to compile in order to tell which compilers to run.  CC also knows implicitly that arguments starting in `-l' are to be treated as compiler output files, and passed to the linker in their proper position among the other output files.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Define the macros used for specs %a, %l, %L, %S, %C, %1.  */
end_comment

begin_comment
comment|/* config.h can define ASM_SPEC to provide extra args to the assembler    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define ASM_FINAL_SPEC to run a post processor after    the assembler has run.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_FINAL_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_FINAL_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CPP_SPEC to provide extra args to the C preprocessor    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPP_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CPP_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CC1_SPEC to provide extra args to cc1 and cc1plus    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC1_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CC1_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CC1PLUS_SPEC to provide extra args to cc1plus    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC1PLUS_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CC1PLUS_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LINK_SPEC to provide extra args to the linker    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LINK_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LIB_SPEC to override the default libraries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIB_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LIB_SPEC
value|"%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* mudflap specs */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MFWRAP_SPEC
end_ifndef

begin_comment
comment|/* XXX: valid only for GNU ld */
end_comment

begin_comment
comment|/* XXX: should exactly match hooks provided by libmudflap.a */
end_comment

begin_define
define|#
directive|define
name|MFWRAP_SPEC
value|" %{static: %{fmudflap|fmudflapth: \  --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\  --wrap=mmap --wrap=munmap --wrap=alloca\ } %{fmudflapth: --wrap=pthread_create\ }} %{fmudflap|fmudflapth: --wrap=main}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MFLIB_SPEC
end_ifndef

begin_define
define|#
directive|define
name|MFLIB_SPEC
value|"%{fmudflap|fmudflapth: -export-dynamic}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LIBGCC_SPEC to override how and when libgcc.a is    included.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBGCC_SPEC
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REAL_LIBGCC_SPEC
argument_list|)
end_if

begin_define
define|#
directive|define
name|LIBGCC_SPEC
value|REAL_LIBGCC_SPEC
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|LINK_LIBGCC_SPECIAL_1
argument_list|)
end_elif

begin_comment
comment|/* Have gcc do the search for libgcc.a.  */
end_comment

begin_define
define|#
directive|define
name|LIBGCC_SPEC
value|"libgcc.a%s"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIBGCC_SPEC
value|"-lgcc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define STARTFILE_SPEC to override the default crt0 files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STARTFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|STARTFILE_SPEC
define|\
value|"%{!shared:%{pg:gcrt0%O%s}%{!pg:%{p:mcrt0%O%s}%{!p:crt0%O%s}}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define SWITCHES_NEED_SPACES to control which options    require spaces between the option and the argument.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCHES_NEED_SPACES
end_ifndef

begin_define
define|#
directive|define
name|SWITCHES_NEED_SPACES
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define ENDFILE_SPEC to override the default crtn files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENDFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ENDFILE_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINKER_NAME
end_ifndef

begin_define
define|#
directive|define
name|LINKER_NAME
value|"collect2"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define ASM_DEBUG_SPEC to be a spec suitable for translating '-g'    to the assembler.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_DEBUG_SPEC
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GDWARF2_DEBUG_FLAG
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GSTABS_DEBUG_FLAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
define|\
value|(PREFERRED_DEBUGGING_TYPE == DBX_DEBUG			\        ? "%{gdwarf-2*:--gdwarf2}%{!gdwarf-2*:%{g*:--gstabs}}"	\        : "%{gstabs*:--gstabs}%{!gstabs*:%{g*:--gdwarf2}}")
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GSTABS_DEBUG_FLAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
value|"%{g*:--gstabs}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_AS_GDWARF2_DEBUG_FLAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
value|"%{g*:--gdwarf2}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_DEBUG_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_DEBUG_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Here is the spec for running the linker, after compiling all files.  */
end_comment

begin_comment
comment|/* This is overridable by the target in case they need to specify the    -lgcc and -lc order specially, yet not require them to override all    of LINK_COMMAND_SPEC.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_GCC_C_SEQUENCE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LINK_GCC_C_SEQUENCE_SPEC
value|"%G %L %G"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_SSP_SPEC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_LIBC_PROVIDES_SSP
end_ifdef

begin_define
define|#
directive|define
name|LINK_SSP_SPEC
value|"%{fstack-protector:}"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LINK_SSP_SPEC
value|"%{fstack-protector|fstack-protector-all:-lssp_nonshared -lssp}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_PIE_SPEC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LD_PIE
end_ifdef

begin_define
define|#
directive|define
name|LINK_PIE_SPEC
value|"%{pie:-pie} "
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LINK_PIE_SPEC
value|"%{pie:} "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* -u* was put back because both BSD and SysV seem to support it.  */
end_comment

begin_comment
comment|/* %{static:} simply prevents an error message if the target machine    doesn't handle -static.  */
end_comment

begin_comment
comment|/* We want %{T*} after %{L*} and %D so that it can be used to specify linker    scripts which exist in user specified directories, or in standard    directories.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_COMMAND_SPEC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
end_ifndef

begin_define
define|#
directive|define
name|LINK_COMMAND_SPEC
value|"\ %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\     %(linker) %l " LINK_PIE_SPEC "%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\     %{fopenmp:%:include(libgomp.spec)%(link_gomp)} %(mflib)\     %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LINK_COMMAND_SPEC
value|"\ %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\     %(linker) %l " LINK_PIE_SPEC "%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\     %{fopenmp: -lgomp} %(mflib)\     %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_LIBGCC_SPEC
end_ifndef

begin_comment
comment|/* Generate -L options for startfile prefix list.  */
end_comment

begin_define
define|#
directive|define
name|LINK_LIBGCC_SPEC
value|"%D"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STARTFILE_PREFIX_SPEC
end_ifndef

begin_define
define|#
directive|define
name|STARTFILE_PREFIX_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSROOT_SPEC
end_ifndef

begin_define
define|#
directive|define
name|SYSROOT_SPEC
value|"--sysroot=%R"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSROOT_SUFFIX_SPEC
end_ifndef

begin_define
define|#
directive|define
name|SYSROOT_SUFFIX_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSROOT_HEADERS_SUFFIX_SPEC
end_ifndef

begin_define
define|#
directive|define
name|SYSROOT_HEADERS_SUFFIX_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_spec
init|=
name|CPP_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cc1_spec
init|=
name|CC1_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cc1plus_spec
init|=
name|CC1PLUS_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_gcc_c_sequence_spec
init|=
name|LINK_GCC_C_SEQUENCE_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_ssp_spec
init|=
name|LINK_SSP_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_spec
init|=
name|ASM_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_final_spec
init|=
name|ASM_FINAL_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_spec
init|=
name|LINK_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lib_spec
init|=
name|LIB_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mfwrap_spec
init|=
name|MFWRAP_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mflib_spec
init|=
name|MFLIB_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_gomp_spec
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|libgcc_spec
init|=
name|LIBGCC_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|endfile_spec
init|=
name|ENDFILE_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|startfile_spec
init|=
name|STARTFILE_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|switches_need_spaces
init|=
name|SWITCHES_NEED_SPACES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|linker_name_spec
init|=
name|LINKER_NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_command_spec
init|=
name|LINK_COMMAND_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|link_libgcc_spec
init|=
name|LINK_LIBGCC_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|startfile_prefix_spec
init|=
name|STARTFILE_PREFIX_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sysroot_spec
init|=
name|SYSROOT_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sysroot_suffix_spec
init|=
name|SYSROOT_SUFFIX_SPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sysroot_hdrs_suffix_spec
init|=
name|SYSROOT_HEADERS_SUFFIX_SPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard options to cpp, cc1, and as, to reduce duplication in specs.    There should be no need to override these in target dependent files,    but we need to copy them to the specs file so that newer versions    of the GCC driver can correctly drive older tool chains with the    appropriate -B options.  */
end_comment

begin_comment
comment|/* When cpplib handles traditional preprocessing, get rid of this, and    call cc1 (or cc1obj in objc/lang-specs.h) from the main specs so    that we default the front end language better.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|trad_capable_cpp
init|=
literal|"cc1 -E %{traditional|ftraditional|traditional-cpp:-traditional-cpp}"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We don't wrap .d files in %W{} since a missing .d file, and    therefore no dependency entry, confuses make into thinking a .o    file that happens to exist is up-to-date.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_unique_options
init|=
literal|"%{C|CC:%{!E:%eGCC does not support -C or -CC without -E}}\  %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I\  %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\  %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\  %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\  %{!E:%{!M:%{!MM:%{MD|MMD:%{o*:-MQ %*}}}}}\  %{remap} %{g3:-dD} %{H} %C %{D*&U*&A*} %{i*} %Z %i\  %{fmudflap:-D_MUDFLAP -include mf-runtime.h}\  %{fmudflapth:-D_MUDFLAP -D_MUDFLAPTH -include mf-runtime.h}\  %{E|M|MM:%W{o*}}"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This contains cpp options which are common with cc1_options and are passed    only when preprocessing only to avoid duplication.  We pass the cc1 spec    options to the preprocessor so that it the cc1 spec may manipulate    options used to set target flags.  Those special target flags settings may    in turn cause preprocessor symbols to be defined specially.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_options
init|=
literal|"%(cpp_unique_options) %1 %{m*} %{std*&ansi&trigraphs} %{W*&pedantic*} %{w}\  %{f*} %{g*:%{!g0:%{!fno-working-directory:-fworking-directory}}} %{O*}\  %{undef} %{save-temps:-fpch-preprocess}"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This contains cpp options which are not passed when the preprocessor    output will be used by another program.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpp_debug_options
init|=
literal|"%{d*}"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NB: This is shared amongst all front-ends.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cc1_options
init|=
literal|"%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\  %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\  %{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}%{!c:%{!S:-auxbase %b}}\  %{g*} %{O*} %{W*&pedantic*} %{w} %{std*&ansi&trigraphs}\  %{v:-version} %{pg:-p} %{p} %{f*} %{undef}\  %{Qn:-fno-ident} %{--help:--help}\  %{--target-help:--target-help}\  %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\  %{fsyntax-only:-o %j} %{-param*}\  %{fmudflap|fmudflapth:-fno-builtin -fno-merge-constants}\  %{coverage:-fprofile-arcs -ftest-coverage}"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_options
init|=
literal|"%a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|invoke_as
init|=
ifdef|#
directive|ifdef
name|AS_NEEDS_DASH_FOR_PIPED_INPUT
literal|"%{!S:-o %|.s |\n as %(asm_options) %|.s %A }"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|"%{!S:-o %|.s |\n as %(asm_options) %m.s %A }"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some compilers have limits on line lengths, and the multilib_select    and/or multilib_matches strings can be very long, so we build them at    run time.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|multilib_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_select
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_matches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_defaults
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_exclusions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check whether a particular argument is a default argument.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MULTILIB_DEFAULTS
end_ifndef

begin_define
define|#
directive|define
name|MULTILIB_DEFAULTS
value|{ "" }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|multilib_defaults_raw
index|[]
init|=
name|MULTILIB_DEFAULTS
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DRIVER_SELF_SPECS
end_ifndef

begin_define
define|#
directive|define
name|DRIVER_SELF_SPECS
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Adding -fopenmp should imply pthreads.  This is particularly important    for targets that use different start files and suchlike.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GOMP_SELF_SPECS
end_ifndef

begin_define
define|#
directive|define
name|GOMP_SELF_SPECS
value|"%{fopenmp: -pthread}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|driver_self_specs
index|[]
init|=
block|{
name|DRIVER_SELF_SPECS
block|,
name|GOMP_SELF_SPECS
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPTION_DEFAULT_SPECS
end_ifndef

begin_define
define|#
directive|define
name|OPTION_DEFAULT_SPECS
value|{ "", "" }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|default_spec
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|default_spec
name|option_default_specs
index|[]
init|=
block|{
name|OPTION_DEFAULT_SPECS
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|user_specs
block|{
name|struct
name|user_specs
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|user_specs
modifier|*
name|user_specs_head
decl_stmt|,
modifier|*
name|user_specs_tail
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|SWITCH_TAKES_ARG
parameter_list|(
name|CHAR
parameter_list|)
value|DEFAULT_SWITCH_TAKES_ARG(CHAR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WORD_SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
value|DEFAULT_WORD_SWITCH_TAKES_ARG (STR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TARGET_EXECUTABLE_SUFFIX
end_ifdef

begin_comment
comment|/* This defines which switches stop a full compilation.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SWITCH_CURTAILS_COMPILATION
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|((CHAR) == 'c' || (CHAR) == 'S')
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCH_CURTAILS_COMPILATION
end_ifndef

begin_define
define|#
directive|define
name|SWITCH_CURTAILS_COMPILATION
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|DEFAULT_SWITCH_CURTAILS_COMPILATION(CHAR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Record the mapping from file suffixes for compilation specs.  */
end_comment

begin_struct
struct|struct
name|compiler
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* Use this compiler for input files 				   whose names end in this suffix.  */
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* To use this compiler, run this spec.  */
specifier|const
name|char
modifier|*
name|cpp_spec
decl_stmt|;
comment|/* If non-NULL, substitute this spec 				   for `%C', rather than the usual 				   cpp_spec.  */
specifier|const
name|int
name|combinable
decl_stmt|;
comment|/* If nonzero, compiler can deal with 				    multiple source files at once (IMA).  */
specifier|const
name|int
name|needs_preprocessing
decl_stmt|;
comment|/* If nonzero, source files need to 				    be run through a preprocessor.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Pointer to a vector of `struct compiler' that gives the spec for    compiling a file, based on its suffix.    A file that does not end in any of these suffixes will be passed    unchanged to the loader and nothing else will be done to it.     An entry containing two 0s is used to terminate the vector.     If multiple entries match a file, the last matching one is used.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|compiler
modifier|*
name|compilers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in `compilers', not counting the null terminator.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_compilers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default list of file name suffixes and their compilation specs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|compiler
name|default_compilers
index|[]
init|=
block|{
comment|/* Add lists of suffixes of known languages here.  If those languages      were not present when we built the driver, we will hit these copies      and be given a more meaningful error than "file not used since      linking is not done".  */
block|{
literal|".m"
block|,
literal|"#Objective-C"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".mi"
block|,
literal|"#Objective-C"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".mm"
block|,
literal|"#Objective-C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".M"
block|,
literal|"#Objective-C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".mii"
block|,
literal|"#Objective-C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".cc"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".cxx"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".cpp"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".cp"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".c++"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".C"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".CPP"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".ii"
block|,
literal|"#C++"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".ads"
block|,
literal|"#Ada"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".adb"
block|,
literal|"#Ada"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".f"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".for"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".fpp"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".F"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".FOR"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".FPP"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".f90"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".f95"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".F90"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".F95"
block|,
literal|"#Fortran"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".r"
block|,
literal|"#Ratfor"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".p"
block|,
literal|"#Pascal"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".pas"
block|,
literal|"#Pascal"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".java"
block|,
literal|"#Java"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".class"
block|,
literal|"#Java"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".zip"
block|,
literal|"#Java"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".jar"
block|,
literal|"#Java"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Next come the entries for C.  */
block|{
literal|".c"
block|,
literal|"@c"
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"@c"
block|,
comment|/* cc1 has an integrated ISO C preprocessor.  We should invoke the       external preprocessor if -save-temps is given.  */
literal|"%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}\       %{!E:%{!M:%{!MM:\           %{traditional|ftraditional:\ %eGNU C no longer supports -traditional without -E}\        %{!combine:\ 	  %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \ 		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\ 		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \ 			%(cc1_options)}\ 	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\ 		cc1 %(cpp_unique_options) %(cc1_options)}}}\           %{!fsyntax-only:%(invoke_as)}} \       %{combine:\ 	  %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \ 		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i}}\ 	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\ 		cc1 %(cpp_unique_options) %(cc1_options)}}\                 %{!fsyntax-only:%(invoke_as)}}}}}}"
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"-"
block|,
literal|"%{!E:%e-E or -x required when input is from standard input}\     %(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".h"
block|,
literal|"@c-header"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"@c-header"
block|,
comment|/* cc1 has an integrated ISO C preprocessor.  We should invoke the       external preprocessor if -save-temps is given.  */
literal|"%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}\       %{!E:%{!M:%{!MM:\ 	  %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \ 		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\ 		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \ 			%(cc1_options)\                         -o %g.s %{!o*:--output-pch=%i.gch}\                         %W{o*:--output-pch=%*}%V}\ 	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\ 		cc1 %(cpp_unique_options) %(cc1_options)\                     -o %g.s %{!o*:--output-pch=%i.gch}\                     %W{o*:--output-pch=%*}%V}}}}}}"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".i"
block|,
literal|"@cpp-output"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"@cpp-output"
block|,
literal|"%{!M:%{!MM:%{!E:cc1 -fpreprocessed %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}}}}"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|".s"
block|,
literal|"@assembler"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"@assembler"
block|,
literal|"%{!M:%{!MM:%{!E:%{!S:as %(asm_debug) %(asm_options) %i %A }}}}"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|".S"
block|,
literal|"@assembler-with-cpp"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"@assembler-with-cpp"
block|,
ifdef|#
directive|ifdef
name|AS_NEEDS_DASH_FOR_PIPED_INPUT
literal|"%(trad_capable_cpp) -lang-asm %(cpp_options)\       %{E|M|MM:%(cpp_debug_options)}\       %{!M:%{!MM:%{!E:%{!S:-o %|.s |\n\        as %(asm_debug) %(asm_options) %|.s %A }}}}"
else|#
directive|else
literal|"%(trad_capable_cpp) -lang-asm %(cpp_options)\       %{E|M|MM:%(cpp_debug_options)}\       %{!M:%{!MM:%{!E:%{!S:-o %|.s |\n\        as %(asm_debug) %(asm_options) %m.s %A }}}}"
endif|#
directive|endif
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
include|#
directive|include
file|"specs.h"
comment|/* Mark end of table.  */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in default_compilers, not counting the terminator.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|n_default_compilers
init|=
name|ARRAY_SIZE
argument_list|(
name|default_compilers
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the linker.    These options are accumulated by %x,    and substituted into the linker command with %X.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_linker_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|linker_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the assembler.    These options are accumulated by -Wa,    and substituted into the assembler command with %Y.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_assembler_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|assembler_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of options to give to the preprocessor.    These options are accumulated by -Wp,    and substituted into the preprocessor command with %Z.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_preprocessor_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|preprocessor_options
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Define how to map long options into short ones.  */
end_comment

begin_comment
comment|/* This structure describes one mapping.  */
end_comment

begin_struct
struct|struct
name|option_map
block|{
comment|/* The long option's name.  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* The equivalent short option.  */
specifier|const
name|char
modifier|*
specifier|const
name|equivalent
decl_stmt|;
comment|/* Argument info.  A string of flag chars; NULL equals no options.      a => argument required.      o => argument optional.      j => join argument to equivalent, making one word.      * => require other text after NAME as an argument.  */
specifier|const
name|char
modifier|*
specifier|const
name|arg_info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the table of mappings.  Mappings are tried sequentially    for each option encountered; the first one that matches, wins.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option_map
name|option_map
index|[]
init|=
block|{
block|{
literal|"--all-warnings"
block|,
literal|"-Wall"
block|,
literal|0
block|}
block|,
block|{
literal|"--ansi"
block|,
literal|"-ansi"
block|,
literal|0
block|}
block|,
block|{
literal|"--assemble"
block|,
literal|"-S"
block|,
literal|0
block|}
block|,
block|{
literal|"--assert"
block|,
literal|"-A"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--classpath"
block|,
literal|"-fclasspath="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--bootclasspath"
block|,
literal|"-fbootclasspath="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--CLASSPATH"
block|,
literal|"-fclasspath="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--combine"
block|,
literal|"-combine"
block|,
literal|0
block|}
block|,
block|{
literal|"--comments"
block|,
literal|"-C"
block|,
literal|0
block|}
block|,
block|{
literal|"--comments-in-macros"
block|,
literal|"-CC"
block|,
literal|0
block|}
block|,
block|{
literal|"--compile"
block|,
literal|"-c"
block|,
literal|0
block|}
block|,
block|{
literal|"--debug"
block|,
literal|"-g"
block|,
literal|"oj"
block|}
block|,
block|{
literal|"--define-macro"
block|,
literal|"-D"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--dependencies"
block|,
literal|"-M"
block|,
literal|0
block|}
block|,
block|{
literal|"--dump"
block|,
literal|"-d"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--dumpbase"
block|,
literal|"-dumpbase"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--encoding"
block|,
literal|"-fencoding="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--entry"
block|,
literal|"-e"
block|,
literal|0
block|}
block|,
block|{
literal|"--extra-warnings"
block|,
literal|"-W"
block|,
literal|0
block|}
block|,
block|{
literal|"--extdirs"
block|,
literal|"-fextdirs="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--for-assembler"
block|,
literal|"-Wa"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--for-linker"
block|,
literal|"-Xlinker"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--force-link"
block|,
literal|"-u"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--coverage"
block|,
literal|"-coverage"
block|,
literal|0
block|}
block|,
block|{
literal|"--imacros"
block|,
literal|"-imacros"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include"
block|,
literal|"-include"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-barrier"
block|,
literal|"-I-"
block|,
literal|0
block|}
block|,
block|{
literal|"--include-directory"
block|,
literal|"-I"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--include-directory-after"
block|,
literal|"-idirafter"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-prefix"
block|,
literal|"-iprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix"
block|,
literal|"-iwithprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix-before"
block|,
literal|"-iwithprefixbefore"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--include-with-prefix-after"
block|,
literal|"-iwithprefix"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--language"
block|,
literal|"-x"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--library-directory"
block|,
literal|"-L"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--machine"
block|,
literal|"-m"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--machine-"
block|,
literal|"-m"
block|,
literal|"*j"
block|}
block|,
block|{
literal|"--no-integrated-cpp"
block|,
literal|"-no-integrated-cpp"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-line-commands"
block|,
literal|"-P"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-precompiled-includes"
block|,
literal|"-noprecomp"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-standard-includes"
block|,
literal|"-nostdinc"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-standard-libraries"
block|,
literal|"-nostdlib"
block|,
literal|0
block|}
block|,
block|{
literal|"--no-warnings"
block|,
literal|"-w"
block|,
literal|0
block|}
block|,
block|{
literal|"--optimize"
block|,
literal|"-O"
block|,
literal|"oj"
block|}
block|,
block|{
literal|"--output"
block|,
literal|"-o"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--output-class-directory"
block|,
literal|"-foutput-class-dir="
block|,
literal|"ja"
block|}
block|,
block|{
literal|"--param"
block|,
literal|"--param"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--pass-exit-codes"
block|,
literal|"-pass-exit-codes"
block|,
literal|0
block|}
block|,
block|{
literal|"--pedantic"
block|,
literal|"-pedantic"
block|,
literal|0
block|}
block|,
block|{
literal|"--pedantic-errors"
block|,
literal|"-pedantic-errors"
block|,
literal|0
block|}
block|,
block|{
literal|"--pie"
block|,
literal|"-pie"
block|,
literal|0
block|}
block|,
block|{
literal|"--pipe"
block|,
literal|"-pipe"
block|,
literal|0
block|}
block|,
block|{
literal|"--prefix"
block|,
literal|"-B"
block|,
literal|"a"
block|}
block|,
block|{
literal|"--preprocess"
block|,
literal|"-E"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-search-dirs"
block|,
literal|"-print-search-dirs"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-file-name"
block|,
literal|"-print-file-name="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--print-libgcc-file-name"
block|,
literal|"-print-libgcc-file-name"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-missing-file-dependencies"
block|,
literal|"-MG"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-multi-lib"
block|,
literal|"-print-multi-lib"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-multi-directory"
block|,
literal|"-print-multi-directory"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-multi-os-directory"
block|,
literal|"-print-multi-os-directory"
block|,
literal|0
block|}
block|,
block|{
literal|"--print-prog-name"
block|,
literal|"-print-prog-name="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--profile"
block|,
literal|"-p"
block|,
literal|0
block|}
block|,
block|{
literal|"--profile-blocks"
block|,
literal|"-a"
block|,
literal|0
block|}
block|,
block|{
literal|"--quiet"
block|,
literal|"-q"
block|,
literal|0
block|}
block|,
block|{
literal|"--resource"
block|,
literal|"-fcompile-resource="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--save-temps"
block|,
literal|"-save-temps"
block|,
literal|0
block|}
block|,
block|{
literal|"--shared"
block|,
literal|"-shared"
block|,
literal|0
block|}
block|,
block|{
literal|"--silent"
block|,
literal|"-q"
block|,
literal|0
block|}
block|,
block|{
literal|"--specs"
block|,
literal|"-specs="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--static"
block|,
literal|"-static"
block|,
literal|0
block|}
block|,
block|{
literal|"--std"
block|,
literal|"-std="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--symbolic"
block|,
literal|"-symbolic"
block|,
literal|0
block|}
block|,
block|{
literal|"--sysroot"
block|,
literal|"--sysroot="
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--time"
block|,
literal|"-time"
block|,
literal|0
block|}
block|,
block|{
literal|"--trace-includes"
block|,
literal|"-H"
block|,
literal|0
block|}
block|,
block|{
literal|"--traditional"
block|,
literal|"-traditional"
block|,
literal|0
block|}
block|,
block|{
literal|"--traditional-cpp"
block|,
literal|"-traditional-cpp"
block|,
literal|0
block|}
block|,
block|{
literal|"--trigraphs"
block|,
literal|"-trigraphs"
block|,
literal|0
block|}
block|,
block|{
literal|"--undefine-macro"
block|,
literal|"-U"
block|,
literal|"aj"
block|}
block|,
block|{
literal|"--user-dependencies"
block|,
literal|"-MM"
block|,
literal|0
block|}
block|,
block|{
literal|"--verbose"
block|,
literal|"-v"
block|,
literal|0
block|}
block|,
block|{
literal|"--warn-"
block|,
literal|"-W"
block|,
literal|"*j"
block|}
block|,
block|{
literal|"--write-dependencies"
block|,
literal|"-MD"
block|,
literal|0
block|}
block|,
block|{
literal|"--write-user-dependencies"
block|,
literal|"-MMD"
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
literal|"-f"
block|,
literal|"*j"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OPTION_TRANSLATE_TABLE
end_ifdef

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|option_found
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|replacements
decl_stmt|;
block|}
name|target_option_translations
index|[]
init|=
block|{
name|TARGET_OPTION_TRANSLATE_TABLE
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate the options described by *ARGCP and *ARGVP.    Make a new vector and store it back in *ARGVP,    and store its length in *ARGVC.  */
end_comment

begin_function
specifier|static
name|void
name|translate_options
parameter_list|(
name|int
modifier|*
name|argcp
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
modifier|*
name|argvp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|argc
init|=
operator|*
name|argcp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|argv
init|=
operator|*
name|argvp
decl_stmt|;
name|int
name|newvsize
init|=
operator|(
name|argc
operator|+
literal|2
operator|)
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|newv
init|=
name|xmalloc
argument_list|(
name|newvsize
argument_list|)
decl_stmt|;
name|int
name|newindex
init|=
literal|0
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|argc
condition|)
block|{
ifdef|#
directive|ifdef
name|TARGET_OPTION_TRANSLATE_TABLE
name|int
name|tott_idx
decl_stmt|;
for|for
control|(
name|tott_idx
operator|=
literal|0
init|;
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|option_found
condition|;
name|tott_idx
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|option_found
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|spaces
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|replacements
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|' '
condition|)
name|spaces
operator|++
expr_stmt|;
block|}
name|newvsize
operator|+=
name|spaces
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|newv
operator|=
name|xrealloc
argument_list|(
name|newv
argument_list|,
name|newvsize
argument_list|)
expr_stmt|;
name|sp
operator|=
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|replacements
expr_stmt|;
name|np
operator|=
name|xstrdup
argument_list|(
name|sp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|np
operator|==
literal|' '
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|0
condition|)
break|break;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|np
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|!=
literal|' '
operator|&&
operator|*
name|np
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|0
condition|)
break|break;
operator|*
name|np
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target_option_translations
index|[
name|tott_idx
index|]
operator|.
name|option_found
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Translate -- options.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|size_t
name|j
decl_stmt|;
comment|/* Find a mapping that applies to this option.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|option_map
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|size_t
name|optlen
init|=
name|strlen
argument_list|(
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|size_t
name|arglen
init|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|size_t
name|complen
init|=
name|arglen
operator|>
name|optlen
condition|?
name|optlen
else|:
name|arglen
decl_stmt|;
specifier|const
name|char
modifier|*
name|arginfo
init|=
name|option_map
index|[
name|j
index|]
operator|.
name|arg_info
decl_stmt|;
if|if
condition|(
name|arginfo
operator|==
literal|0
condition|)
name|arginfo
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|complen
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arglen
operator|<
name|optlen
condition|)
block|{
name|size_t
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
name|ARRAY_SIZE
argument_list|(
name|option_map
argument_list|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
name|option_map
index|[
name|k
index|]
operator|.
name|name
argument_list|)
operator|>=
name|arglen
operator|&&
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|option_map
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|arglen
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous abbreviation %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|k
operator|!=
name|ARRAY_SIZE
argument_list|(
name|option_map
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|arglen
operator|>
name|optlen
condition|)
block|{
comment|/* If the option has an argument, accept that.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|optlen
index|]
operator|==
literal|'='
condition|)
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|optlen
operator|+
literal|1
expr_stmt|;
comment|/* If this mapping requires extra text at end of name, 			 accept that as "argument".  */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|optlen
expr_stmt|;
comment|/* Otherwise, extra text at end means mismatch. 			 Try other mappings.  */
else|else
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"incomplete '%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Handle arguments.  */
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'a'
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"missing argument to '%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'o'
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"extraneous argument to '%s' option"
argument_list|,
name|option_map
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Store the translation as one argv elt or as two.  */
if|if
condition|(
name|arg
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|arginfo
argument_list|,
literal|'j'
argument_list|)
operator|!=
literal|0
condition|)
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|concat
argument_list|(
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
literal|0
condition|)
block|{
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
expr_stmt|;
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
else|else
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|option_map
index|[
name|j
index|]
operator|.
name|equivalent
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* Handle old-fashioned options--just copy them through, 	 with their arguments.  */
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
name|int
name|nskip
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
name|nskip
operator|+=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|nskip
operator|+=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
literal|'x'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"Xlinker"
argument_list|)
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"Xpreprocessor"
argument_list|)
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"Xassembler"
argument_list|)
condition|)
name|nskip
operator|+=
literal|1
expr_stmt|;
comment|/* Watch out for an option at the end of the command line that 	     is missing arguments, and avoid skipping past the end of the 	     command line.  */
if|if
condition|(
name|nskip
operator|+
name|i
operator|>
name|argc
condition|)
name|nskip
operator|=
name|argc
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|nskip
operator|>
literal|0
condition|)
block|{
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
name|nskip
operator|--
expr_stmt|;
block|}
block|}
else|else
comment|/* Ordinary operands, or +e options.  */
name|newv
index|[
name|newindex
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
name|newv
index|[
name|newindex
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|argvp
operator|=
name|newv
expr_stmt|;
operator|*
name|argcp
operator|=
name|newindex
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|skip_whitespace
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* A fully-blank line is a delimiter in the SPEC file and shouldn't 	 be considered whitespace.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
return|return
name|p
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Structures to keep track of prefixes to try when looking for files.  */
end_comment

begin_struct
struct|struct
name|prefix_list
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* String to prepend to the path.  */
name|struct
name|prefix_list
modifier|*
name|next
decl_stmt|;
comment|/* Next in linked list.  */
name|int
name|require_machine_suffix
decl_stmt|;
comment|/* Don't use without machine_suffix.  */
comment|/* 2 means try both machine_suffix and just_machine_suffix.  */
name|int
name|priority
decl_stmt|;
comment|/* Sort key - priority within list.  */
name|int
name|os_multilib
decl_stmt|;
comment|/* 1 if OS multilib scheme should be used, 				 0 for GCC multilib scheme.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|path_prefix
block|{
name|struct
name|prefix_list
modifier|*
name|plist
decl_stmt|;
comment|/* List of prefixes to try */
name|int
name|max_len
decl_stmt|;
comment|/* Max length of a prefix in PLIST */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of this list (used in config stuff) */
block|}
struct|;
end_struct

begin_comment
comment|/* List of prefixes to try when looking for executables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|exec_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"exec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of prefixes to try when looking for startup (crt0) files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|startfile_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"startfile"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of prefixes to try when looking for include files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|include_prefixes
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"include"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suffix to attach to directories searched for commands.    This looks like `MACHINE/VERSION/'.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|machine_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suffix to attach to directories searched for commands.    This is just `MACHINE/'.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|just_machine_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjusted value of GCC_EXEC_PREFIX envvar.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gcc_exec_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjusted value of standard_libexec_prefix.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gcc_libexec_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default prefixes to attach to command names.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_STARTFILE_PREFIX_1
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_STARTFILE_PREFIX_1
value|"/lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_STARTFILE_PREFIX_2
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_STARTFILE_PREFIX_2
value|"/usr/lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_comment
comment|/* Don't use these prefixes for a cross compiler.  */
end_comment

begin_undef
undef|#
directive|undef
name|MD_EXEC_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|MD_STARTFILE_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|MD_STARTFILE_PREFIX_1
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If no prefixes defined, use the null string, which will disable them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MD_EXEC_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|MD_EXEC_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MD_STARTFILE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|MD_STARTFILE_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MD_STARTFILE_PREFIX_1
end_ifndef

begin_define
define|#
directive|define
name|MD_STARTFILE_PREFIX_1
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_exec_prefix
init|=
name|STANDARD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_exec_prefix_1
init|=
literal|"/usr/libexec/gcc/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_exec_prefix_2
init|=
literal|"/usr/lib/gcc/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|md_exec_prefix
init|=
name|MD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|md_startfile_prefix
init|=
name|MD_STARTFILE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|md_startfile_prefix_1
init|=
name|MD_STARTFILE_PREFIX_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_startfile_prefix
init|=
name|STANDARD_STARTFILE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_startfile_prefix_1
init|=
name|STANDARD_STARTFILE_PREFIX_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_startfile_prefix_2
init|=
name|STANDARD_STARTFILE_PREFIX_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tooldir_base_prefix
init|=
name|TOOLDIR_BASE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tooldir_prefix
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_bindir_prefix
init|=
name|STANDARD_BINDIR_PREFIX
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not FREEBSD_NATIVE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|standard_libexec_prefix
init|=
name|STANDARD_LIBEXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subdirectory to use for locating libraries.  Set by    set_multilib_dir based on the compilation options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subdirectory to use for locating libraries in OS conventions.  Set by    set_multilib_dir based on the compilation options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|multilib_os_dir
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Structure to keep track of the specs that have been defined so far.    These are accessed using %(specname) or %[specname] in a compiler    or link spec.  */
end_comment

begin_struct
struct|struct
name|spec_list
block|{
comment|/* The following 2 fields must be first */
comment|/* to allow EXTRA_SPECS to be initialized */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the spec.  */
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* available ptr if no static pointer */
comment|/* The following fields are not initialized */
comment|/* by EXTRA_SPECS */
specifier|const
name|char
modifier|*
modifier|*
name|ptr_spec
decl_stmt|;
comment|/* pointer to the spec itself.  */
name|struct
name|spec_list
modifier|*
name|next
decl_stmt|;
comment|/* Next spec in linked list.  */
name|int
name|name_len
decl_stmt|;
comment|/* length of the name */
name|int
name|alloc_p
decl_stmt|;
comment|/* whether string was allocated */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INIT_STATIC_SPEC
parameter_list|(
name|NAME
parameter_list|,
name|PTR
parameter_list|)
define|\
value|{ NAME, NULL, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, 0 }
end_define

begin_comment
comment|/* List of statically defined specs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spec_list
name|static_specs
index|[]
init|=
block|{
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm"
argument_list|,
operator|&
name|asm_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm_debug"
argument_list|,
operator|&
name|asm_debug
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm_final"
argument_list|,
operator|&
name|asm_final_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"asm_options"
argument_list|,
operator|&
name|asm_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"invoke_as"
argument_list|,
operator|&
name|invoke_as
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cpp"
argument_list|,
operator|&
name|cpp_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cpp_options"
argument_list|,
operator|&
name|cpp_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cpp_debug_options"
argument_list|,
operator|&
name|cpp_debug_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cpp_unique_options"
argument_list|,
operator|&
name|cpp_unique_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"trad_capable_cpp"
argument_list|,
operator|&
name|trad_capable_cpp
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cc1"
argument_list|,
operator|&
name|cc1_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cc1_options"
argument_list|,
operator|&
name|cc1_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cc1plus"
argument_list|,
operator|&
name|cc1plus_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"link_gcc_c_sequence"
argument_list|,
operator|&
name|link_gcc_c_sequence_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"link_ssp"
argument_list|,
operator|&
name|link_ssp_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"endfile"
argument_list|,
operator|&
name|endfile_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"link"
argument_list|,
operator|&
name|link_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"lib"
argument_list|,
operator|&
name|lib_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"mfwrap"
argument_list|,
operator|&
name|mfwrap_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"mflib"
argument_list|,
operator|&
name|mflib_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"link_gomp"
argument_list|,
operator|&
name|link_gomp_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"libgcc"
argument_list|,
operator|&
name|libgcc_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"startfile"
argument_list|,
operator|&
name|startfile_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"switches_need_spaces"
argument_list|,
operator|&
name|switches_need_spaces
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"cross_compile"
argument_list|,
operator|&
name|cross_compile
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"version"
argument_list|,
operator|&
name|compiler_version
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib"
argument_list|,
operator|&
name|multilib_select
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_defaults"
argument_list|,
operator|&
name|multilib_defaults
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_extra"
argument_list|,
operator|&
name|multilib_extra
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_matches"
argument_list|,
operator|&
name|multilib_matches
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_exclusions"
argument_list|,
operator|&
name|multilib_exclusions
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"multilib_options"
argument_list|,
operator|&
name|multilib_options
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"linker"
argument_list|,
operator|&
name|linker_name_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"link_libgcc"
argument_list|,
operator|&
name|link_libgcc_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"md_exec_prefix"
argument_list|,
operator|&
name|md_exec_prefix
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"md_startfile_prefix"
argument_list|,
operator|&
name|md_startfile_prefix
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"md_startfile_prefix_1"
argument_list|,
operator|&
name|md_startfile_prefix_1
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"startfile_prefix_spec"
argument_list|,
operator|&
name|startfile_prefix_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"sysroot_spec"
argument_list|,
operator|&
name|sysroot_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"sysroot_suffix_spec"
argument_list|,
operator|&
name|sysroot_suffix_spec
argument_list|)
block|,
name|INIT_STATIC_SPEC
argument_list|(
literal|"sysroot_hdrs_suffix_spec"
argument_list|,
operator|&
name|sysroot_hdrs_suffix_spec
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SPECS
end_ifdef

begin_comment
comment|/* additional specs needed */
end_comment

begin_comment
comment|/* Structure to keep track of just the first two args of a spec_list.    That is all that the EXTRA_SPECS macro gives us.  */
end_comment

begin_struct
struct|struct
name|spec_list_1
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|ptr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|spec_list_1
name|extra_specs_1
index|[]
init|=
block|{
name|EXTRA_SPECS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|spec_list
modifier|*
name|extra_specs
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of dynamically allocates specs that have been defined so far.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spec_list
modifier|*
name|specs
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* List of static spec functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|spec_function
name|static_spec_functions
index|[]
init|=
block|{
block|{
literal|"if-exists"
block|,
name|if_exists_spec_function
block|}
block|,
block|{
literal|"if-exists-else"
block|,
name|if_exists_else_spec_function
block|}
block|,
block|{
literal|"replace-outfile"
block|,
name|replace_outfile_spec_function
block|}
block|,
block|{
literal|"version-compare"
block|,
name|version_compare_spec_function
block|}
block|,
block|{
literal|"include"
block|,
name|include_spec_function
block|}
block|,
ifdef|#
directive|ifdef
name|EXTRA_SPEC_FUNCTIONS
name|EXTRA_SPEC_FUNCTIONS
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|processing_spec_function
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add appropriate libgcc specs to OBSTACK, taking into account    various permutations of -shared-libgcc, -shared, and such.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_SHARED_LIBGCC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REAL_LIBGCC_SPEC
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|USE_LD_AS_NEEDED
end_ifndef

begin_define
define|#
directive|define
name|USE_LD_AS_NEEDED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|init_gcc_specs
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|,
specifier|const
name|char
modifier|*
name|shared_name
parameter_list|,
specifier|const
name|char
modifier|*
name|static_name
parameter_list|,
specifier|const
name|char
modifier|*
name|eh_name
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|concat
argument_list|(
literal|"%{pg:"
argument_list|,
name|static_name
argument_list|,
literal|" "
argument_list|,
name|eh_name
argument_list|,
literal|"} %{!pg:"
argument_list|,
literal|"%{static|static-libgcc|pg:"
argument_list|,
name|static_name
argument_list|,
literal|" "
argument_list|,
name|eh_name
argument_list|,
literal|"}"
literal|"%{!static:%{!static-libgcc:"
if|#
directive|if
name|USE_LD_AS_NEEDED
literal|"%{!shared-libgcc:"
argument_list|,
name|static_name
argument_list|,
literal|" --as-needed "
argument_list|,
name|shared_name
argument_list|,
literal|" --no-as-needed"
literal|"}"
literal|"%{shared-libgcc:"
argument_list|,
name|shared_name
argument_list|,
literal|"%{!shared: "
argument_list|,
name|static_name
argument_list|,
literal|"}"
literal|"}"
else|#
directive|else
literal|"%{!shared:"
literal|"%{!shared-libgcc:"
argument_list|,
name|static_name
argument_list|,
literal|" "
argument_list|,
name|eh_name
argument_list|,
literal|"}"
literal|"%{shared-libgcc:"
argument_list|,
name|shared_name
argument_list|,
literal|" "
argument_list|,
name|static_name
argument_list|,
literal|"}"
literal|"}"
ifdef|#
directive|ifdef
name|LINK_EH_SPEC
literal|"%{shared:"
literal|"%{shared-libgcc:"
argument_list|,
name|shared_name
argument_list|,
literal|"}"
literal|"%{!shared-libgcc:"
argument_list|,
name|static_name
argument_list|,
literal|"}"
literal|"}"
else|#
directive|else
literal|"%{shared:"
argument_list|,
name|shared_name
argument_list|,
literal|"}"
endif|#
directive|endif
endif|#
directive|endif
literal|"}}}"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_SHARED_LIBGCC */
end_comment

begin_comment
comment|/* Initialize the specs lookup routines.  */
end_comment

begin_function
specifier|static
name|void
name|init_spec
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|spec_list
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|sl
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|specs
condition|)
return|return;
comment|/* Already initialized.  */
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"Using built-in specs.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_SPECS
name|extra_specs
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_list
argument_list|)
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|extra_specs_1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|extra_specs_1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sl
operator|=
operator|&
name|extra_specs
index|[
name|i
index|]
expr_stmt|;
name|sl
operator|->
name|name
operator|=
name|extra_specs_1
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|sl
operator|->
name|ptr
operator|=
name|extra_specs_1
index|[
name|i
index|]
operator|.
name|ptr
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|sl
operator|->
name|name_len
operator|=
name|strlen
argument_list|(
name|sl
operator|->
name|name
argument_list|)
expr_stmt|;
name|sl
operator|->
name|ptr_spec
operator|=
operator|&
name|sl
operator|->
name|ptr
expr_stmt|;
name|next
operator|=
name|sl
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize here, not in definition.  The IRIX 6 O32 cc sometimes chokes      on ?: in file-scope variable initializations.  */
name|asm_debug
operator|=
name|ASM_DEBUG_SPEC
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|static_specs
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sl
operator|=
operator|&
name|static_specs
index|[
name|i
index|]
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|sl
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_SHARED_LIBGCC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REAL_LIBGCC_SPEC
argument_list|)
comment|/* ??? If neither -shared-libgcc nor --static-libgcc was      seen, then we should be making an educated guess.  Some proposed      heuristics for ELF include:  	(1) If "-Wl,--export-dynamic", then it's a fair bet that the 	    program will be doing dynamic loading, which will likely 	    need the shared libgcc.  	(2) If "-ldl", then it's also a fair bet that we're doing 	    dynamic loading.  	(3) For each ET_DYN we're linking against (either through -lfoo 	    or /some/path/foo.so), check to see whether it or one of 	    its dependencies depends on a shared libgcc.  	(4) If "-shared"  	    If the runtime is fixed to look for program headers instead 	    of calling __register_frame_info at all, for each object, 	    use the shared libgcc if any EH symbol referenced.  	    If crtstuff is fixed to not invoke __register_frame_info 	    automatically, for each object, use the shared libgcc if 	    any non-empty unwind section found.       Doing any of this probably requires invoking an external program to      do the actual object file scanning.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|libgcc_spec
decl_stmt|;
name|int
name|in_sep
init|=
literal|1
decl_stmt|;
comment|/* Transform the extant libgcc_spec into one that uses the shared libgcc        when given the proper command line arguments.  */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|in_sep
operator|&&
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-lgcc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|init_gcc_specs
argument_list|(
operator|&
name|obstack
argument_list|,
literal|"-lgcc_s"
ifdef|#
directive|ifdef
name|USE_LIBUNWIND_EXCEPTIONS
literal|" -lunwind"
endif|#
directive|endif
argument_list|,
ifdef|#
directive|ifdef
name|FREEBSD_NATIVE
name|LIBGCC_STATIC_LIB_SPEC
argument_list|,
name|LIBGCC_EH_STATIC_LIB_SPEC
else|#
directive|else
literal|"-lgcc"
argument_list|,
literal|"-lgcc_eh"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LIBUNWIND_EXCEPTIONS
ifdef|#
directive|ifdef
name|HAVE_LD_STATIC_DYNAMIC
literal|" %{!static:-Bstatic} -lunwind %{!static:-Bdynamic}"
else|#
directive|else
literal|" -lunwind"
endif|#
directive|endif
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
name|in_sep
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_sep
operator|&&
operator|*
name|p
operator|==
literal|'l'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"libgcc.a%s"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Ug.  We don't know shared library extensions.  Hope that 	       systems that use this form don't do shared libraries.  */
name|init_gcc_specs
argument_list|(
operator|&
name|obstack
argument_list|,
literal|"-lgcc_s"
argument_list|,
literal|"libgcc.a%s"
argument_list|,
literal|"libgcc_eh.a%s"
ifdef|#
directive|ifdef
name|USE_LIBUNWIND_EXCEPTIONS
literal|" -lunwind"
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|10
expr_stmt|;
name|in_sep
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|in_sep
operator|=
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|libgcc_spec
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_AS_TRADITIONAL_FORMAT
comment|/* Prepend "--traditional-format" to whatever asm_spec we had before.  */
block|{
specifier|static
specifier|const
name|char
name|tf
index|[]
init|=
literal|"--traditional-format "
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|tf
argument_list|,
sizeof|sizeof
argument_list|(
name|tf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|asm_spec
argument_list|,
name|strlen
argument_list|(
name|asm_spec
argument_list|)
argument_list|)
expr_stmt|;
name|asm_spec
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LINK_EH_SPEC
comment|/* Prepend LINK_EH_SPEC to whatever link_spec we had before.  */
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|LINK_EH_SPEC
argument_list|,
sizeof|sizeof
argument_list|(
name|LINK_EH_SPEC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|link_spec
argument_list|,
name|strlen
argument_list|(
name|link_spec
argument_list|)
argument_list|)
expr_stmt|;
name|link_spec
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|specs
operator|=
name|sl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is    removed; If the spec starts with a + then SPEC is added to the end of the    current spec.  */
end_comment

begin_function
specifier|static
name|void
name|set_spec
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_spec
decl_stmt|;
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If this is the first call, initialize the statically allocated specs.  */
if|if
condition|(
operator|!
name|specs
condition|)
block|{
name|struct
name|spec_list
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_list
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|static_specs
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sl
operator|=
operator|&
name|static_specs
index|[
name|i
index|]
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|sl
expr_stmt|;
block|}
name|specs
operator|=
name|sl
expr_stmt|;
block|}
comment|/* See if the spec already exists.  */
for|for
control|(
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|name_len
operator|==
name|sl
operator|->
name|name_len
operator|&&
operator|!
name|strcmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|sl
condition|)
block|{
comment|/* Not found - make it.  */
name|sl
operator|=
name|XNEW
argument_list|(
expr|struct
name|spec_list
argument_list|)
expr_stmt|;
name|sl
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sl
operator|->
name|name_len
operator|=
name|name_len
expr_stmt|;
name|sl
operator|->
name|ptr_spec
operator|=
operator|&
name|sl
operator|->
name|ptr
expr_stmt|;
name|sl
operator|->
name|alloc_p
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
operator|=
literal|""
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|specs
expr_stmt|;
name|specs
operator|=
name|sl
expr_stmt|;
block|}
name|old_spec
operator|=
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
expr_stmt|;
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
operator|=
operator|(
operator|(
name|spec
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|spec
index|[
literal|1
index|]
argument_list|)
operator|)
condition|?
name|concat
argument_list|(
name|old_spec
argument_list|,
name|spec
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
else|:
name|xstrdup
argument_list|(
name|spec
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPECS
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"Setting spec %s to '%s'\n\n"
argument_list|,
name|name
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Free the old spec.  */
if|if
condition|(
name|old_spec
operator|&&
name|sl
operator|->
name|alloc_p
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|old_spec
argument_list|)
expr_stmt|;
name|sl
operator|->
name|alloc_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Accumulate a command (program name and args), and run it.  */
end_comment

begin_comment
comment|/* Vector of pointers to arguments in the current line of specifications.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|argbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated in argbuf.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argbuf_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in argbuf currently in use (containing args).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argbuf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position in the argbuf array containing the name of the output file    (the value associated with the "-o" flag).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_o_argbuf_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Were the options -c or -S passed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_c
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Was the option -o passed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_o
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the list of suffixes and codes (%g/%u/%U/%j) and the associated    temp file.  If the HOST_BIT_BUCKET is used for %j, no entry is made for    it here.  */
end_comment

begin_struct
specifier|static
struct|struct
name|temp_name
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* suffix associated with the code.  */
name|int
name|length
decl_stmt|;
comment|/* strlen (suffix).  */
name|int
name|unique
decl_stmt|;
comment|/* Indicates whether %g or %u/%U was used.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* associated filename.  */
name|int
name|filename_length
decl_stmt|;
comment|/* strlen (filename).  */
name|struct
name|temp_name
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|temp_names
struct|;
end_struct

begin_comment
comment|/* Number of commands executed so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|execution_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of commands that exited with a signal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|signal_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name with which this program was invoked.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|programname
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate the argument vector.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_args
parameter_list|(
name|void
parameter_list|)
block|{
name|argbuf_length
operator|=
literal|10
expr_stmt|;
name|argbuf
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|argbuf_length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out the vector of arguments (after a command is executed).  */
end_comment

begin_function
specifier|static
name|void
name|clear_args
parameter_list|(
name|void
parameter_list|)
block|{
name|argbuf_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add one argument to the vector at the end.    This is done when a space is seen or at the end of the line.    If DELETE_ALWAYS is nonzero, the arg is a filename     and the file should be deleted eventually.    If DELETE_FAILURE is nonzero, the arg is a filename     and the file should be deleted if this compilation fails.  */
end_comment

begin_function
specifier|static
name|void
name|store_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|delete_always
parameter_list|,
name|int
name|delete_failure
parameter_list|)
block|{
if|if
condition|(
name|argbuf_index
operator|+
literal|1
operator|==
name|argbuf_length
condition|)
name|argbuf
operator|=
name|xrealloc
argument_list|(
name|argbuf
argument_list|,
operator|(
name|argbuf_length
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argbuf
index|[
name|argbuf_index
operator|++
index|]
operator|=
name|arg
expr_stmt|;
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
name|have_o_argbuf_index
operator|=
name|argbuf_index
expr_stmt|;
if|if
condition|(
name|delete_always
operator|||
name|delete_failure
condition|)
name|record_temp_file
argument_list|(
name|arg
argument_list|,
name|delete_always
argument_list|,
name|delete_failure
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load specs from a file name named FILENAME, replacing occurrences of    various different types of line-endings, \r\n, \n\r and just \r, with    a single \n.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|load_specs
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|desc
decl_stmt|;
name|int
name|readlen
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|buffer_p
decl_stmt|;
name|char
modifier|*
name|specs
decl_stmt|;
name|char
modifier|*
name|specs_p
decl_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"Reading specs from %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Open and stat the file.  */
name|desc
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Read contents of file into BUFFER.  */
name|buffer
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|readlen
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|statbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|buffer
index|[
name|readlen
index|]
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|specs
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|readlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|specs_p
operator|=
name|specs
expr_stmt|;
for|for
control|(
name|buffer_p
operator|=
name|buffer
init|;
name|buffer_p
operator|&&
operator|*
name|buffer_p
condition|;
name|buffer_p
operator|++
control|)
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|char
name|c
init|=
operator|*
name|buffer_p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|buffer_p
operator|>
name|buffer
operator|&&
operator|*
operator|(
name|buffer_p
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
comment|/* \n\r */
name|skip
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|buffer_p
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
comment|/* \r\n */
name|skip
operator|=
literal|1
expr_stmt|;
else|else
comment|/* \r */
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
operator|*
name|specs_p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|specs_p
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|specs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read compilation specs from a file named FILENAME,    replacing the default ones.     A suffix which starts with `*' is a definition for    one of the machine-specific sub-specs.  The "suffix" should be    *asm, *cc1, *cpp, *link, *startfile, etc.    The corresponding spec is stored in asm_spec, etc.,    rather than in the `compilers' vector.     Anything invalid in the file is a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|read_specs
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|main_p
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|buffer
operator|=
name|load_specs
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Scan BUFFER for specs, putting them in the vector.  */
name|p
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|spec
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
comment|/* Advance P in BUFFER to the next nonblank nocomment line.  */
name|p
operator|=
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
comment|/* Is this a special command that starts with '%'? */
comment|/* Don't allow this for the main specs file, since it would 	 encourage people to overwrite it.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&&
operator|!
name|main_p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip '\n'.  */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
literal|"%include"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"%include"
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|p1
index|[
sizeof|sizeof
expr|"%include"
operator|-
literal|1
expr|]
operator|==
literal|' '
operator|||
name|p1
index|[
sizeof|sizeof
expr|"%include"
operator|-
literal|1
expr|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|char
modifier|*
name|new_filename
decl_stmt|;
name|p1
operator|+=
sizeof|sizeof
argument_list|(
literal|"%include"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
literal|'<'
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'>'
condition|)
name|fatal
argument_list|(
literal|"specs %%include syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
index|[
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_filename
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|p1
argument_list|,
name|R_OK
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|read_specs
argument_list|(
name|new_filename
condition|?
name|new_filename
else|:
name|p1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
literal|"%include_noerr"
argument_list|,
sizeof|sizeof
expr|"%include_noerr"
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|p1
index|[
sizeof|sizeof
expr|"%include_noerr"
operator|-
literal|1
expr|]
operator|==
literal|' '
operator|||
name|p1
index|[
sizeof|sizeof
expr|"%include_noerr"
operator|-
literal|1
expr|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|char
modifier|*
name|new_filename
decl_stmt|;
name|p1
operator|+=
sizeof|sizeof
expr|"%include_noerr"
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
literal|'<'
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'>'
condition|)
name|fatal
argument_list|(
literal|"specs %%include syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
index|[
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_filename
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|p1
argument_list|,
name|R_OK
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_filename
condition|)
name|read_specs
argument_list|(
name|new_filename
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose_flag
condition|)
name|notice
argument_list|(
literal|"could not find specs file %s\n"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
literal|"%rename"
argument_list|,
sizeof|sizeof
expr|"%rename"
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|p1
index|[
sizeof|sizeof
expr|"%rename"
operator|-
literal|1
expr|]
operator|==
literal|' '
operator|||
name|p1
index|[
sizeof|sizeof
expr|"%rename"
operator|-
literal|1
expr|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|int
name|name_len
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|newsl
decl_stmt|;
comment|/* Get original name.  */
name|p1
operator|+=
sizeof|sizeof
expr|"%rename"
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p1
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p2
argument_list|)
condition|)
name|p2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p2
operator|!=
literal|' '
operator|&&
operator|*
name|p2
operator|!=
literal|'\t'
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p2
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|name_len
operator|=
name|p2
operator|-
name|p1
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|==
literal|' '
operator|||
operator|*
name|p2
operator|==
literal|'\t'
condition|)
name|p2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p2
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p2
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get new spec name.  */
name|p3
operator|=
name|p2
expr_stmt|;
while|while
condition|(
operator|*
name|p3
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p3
argument_list|)
condition|)
name|p3
operator|++
expr_stmt|;
if|if
condition|(
name|p3
operator|!=
name|p
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"specs %%rename syntax malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p3
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p3
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|name_len
operator|==
name|sl
operator|->
name|name_len
operator|&&
operator|!
name|strcmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|p1
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|sl
condition|)
name|fatal
argument_list|(
literal|"specs %s spec was not found to be renamed"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|newsl
operator|=
name|specs
init|;
name|newsl
condition|;
name|newsl
operator|=
name|newsl
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|newsl
operator|->
name|name
argument_list|,
name|p2
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: attempt to rename spec '%s' to already defined spec '%s'"
argument_list|,
name|filename
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|notice
argument_list|(
literal|"rename spec %s to %s\n"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPECS
name|notice
argument_list|(
literal|"spec is '%s'\n\n"
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|set_spec
argument_list|(
name|p2
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl
operator|->
name|alloc_p
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
operator|=
literal|""
expr_stmt|;
name|sl
operator|->
name|alloc_p
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
name|fatal
argument_list|(
literal|"specs unknown %% command after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find the colon that should end the suffix.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|':'
operator|&&
operator|*
name|p1
operator|!=
literal|'\n'
condition|)
name|p1
operator|++
expr_stmt|;
comment|/* The colon shouldn't be missing.  */
if|if
condition|(
operator|*
name|p1
operator|!=
literal|':'
condition|)
name|fatal
argument_list|(
literal|"specs file malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p1
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip back over trailing whitespace.  */
name|p2
operator|=
name|p1
expr_stmt|;
while|while
condition|(
name|p2
operator|>
name|buffer
operator|&&
operator|(
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p2
operator|--
expr_stmt|;
comment|/* Copy the suffix to a string.  */
name|suffix
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|p2
operator|-
name|p
argument_list|)
expr_stmt|;
comment|/* Find the next line.  */
name|p
operator|=
name|skip_whitespace
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"specs file malformed after %ld characters"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|p
operator|-
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
comment|/* Find next blank line or end of string.  */
while|while
condition|(
operator|*
name|p1
operator|&&
operator|!
operator|(
operator|*
name|p1
operator|==
literal|'\n'
operator|&&
operator|(
name|p1
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
name|p1
operator|++
expr_stmt|;
comment|/* Specs end at the blank line and do not include the newline.  */
name|spec
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
comment|/* Delete backslash-newline sequences from the spec.  */
name|in
operator|=
name|spec
expr_stmt|;
name|out
operator|=
name|spec
expr_stmt|;
while|while
condition|(
operator|*
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
while|while
condition|(
operator|*
name|in
operator|&&
operator|*
name|in
operator|!=
literal|'\n'
condition|)
name|in
operator|++
expr_stmt|;
else|else
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|suffix
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
literal|"*link_command"
argument_list|)
condition|)
name|link_command_spec
operator|=
name|spec
expr_stmt|;
else|else
name|set_spec
argument_list|(
name|suffix
operator|+
literal|1
argument_list|,
name|spec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add this pair to the vector.  */
name|compilers
operator|=
name|xrealloc
argument_list|(
name|compilers
argument_list|,
operator|(
name|n_compilers
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|suffix
operator|=
name|suffix
expr_stmt|;
name|compilers
index|[
name|n_compilers
index|]
operator|.
name|spec
operator|=
name|spec
expr_stmt|;
name|n_compilers
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|compilers
index|[
name|n_compilers
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|compilers
index|[
name|n_compilers
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|suffix
operator|==
literal|0
condition|)
name|link_command_spec
operator|=
name|spec
expr_stmt|;
block|}
if|if
condition|(
name|link_command_spec
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"spec file has no spec for linking"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the names of temporary files we tell compilers to write,    and delete them at the end of the run.  */
end_comment

begin_comment
comment|/* This is the common prefix we use to make temp file names.    It is chosen once for each run of this program.    It is substituted into a spec by %g or %j.    Thus, all temp file names contain this prefix.    In practice, all temp file names start with this prefix.     This prefix comes from the envvar TMPDIR if it is defined;    otherwise, from the P_tmpdir macro if that is defined;    otherwise, in /usr/tmp or /tmp;    or finally the current directory if all else fails.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the prefix.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|temp_filename_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the list of temporary files to delete.  */
end_comment

begin_struct
struct|struct
name|temp_file
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|temp_file
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Queue of files to delete on success or failure of compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|temp_file
modifier|*
name|always_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of files to delete on failure of compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|temp_file
modifier|*
name|failure_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record FILENAME as a file to be deleted automatically.    ALWAYS_DELETE nonzero means delete it if all compilation succeeds;    otherwise delete it in any case.    FAIL_DELETE nonzero means delete it if a compilation step fails;    otherwise delete it in any case.  */
end_comment

begin_function
name|void
name|record_temp_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|always_delete
parameter_list|,
name|int
name|fail_delete
parameter_list|)
block|{
name|char
modifier|*
specifier|const
name|name
init|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|always_delete
condition|)
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already1
goto|;
name|temp
operator|=
name|XNEW
argument_list|(
expr|struct
name|temp_file
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|always_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|always_delete_queue
operator|=
name|temp
expr_stmt|;
name|already1
label|:
empty_stmt|;
block|}
if|if
condition|(
name|fail_delete
condition|)
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already2
goto|;
name|temp
operator|=
name|XNEW
argument_list|(
expr|struct
name|temp_file
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|failure_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|failure_delete_queue
operator|=
name|temp
expr_stmt|;
name|already2
label|:
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all the temporary files whose names we previously recorded.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DELETE_IF_ORDINARY
end_ifndef

begin_define
define|#
directive|define
name|DELETE_IF_ORDINARY
parameter_list|(
name|NAME
parameter_list|,
name|ST
parameter_list|,
name|VERBOSE_FLAG
parameter_list|)
define|\
value|do                                                      \   {                                                     \     if (stat (NAME,&ST)>= 0&& S_ISREG (ST.st_mode))  \       if (unlink (NAME)< 0)                            \ 	if (VERBOSE_FLAG)                               \ 	  perror_with_name (NAME);                      \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|delete_if_ordinary
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"Delete %s? (y or n) "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|'y'
operator|||
name|i
operator|==
literal|'Y'
condition|)
endif|#
directive|endif
comment|/* DEBUG */
name|DELETE_IF_ORDINARY
argument_list|(
name|name
argument_list|,
name|st
argument_list|,
name|verbose_flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_temp_files
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
name|delete_if_ordinary
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|always_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files to be deleted on error.  */
end_comment

begin_function
specifier|static
name|void
name|delete_failure_queue
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
name|delete_if_ordinary
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_failure_queue
parameter_list|(
name|void
parameter_list|)
block|{
name|failure_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call CALLBACK for each path in PATHS, breaking out early if CALLBACK    returns non-NULL.    If DO_MULTI is true iterate over the paths twice, first with multilib    suffix then without, otherwise iterate over the paths once without    adding a multilib suffix.  When DO_MULTI is true, some attempt is made    to avoid visiting the same path twice, but we could do better.  For    instance, /usr/lib/../lib is considered different from /usr/lib.    At least EXTRA_SPACE chars past the end of the path passed to    CALLBACK are available for use by the callback.    CALLBACK_INFO allows extra parameters to be passed to CALLBACK.     Returns the value returned by CALLBACK.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|for_each_path
parameter_list|(
specifier|const
name|struct
name|path_prefix
modifier|*
name|paths
parameter_list|,
name|bool
name|do_multi
parameter_list|,
name|size_t
name|extra_space
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|callback_info
parameter_list|)
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
specifier|const
name|char
modifier|*
name|multi_dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|multi_os_dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|multi_suffix
decl_stmt|;
specifier|const
name|char
modifier|*
name|just_multi_suffix
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|bool
name|skip_multi_dir
init|=
name|false
decl_stmt|;
name|bool
name|skip_multi_os_dir
init|=
name|false
decl_stmt|;
name|multi_suffix
operator|=
name|machine_suffix
expr_stmt|;
name|just_multi_suffix
operator|=
name|just_machine_suffix
expr_stmt|;
if|if
condition|(
name|do_multi
operator|&&
name|multilib_dir
operator|&&
name|strcmp
argument_list|(
name|multilib_dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|multi_dir
operator|=
name|concat
argument_list|(
name|multilib_dir
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|multi_suffix
operator|=
name|concat
argument_list|(
name|multi_suffix
argument_list|,
name|multi_dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|just_multi_suffix
operator|=
name|concat
argument_list|(
name|just_multi_suffix
argument_list|,
name|multi_dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_multi
operator|&&
name|multilib_os_dir
operator|&&
name|strcmp
argument_list|(
name|multilib_os_dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
name|multi_os_dir
operator|=
name|concat
argument_list|(
name|multilib_os_dir
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|multi_dir_len
init|=
literal|0
decl_stmt|;
name|size_t
name|multi_os_dir_len
init|=
literal|0
decl_stmt|;
name|size_t
name|suffix_len
decl_stmt|;
name|size_t
name|just_suffix_len
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|multi_dir
condition|)
name|multi_dir_len
operator|=
name|strlen
argument_list|(
name|multi_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_os_dir
condition|)
name|multi_os_dir_len
operator|=
name|strlen
argument_list|(
name|multi_os_dir
argument_list|)
expr_stmt|;
name|suffix_len
operator|=
name|strlen
argument_list|(
name|multi_suffix
argument_list|)
expr_stmt|;
name|just_suffix_len
operator|=
name|strlen
argument_list|(
name|just_multi_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
name|paths
operator|->
name|max_len
operator|+
name|extra_space
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|suffix_len
operator|>
name|multi_os_dir_len
condition|)
name|len
operator|+=
name|suffix_len
expr_stmt|;
else|else
name|len
operator|+=
name|multi_os_dir_len
expr_stmt|;
name|path
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pl
operator|=
name|paths
operator|->
name|plist
init|;
name|pl
operator|!=
literal|0
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|pl
operator|->
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Look first in MACHINE/VERSION subdirectory.  */
if|if
condition|(
operator|!
name|skip_multi_dir
condition|)
block|{
name|memcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|multi_suffix
argument_list|,
name|suffix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|callback
argument_list|(
name|path
argument_list|,
name|callback_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
comment|/* Some paths are tried with just the machine (ie. target) 	     subdir.  This is used for finding as, ld, etc.  */
if|if
condition|(
operator|!
name|skip_multi_dir
operator|&&
name|pl
operator|->
name|require_machine_suffix
operator|==
literal|2
condition|)
block|{
name|memcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|just_multi_suffix
argument_list|,
name|just_suffix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|callback
argument_list|(
name|path
argument_list|,
name|callback_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
comment|/* Now try the base path.  */
if|if
condition|(
operator|!
name|pl
operator|->
name|require_machine_suffix
operator|&&
operator|!
operator|(
name|pl
operator|->
name|os_multilib
condition|?
name|skip_multi_os_dir
else|:
name|skip_multi_dir
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|this_multi
decl_stmt|;
name|size_t
name|this_multi_len
decl_stmt|;
if|if
condition|(
name|pl
operator|->
name|os_multilib
condition|)
block|{
name|this_multi
operator|=
name|multi_os_dir
expr_stmt|;
name|this_multi_len
operator|=
name|multi_os_dir_len
expr_stmt|;
block|}
else|else
block|{
name|this_multi
operator|=
name|multi_dir
expr_stmt|;
name|this_multi_len
operator|=
name|multi_dir_len
expr_stmt|;
block|}
if|if
condition|(
name|this_multi_len
condition|)
name|memcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|this_multi
argument_list|,
name|this_multi_len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|callback
argument_list|(
name|path
argument_list|,
name|callback_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|pl
condition|)
break|break;
if|if
condition|(
name|multi_dir
operator|==
name|NULL
operator|&&
name|multi_os_dir
operator|==
name|NULL
condition|)
break|break;
comment|/* Run through the paths again, this time without multilibs. 	 Don't repeat any we have already seen.  */
if|if
condition|(
name|multi_dir
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multi_dir
argument_list|)
expr_stmt|;
name|multi_dir
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multi_suffix
argument_list|)
expr_stmt|;
name|multi_suffix
operator|=
name|machine_suffix
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|just_multi_suffix
argument_list|)
expr_stmt|;
name|just_multi_suffix
operator|=
name|just_machine_suffix
expr_stmt|;
block|}
else|else
name|skip_multi_dir
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|multi_os_dir
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multi_os_dir
argument_list|)
expr_stmt|;
name|multi_os_dir
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|skip_multi_os_dir
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|multi_dir
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multi_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multi_suffix
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|just_multi_suffix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multi_os_dir
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multi_os_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Callback for build_search_list.  Adds path to obstack being built.  */
end_comment

begin_struct
struct|struct
name|add_to_obstack_info
block|{
name|struct
name|obstack
modifier|*
name|ob
decl_stmt|;
name|bool
name|check_dir
decl_stmt|;
name|bool
name|first_time
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
modifier|*
name|add_to_obstack
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|add_to_obstack_info
modifier|*
name|info
init|=
name|data
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|check_dir
operator|&&
operator|!
name|is_directory
argument_list|(
name|path
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|first_time
condition|)
name|obstack_1grow
argument_list|(
name|info
operator|->
name|ob
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|info
operator|->
name|ob
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|first_time
operator|=
name|false
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Build a list of search directories from PATHS.    PREFIX is a string to prepend to the list.    If CHECK_DIR_P is true we ensure the directory exists.    If DO_MULTI is true, multilib paths are output first, then    non-multilib paths.    This is used mostly by putenv_from_prefixes so we use `collect_obstack'.    It is also used by the --print-search-dirs flag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_search_list
parameter_list|(
specifier|const
name|struct
name|path_prefix
modifier|*
name|paths
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|bool
name|check_dir
parameter_list|,
name|bool
name|do_multi
parameter_list|)
block|{
name|struct
name|add_to_obstack_info
name|info
decl_stmt|;
name|info
operator|.
name|ob
operator|=
operator|&
name|collect_obstack
expr_stmt|;
name|info
operator|.
name|check_dir
operator|=
name|check_dir
expr_stmt|;
name|info
operator|.
name|first_time
operator|=
name|true
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|for_each_path
argument_list|(
name|paths
argument_list|,
name|do_multi
argument_list|,
literal|0
argument_list|,
name|add_to_obstack
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|XOBFINISH
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|char
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables    for collect.  */
end_comment

begin_function
specifier|static
name|void
name|putenv_from_prefixes
parameter_list|(
specifier|const
name|struct
name|path_prefix
modifier|*
name|paths
parameter_list|,
specifier|const
name|char
modifier|*
name|env_var
parameter_list|,
name|bool
name|do_multi
parameter_list|)
block|{
name|putenv
argument_list|(
name|build_search_list
argument_list|(
name|paths
argument_list|,
name|env_var
argument_list|,
name|true
argument_list|,
name|do_multi
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether NAME can be accessed in MODE.  This is like access,    except that it never considers directories to be executable.  */
end_comment

begin_function
specifier|static
name|int
name|access_check
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|X_OK
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|access
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback for find_a_file.  Appends the file name to the directory    path.  If the resulting file exists in the right mode, return the    full pathname to the file.  */
end_comment

begin_struct
struct|struct
name|file_at_path_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|name_len
decl_stmt|;
name|int
name|suffix_len
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
modifier|*
name|file_at_path
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|file_at_path_info
modifier|*
name|info
init|=
name|data
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|info
operator|->
name|name_len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|info
operator|->
name|name_len
expr_stmt|;
comment|/* Some systems have a suffix for executable files.      So try appending that first.  */
if|if
condition|(
name|info
operator|->
name|suffix_len
condition|)
block|{
name|memcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|info
operator|->
name|suffix
argument_list|,
name|info
operator|->
name|suffix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|path
argument_list|,
name|info
operator|->
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
name|path
return|;
block|}
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access_check
argument_list|(
name|path
argument_list|,
name|info
operator|->
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
name|path
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Search for NAME using the prefix list PREFIXES.  MODE is passed to    access to check permissions.  If DO_MULTI is true, search multilib    paths then non-multilib paths, otherwise do not search multilib paths.    Return 0 if not found, otherwise return its name, allocated with malloc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
specifier|const
name|struct
name|path_prefix
modifier|*
name|pprefix
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|bool
name|do_multi
parameter_list|)
block|{
name|struct
name|file_at_path_info
name|info
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_ASSEMBLER
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"as"
argument_list|)
operator|&&
name|access
argument_list|(
name|DEFAULT_ASSEMBLER
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
name|DEFAULT_ASSEMBLER
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEFAULT_LINKER
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ld"
argument_list|)
operator|&&
name|access
argument_list|(
name|DEFAULT_LINKER
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
name|DEFAULT_LINKER
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FREEBSD_NATIVE
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"include"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|CROSS_INCLUDE_DIR
return|return
name|xstrdup
argument_list|(
name|CROSS_INCLUDE_DIR
argument_list|)
return|;
else|#
directive|else
return|return
name|xstrdup
argument_list|(
name|STANDARD_INCLUDE_DIR
argument_list|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* Determine the filename to execute (special case for absolute paths).  */
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
name|name
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
name|info
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|info
operator|.
name|suffix
operator|=
operator|(
name|mode
operator|&
name|X_OK
operator|)
operator|!=
literal|0
condition|?
name|HOST_EXECUTABLE_SUFFIX
else|:
literal|""
expr_stmt|;
name|info
operator|.
name|name_len
operator|=
name|strlen
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
name|info
operator|.
name|suffix_len
operator|=
name|strlen
argument_list|(
name|info
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|info
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
return|return
name|for_each_path
argument_list|(
name|pprefix
argument_list|,
name|do_multi
argument_list|,
name|info
operator|.
name|name_len
operator|+
name|info
operator|.
name|suffix_len
argument_list|,
name|file_at_path
argument_list|,
operator|&
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ranking of prefixes in the sort list. -B prefixes are put before    all others.  */
end_comment

begin_enum
enum|enum
name|path_prefix_priority
block|{
name|PREFIX_PRIORITY_B_OPT
block|,
name|PREFIX_PRIORITY_LAST
block|}
enum|;
end_enum

begin_comment
comment|/* Add an entry for PREFIX in PLIST.  The PLIST is kept in ascending    order according to PRIORITY.  Within each PRIORITY, new entries are    appended.     If WARN is nonzero, we will warn if no file is found    through this prefix.  WARN should point to an int    which will be set to 1 if this entry is used.     COMPONENT is the value to be passed to update_path.     REQUIRE_MACHINE_SUFFIX is 1 if this prefix can't be used without    the complete value of machine_suffix.    2 means try both machine_suffix and just_machine_suffix.  */
end_comment

begin_function
specifier|static
name|void
name|add_prefix
parameter_list|(
name|struct
name|path_prefix
modifier|*
name|pprefix
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
comment|/* enum prefix_priority */
name|int
name|priority
parameter_list|,
name|int
name|require_machine_suffix
parameter_list|,
name|int
name|os_multilib
parameter_list|)
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|prev
operator|=
operator|&
name|pprefix
operator|->
name|plist
init|;
operator|(
operator|*
name|prev
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|prev
operator|)
operator|->
name|priority
operator|<=
name|priority
condition|;
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
control|)
empty_stmt|;
comment|/* Keep track of the longest prefix.  */
name|prefix
operator|=
name|update_path
argument_list|(
name|prefix
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pprefix
operator|->
name|max_len
condition|)
name|pprefix
operator|->
name|max_len
operator|=
name|len
expr_stmt|;
name|pl
operator|=
name|XNEW
argument_list|(
expr|struct
name|prefix_list
argument_list|)
expr_stmt|;
name|pl
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
name|pl
operator|->
name|require_machine_suffix
operator|=
name|require_machine_suffix
expr_stmt|;
name|pl
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
name|pl
operator|->
name|os_multilib
operator|=
name|os_multilib
expr_stmt|;
comment|/* Insert after PREV.  */
name|pl
operator|->
name|next
operator|=
operator|(
operator|*
name|prev
operator|)
expr_stmt|;
operator|(
operator|*
name|prev
operator|)
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as add_prefix, but prepending target_system_root to prefix.  */
end_comment

begin_function
specifier|static
name|void
name|add_sysrooted_prefix
parameter_list|(
name|struct
name|path_prefix
modifier|*
name|pprefix
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
comment|/* enum prefix_priority */
name|int
name|priority
parameter_list|,
name|int
name|require_machine_suffix
parameter_list|,
name|int
name|os_multilib
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|prefix
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"system path '%s' is not absolute"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_system_root
condition|)
block|{
if|if
condition|(
name|target_sysroot_suffix
condition|)
name|prefix
operator|=
name|concat
argument_list|(
name|target_sysroot_suffix
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|concat
argument_list|(
name|target_system_root
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We have to override this because GCC's notion of sysroot 	 moves along with GCC.  */
name|component
operator|=
literal|"GCC"
expr_stmt|;
block|}
name|add_prefix
argument_list|(
name|pprefix
argument_list|,
name|prefix
argument_list|,
name|component
argument_list|,
name|priority
argument_list|,
name|require_machine_suffix
argument_list|,
name|os_multilib
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute the command specified by the arguments on the current line of spec.    When using pipes, this includes several piped-together commands    with `|' between them.     Return 0 if successful, -1 if failed.  */
end_comment

begin_function
specifier|static
name|int
name|execute
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_commands
decl_stmt|;
comment|/* # of command.  */
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|pex_obj
modifier|*
name|pex
decl_stmt|;
struct|struct
name|command
block|{
specifier|const
name|char
modifier|*
name|prog
decl_stmt|;
comment|/* program name.  */
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* vector of args.  */
block|}
struct|;
name|struct
name|command
modifier|*
name|commands
decl_stmt|;
comment|/* each command buffer with above info.  */
name|gcc_assert
argument_list|(
operator|!
name|processing_spec_function
argument_list|)
expr_stmt|;
comment|/* Count # of piped commands.  */
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
name|n_commands
operator|++
expr_stmt|;
comment|/* Get storage for each command.  */
name|commands
operator|=
name|alloca
argument_list|(
name|n_commands
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split argbuf into its separate piped processes,      and record info about each one.      Also search for the programs that are to be run.  */
name|commands
index|[
literal|0
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
comment|/* first command.  */
name|commands
index|[
literal|0
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|commands
index|[
literal|0
index|]
operator|.
name|prog
argument_list|,
name|X_OK
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
literal|0
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* each command.  */
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
name|fatal
argument_list|(
literal|"-pipe not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* termination of command args.  */
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|string
operator|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
argument_list|,
name|X_OK
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
name|n_commands
operator|++
expr_stmt|;
block|}
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If -v, print what we are about to do, and maybe query.  */
if|if
condition|(
name|verbose_flag
condition|)
block|{
comment|/* For help listings, put a blank line between sub-processes.  */
if|if
condition|(
name|print_help_list
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Print each piped command as a separate line.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|j
decl_stmt|;
if|if
condition|(
name|verbose_only_flag
condition|)
block|{
for|for
control|(
name|j
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
init|;
operator|*
name|j
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" \""
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|j
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|p
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|j
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
init|;
operator|*
name|j
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|j
argument_list|)
expr_stmt|;
comment|/* Print a pipe symbol after all but the last command.  */
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|n_commands
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" |"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose_only_flag
operator|!=
literal|0
condition|)
block|{
comment|/* verbose_only_flag should act as if the spec was 	     executed, so increment execution_count before 	     returning.  This prevents spurious warnings about 	     unused linker input files, etc.  */
name|execution_count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|notice
argument_list|(
literal|"\nGo ahead? (y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'y'
operator|&&
name|i
operator|!=
literal|'Y'
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
ifdef|#
directive|ifdef
name|ENABLE_VALGRIND_CHECKING
comment|/* Run the each command through valgrind.  To simplify prepending the      path to valgrind and the option "-q" (for quiet operation unless      something triggers), we allocate a separate argv array.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|argc
operator|=
literal|0
init|;
name|commands
index|[
name|i
index|]
operator|.
name|argv
index|[
name|argc
index|]
operator|!=
name|NULL
condition|;
name|argc
operator|++
control|)
empty_stmt|;
name|argv
operator|=
name|alloca
argument_list|(
operator|(
name|argc
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|VALGRIND_PATH
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
literal|"-q"
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|argc
operator|+
literal|2
condition|;
name|j
operator|++
control|)
name|argv
index|[
name|j
index|]
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
index|[
name|j
operator|-
literal|2
index|]
expr_stmt|;
name|argv
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|commands
index|[
name|i
index|]
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|commands
index|[
name|i
index|]
operator|.
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Run each piped subprocess.  */
name|pex
operator|=
name|pex_init
argument_list|(
name|PEX_USE_PIPES
operator||
operator|(
name|report_times
condition|?
name|PEX_RECORD_TIMES
else|:
literal|0
operator|)
argument_list|,
name|programname
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pex
operator|==
name|NULL
condition|)
name|pfatal_with_name
argument_list|(
name|_
argument_list|(
literal|"pex_init failed"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
init|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|errmsg
operator|=
name|pex_run
argument_list|(
name|pex
argument_list|,
operator|(
operator|(
name|i
operator|+
literal|1
operator|==
name|n_commands
condition|?
name|PEX_LAST
else|:
literal|0
operator|)
operator||
operator|(
name|string
operator|==
name|commands
index|[
name|i
index|]
operator|.
name|prog
condition|?
name|PEX_SEARCH
else|:
literal|0
operator|)
operator|)
argument_list|,
name|string
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|commands
index|[
name|i
index|]
operator|.
name|argv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
else|else
block|{
name|errno
operator|=
name|err
expr_stmt|;
name|pfatal_with_name
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|string
operator|!=
name|commands
index|[
name|i
index|]
operator|.
name|prog
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|string
argument_list|)
expr_stmt|;
block|}
name|execution_count
operator|++
expr_stmt|;
comment|/* Wait for all the subprocesses to finish.  */
block|{
name|int
modifier|*
name|statuses
decl_stmt|;
name|struct
name|pex_time
modifier|*
name|times
init|=
name|NULL
decl_stmt|;
name|int
name|ret_code
init|=
literal|0
decl_stmt|;
name|statuses
operator|=
name|alloca
argument_list|(
name|n_commands
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pex_get_status
argument_list|(
name|pex
argument_list|,
name|n_commands
argument_list|,
name|statuses
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|_
argument_list|(
literal|"failed to get exit status"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|report_times
condition|)
block|{
name|times
operator|=
name|alloca
argument_list|(
name|n_commands
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pex_time
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pex_get_times
argument_list|(
name|pex
argument_list|,
name|n_commands
argument_list|,
name|times
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|_
argument_list|(
literal|"failed to get process times"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pex_free
argument_list|(
name|pex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
operator|++
name|i
control|)
block|{
name|int
name|status
init|=
name|statuses
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* SIGPIPE is a special case.  It happens in -pipe mode 	       when the compiler dies before the preprocessor is done, 	       or the assembler dies before the compiler is done. 	       There's generally been an error already, and this is 	       just fallout.  So don't generate another error unless 	       we would otherwise have succeeded.  */
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGPIPE
operator|&&
operator|(
name|signal_count
operator|||
name|greatest_status
operator|>=
name|MIN_FATAL_STATUS
operator|)
condition|)
block|{
name|signal_count
operator|++
expr_stmt|;
name|ret_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|fatal_ice
argument_list|(
literal|"\ Internal error: %s (program %s)\n\ Please submit a full bug report.\n\ See %s for instructions."
argument_list|,
name|strsignal
argument_list|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
argument_list|,
name|commands
index|[
name|i
index|]
operator|.
name|prog
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>=
name|MIN_FATAL_STATUS
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>
name|greatest_status
condition|)
name|greatest_status
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|ret_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|report_times
condition|)
block|{
name|struct
name|pex_time
modifier|*
name|pt
init|=
operator|&
name|times
index|[
name|i
index|]
decl_stmt|;
name|double
name|ut
decl_stmt|,
name|st
decl_stmt|;
name|ut
operator|=
operator|(
operator|(
name|double
operator|)
name|pt
operator|->
name|user_seconds
operator|+
operator|(
name|double
operator|)
name|pt
operator|->
name|user_microseconds
operator|/
literal|1.0e6
operator|)
expr_stmt|;
name|st
operator|=
operator|(
operator|(
name|double
operator|)
name|pt
operator|->
name|system_seconds
operator|+
operator|(
name|double
operator|)
name|pt
operator|->
name|system_microseconds
operator|/
literal|1.0e6
operator|)
expr_stmt|;
if|if
condition|(
name|ut
operator|+
name|st
operator|!=
literal|0
condition|)
name|notice
argument_list|(
literal|"# %s %.2f %.2f\n"
argument_list|,
name|commands
index|[
name|i
index|]
operator|.
name|prog
argument_list|,
name|ut
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret_code
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the switches given to us    and make a vector describing them.    The elements of the vector are strings, one per switch given.    If a switch uses following arguments, then the `part1' field    is the switch itself and the `args' field    is a null-terminated vector containing the following arguments.    The `live_cond' field is:    0 when initialized    1 if the switch is true in a conditional spec,    -1 if false (overridden by a later switch)    -2 if this switch should be ignored (used in %<S)    The `validated' field is nonzero if any spec has looked at this switch;    if it remains zero at the end of the run, it must be meaningless.  */
end_comment

begin_define
define|#
directive|define
name|SWITCH_OK
value|0
end_define

begin_define
define|#
directive|define
name|SWITCH_FALSE
value|-1
end_define

begin_define
define|#
directive|define
name|SWITCH_IGNORE
value|-2
end_define

begin_define
define|#
directive|define
name|SWITCH_LIVE
value|1
end_define

begin_struct
struct|struct
name|switchstr
block|{
specifier|const
name|char
modifier|*
name|part1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|live_cond
decl_stmt|;
name|unsigned
name|char
name|validated
decl_stmt|;
name|unsigned
name|char
name|ordering
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|switchstr
modifier|*
name|switches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_switches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Language is one of three things:     1) The name of a real programming language.    2) NULL, indicating that no one has figured out    what it is yet.    3) '*', indicating that the file should be passed    to the linker.  */
end_comment

begin_struct
struct|struct
name|infile
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
name|struct
name|compiler
modifier|*
name|incompiler
decl_stmt|;
name|bool
name|compiled
decl_stmt|;
name|bool
name|preprocessed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Also a vector of input files specified.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|infile
modifier|*
name|infiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if multiple input files are being compiled to a single    assembly file.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|combine_inputs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts the number of libraries added by lang_specific_driver, so that    we can tell if there were any user supplied any files or libraries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|added_libraries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And a vector of corresponding output files is made up later.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|outfiles
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_OBJECT_SUFFIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
end_if

begin_comment
comment|/* Convert NAME to a new name if it is the standard suffix.  DO_EXE    is true if we should look for an executable suffix.  DO_OBJ    is true if we should look for an object suffix.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|convert_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|do_exe
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|do_obj
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|int
name|len
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TARGET_OBJECT_SUFFIX
comment|/* Convert x.o to x.obj if TARGET_OBJECT_SUFFIX is ".obj".  */
if|if
condition|(
name|do_obj
operator|&&
name|len
operator|>
literal|2
operator|&&
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|name
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
comment|/* If there is no filetype, make it the executable suffix (which includes      the ".").  But don't get confused if we have just "-o".  */
if|if
condition|(
operator|!
name|do_exe
operator|||
name|TARGET_EXECUTABLE_SUFFIX
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|len
operator|==
literal|2
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
return|return
name|name
return|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
return|return
name|name
return|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|TARGET_EXECUTABLE_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|TARGET_EXECUTABLE_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Display the command line switches accepted by gcc.  */
end_comment

begin_function
specifier|static
name|void
name|display_help
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [options] file...\n"
argument_list|)
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"Options:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -pass-exit-codes         Exit with highest error code from a phase\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  --help                   Display this information\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  --target-help            Display target specific command line options\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose_flag
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  (Use '-v --help' to display command line options of sub-processes)\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -dumpspecs               Display all of the built in spec strings\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -dumpversion             Display the version of the compiler\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -dumpmachine             Display the compiler's target processor\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-search-dirs       Display the directories in the compiler's search path\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-libgcc-file-name  Display the name of the compiler's companion library\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-file-name=<lib>   Display the full path to library<lib>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-prog-name=<prog>  Display the full path to compiler component<prog>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-multi-directory   Display the root directory for versions of libgcc\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -print-multi-lib         Display the mapping between command line options and\n\                            multiple library search directories\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -print-multi-os-directory Display the relative path to OS libraries\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Wa,<options>            Pass comma-separated<options> on to the assembler\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Wp,<options>            Pass comma-separated<options> on to the preprocessor\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Wl,<options>            Pass comma-separated<options> on to the linker\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Xassembler<arg>        Pass<arg> on to the assembler\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Xpreprocessor<arg>     Pass<arg> on to the preprocessor\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -Xlinker<arg>           Pass<arg> on to the linker\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -combine                 Pass multiple source files to compiler at once\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -save-temps              Do not delete intermediate files\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -pipe                    Use pipes rather than intermediate files\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -time                    Time the execution of each subprocess\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -specs=<file>            Override built-in specs with the contents of<file>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -std=<standard>          Assume that the input sources are for<standard>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   --sysroot=<directory>    Use<directory> as the root directory for headers\n\                            and libraries\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -B<directory>           Add<directory> to the compiler's search paths\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -b<machine>             Run gcc for target<machine>, if installed\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -V<version>             Run gcc version number<version>, if installed\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -v                       Display the programs invoked by the compiler\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -###                     Like -v but options quoted and commands not executed\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -E                       Preprocess only; do not compile, assemble or link\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -S                       Compile only; do not assemble or link\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -c                       Compile and assemble, but do not link\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"  -o<file>                Place the output into<file>\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -x<language>            Specify the language of the following input files\n\                            Permissible languages include: c c++ assembler none\n\                            'none' means revert to the default behavior of\n\                            guessing the language based on the file's extension\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \nOptions starting with -g, -f, -m, -O, -W, or --param are automatically\n\  passed on to the various sub-processes invoked by %s.  In order to pass\n\  other options on to these processes the -W<letter> options must be used.\n\ "
argument_list|)
argument_list|,
name|programname
argument_list|)
expr_stmt|;
comment|/* The rest of the options are displayed by invocations of the various      sub-processes.  */
block|}
end_function

begin_function
specifier|static
name|void
name|add_preprocessor_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|n_preprocessor_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|preprocessor_options
condition|)
name|preprocessor_options
operator|=
name|XNEWVEC
argument_list|(
name|char
operator|*
argument_list|,
name|n_preprocessor_options
argument_list|)
expr_stmt|;
else|else
name|preprocessor_options
operator|=
name|xrealloc
argument_list|(
name|preprocessor_options
argument_list|,
name|n_preprocessor_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|preprocessor_options
index|[
name|n_preprocessor_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|option
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_assembler_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|n_assembler_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|assembler_options
condition|)
name|assembler_options
operator|=
name|XNEWVEC
argument_list|(
name|char
operator|*
argument_list|,
name|n_assembler_options
argument_list|)
expr_stmt|;
else|else
name|assembler_options
operator|=
name|xrealloc
argument_list|(
name|assembler_options
argument_list|,
name|n_assembler_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|assembler_options
index|[
name|n_assembler_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|option
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_linker_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|n_linker_options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|linker_options
condition|)
name|linker_options
operator|=
name|XNEWVEC
argument_list|(
name|char
operator|*
argument_list|,
name|n_linker_options
argument_list|)
expr_stmt|;
else|else
name|linker_options
operator|=
name|xrealloc
argument_list|(
name|linker_options
argument_list|,
name|n_linker_options
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|linker_options
index|[
name|n_linker_options
operator|-
literal|1
index|]
operator|=
name|save_string
argument_list|(
name|option
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the vector `switches' and its contents.    Store its length in `n_switches'.  */
end_comment

begin_function
specifier|static
name|void
name|process_command
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|temp1
decl_stmt|;
specifier|const
name|char
modifier|*
name|spec_lang
init|=
literal|0
decl_stmt|;
name|int
name|last_language_n_infiles
decl_stmt|;
name|int
name|lang_n_infiles
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
name|int
name|is_modify_target_name
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
endif|#
directive|endif
name|GET_ENVIRONMENT
argument_list|(
name|gcc_exec_prefix
argument_list|,
literal|"GCC_EXEC_PREFIX"
argument_list|)
expr_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
name|added_libraries
operator|=
literal|0
expr_stmt|;
comment|/* Figure compiler version from version string.  */
name|compiler_version
operator|=
name|temp1
operator|=
name|xstrdup
argument_list|(
name|version_string
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|temp1
condition|;
operator|++
name|temp1
control|)
block|{
if|if
condition|(
operator|*
name|temp1
operator|==
literal|' '
condition|)
block|{
operator|*
name|temp1
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* If there is a -V or -b option (or both), process it now, before      trying to interpret the rest of the command line.      Use heuristic that all configuration names must have at least      one dash '-'. This allows us to pass options starting with -b.  */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'V'
operator|||
operator|(
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|NULL
operator|!=
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
operator|+
literal|2
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_version
init|=
name|DEFAULT_TARGET_VERSION
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_machine
init|=
name|DEFAULT_TARGET_MACHINE
decl_stmt|;
specifier|const
name|char
modifier|*
name|progname
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
name|char
modifier|*
name|new_argv0
decl_stmt|;
name|int
name|baselen
decl_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'V'
operator|||
operator|(
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|NULL
operator|!=
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
operator|+
literal|2
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|char
name|opt
init|=
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|arg
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
name|argc
operator|-=
literal|1
expr_stmt|;
name|argv
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|arg
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"'-%c' option must have argument"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|==
literal|'V'
condition|)
name|new_version
operator|=
name|arg
expr_stmt|;
else|else
name|new_machine
operator|=
name|arg
expr_stmt|;
block|}
for|for
control|(
name|baselen
operator|=
name|strlen
argument_list|(
name|progname
argument_list|)
init|;
name|baselen
operator|>
literal|0
condition|;
name|baselen
operator|--
control|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|progname
index|[
name|baselen
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
name|new_argv0
operator|=
name|xmemdup
argument_list|(
name|progname
argument_list|,
name|baselen
argument_list|,
name|baselen
operator|+
name|concat_length
argument_list|(
name|new_version
argument_list|,
name|new_machine
argument_list|,
literal|"-gcc-"
argument_list|,
name|NULL
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_argv0
operator|+
name|baselen
argument_list|,
name|new_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new_argv0
argument_list|,
literal|"-gcc-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new_argv0
argument_list|,
name|new_version
argument_list|)
expr_stmt|;
name|new_argv
operator|=
name|xmemdup
argument_list|(
name|argv
argument_list|,
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|new_argv0
expr_stmt|;
name|execvp
argument_list|(
name|new_argv0
argument_list|,
name|new_argv
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"couldn't run '%s': %s"
argument_list|,
name|new_argv0
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,      see if we can create it from the pathname specified in argv[0].  */
name|gcc_libexec_prefix
operator|=
name|standard_libexec_prefix
expr_stmt|;
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
ifndef|#
directive|ifndef
name|VMS
comment|/* FIXME: make_relative_prefix doesn't yet work for VMS.  */
if|if
condition|(
operator|!
name|gcc_exec_prefix
condition|)
block|{
name|gcc_exec_prefix
operator|=
name|make_relative_prefix
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|standard_bindir_prefix
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
name|gcc_libexec_prefix
operator|=
name|make_relative_prefix
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|standard_bindir_prefix
argument_list|,
name|standard_libexec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcc_exec_prefix
condition|)
name|putenv
argument_list|(
name|concat
argument_list|(
literal|"GCC_EXEC_PREFIX="
argument_list|,
name|gcc_exec_prefix
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* make_relative_prefix requires a program name, but 	 GCC_EXEC_PREFIX is typically a directory name with a trailing 	 / (which is ignored by make_relative_prefix), so append a 	 program name.  */
name|char
modifier|*
name|tmp_prefix
init|=
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
literal|"gcc"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gcc_libexec_prefix
operator|=
name|make_relative_prefix
argument_list|(
name|tmp_prefix
argument_list|,
name|standard_exec_prefix
argument_list|,
name|standard_libexec_prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_prefix
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
endif|#
directive|endif
endif|#
directive|endif
comment|/* not FREEBSD_NATIVE */
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|gcc_exec_prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
literal|"/lib/gcc/"
argument_list|)
operator|-
literal|1
operator|&&
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|gcc_exec_prefix
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|gcc_exec_prefix
operator|+
name|len
operator|-
sizeof|sizeof
argument_list|(
literal|"/lib/gcc/"
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|temp
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|temp
operator|+
literal|1
argument_list|,
literal|"lib"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|temp
index|[
literal|4
index|]
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|temp
operator|+
literal|5
argument_list|,
literal|"gcc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|-=
sizeof|sizeof
argument_list|(
literal|"/lib/gcc/"
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|set_std_prefix
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|gcc_libexec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|gcc_exec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* COMPILER_PATH and LIBRARY_PATH have values      that are lists of directory names with colons.  */
name|GET_ENVIRONMENT
argument_list|(
name|temp
argument_list|,
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
specifier|const
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|nstore
argument_list|,
literal|0
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|nstore
argument_list|,
literal|0
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
name|GET_ENVIRONMENT
argument_list|(
name|temp
argument_list|,
name|LIBRARY_PATH_ENV
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|*
name|cross_compile
operator|==
literal|'0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|nstore
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Use LPATH like LIBRARY_PATH (for the CMU build program).  */
name|GET_ENVIRONMENT
argument_list|(
name|temp
argument_list|,
literal|"LPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|*
name|cross_compile
operator|==
literal|'0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
name|concat
argument_list|(
literal|"."
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|nstore
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Options specified as if they appeared on the command line.  */
name|temp
operator|=
name|getenv
argument_list|(
literal|"GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|optc
init|=
literal|1
decl_stmt|;
name|int
name|new_argc
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
name|char
modifier|*
name|envopts
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|temp
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|envopts
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|envopts
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|isspace
argument_list|(
name|envopts
index|[
name|i
index|]
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|isspace
argument_list|(
name|envopts
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
name|optc
operator|++
expr_stmt|;
name|new_argv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|optc
operator|+
name|argc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|new_argc
operator|=
literal|1
init|;
name|new_argc
operator|<=
name|optc
condition|;
name|new_argc
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|envopts
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|envopts
operator|+
name|i
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
name|envopts
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|envopts
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|)
condition|)
name|i
operator|++
expr_stmt|;
name|envopts
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|argv
operator|=
name|new_argv
expr_stmt|;
name|argc
operator|=
name|new_argc
expr_stmt|;
block|}
comment|/* Convert new-style -- options to old-style.  */
name|translate_options
argument_list|(
operator|&
name|argc
argument_list|,
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|*
operator|)
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* Do language-specific adjustment/addition of flags.  */
name|lang_specific_driver
argument_list|(
operator|&
name|argc
argument_list|,
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|*
operator|)
operator|&
name|argv
argument_list|,
operator|&
name|added_libraries
argument_list|)
expr_stmt|;
comment|/* Scan argv twice.  Here, the first time, just count how many switches      there will be in their vector, and how many input files in theirs.      Here we also parse the switches that cc itself uses (e.g. -v).  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpspecs"
argument_list|)
condition|)
block|{
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
name|init_spec
argument_list|()
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"*%s:\n%s\n\n"
argument_list|,
name|sl
operator|->
name|name
argument_list|,
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_command_spec
condition|)
name|printf
argument_list|(
literal|"*link_command:\n%s\n\n"
argument_list|,
name|link_command_spec
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpversion"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|spec_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-dumpmachine"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|spec_machine
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fversion"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* translate_options () has turned --version into -fversion.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s (GCC) %s\n"
argument_list|)
argument_list|,
name|programname
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Copyright %s 2007 Free Software Foundation, Inc.\n"
argument_list|,
name|_
argument_list|(
literal|"(C)"
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"This is free software; see the source for copying conditions.  There is NO\n\ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fhelp"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* translate_options () has turned --help into -fhelp.  */
name|print_help_list
operator|=
literal|1
expr_stmt|;
comment|/* We will be passing a dummy file on to the sub-processes.  */
name|n_infiles
operator|++
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
comment|/* CPP driver cannot obtain switch from cc1_options.  */
if|if
condition|(
name|is_cpp_driver
condition|)
name|add_preprocessor_option
argument_list|(
literal|"--help"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|add_assembler_option
argument_list|(
literal|"--help"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|add_linker_option
argument_list|(
literal|"--help"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ftarget-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* translate_options() has turned --target-help into -ftarget-help.  */
name|target_help_flag
operator|=
literal|1
expr_stmt|;
comment|/* We will be passing a dummy file on to the sub-processes.  */
name|n_infiles
operator|++
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
comment|/* CPP driver cannot obtain switch from cc1_options.  */
if|if
condition|(
name|is_cpp_driver
condition|)
name|add_preprocessor_option
argument_list|(
literal|"--target-help"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|add_assembler_option
argument_list|(
literal|"--target-help"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|add_linker_option
argument_list|(
literal|"--target-help"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pass-exit-codes"
argument_list|)
condition|)
block|{
name|pass_exit_codes
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-search-dirs"
argument_list|)
condition|)
name|print_search_dirs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-libgcc-file-name"
argument_list|)
condition|)
name|print_file_name
operator|=
literal|"libgcc.a"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-file-name="
argument_list|,
literal|17
argument_list|)
condition|)
name|print_file_name
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-prog-name="
argument_list|,
literal|17
argument_list|)
condition|)
name|print_prog_name
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-lib"
argument_list|)
condition|)
name|print_multi_lib
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-directory"
argument_list|)
condition|)
name|print_multi_directory
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-os-directory"
argument_list|)
condition|)
name|print_multi_os_directory
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wa,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Pass the rest of this option to the assembler.  */
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|add_assembler_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|add_assembler_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wp,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Pass the rest of this option to the preprocessor.  */
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|add_preprocessor_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|add_preprocessor_option
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
comment|/* The +e options to the C++ front-end.  */
name|n_switches
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wl,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Split the argument at commas.  */
for|for
control|(
name|j
operator|=
literal|3
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|n_infiles
operator|+=
operator|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xlinker"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-Xlinker' is missing"
argument_list|)
expr_stmt|;
name|n_infiles
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xpreprocessor"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-Xpreprocessor' is missing"
argument_list|)
expr_stmt|;
name|add_preprocessor_option
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xassembler"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-Xassembler' is missing"
argument_list|)
expr_stmt|;
name|add_assembler_option
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-l' is missing"
argument_list|)
expr_stmt|;
name|n_infiles
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|n_infiles
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-save-temps"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|save_temps_flag
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-combine"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|combine_flag
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|user_specs
modifier|*
name|user
init|=
name|XNEW
argument_list|(
expr|struct
name|user_specs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-specs' is missing"
argument_list|)
expr_stmt|;
name|user
operator|->
name|next
operator|=
operator|(
expr|struct
name|user_specs
operator|*
operator|)
literal|0
expr_stmt|;
name|user
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|user_specs_tail
condition|)
name|user_specs_tail
operator|->
name|next
operator|=
name|user
expr_stmt|;
else|else
name|user_specs_head
operator|=
name|user
expr_stmt|;
name|user_specs_tail
operator|=
name|user
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|user_specs
modifier|*
name|user
init|=
name|XNEW
argument_list|(
expr|struct
name|user_specs
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|7
condition|)
name|fatal
argument_list|(
literal|"argument to '-specs=' is missing"
argument_list|)
expr_stmt|;
name|user
operator|->
name|next
operator|=
operator|(
expr|struct
name|user_specs
operator|*
operator|)
literal|0
expr_stmt|;
name|user
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|7
expr_stmt|;
if|if
condition|(
name|user_specs_tail
condition|)
name|user_specs_tail
operator|->
name|next
operator|=
name|user
expr_stmt|;
else|else
name|user_specs_head
operator|=
name|user
expr_stmt|;
name|user_specs_tail
operator|=
name|user
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-time"
argument_list|)
operator|==
literal|0
condition|)
name|report_times
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pipe"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* -pipe has to go into the switches array as well as 	     setting a flag.  */
name|use_pipes
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-###"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is similar to -v except that there is no execution 	     of the commands and the echoed arguments are quoted.  It 	     is intended for use in shell scripts to capture the 	     driver-generated command line.  */
name|verbose_only_flag
operator|++
expr_stmt|;
name|verbose_flag
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|NULL
operator|==
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|'-'
argument_list|)
condition|)
goto|goto
name|normal_switch
goto|;
comment|/* Fall through.  */
case|case
literal|'V'
case|:
name|fatal
argument_list|(
literal|"'-%c' must come at the start of the command line"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
block|{
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-B' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|value
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|value
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Catch the case where the user has forgotten to append a 		   directory separator to the path.  Note, they may be using 		   -B to add an executable name prefix, eg "i386-elf-", in 		   order to distinguish between multiple installations of 		   GCC in the same directory.  Hence we must check to see 		   if appending a directory separator actually makes a 		   valid directory name.  */
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|value
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|is_directory
argument_list|(
name|value
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|tmp
index|[
name|len
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|tmp
index|[
operator|++
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* As a kludge, if the arg is "[foo/]stageN/", just 		   add "[foo/]include" to the include prefix.  */
if|if
condition|(
operator|(
name|len
operator|==
literal|7
operator|||
operator|(
name|len
operator|>
literal|7
operator|&&
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|value
index|[
name|len
operator|-
literal|8
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|value
operator|+
name|len
operator|-
literal|7
argument_list|,
literal|"stage"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIGIT
argument_list|(
name|value
index|[
name|len
operator|-
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|value
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|7
condition|)
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
literal|"./"
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|string
init|=
name|xmalloc
argument_list|(
name|len
operator|-
literal|6
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|string
argument_list|,
name|value
argument_list|,
name|len
operator|-
literal|7
argument_list|)
expr_stmt|;
name|string
index|[
name|len
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|string
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_B_OPT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* Print our subcommands and print versions.  */
name|n_switches
operator|++
expr_stmt|;
comment|/* If they do anything other than exactly `-v', don't set 		 verbose_flag; rather, continue on to give the error.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
break|break;
name|verbose_flag
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'c'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|have_c
operator|=
literal|1
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
break|break;
block|}
goto|goto
name|normal_switch
goto|;
case|case
literal|'o'
case|:
name|have_o
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
if|if
condition|(
operator|!
name|have_c
condition|)
block|{
name|int
name|skip
decl_stmt|;
comment|/* Forward scan, just in case -S or -c is specified 		     after -o.  */
name|int
name|j
init|=
name|i
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
operator|++
name|j
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|argc
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|j
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|SWITCH_CURTAILS_COMPILATION
argument_list|(
name|argv
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
operator|&&
name|argv
index|[
name|j
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|have_c
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|skip
operator|=
name|SWITCH_TAKES_ARG
argument_list|(
name|argv
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|j
operator|+=
name|skip
operator|-
operator|(
name|argv
index|[
name|j
index|]
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|skip
operator|=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|argv
index|[
name|j
index|]
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|j
operator|+=
name|skip
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TARGET_EXECUTABLE_SUFFIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TARGET_OBJECT_SUFFIX
argument_list|)
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|convert_filename
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|!
name|have_c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|argv
index|[
name|i
index|]
operator|=
name|convert_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|have_c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|normal_switch
goto|;
default|default:
name|normal_switch
label|:
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
name|is_modify_target_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|modify_target
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modify_target
index|[
name|j
index|]
operator|.
name|sw
argument_list|)
condition|)
block|{
name|char
modifier|*
name|new_name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|)
operator|+
name|strlen
argument_list|(
name|spec_machine
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|made_addition
init|=
literal|0
decl_stmt|;
name|is_modify_target_name
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|spec_machine
operator|,
name|q
operator|=
name|new_name
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|modify_target
index|[
name|j
index|]
operator|.
name|add_del
operator|==
name|DELETE
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|q
argument_list|,
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|strlen
argument_list|(
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|)
argument_list|)
operator|)
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|modify_target
index|[
name|j
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|modify_target
index|[
name|j
index|]
operator|.
name|add_del
operator|==
name|ADD
operator|&&
operator|!
name|made_addition
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|r
operator|=
name|modify_target
index|[
name|j
index|]
operator|.
name|str
init|;
operator|*
name|r
operator|!=
literal|0
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
name|made_addition
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|spec_machine
operator|=
name|new_name
expr_stmt|;
block|}
if|if
condition|(
name|is_modify_target_name
condition|)
break|break;
endif|#
directive|endif
name|n_switches
operator|++
expr_stmt|;
if|if
condition|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
name|i
operator|+=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|i
operator|+=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|n_infiles
operator|++
expr_stmt|;
name|lang_n_infiles
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_temps_flag
operator|&&
name|use_pipes
condition|)
block|{
comment|/* -save-temps overrides -pipe, so that temp files are produced */
if|if
condition|(
name|save_temps_flag
condition|)
name|error
argument_list|(
literal|"warning: -pipe ignored because -save-temps specified"
argument_list|)
expr_stmt|;
name|use_pipes
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set up the search paths before we go looking for config files.  */
ifdef|#
directive|ifdef
name|FREEBSD_NATIVE
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|PREFIX
literal|"/bin/"
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
comment|/* These come before the md prefixes so that we will find gcc's subcommands      (such as cpp) rather than those of the host system.  */
comment|/* Use 2 as fourth arg meaning try just the machine as a suffix,      as well as trying the machine and the version.  */
ifndef|#
directive|ifndef
name|OS2
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_libexec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_libexec_prefix
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix_1
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|standard_exec_prefix_2
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_exec_prefix
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_exec_prefix_2
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tooldir_prefix
operator|=
name|concat
argument_list|(
name|tooldir_base_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If tooldir is relative, base it on exec_prefixes.  A relative      tooldir lets us move the installed tree as a unit.       If GCC_EXEC_PREFIX is defined, then we want to add two relative      directories, so that we can search both the user specified directory      and the standard place.  */
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|tooldir_prefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|char
modifier|*
name|gcc_exec_tooldir_prefix
init|=
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|tooldir_prefix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|concat
argument_list|(
name|gcc_exec_tooldir_prefix
argument_list|,
literal|"bin"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|gcc_exec_tooldir_prefix
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|tooldir_prefix
operator|=
name|concat
argument_list|(
name|standard_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|tooldir_prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|concat
argument_list|(
name|tooldir_prefix
argument_list|,
literal|"bin"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|tooldir_prefix
argument_list|,
literal|"lib"
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_SYSTEM_ROOT_RELOCATABLE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
comment|/* If the normal TARGET_SYSTEM_ROOT is inside of $exec_prefix,      then consider it to relocate with the rest of the GCC installation      if GCC_EXEC_PREFIX is set.      ``make_relative_prefix'' is not compiled for VMS, so don't call it.  */
if|if
condition|(
name|target_system_root
operator|&&
name|gcc_exec_prefix
condition|)
block|{
name|char
modifier|*
name|tmp_prefix
init|=
name|make_relative_prefix
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|standard_bindir_prefix
argument_list|,
name|target_system_root
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp_prefix
operator|&&
name|access_check
argument_list|(
name|tmp_prefix
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|target_system_root
operator|=
name|tmp_prefix
expr_stmt|;
name|target_system_root_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
comment|/* More prefixes are enabled in main, after we read the specs file      and determine whether this is cross-compilation or not.  */
comment|/* Then create the space for the vectors and scan again.  */
name|switches
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|switchstr
argument_list|,
name|n_switches
operator|+
literal|1
argument_list|)
expr_stmt|;
name|infiles
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|infile
argument_list|,
name|n_infiles
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
name|last_language_n_infiles
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This, time, copy the text of each switch and store a pointer      to the copy in the vector of switches.      Store all the infiles in their vector.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* Just skip the switches that were handled by the preceding loop.  */
ifdef|#
directive|ifdef
name|MODIFY_TARGET_NAME
name|is_modify_target_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|modify_target
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modify_target
index|[
name|j
index|]
operator|.
name|sw
argument_list|)
condition|)
name|is_modify_target_name
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_modify_target_name
condition|)
empty_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wa,"
argument_list|,
literal|4
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wp,"
argument_list|,
literal|4
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pass-exit-codes"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-search-dirs"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-libgcc-file-name"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-file-name="
argument_list|,
literal|17
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-prog-name="
argument_list|,
literal|17
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-lib"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-directory"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print-multi-os-directory"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ftarget-help"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fhelp"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--sysroot="
argument_list|,
name|strlen
argument_list|(
literal|"--sysroot="
argument_list|)
argument_list|)
condition|)
block|{
name|target_system_root
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|strlen
argument_list|(
literal|"--sysroot="
argument_list|)
expr_stmt|;
name|target_system_root_changed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Compensate for the +e options to the C++ front-end; 	     they're there simply for cfront call-compatibility.  We do 	     some magic in default_compilers to pass them down properly. 	     Note we deliberately start at the `+' here, to avoid passing 	     -e0 or -e1 down into the linker.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wl,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|prev
decl_stmt|,
name|j
decl_stmt|;
comment|/* Split the argument at commas.  */
name|prev
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|','
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|save_string
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|prev
argument_list|,
name|j
operator|-
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Record the part after the last comma.  */
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xlinker"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
comment|/* Xassembler and Xpreprocessor were already handled in the first argv 	 scan, so all we need to do here is ignore them and their argument.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xassembler"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Xpreprocessor"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* POSIX allows separation of -l and the lib arg; 	     canonicalize by concatenating -l with its arg */
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
literal|"*"
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-specs="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-time"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-###"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-x' is missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|spec_lang
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|spec_lang
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spec_lang
argument_list|,
literal|"none"
argument_list|)
condition|)
comment|/* Suppress the warning if -xnone comes after the last input 		   file, because alternate command interfaces like g++ might 		   find it useful to place -xnone after each input file.  */
name|spec_lang
operator|=
literal|0
expr_stmt|;
else|else
name|last_language_n_infiles
operator|=
name|n_infiles
expr_stmt|;
continue|continue;
block|}
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
name|p
expr_stmt|;
comment|/* Deal with option arguments in separate argv elements.  */
if|if
condition|(
operator|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|>
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|n_args
init|=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_args
operator|==
literal|0
condition|)
block|{
comment|/* Count only the option arguments in separate argv elements.  */
name|n_args
operator|=
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
name|n_args
operator|>=
name|argc
condition|)
name|fatal
argument_list|(
literal|"argument to '-%s' is missing"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|n_args
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|n_args
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
comment|/* Null-terminate the vector.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|switches_need_spaces
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* On some systems, ld cannot handle some options without 		 a space.  So split the option from its argument.  */
name|char
modifier|*
name|part1
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|part1
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|part1
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
name|part1
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|ordering
operator|=
literal|0
expr_stmt|;
comment|/* These are always valid, since gcc.c itself understands them.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"save-temps"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"static-libgcc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"shared-libgcc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pipe"
argument_list|)
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|char
name|ch
init|=
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'B'
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
name|n_switches
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_TARGET_OBJECT_SUFFIX
name|argv
index|[
name|i
index|]
operator|=
name|convert_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|access
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|F_OK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
name|access
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|F_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|language
operator|=
name|spec_lang
expr_stmt|;
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|.
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|n_infiles
operator|==
name|last_language_n_infiles
operator|&&
name|spec_lang
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"warning: '-x %s' after last input file has no effect"
argument_list|,
name|spec_lang
argument_list|)
expr_stmt|;
comment|/* Ensure we only invoke each subprocess once.  */
if|if
condition|(
name|target_help_flag
operator|||
name|print_help_list
condition|)
block|{
name|n_infiles
operator|=
literal|1
expr_stmt|;
comment|/* Create a dummy input file, so that we can pass --target-help on to 	 the various sub-processes.  */
name|infiles
index|[
literal|0
index|]
operator|.
name|language
operator|=
literal|"c"
expr_stmt|;
name|infiles
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|"help-dummy"
expr_stmt|;
if|if
condition|(
name|target_help_flag
condition|)
block|{
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|"--target-help"
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|print_help_list
condition|)
block|{
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|"--help"
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|args
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|validated
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
block|}
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store switches not filtered out by %<S in spec in COLLECT_GCC_OPTIONS    and place that in the environment.  */
end_comment

begin_function
specifier|static
name|void
name|set_collect_gcc_options
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|first_time
decl_stmt|;
comment|/* Build COLLECT_GCC_OPTIONS to have all of the options specified to      the compiler.  */
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"COLLECT_GCC_OPTIONS="
argument_list|,
sizeof|sizeof
argument_list|(
literal|"COLLECT_GCC_OPTIONS="
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|first_time
condition|)
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
comment|/* Ignore elided switches.  */
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|live_cond
operator|==
name|SWITCH_IGNORE
condition|)
continue|continue;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'-"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
name|switches
index|[
name|i
index|]
operator|.
name|part1
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'\\''"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|q
operator|=
operator|++
name|p
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|switches
index|[
name|i
index|]
operator|.
name|args
init|;
name|args
operator|&&
operator|*
name|args
condition|;
name|args
operator|++
control|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|" '"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
operator|*
name|args
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'\\''"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|q
operator|=
operator|++
name|p
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|XOBFINISH
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a spec string, accumulating and running commands.  */
end_comment

begin_comment
comment|/* These variables describe the input file name.    input_file_number is the index on outfiles of this file,    so that the output file name can be stored for later use by %o.    input_basename is the start of the part of the input file    sans all directory names, and basename_length is the number    of characters starting there excluding the suffix .c or whatever.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_file_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|input_filename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|basename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|suffixed_basename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_basename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_suffix
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_LACKS_INODE_NUMBERS
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|stat
name|input_stat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|input_stat_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiler used to process the current input file.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|compiler
modifier|*
name|input_file_compiler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are variables used within do_spec and do_spec_1.  */
end_comment

begin_comment
comment|/* Nonzero if an arg has been started and not yet terminated    (with space, tab or newline).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arg_going
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %d or %g has been seen; the next arg to be terminated    is a temporary file name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delete_this_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %w has been seen; the next arg to be terminated    is the output file name of this compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_is_output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %s has been seen; the next arg to be terminated    is the name of a library file and we should try the standard    search dirs for it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_is_library_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that the input of this command is coming from a pipe.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_from_pipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonnull means substitute this for any suffix when outputting a switches    arguments.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|suffix_subst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process the spec SPEC and run the commands specified therein.    Returns 0 if the spec is successfully processed; -1 if failed.  */
end_comment

begin_function
name|int
name|do_spec
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|do_spec_2
argument_list|(
name|spec
argument_list|)
expr_stmt|;
comment|/* Force out any unfinished command.      If -pipe, this forces out the last command if it ended in `|'.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
name|argbuf_index
operator|--
expr_stmt|;
name|set_collect_gcc_options
argument_list|()
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
name|value
operator|=
name|execute
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_spec_2
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|result
decl_stmt|;
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
name|input_from_pipe
operator|=
literal|0
expr_stmt|;
name|suffix_subst
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|do_spec_1
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* End any pending argument.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Process the given spec string and add any new options to the end    of the switches/n_switches array.  */
end_comment

begin_function
specifier|static
name|void
name|do_option_spec
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|value_count
decl_stmt|,
name|value_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|tmp_spec
decl_stmt|,
modifier|*
name|tmp_spec_p
decl_stmt|;
if|if
condition|(
name|configure_default_options
index|[
literal|0
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|configure_default_options
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|configure_default_options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|configure_default_options
argument_list|)
condition|)
return|return;
name|value
operator|=
name|configure_default_options
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
name|value_len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Compute the size of the final spec.  */
name|value_count
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|spec
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|p
argument_list|,
literal|"%(VALUE)"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|value_count
operator|++
expr_stmt|;
block|}
comment|/* Replace each %(VALUE) by the specified value.  */
name|tmp_spec
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|spec
argument_list|)
operator|+
literal|1
operator|+
name|value_count
operator|*
operator|(
name|value_len
operator|-
name|strlen
argument_list|(
literal|"%(VALUE)"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmp_spec_p
operator|=
name|tmp_spec
expr_stmt|;
name|q
operator|=
name|spec
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|q
argument_list|,
literal|"%(VALUE)"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|tmp_spec_p
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|tmp_spec_p
operator|=
name|tmp_spec_p
operator|+
operator|(
name|p
operator|-
name|q
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_spec_p
argument_list|,
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
name|tmp_spec_p
operator|+=
name|value_len
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
literal|"%(VALUE)"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp_spec_p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|do_self_spec
argument_list|(
name|tmp_spec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the given spec string and add any new options to the end    of the switches/n_switches array.  */
end_comment

begin_function
specifier|static
name|void
name|do_self_spec
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|do_spec_2
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
name|n_switches
expr_stmt|;
name|n_switches
operator|+=
name|argbuf_index
expr_stmt|;
name|switches
operator|=
name|xrealloc
argument_list|(
name|switches
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|switchstr
argument_list|)
operator|*
operator|(
name|n_switches
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|=
name|switches
index|[
name|first
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|switchstr
modifier|*
name|sw
decl_stmt|;
comment|/* Each switch should start with '-'.  */
if|if
condition|(
name|argbuf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"switch '%s' does not start with '-'"
argument_list|,
name|argbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sw
operator|=
operator|&
name|switches
index|[
name|i
operator|+
name|first
index|]
expr_stmt|;
name|sw
operator|->
name|part1
operator|=
operator|&
name|argbuf
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
name|sw
operator|->
name|args
operator|=
literal|0
expr_stmt|;
name|sw
operator|->
name|live_cond
operator|=
name|SWITCH_OK
expr_stmt|;
name|sw
operator|->
name|validated
operator|=
literal|0
expr_stmt|;
name|sw
operator|->
name|ordering
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Callback for processing %D and %I specs.  */
end_comment

begin_struct
struct|struct
name|spec_path_info
block|{
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
specifier|const
name|char
modifier|*
name|append
decl_stmt|;
name|size_t
name|append_len
decl_stmt|;
name|bool
name|omit_relative
decl_stmt|;
name|bool
name|separate_options
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
modifier|*
name|spec_path
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|spec_path_info
modifier|*
name|info
init|=
name|data
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
name|save
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|omit_relative
operator|&&
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|info
operator|->
name|append_len
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|info
operator|->
name|append
argument_list|,
name|info
operator|->
name|append_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_directory
argument_list|(
name|path
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|NULL
return|;
name|do_spec_1
argument_list|(
name|info
operator|->
name|option
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|separate_options
condition|)
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|append_len
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|save
operator|=
name|path
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|path
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|do_spec_1
argument_list|(
name|path
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Must not damage the original path.  */
if|if
condition|(
name|info
operator|->
name|append_len
operator|==
literal|0
condition|)
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|save
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Process the sub-spec SPEC as a portion of a larger spec.    This is like processing a whole spec except that we do    not initialize at the beginning and we do not supply a    newline by default at the end.    INSWITCH nonzero means don't process %-sequences in SPEC;    in this case, % is treated as an ordinary character.    This is used while substituting switches.    INSWITCH nonzero also causes SPC not to terminate an argument.     Value is zero unless a line was finished    and the command on that line reported an error.  */
end_comment

begin_function
specifier|static
name|int
name|do_spec_1
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|int
name|inswitch
parameter_list|,
specifier|const
name|char
modifier|*
name|soft_matched_part
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|spec
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|value
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
comment|/* If substituting a switch, treat all chars like letters.        Otherwise, NL, SPC, TAB and % are special.  */
switch|switch
condition|(
name|inswitch
condition|?
literal|'a'
else|:
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* End of line: finish any pending argument, 	   then run the pending command if one has been started.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
name|arg_going
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
block|{
comment|/* A `|' before the newline means use a pipe here, 	       but only if -pipe was specified. 	       Otherwise, execute now and don't pass the `|' as an arg.  */
if|if
condition|(
name|use_pipes
condition|)
block|{
name|input_from_pipe
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|argbuf_index
operator|--
expr_stmt|;
block|}
name|set_collect_gcc_options
argument_list|()
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|execute
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
condition|)
return|return
name|value
return|;
block|}
comment|/* Reinitialize for a new command, and for a new argument.  */
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
name|input_from_pipe
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* End any pending argument.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Use pipe */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
comment|/* Space or tab ends an argument if one is pending.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Reinitialize for a new argument.  */
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|fatal
argument_list|(
literal|"spec '%s' invalid"
argument_list|,
name|spec
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_basename
argument_list|,
name|basename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_basename
argument_list|,
name|suffixed_basename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete_this_arg
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* Dump out the directories specified with LIBRARY_PATH, 	     followed by the absolute directories 	     that we search for startfiles.  */
case|case
literal|'D'
case|:
block|{
name|struct
name|spec_path_info
name|info
decl_stmt|;
name|info
operator|.
name|option
operator|=
literal|"-L"
expr_stmt|;
name|info
operator|.
name|append_len
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RELATIVE_PREFIX_NOT_LINKDIR
comment|/* Used on systems which record the specified -L dirs 		 and use them to search for dynamic linking. 		 Relative directories always come from -B, 		 and it is better not to use them for searching 		 at run time.  In particular, stage1 loses.  */
name|info
operator|.
name|omit_relative
operator|=
name|true
expr_stmt|;
else|#
directive|else
name|info
operator|.
name|omit_relative
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
name|info
operator|.
name|separate_options
operator|=
name|false
expr_stmt|;
name|for_each_path
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|spec_path
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* %efoo means report an error with `foo' as error message 	       and don't execute any more commands for this file.  */
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|p
operator|-
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|q
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* %nfoo means report a notice with `foo' on stderr.  */
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|p
operator|-
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|q
index|]
operator|=
literal|0
expr_stmt|;
name|notice
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'j'
case|:
block|{
name|struct
name|stat
name|st
decl_stmt|;
comment|/* If save_temps_flag is off, and the HOST_BIT_BUCKET is 		 defined, and it is not a directory, and it is 		 writable, use it.  Otherwise, treat this like any 		 other temporary file.  */
if|if
condition|(
operator|(
operator|!
name|save_temps_flag
operator|)
operator|&&
operator|(
name|stat
argument_list|(
name|HOST_BIT_BUCKET
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|)
operator|&&
operator|(
name|access
argument_list|(
name|HOST_BIT_BUCKET
argument_list|,
name|W_OK
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|HOST_BIT_BUCKET
argument_list|,
name|strlen
argument_list|(
name|HOST_BIT_BUCKET
argument_list|)
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
goto|goto
name|create_temp_file
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
name|use_pipes
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
comment|/* consume suffix */
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
goto|goto
name|create_temp_file
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
name|use_pipes
condition|)
block|{
comment|/* consume suffix */
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
goto|goto
name|create_temp_file
goto|;
case|case
literal|'g'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|create_temp_file
label|:
block|{
name|struct
name|temp_name
modifier|*
name|t
decl_stmt|;
name|int
name|suffix_length
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|saved_suffix
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|suffix_length
operator|=
name|p
operator|-
name|suffix
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* We don't support extra suffix characters after %O.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"spec '%s' has invalid '%%0%c'"
argument_list|,
name|spec
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix_length
operator|==
literal|0
condition|)
name|suffix
operator|=
name|TARGET_OBJECT_SUFFIX
expr_stmt|;
else|else
block|{
name|saved_suffix
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|suffix_length
operator|+
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|saved_suffix
argument_list|,
name|suffix
argument_list|,
name|suffix_length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|saved_suffix
operator|+
name|suffix_length
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|)
expr_stmt|;
block|}
name|suffix_length
operator|+=
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
expr_stmt|;
block|}
comment|/* If the input_filename has the same suffix specified 		   for the %g, %u, or %U, and -save-temps is specified, 		   we could end up using that file as an intermediate 		   thus clobbering the user's source file (.e.g., 		   gcc -save-temps foo.s would clobber foo.s with the 		   output of cpp0).  So check for this condition and 		   generate a temp file as the intermediate.  */
if|if
condition|(
name|save_temps_flag
condition|)
block|{
name|temp_filename_length
operator|=
name|basename_length
operator|+
name|suffix_length
expr_stmt|;
name|temp_filename
operator|=
name|alloca
argument_list|(
name|temp_filename_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp_filename
argument_list|,
name|input_basename
argument_list|,
name|basename_length
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp_filename
operator|+
name|basename_length
argument_list|,
name|suffix
argument_list|,
name|suffix_length
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|temp_filename
operator|+
name|temp_filename_length
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|temp_filename
argument_list|,
name|input_filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|HOST_LACKS_INODE_NUMBERS
name|struct
name|stat
name|st_temp
decl_stmt|;
comment|/* Note, set_input() resets input_stat_set to 0.  */
if|if
condition|(
name|input_stat_set
operator|==
literal|0
condition|)
block|{
name|input_stat_set
operator|=
name|stat
argument_list|(
name|input_filename
argument_list|,
operator|&
name|input_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_stat_set
operator|>=
literal|0
condition|)
name|input_stat_set
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we have the stat for the input_filename 			   and we can do the stat for the temp_filename 			   then the they could still refer to the same 			   file if st_dev/st_ino's are the same.  */
if|if
condition|(
name|input_stat_set
operator|!=
literal|1
operator|||
name|stat
argument_list|(
name|temp_filename
argument_list|,
operator|&
name|st_temp
argument_list|)
operator|<
literal|0
operator|||
name|input_stat
operator|.
name|st_dev
operator|!=
name|st_temp
operator|.
name|st_dev
operator|||
name|input_stat
operator|.
name|st_ino
operator|!=
name|st_temp
operator|.
name|st_ino
condition|)
else|#
directive|else
comment|/* Just compare canonical pathnames.  */
name|char
modifier|*
name|input_realname
init|=
name|lrealpath
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp_realname
init|=
name|lrealpath
argument_list|(
name|temp_filename
argument_list|)
decl_stmt|;
name|bool
name|files_differ
init|=
name|strcmp
argument_list|(
name|input_realname
argument_list|,
name|temp_realname
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|input_realname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|files_differ
condition|)
endif|#
directive|endif
block|{
name|temp_filename
operator|=
name|save_string
argument_list|(
name|temp_filename
argument_list|,
name|temp_filename_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|temp_filename
argument_list|,
name|temp_filename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* See if we already have an association of %g/%u/%U and 		   suffix.  */
for|for
control|(
name|t
operator|=
name|temp_names
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|length
operator|==
name|suffix_length
operator|&&
name|strncmp
argument_list|(
name|t
operator|->
name|suffix
argument_list|,
name|suffix
argument_list|,
name|suffix_length
argument_list|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|unique
operator|==
operator|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
operator|||
name|c
operator|==
literal|'j'
operator|)
condition|)
break|break;
comment|/* Make a new association if needed.  %u and %j 		   require one.  */
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'j'
condition|)
block|{
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|temp_names
expr_stmt|;
name|temp_names
operator|=
name|t
expr_stmt|;
block|}
name|t
operator|->
name|length
operator|=
name|suffix_length
expr_stmt|;
if|if
condition|(
name|saved_suffix
condition|)
block|{
name|t
operator|->
name|suffix
operator|=
name|saved_suffix
expr_stmt|;
name|saved_suffix
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|t
operator|->
name|suffix
operator|=
name|save_string
argument_list|(
name|suffix
argument_list|,
name|suffix_length
argument_list|)
expr_stmt|;
name|t
operator|->
name|unique
operator|=
operator|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
operator|||
name|c
operator|==
literal|'j'
operator|)
expr_stmt|;
name|temp_filename
operator|=
name|make_temp_file
argument_list|(
name|t
operator|->
name|suffix
argument_list|)
expr_stmt|;
name|temp_filename_length
operator|=
name|strlen
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|temp_filename
expr_stmt|;
name|t
operator|->
name|filename_length
operator|=
name|temp_filename_length
expr_stmt|;
block|}
if|if
condition|(
name|saved_suffix
condition|)
name|free
argument_list|(
name|saved_suffix
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|t
operator|->
name|filename
argument_list|,
name|t
operator|->
name|filename_length
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|1
expr_stmt|;
block|}
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|combine_inputs
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|!
name|infiles
index|[
name|i
index|]
operator|.
name|language
operator|)
operator|||
operator|(
name|infiles
index|[
name|i
index|]
operator|.
name|language
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|)
condition|)
if|if
condition|(
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
operator|==
name|input_file_compiler
condition|)
block|{
name|store_arg
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|compiled
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_filename
argument_list|,
name|input_filename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
block|{
name|struct
name|spec_path_info
name|info
decl_stmt|;
if|if
condition|(
name|multilib_dir
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-imultilib"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|multilib_dir
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gcc_exec_prefix
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-iprefix"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|gcc_exec_prefix
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_system_root_changed
operator|||
operator|(
name|target_system_root
operator|&&
name|target_sysroot_hdrs_suffix
operator|)
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-isysroot"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make this a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|target_system_root
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_sysroot_hdrs_suffix
condition|)
name|do_spec_1
argument_list|(
name|target_sysroot_hdrs_suffix
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|option
operator|=
literal|"-isystem"
expr_stmt|;
name|info
operator|.
name|append
operator|=
literal|"include"
expr_stmt|;
name|info
operator|.
name|append_len
operator|=
name|strlen
argument_list|(
name|info
operator|.
name|append
argument_list|)
expr_stmt|;
name|info
operator|.
name|omit_relative
operator|=
name|false
expr_stmt|;
name|info
operator|.
name|separate_options
operator|=
name|true
expr_stmt|;
name|for_each_path
argument_list|(
operator|&
name|include_prefixes
argument_list|,
name|false
argument_list|,
name|info
operator|.
name|append_len
argument_list|,
name|spec_path
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
block|{
name|int
name|max
init|=
name|n_infiles
decl_stmt|;
name|max
operator|+=
name|lang_specific_extra_outfiles
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|outfiles
index|[
name|i
index|]
condition|)
name|store_arg
argument_list|(
name|outfiles
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'O'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|this_is_library_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|this_is_output_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
block|{
name|int
name|cur_index
init|=
name|argbuf_index
decl_stmt|;
comment|/* Handle the {...} following the %W.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
name|fatal
argument_list|(
literal|"spec '%s' has invalid '%%W%c"
argument_list|,
name|spec
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|handle_braces
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* End any pending argument.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If any args were output, mark the last one for deletion 		 on failure.  */
if|if
condition|(
name|argbuf_index
operator|!=
name|cur_index
condition|)
name|record_temp_file
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* %x{OPTION} records OPTION for %X to output.  */
case|case
literal|'x'
case|:
block|{
specifier|const
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Skip past the option value and make a copy.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
name|fatal
argument_list|(
literal|"spec '%s' has invalid '%%x%c'"
argument_list|,
name|spec
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
name|string
operator|=
name|save_string
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
name|p
operator|-
name|p1
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* See if we already recorded this option.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_linker_options
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|string
argument_list|,
name|linker_options
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This option is new; add it.  */
name|add_linker_option
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using %x.  */
case|case
literal|'X'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_linker_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|linker_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using -Wa,.  */
case|case
literal|'Y'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_assembler_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|assembler_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Dump out the options accumulated previously using -Wp,.  */
case|case
literal|'Z'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_preprocessor_options
condition|;
name|i
operator|++
control|)
block|{
name|do_spec_1
argument_list|(
name|preprocessor_options
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make each accumulated option a separate argument.  */
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Here are digits and numbers that just process 	       a certain constant string as a spec.  */
case|case
literal|'1'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|cc1_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'2'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|cc1plus_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'a'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|asm_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'A'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|asm_final_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'C'
case|:
block|{
specifier|const
name|char
modifier|*
specifier|const
name|spec
init|=
operator|(
name|input_file_compiler
operator|->
name|cpp_spec
condition|?
name|input_file_compiler
operator|->
name|cpp_spec
else|:
name|cpp_spec
operator|)
decl_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
break|break;
case|case
literal|'E'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|endfile_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'l'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|link_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'L'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|lib_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'G'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|libgcc_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
case|case
literal|'R'
case|:
comment|/* We assume there is a directory 	       separator at the end of this string.  */
if|if
condition|(
name|target_system_root
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|target_system_root
argument_list|,
name|strlen
argument_list|(
name|target_system_root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_sysroot_suffix
condition|)
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|target_sysroot_suffix
argument_list|,
name|strlen
argument_list|(
name|target_sysroot_suffix
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
name|value
operator|=
name|do_spec_1
argument_list|(
name|startfile_spec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
break|break;
comment|/* Here we define characters other than letters and digits.  */
case|case
literal|'{'
case|:
name|p
operator|=
name|handle_braces
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|':'
case|:
name|p
operator|=
name|handle_spec_function
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'%'
case|:
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
block|{
name|unsigned
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
index|[
name|len
index|]
operator|&&
name|p
index|[
name|len
index|]
operator|!=
literal|' '
operator|&&
name|p
index|[
name|len
index|]
operator|!=
literal|'%'
condition|)
name|len
operator|++
expr_stmt|;
name|suffix_subst
operator|=
name|save_string
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
break|break;
comment|/* Henceforth ignore the option(s) matching the pattern 	      after the %<.  */
case|case
literal|'<'
case|:
block|{
name|unsigned
name|len
init|=
literal|0
decl_stmt|;
name|int
name|have_wildcard
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|p
index|[
name|len
index|]
operator|&&
name|p
index|[
name|len
index|]
operator|!=
literal|' '
operator|&&
name|p
index|[
name|len
index|]
operator|!=
literal|'\t'
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|have_wildcard
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|p
argument_list|,
name|len
operator|-
name|have_wildcard
argument_list|)
operator|&&
operator|(
name|have_wildcard
operator|||
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_IGNORE
expr_stmt|;
name|switches
index|[
name|i
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|soft_matched_part
condition|)
block|{
name|do_spec_1
argument_list|(
name|soft_matched_part
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Catch the case where a spec string contains something like 		 '%{foo:%*}'.  i.e. there is no * in the pattern on the left 		 hand side of the :.  */
name|error
argument_list|(
literal|"spec failure: '%%*' has not been initialized by pattern match"
argument_list|)
expr_stmt|;
break|break;
comment|/* Process a string found as the value of a spec given by name. 	       This feature allows individual machine descriptions 	       to add and use their own specs. 	       %[...] modifies -D options the way %P does; 	       %(...) uses the spec unmodified.  */
case|case
literal|'['
case|:
name|error
argument_list|(
literal|"warning: use of obsolete %%[ operator in specs"
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|p
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|sl
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* The string after the S/P is the name of a spec that is to be 		 processed.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|')'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* See if it's in the list.  */
for|for
control|(
name|len
operator|=
name|p
operator|-
name|name
operator|,
name|sl
operator|=
name|specs
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
if|if
condition|(
name|sl
operator|->
name|name_len
operator|==
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|sl
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|name
operator|=
operator|*
operator|(
name|sl
operator|->
name|ptr_spec
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPECS
name|notice
argument_list|(
literal|"Processing spec %c%s%c, which is '%s'\n"
argument_list|,
name|c
argument_list|,
name|sl
operator|->
name|name
argument_list|,
operator|(
name|c
operator|==
literal|'('
operator|)
condition|?
literal|')'
else|:
literal|']'
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|sl
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|value
operator|=
name|do_spec_1
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
else|else
block|{
name|char
modifier|*
name|x
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|*
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|y
init|=
name|name
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
comment|/* Copy all of NAME into BUF, but put __ after 			 every -D and at the end of each arg.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
name|y
operator|+=
literal|2
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&&
operator|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|'\t'
operator|||
operator|*
name|y
operator|==
literal|'='
operator|||
operator|*
name|y
operator|==
literal|'}'
operator|||
operator|*
name|y
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|y
operator|==
literal|0
condition|)
break|break;
else|else
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
block|}
comment|/* Discard the closing paren or bracket.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"spec failure: unrecognized spec option '%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash: treat next character as ordinary.  */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Fall through.  */
default|default:
comment|/* Ordinary character: put it into the current argument.  */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
block|}
comment|/* End of string.  If we are processing a spec function, we need to      end any pending argument.  */
if|if
condition|(
name|processing_spec_function
operator|&&
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look up a spec function.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|spec_function
modifier|*
name|lookup_spec_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|spec_function
modifier|*
name|sf
decl_stmt|;
for|for
control|(
name|sf
operator|=
name|static_spec_functions
init|;
name|sf
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sf
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sf
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sf
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Evaluate a spec function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eval_spec_function
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
specifier|const
name|struct
name|spec_function
modifier|*
name|sf
decl_stmt|;
specifier|const
name|char
modifier|*
name|funcval
decl_stmt|;
comment|/* Saved spec processing context.  */
name|int
name|save_argbuf_index
decl_stmt|;
name|int
name|save_argbuf_length
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|save_argbuf
decl_stmt|;
name|int
name|save_arg_going
decl_stmt|;
name|int
name|save_delete_this_arg
decl_stmt|;
name|int
name|save_this_is_output_file
decl_stmt|;
name|int
name|save_this_is_library_file
decl_stmt|;
name|int
name|save_input_from_pipe
decl_stmt|;
specifier|const
name|char
modifier|*
name|save_suffix_subst
decl_stmt|;
name|sf
operator|=
name|lookup_spec_function
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"unknown spec function '%s'"
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* Push the spec processing context.  */
name|save_argbuf_index
operator|=
name|argbuf_index
expr_stmt|;
name|save_argbuf_length
operator|=
name|argbuf_length
expr_stmt|;
name|save_argbuf
operator|=
name|argbuf
expr_stmt|;
name|save_arg_going
operator|=
name|arg_going
expr_stmt|;
name|save_delete_this_arg
operator|=
name|delete_this_arg
expr_stmt|;
name|save_this_is_output_file
operator|=
name|this_is_output_file
expr_stmt|;
name|save_this_is_library_file
operator|=
name|this_is_library_file
expr_stmt|;
name|save_input_from_pipe
operator|=
name|input_from_pipe
expr_stmt|;
name|save_suffix_subst
operator|=
name|suffix_subst
expr_stmt|;
comment|/* Create a new spec processing context, and build the function      arguments.  */
name|alloc_args
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_spec_2
argument_list|(
name|args
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"error in args to spec function '%s'"
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* argbuf_index is an index for the next argument to be inserted, and      so contains the count of the args already inserted.  */
name|funcval
operator|=
call|(
modifier|*
name|sf
operator|->
name|func
call|)
argument_list|(
name|argbuf_index
argument_list|,
name|argbuf
argument_list|)
expr_stmt|;
comment|/* Pop the spec processing context.  */
name|argbuf_index
operator|=
name|save_argbuf_index
expr_stmt|;
name|argbuf_length
operator|=
name|save_argbuf_length
expr_stmt|;
name|free
argument_list|(
name|argbuf
argument_list|)
expr_stmt|;
name|argbuf
operator|=
name|save_argbuf
expr_stmt|;
name|arg_going
operator|=
name|save_arg_going
expr_stmt|;
name|delete_this_arg
operator|=
name|save_delete_this_arg
expr_stmt|;
name|this_is_output_file
operator|=
name|save_this_is_output_file
expr_stmt|;
name|this_is_library_file
operator|=
name|save_this_is_library_file
expr_stmt|;
name|input_from_pipe
operator|=
name|save_input_from_pipe
expr_stmt|;
name|suffix_subst
operator|=
name|save_suffix_subst
expr_stmt|;
return|return
name|funcval
return|;
block|}
end_function

begin_comment
comment|/* Handle a spec function call of the form:     %:function(args)     ARGS is processed as a spec in a separate context and split into an    argument vector in the normal fashion.  The function returns a string    containing a spec which we then process in the caller's context, or    NULL if no processing is required.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|handle_spec_function
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|func
decl_stmt|,
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|endp
decl_stmt|,
modifier|*
name|funcval
decl_stmt|;
name|int
name|count
decl_stmt|;
name|processing_spec_function
operator|++
expr_stmt|;
comment|/* Get the function name.  */
for|for
control|(
name|endp
operator|=
name|p
init|;
operator|*
name|endp
operator|!=
literal|'\0'
condition|;
name|endp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
literal|'('
condition|)
comment|/* ) */
break|break;
comment|/* Only allow [A-Za-z0-9], -, and _ in function names.  */
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
name|endp
argument_list|)
operator|&&
operator|!
operator|(
operator|*
name|endp
operator|==
literal|'-'
operator|||
operator|*
name|endp
operator|==
literal|'_'
operator|)
condition|)
name|fatal
argument_list|(
literal|"malformed spec function name"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'('
condition|)
comment|/* ) */
name|fatal
argument_list|(
literal|"no arguments for spec function"
argument_list|)
expr_stmt|;
name|func
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|endp
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|++
name|endp
expr_stmt|;
comment|/* Get the arguments.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|*
name|endp
operator|!=
literal|'\0'
condition|;
name|endp
operator|++
control|)
block|{
comment|/* ( */
if|if
condition|(
operator|*
name|endp
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
name|count
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|endp
operator|==
literal|'('
condition|)
comment|/* ) */
name|count
operator|++
expr_stmt|;
block|}
comment|/* ( */
if|if
condition|(
operator|*
name|endp
operator|!=
literal|')'
condition|)
name|fatal
argument_list|(
literal|"malformed spec function arguments"
argument_list|)
expr_stmt|;
name|args
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
name|endp
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|++
name|endp
expr_stmt|;
comment|/* p now points to just past the end of the spec function expression.  */
name|funcval
operator|=
name|eval_spec_function
argument_list|(
name|func
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcval
operator|!=
name|NULL
operator|&&
name|do_spec_1
argument_list|(
name|funcval
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|processing_spec_function
operator|--
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Inline subroutine of handle_braces.  Returns true if the current    input suffix matches the atom bracketed by ATOM and END_ATOM.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|input_suffix_matches
parameter_list|(
specifier|const
name|char
modifier|*
name|atom
parameter_list|,
specifier|const
name|char
modifier|*
name|end_atom
parameter_list|)
block|{
comment|/* We special case the semantics of {.s:...} and {.S:...} and their      negative variants.  Instead of testing the input filename suffix,      we test whether the input source file is an assembler file or an      assembler-with-cpp file respectively.  This allows us to correctly      handle the -x command line option.  */
if|if
condition|(
name|atom
operator|+
literal|1
operator|==
name|end_atom
operator|&&
name|input_file_compiler
operator|&&
name|input_file_compiler
operator|->
name|suffix
condition|)
block|{
if|if
condition|(
operator|*
name|atom
operator|==
literal|'s'
condition|)
return|return
operator|!
name|strcmp
argument_list|(
name|input_file_compiler
operator|->
name|suffix
argument_list|,
literal|"@assembler"
argument_list|)
return|;
if|if
condition|(
operator|*
name|atom
operator|==
literal|'S'
condition|)
return|return
operator|!
name|strcmp
argument_list|(
name|input_file_compiler
operator|->
name|suffix
argument_list|,
literal|"@assembler-with-cpp"
argument_list|)
return|;
block|}
return|return
operator|(
name|input_suffix
operator|&&
operator|!
name|strncmp
argument_list|(
name|input_suffix
argument_list|,
name|atom
argument_list|,
name|end_atom
operator|-
name|atom
argument_list|)
operator|&&
name|input_suffix
index|[
name|end_atom
operator|-
name|atom
index|]
operator|==
literal|'\0'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of handle_braces.  Returns true if a switch    matching the atom bracketed by ATOM and END_ATOM appeared on the    command line.  */
end_comment

begin_function
specifier|static
name|bool
name|switch_matches
parameter_list|(
specifier|const
name|char
modifier|*
name|atom
parameter_list|,
specifier|const
name|char
modifier|*
name|end_atom
parameter_list|,
name|int
name|starred
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
name|end_atom
operator|-
name|atom
decl_stmt|;
name|int
name|plen
init|=
name|starred
condition|?
name|len
else|:
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|atom
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|starred
operator|||
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|plen
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Inline subroutine of handle_braces.  Mark all of the switches which    match ATOM (extends to END_ATOM; STARRED indicates whether there    was a star after the atom) for later processing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_matching_switches
parameter_list|(
specifier|const
name|char
modifier|*
name|atom
parameter_list|,
specifier|const
name|char
modifier|*
name|end_atom
parameter_list|,
name|int
name|starred
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
name|end_atom
operator|-
name|atom
decl_stmt|;
name|int
name|plen
init|=
name|starred
condition|?
name|len
else|:
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|atom
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|starred
operator|||
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|plen
argument_list|)
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|ordering
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inline subroutine of handle_braces.  Process all the currently    marked switches through give_switch, and clear the marks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|process_marked_switches
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|ordering
operator|==
literal|1
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|ordering
operator|=
literal|0
expr_stmt|;
name|give_switch
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a %{ ... } construct.  P points just inside the leading {.    Returns a pointer one past the end of the brace block, or 0    if we call do_spec_1 and that returns -1.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|handle_braces
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|atom
decl_stmt|,
modifier|*
name|end_atom
decl_stmt|;
specifier|const
name|char
modifier|*
name|d_atom
init|=
name|NULL
decl_stmt|,
modifier|*
name|d_end_atom
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig
init|=
name|p
decl_stmt|;
name|bool
name|a_is_suffix
decl_stmt|;
name|bool
name|a_is_starred
decl_stmt|;
name|bool
name|a_is_negated
decl_stmt|;
name|bool
name|a_matched
decl_stmt|;
name|bool
name|a_must_be_last
init|=
name|false
decl_stmt|;
name|bool
name|ordered_set
init|=
name|false
decl_stmt|;
name|bool
name|disjunct_set
init|=
name|false
decl_stmt|;
name|bool
name|disj_matched
init|=
name|false
decl_stmt|;
name|bool
name|disj_starred
init|=
name|true
decl_stmt|;
name|bool
name|n_way_choice
init|=
name|false
decl_stmt|;
name|bool
name|n_way_matched
init|=
name|false
decl_stmt|;
define|#
directive|define
name|SKIP_WHITE
parameter_list|()
value|do { while (*p == ' ' || *p == '\t') p++; } while (0)
do|do
block|{
if|if
condition|(
name|a_must_be_last
condition|)
goto|goto
name|invalid
goto|;
comment|/* Scan one "atom" (S in the description above of %{}, possibly 	 with !, ., or * modifiers).  */
name|a_matched
operator|=
name|a_is_suffix
operator|=
name|a_is_starred
operator|=
name|a_is_negated
operator|=
name|false
expr_stmt|;
name|SKIP_WHITE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
name|p
operator|++
operator|,
name|a_is_negated
operator|=
name|true
expr_stmt|;
name|SKIP_WHITE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
operator|,
name|a_is_suffix
operator|=
name|true
expr_stmt|;
name|atom
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|ISIDNUM
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'='
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|'@'
condition|)
name|p
operator|++
expr_stmt|;
name|end_atom
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
name|p
operator|++
operator|,
name|a_is_starred
operator|=
literal|1
expr_stmt|;
name|SKIP_WHITE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'&'
case|:
case|case
literal|'}'
case|:
comment|/* Substitute the switch(es) indicated by the current atom.  */
name|ordered_set
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|disjunct_set
operator|||
name|n_way_choice
operator|||
name|a_is_negated
operator|||
name|a_is_suffix
operator|||
name|atom
operator|==
name|end_atom
condition|)
goto|goto
name|invalid
goto|;
name|mark_matching_switches
argument_list|(
name|atom
argument_list|,
name|end_atom
argument_list|,
name|a_is_starred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
name|process_marked_switches
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
case|case
literal|':'
case|:
comment|/* Substitute some text if the current atom appears as a switch 	     or suffix.  */
name|disjunct_set
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|ordered_set
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
name|atom
operator|==
name|end_atom
condition|)
block|{
if|if
condition|(
operator|!
name|n_way_choice
operator|||
name|disj_matched
operator|||
operator|*
name|p
operator|==
literal|'|'
operator|||
name|a_is_negated
operator|||
name|a_is_suffix
operator|||
name|a_is_starred
condition|)
goto|goto
name|invalid
goto|;
comment|/* An empty term may appear as the last choice of an 		 N-way choice set; it means "otherwise".  */
name|a_must_be_last
operator|=
name|true
expr_stmt|;
name|disj_matched
operator|=
operator|!
name|n_way_matched
expr_stmt|;
name|disj_starred
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a_is_suffix
operator|&&
name|a_is_starred
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
operator|!
name|a_is_starred
condition|)
name|disj_starred
operator|=
name|false
expr_stmt|;
comment|/* Don't bother testing this atom if we already have a                   match.  */
if|if
condition|(
operator|!
name|disj_matched
operator|&&
operator|!
name|n_way_matched
condition|)
block|{
if|if
condition|(
name|a_is_suffix
condition|)
name|a_matched
operator|=
name|input_suffix_matches
argument_list|(
name|atom
argument_list|,
name|end_atom
argument_list|)
expr_stmt|;
else|else
name|a_matched
operator|=
name|switch_matches
argument_list|(
name|atom
argument_list|,
name|end_atom
argument_list|,
name|a_is_starred
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_matched
operator|!=
name|a_is_negated
condition|)
block|{
name|disj_matched
operator|=
name|true
expr_stmt|;
name|d_atom
operator|=
name|atom
expr_stmt|;
name|d_end_atom
operator|=
name|end_atom
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* Found the body, that is, the text to substitute if the 		 current disjunction matches.  */
name|p
operator|=
name|process_brace_body
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|d_atom
argument_list|,
name|d_end_atom
argument_list|,
name|disj_starred
argument_list|,
name|disj_matched
operator|&&
operator|!
name|n_way_matched
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we have an N-way choice, reset state for the next 		 disjunction.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
name|n_way_choice
operator|=
name|true
expr_stmt|;
name|n_way_matched
operator||=
name|disj_matched
expr_stmt|;
name|disj_matched
operator|=
name|false
expr_stmt|;
name|disj_starred
operator|=
name|true
expr_stmt|;
name|d_atom
operator|=
name|d_end_atom
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
default|default:
goto|goto
name|invalid
goto|;
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
do|;
return|return
name|p
return|;
name|invalid
label|:
name|fatal
argument_list|(
literal|"braced spec '%s' is invalid at '%c'"
argument_list|,
name|orig
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SKIP_WHITE
block|}
end_function

begin_comment
comment|/* Subroutine of handle_braces.  Scan and process a brace substitution body    (X in the description of %{} syntax).  P points one past the colon;    ATOM and END_ATOM bracket the first atom which was found to be true    (present) in the current disjunction; STARRED indicates whether all    the atoms in the current disjunction were starred (for syntax validation);    MATCHED indicates whether the disjunction matched or not, and therefore    whether or not the body is to be processed through do_spec_1 or just    skipped.  Returns a pointer to the closing } or ;, or 0 if do_spec_1    returns -1.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|process_brace_body
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|atom
parameter_list|,
specifier|const
name|char
modifier|*
name|end_atom
parameter_list|,
name|int
name|starred
parameter_list|,
name|int
name|matched
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|body
decl_stmt|,
modifier|*
name|end_body
decl_stmt|;
name|unsigned
name|int
name|nesting_level
decl_stmt|;
name|bool
name|have_subst
init|=
name|false
decl_stmt|;
comment|/* Locate the closing } or ;, honoring nested braces.      Trim trailing whitespace.  */
name|body
operator|=
name|p
expr_stmt|;
name|nesting_level
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
name|nesting_level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|nesting_level
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|';'
operator|&&
name|nesting_level
operator|==
literal|1
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|nesting_level
operator|==
literal|1
condition|)
name|have_subst
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
name|p
operator|++
expr_stmt|;
block|}
name|end_body
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|end_body
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|end_body
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
name|end_body
operator|--
expr_stmt|;
if|if
condition|(
name|have_subst
operator|&&
operator|!
name|starred
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
name|matched
condition|)
block|{
comment|/* Copy the substitution body to permanent storage and execute it. 	 If have_subst is false, this is a simple matter of running the 	 body through do_spec_1...  */
name|char
modifier|*
name|string
init|=
name|save_string
argument_list|(
name|body
argument_list|,
name|end_body
operator|-
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|have_subst
condition|)
block|{
if|if
condition|(
name|do_spec_1
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* ... but if have_subst is true, we have to process the 	     body once for each matching switch, with %* set to the 	     variant part of the switch.  */
name|unsigned
name|int
name|hard_match_len
init|=
name|end_atom
operator|-
name|atom
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|atom
argument_list|,
name|hard_match_len
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|hard_match_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_spec_1
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|hard_match_len
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Pass any arguments this switch has.  */
name|give_switch
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|suffix_subst
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
name|p
return|;
name|invalid
label|:
name|fatal
argument_list|(
literal|"braced spec body '%s' is invalid"
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch    on the command line.  PREFIX_LENGTH is the length of XXX in an {XXX*}    spec, or -1 if either exact match or %* is used.     A -O switch is obsoleted by a later -O switch.  A -f, -m, or -W switch    whose value does not begin with "no-" is obsoleted by the same value    with the "no-", similarly for a switch with the "no-" prefix.  */
end_comment

begin_function
specifier|static
name|int
name|check_live_switch
parameter_list|(
name|int
name|switchnum
parameter_list|,
name|int
name|prefix_length
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|switches
index|[
name|switchnum
index|]
operator|.
name|part1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* In the common case of {<at-most-one-letter>*}, a negating      switch would always match, so ignore that case.  We will just      send the conflicting switches to the compiler phase.  */
if|if
condition|(
name|prefix_length
operator|>=
literal|0
operator|&&
name|prefix_length
operator|<=
literal|1
condition|)
return|return
literal|1
return|;
comment|/* If we already processed this switch and determined if it was      live or not, return our past determination.  */
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|!=
literal|0
condition|)
return|return
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|>
literal|0
return|;
comment|/* Now search for duplicate in a manner that depends on the name.  */
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'O'
case|:
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
literal|'O'
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'W'
case|:
case|case
literal|'f'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* We have Xno-YYY, search for XYYY.  */
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|1
index|]
argument_list|,
operator|&
name|name
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* We have XYYY, search for Xno-YYY.  */
for|for
control|(
name|i
operator|=
name|switchnum
operator|+
literal|1
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|3
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
literal|4
index|]
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
break|break;
block|}
comment|/* Otherwise the switch is live.  */
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|=
name|SWITCH_LIVE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pass a switch to the current accumulating command    in the same form that we received it.    SWITCHNUM identifies the switch; it is an index into    the vector of switches gcc received, which is `switches'.    This cannot fail since it never finishes a command line.     If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */
end_comment

begin_function
specifier|static
name|void
name|give_switch
parameter_list|(
name|int
name|switchnum
parameter_list|,
name|int
name|omit_first_word
parameter_list|)
block|{
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|live_cond
operator|==
name|SWITCH_IGNORE
condition|)
return|return;
if|if
condition|(
operator|!
name|omit_first_word
condition|)
block|{
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|part1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|args
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|switches
index|[
name|switchnum
index|]
operator|.
name|args
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
operator|*
name|p
decl_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix_subst
condition|)
block|{
name|unsigned
name|length
init|=
name|strlen
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|--
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|arg
index|[
name|length
index|]
argument_list|)
condition|)
if|if
condition|(
name|arg
index|[
name|length
index|]
operator|==
literal|'.'
condition|)
block|{
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|dot
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|do_spec_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
condition|)
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
name|length
index|]
operator|=
literal|'.'
expr_stmt|;
name|do_spec_1
argument_list|(
name|suffix_subst
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|do_spec_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|switches
index|[
name|switchnum
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search for a file named NAME trying various prefixes including the    user's -B prefix and some standard ones.    Return the absolute file name found.  If nothing is found, return NAME.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|newname
init|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|name
argument_list|,
name|R_OK
argument_list|,
name|true
argument_list|)
decl_stmt|;
return|return
name|newname
condition|?
name|newname
else|:
name|name
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a directory exists.  If LINKER, return 0 for    certain fixed names not needed by the linker.  */
end_comment

begin_function
specifier|static
name|int
name|is_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|bool
name|linker
parameter_list|)
block|{
name|int
name|len1
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
comment|/* Ensure the string ends with "/.".  The resulting path will be a      directory even if the given path is a symbolic link.  */
name|len1
operator|=
name|strlen
argument_list|(
name|path1
argument_list|)
expr_stmt|;
name|path
operator|=
name|alloca
argument_list|(
literal|3
operator|+
name|len1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|path1
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|path
operator|+
name|len1
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
name|DIR_SEPARATOR
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
comment|/* Exclude directories that the linker is known to search.  */
if|if
condition|(
name|linker
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|cp
operator|-
name|path
operator|==
literal|6
operator|&&
name|strncmp
argument_list|(
name|path
operator|+
literal|1
argument_list|,
literal|"lib"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|cp
operator|-
name|path
operator|==
literal|10
operator|&&
name|strncmp
argument_list|(
name|path
operator|+
literal|1
argument_list|,
literal|"usr"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|path
index|[
literal|4
index|]
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|path
operator|+
literal|5
argument_list|,
literal|"lib"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
return|return
operator|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set up the various global variables to indicate that we're processing    the input file named FILENAME.  */
end_comment

begin_function
name|void
name|set_input
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|input_filename
operator|=
name|filename
expr_stmt|;
name|input_filename_length
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|input_basename
operator|=
name|input_filename
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* Skip drive name so 'x:foo' is handled properly.  */
if|if
condition|(
name|input_basename
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|input_basename
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|input_basename
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|input_basename
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Find a suffix starting with the last period,      and set basename_length to exclude that suffix.  */
name|basename_length
operator|=
name|strlen
argument_list|(
name|input_basename
argument_list|)
expr_stmt|;
name|suffixed_basename_length
operator|=
name|basename_length
expr_stmt|;
name|p
operator|=
name|input_basename
operator|+
name|basename_length
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|input_basename
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
operator|!=
name|input_basename
condition|)
block|{
name|basename_length
operator|=
name|p
operator|-
name|input_basename
expr_stmt|;
name|input_suffix
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|input_suffix
operator|=
literal|""
expr_stmt|;
comment|/* If a spec for 'g', 'u', or 'U' is seen with -save-temps then      we will need to do a stat on the input_filename.  The      INPUT_STAT_SET signals that the stat is needed.  */
name|input_stat_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* On fatal signals, delete all the temporary files.  */
end_comment

begin_function
specifier|static
name|void
name|fatal_error
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|signal
argument_list|(
name|signum
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
comment|/* Get the same signal again, this time not handled,      so its normal effect occurs.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|linker_was_run
init|=
literal|0
decl_stmt|;
name|int
name|lang_n_infiles
init|=
literal|0
decl_stmt|;
name|int
name|num_linker_inputs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|explicit_link_files
decl_stmt|;
name|char
modifier|*
name|specs_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|user_specs
modifier|*
name|uptr
decl_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
name|programname
operator|=
name|p
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|programname
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|prune_options
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GCC_DRIVER_HOST_INITIALIZATION
comment|/* Perform host dependent initialization when needed.  */
name|GCC_DRIVER_HOST_INITIALIZATION
expr_stmt|;
endif|#
directive|endif
comment|/* Unlock the stdio streams.  */
name|unlock_std_streams
argument_list|()
expr_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* We *MUST* set SIGCHLD to SIG_DFL so that the wait4() call will      receive the signal.  A different setting is inheritable */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate the argument vector.  */
name|alloc_args
argument_list|()
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
comment|/* Build multilib_select, et. al from the separate lines that make up each      multilib selection.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|q
init|=
name|multilib_raw
decl_stmt|;
name|int
name|need_space
decl_stmt|;
name|obstack_init
argument_list|(
operator|&
name|multilib_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_select
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|q
operator|=
name|multilib_matches_raw
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_matches
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|q
operator|=
name|multilib_exclusions_raw
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_exclusions
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|need_space
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|multilib_defaults_raw
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_space
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|multilib_defaults_raw
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|multilib_defaults_raw
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|need_space
operator|=
name|TRUE
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multilib_defaults
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* Set up to remember the pathname of gcc and any options      needed for collect.  We use argv[0] instead of programname because      we need the complete pathname.  */
name|obstack_init
argument_list|(
operator|&
name|collect_obstack
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
literal|"COLLECT_GCC="
argument_list|,
sizeof|sizeof
argument_list|(
literal|"COLLECT_GCC="
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|XOBFINISH
argument_list|(
operator|&
name|collect_obstack
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_ENVIRONMENT
comment|/* Set up any other necessary machine specific environment variables.  */
name|putenv
argument_list|(
name|INIT_ENVIRONMENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make a table of what switches there are (switches, n_switches).      Make a table of specified input files (infiles, n_infiles).      Decode switches that are handled locally.  */
name|process_command
argument_list|(
name|argc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
comment|/* Initialize the vector of specs to just the default.      This means one element containing 0s, as a terminator.  */
name|compilers
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
name|default_compilers
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|compilers
argument_list|,
name|default_compilers
argument_list|,
sizeof|sizeof
name|default_compilers
argument_list|)
expr_stmt|;
name|n_compilers
operator|=
name|n_default_compilers
expr_stmt|;
comment|/* Read specs from a file if there is one.  */
ifdef|#
directive|ifdef
name|FREEBSD_NATIVE
name|machine_suffix
operator|=
literal|""
expr_stmt|;
name|just_machine_suffix
operator|=
literal|""
expr_stmt|;
else|#
directive|else
comment|/* FREEBSD_NATIVE */
name|machine_suffix
operator|=
name|concat
argument_list|(
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|just_machine_suffix
operator|=
name|concat
argument_list|(
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
name|specs_file
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|"specs"
argument_list|,
name|R_OK
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Read the specs file unless it is a default one.  */
if|if
condition|(
name|specs_file
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|specs_file
argument_list|,
literal|"specs"
argument_list|)
condition|)
name|read_specs
argument_list|(
name|specs_file
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|init_spec
argument_list|()
expr_stmt|;
comment|/* We need to check standard_exec_prefix/just_machine_suffix/specs      for any override of as, ld and libraries.  */
name|specs_file
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|FBSD_DATA_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|just_machine_suffix
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"specs"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|specs_file
argument_list|,
name|FBSD_DATA_PREFIX
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|specs_file
argument_list|,
name|just_machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|specs_file
argument_list|,
literal|"specs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|specs_file
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|read_specs
argument_list|(
name|specs_file
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Process any configure-time defaults specified for the command line      options, via OPTION_DEFAULT_SPECS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|option_default_specs
argument_list|)
condition|;
name|i
operator|++
control|)
name|do_option_spec
argument_list|(
name|option_default_specs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|option_default_specs
index|[
name|i
index|]
operator|.
name|spec
argument_list|)
expr_stmt|;
comment|/* Process DRIVER_SELF_SPECS, adding any new options to the end      of the command line.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|driver_self_specs
argument_list|)
condition|;
name|i
operator|++
control|)
name|do_self_spec
argument_list|(
name|driver_self_specs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* If not cross-compiling, look for executables in the standard      places.  */
if|if
condition|(
operator|*
name|cross_compile
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
name|md_exec_prefix
condition|)
block|{
name|add_prefix
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|md_exec_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process sysroot_suffix_spec.  */
if|if
condition|(
operator|*
name|sysroot_suffix_spec
operator|!=
literal|0
operator|&&
name|do_spec_2
argument_list|(
name|sysroot_suffix_spec
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argbuf_index
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"spec failure: more than one arg to SYSROOT_SUFFIX_SPEC"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argbuf_index
operator|==
literal|1
condition|)
name|target_sysroot_suffix
operator|=
name|xstrdup
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_LD_SYSROOT
comment|/* Pass the --sysroot option to the linker, if it supports that.  If      there is a sysroot_suffix_spec, it has already been processed by      this point, so target_system_root really is the system root we      should be using.  */
if|if
condition|(
name|target_system_root
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|"%(sysroot_spec) "
argument_list|,
name|strlen
argument_list|(
literal|"%(sysroot_spec) "
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|obstack
argument_list|,
name|link_spec
argument_list|,
name|strlen
argument_list|(
name|link_spec
argument_list|)
argument_list|)
expr_stmt|;
name|set_spec
argument_list|(
literal|"link"
argument_list|,
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Process sysroot_hdrs_suffix_spec.  */
if|if
condition|(
operator|*
name|sysroot_hdrs_suffix_spec
operator|!=
literal|0
operator|&&
name|do_spec_2
argument_list|(
name|sysroot_hdrs_suffix_spec
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argbuf_index
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"spec failure: more than one arg to SYSROOT_HEADERS_SUFFIX_SPEC"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argbuf_index
operator|==
literal|1
condition|)
name|target_sysroot_hdrs_suffix
operator|=
name|xstrdup
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Look for startfiles in the standard places.  */
if|if
condition|(
operator|*
name|startfile_prefix_spec
operator|!=
literal|0
operator|&&
name|do_spec_2
argument_list|(
name|startfile_prefix_spec
argument_list|)
operator|==
literal|0
operator|&&
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ndx
decl_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|argbuf_index
condition|;
name|ndx
operator|++
control|)
name|add_sysrooted_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|argbuf
index|[
name|ndx
index|]
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We should eventually get rid of all these and stick to      startfile_prefix_spec exclusively.  */
elseif|else
if|if
condition|(
operator|*
name|cross_compile
operator|==
literal|'0'
operator|||
name|target_system_root
condition|)
block|{
if|if
condition|(
operator|*
name|md_startfile_prefix
condition|)
name|add_sysrooted_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_startfile_prefix
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|md_startfile_prefix_1
condition|)
name|add_sysrooted_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|md_startfile_prefix_1
argument_list|,
literal|"GCC"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If standard_startfile_prefix is relative, base it on 	 standard_exec_prefix.  This lets us move the installed tree 	 as a unit.  If GCC_EXEC_PREFIX is defined, base 	 standard_startfile_prefix on that as well.           If the prefix is relative, only search it for native compilers;          otherwise we will search a directory containing host libraries.  */
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|standard_startfile_prefix
argument_list|)
condition|)
name|add_sysrooted_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cross_compile
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|gcc_exec_prefix
condition|)
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|concat
argument_list|(
name|standard_exec_prefix
argument_list|,
name|machine_suffix
argument_list|,
name|standard_startfile_prefix
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
if|if
condition|(
operator|*
name|standard_startfile_prefix_1
condition|)
name|add_sysrooted_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix_1
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|standard_startfile_prefix_2
condition|)
name|add_sysrooted_prefix
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|standard_startfile_prefix_2
argument_list|,
literal|"BINUTILS"
argument_list|,
name|PREFIX_PRIORITY_LAST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Process any user specified specs in the order given on the command      line.  */
for|for
control|(
name|uptr
operator|=
name|user_specs_head
init|;
name|uptr
condition|;
name|uptr
operator|=
name|uptr
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|filename
init|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|uptr
operator|->
name|filename
argument_list|,
name|R_OK
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|read_specs
argument_list|(
name|filename
condition|?
name|filename
else|:
name|uptr
operator|->
name|filename
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a GCC_EXEC_PREFIX envvar, modify it for cpp's sake.  */
if|if
condition|(
name|gcc_exec_prefix
condition|)
name|gcc_exec_prefix
operator|=
name|concat
argument_list|(
name|gcc_exec_prefix
argument_list|,
name|spec_machine
argument_list|,
name|dir_separator_str
argument_list|,
name|spec_version
argument_list|,
name|dir_separator_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now we have the specs.      Set the `valid' bits for switches that match anything in any spec.  */
name|validate_all_switches
argument_list|()
expr_stmt|;
comment|/* Now that we have the switches and the specs, set      the subdirectory based on the options.  */
name|set_multilib_dir
argument_list|()
expr_stmt|;
comment|/* Warn about any switches that no pass was interested in.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|switches
index|[
name|i
index|]
operator|.
name|validated
condition|)
name|error
argument_list|(
literal|"unrecognized option '-%s'"
argument_list|,
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
expr_stmt|;
comment|/* Obey some of the options.  */
if|if
condition|(
name|print_search_dirs
condition|)
block|{
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|printf
argument_list|(
name|_
argument_list|(
literal|"install: %s%s\n"
argument_list|)
argument_list|,
name|standard_exec_prefix
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"install: %s\n"
argument_list|)
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
name|_
argument_list|(
literal|"programs: %s\n"
argument_list|)
argument_list|,
name|build_search_list
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|""
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"libraries: %s\n"
argument_list|)
argument_list|,
name|build_search_list
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
literal|""
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_file_name
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|find_file
argument_list|(
name|print_file_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_prog_name
condition|)
block|{
name|char
modifier|*
name|newname
init|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
name|print_prog_name
argument_list|,
name|X_OK
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
name|newname
condition|?
name|newname
else|:
name|print_prog_name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_multi_lib
condition|)
block|{
name|print_multilib_info
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_multi_directory
condition|)
block|{
if|if
condition|(
name|multilib_dir
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|multilib_dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|print_multi_os_directory
condition|)
block|{
if|if
condition|(
name|multilib_os_dir
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|multilib_os_dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|target_help_flag
condition|)
block|{
comment|/* Print if any target specific options.  */
comment|/* We do not exit here. Instead we have created a fake input file          called 'target-dummy' which needs to be compiled, and we pass this          on to the various sub-processes, along with the --target-help          switch.  */
block|}
if|if
condition|(
name|print_help_list
condition|)
block|{
name|display_help
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|verbose_flag
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"\nFor bug reporting instructions, please see:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s.\n"
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* We do not exit here.  Instead we have created a fake input file 	 called 'help-dummy' which needs to be compiled, and we pass this 	 on the various sub-processes, along with the --help switch.  */
block|}
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|thrmod
decl_stmt|;
name|notice
argument_list|(
literal|"Target: %s\n"
argument_list|,
name|spec_machine
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"Configured with: %s\n"
argument_list|,
name|configuration_arguments
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_MODEL_SPEC
comment|/* We could have defined THREAD_MODEL_SPEC to "%*" by default, 	 but there's no point in doing all this processing just to get 	 thread_model back.  */
name|obstack_init
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|THREAD_MODEL_SPEC
argument_list|,
literal|0
argument_list|,
name|thread_model
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|thrmod
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|thrmod
operator|=
name|thread_model
expr_stmt|;
endif|#
directive|endif
name|notice
argument_list|(
literal|"Thread model: %s\n"
argument_list|,
name|thrmod
argument_list|)
expr_stmt|;
comment|/* compiler_version is truncated at the first space when initialized 	 from version string, so truncate version_string at the first space 	 before comparing.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|version_string
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|version_string
index|[
name|n
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|version_string
argument_list|,
name|compiler_version
argument_list|,
name|n
argument_list|)
operator|&&
name|compiler_version
index|[
name|n
index|]
operator|==
literal|0
condition|)
name|notice
argument_list|(
literal|"gcc version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"gcc driver version %s executing gcc version %s\n"
argument_list|,
name|version_string
argument_list|,
name|compiler_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_infiles
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n_infiles
operator|==
name|added_libraries
condition|)
name|fatal
argument_list|(
literal|"No input files specified"
argument_list|)
expr_stmt|;
comment|/* Make a place to record the compiler output file names      that correspond to the input files.  */
name|i
operator|=
name|n_infiles
expr_stmt|;
name|i
operator|+=
name|lang_specific_extra_outfiles
expr_stmt|;
name|outfiles
operator|=
name|XCNEWVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Record which files were specified explicitly as link input.  */
name|explicit_link_files
operator|=
name|XCNEWVEC
argument_list|(
name|char
argument_list|,
name|n_infiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_flag
condition|)
name|combine_inputs
operator|=
name|true
expr_stmt|;
else|else
name|combine_inputs
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|infiles
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|struct
name|compiler
modifier|*
name|compiler
init|=
name|lookup_compiler
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|infiles
index|[
name|i
index|]
operator|.
name|language
argument_list|)
decl_stmt|;
if|if
condition|(
name|compiler
operator|&&
operator|!
operator|(
name|compiler
operator|->
name|combinable
operator|)
condition|)
name|combine_inputs
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|lang_n_infiles
operator|>
literal|0
operator|&&
name|compiler
operator|!=
name|input_file_compiler
operator|&&
name|infiles
index|[
name|i
index|]
operator|.
name|language
operator|&&
name|infiles
index|[
name|i
index|]
operator|.
name|language
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
operator|=
name|compiler
expr_stmt|;
elseif|else
if|if
condition|(
name|compiler
condition|)
block|{
name|lang_n_infiles
operator|++
expr_stmt|;
name|input_file_compiler
operator|=
name|compiler
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
operator|=
name|compiler
expr_stmt|;
block|}
else|else
block|{
comment|/* Since there is no compiler for this input file, assume it is a 	     linker file.  */
name|explicit_link_files
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
operator|=
name|NULL
expr_stmt|;
block|}
name|infiles
index|[
name|i
index|]
operator|.
name|compiled
operator|=
name|false
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|preprocessed
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|combine_inputs
operator|&&
name|have_c
operator|&&
name|have_o
operator|&&
name|lang_n_infiles
operator|>
literal|1
condition|)
name|fatal
argument_list|(
literal|"cannot specify -o with -c or -S with multiple files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_flag
operator|&&
name|save_temps_flag
condition|)
block|{
name|bool
name|save_combine_inputs
init|=
name|combine_inputs
decl_stmt|;
comment|/* Must do a separate pre-processing pass for C& Objective-C files, to 	 obtain individual .i files.  */
name|combine_inputs
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_file_error
init|=
literal|0
decl_stmt|;
name|input_file_number
operator|=
name|i
expr_stmt|;
name|set_input
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
operator|&&
operator|(
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
operator|)
operator|->
name|needs_preprocessing
condition|)
name|input_file_compiler
operator|=
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
name|input_file_compiler
condition|)
block|{
if|if
condition|(
name|input_file_compiler
operator|->
name|spec
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|error
argument_list|(
literal|"%s: %s compiler not installed on this system"
argument_list|,
name|input_filename
argument_list|,
operator|&
name|input_file_compiler
operator|->
name|spec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|this_file_error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|do_spec
argument_list|(
name|input_file_compiler
operator|->
name|spec
argument_list|)
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|preprocessed
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|have_o_argbuf_index
condition|)
name|fatal
argument_list|(
literal|"spec '%s' is invalid"
argument_list|,
name|input_file_compiler
operator|->
name|spec
argument_list|)
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|name
operator|=
name|argbuf
index|[
name|have_o_argbuf_index
index|]
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
operator|=
name|lookup_compiler
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|infiles
index|[
name|i
index|]
operator|.
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|this_file_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this_file_error
condition|)
block|{
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
break|break;
block|}
name|clear_failure_queue
argument_list|()
expr_stmt|;
block|}
name|combine_inputs
operator|=
name|save_combine_inputs
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_file_error
init|=
literal|0
decl_stmt|;
comment|/* Tell do_spec what to substitute for %i.  */
name|input_file_number
operator|=
name|i
expr_stmt|;
name|set_input
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|infiles
index|[
name|i
index|]
operator|.
name|compiled
condition|)
continue|continue;
comment|/* Use the same thing in %o, unless cp->spec says otherwise.  */
name|outfiles
index|[
name|i
index|]
operator|=
name|input_filename
expr_stmt|;
comment|/* Figure out which compiler from the file's suffix.  */
if|if
condition|(
operator|!
name|combine_inputs
condition|)
name|input_file_compiler
operator|=
name|lookup_compiler
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|input_filename_length
argument_list|,
name|infiles
index|[
name|i
index|]
operator|.
name|language
argument_list|)
expr_stmt|;
else|else
name|input_file_compiler
operator|=
name|infiles
index|[
name|i
index|]
operator|.
name|incompiler
expr_stmt|;
if|if
condition|(
name|input_file_compiler
condition|)
block|{
comment|/* Ok, we found an applicable compiler.  Run its spec.  */
if|if
condition|(
name|input_file_compiler
operator|->
name|spec
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|error
argument_list|(
literal|"%s: %s compiler not installed on this system"
argument_list|,
name|input_filename
argument_list|,
operator|&
name|input_file_compiler
operator|->
name|spec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|this_file_error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|do_spec
argument_list|(
name|input_file_compiler
operator|->
name|spec
argument_list|)
expr_stmt|;
name|infiles
index|[
name|i
index|]
operator|.
name|compiled
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|this_file_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this file's name does not contain a recognized suffix, 	 record it as explicit linker input.  */
else|else
name|explicit_link_files
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Clear the delete-on-failure queue, deleting the files in it 	 if this compilation failed.  */
if|if
condition|(
name|this_file_error
condition|)
block|{
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
comment|/* If this compilation succeeded, don't delete those files later.  */
name|clear_failure_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Reset the input file name to the first compile/object file name, for use      with %b in LINK_SPEC. We use the first input file that we can find      a compiler to compile it instead of using infiles.language since for      languages other than C we use aliases that we then lookup later.  */
if|if
condition|(
name|n_infiles
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|infiles
index|[
name|i
index|]
operator|.
name|language
operator|&&
name|infiles
index|[
name|i
index|]
operator|.
name|language
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
block|{
name|set_input
argument_list|(
name|infiles
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error_count
operator|==
literal|0
condition|)
block|{
comment|/* Make sure INPUT_FILE_NUMBER points to first available open 	 slot.  */
name|input_file_number
operator|=
name|n_infiles
expr_stmt|;
if|if
condition|(
name|lang_specific_pre_link
argument_list|()
condition|)
name|error_count
operator|++
expr_stmt|;
block|}
comment|/* Determine if there are any linker input files.  */
name|num_linker_inputs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|explicit_link_files
index|[
name|i
index|]
operator|||
name|outfiles
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|num_linker_inputs
operator|++
expr_stmt|;
comment|/* Run ld to link all the compiler output files.  */
if|if
condition|(
name|num_linker_inputs
operator|>
literal|0
operator|&&
name|error_count
operator|==
literal|0
condition|)
block|{
name|int
name|tmp
init|=
name|execution_count
decl_stmt|;
comment|/* We'll use ld if we can't find collect2.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|linker_name_spec
argument_list|,
literal|"collect2"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|find_a_file
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"collect2"
argument_list|,
name|X_OK
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|linker_name_spec
operator|=
literal|"ld"
expr_stmt|;
block|}
comment|/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables 	 for collect.  */
name|putenv_from_prefixes
argument_list|(
operator|&
name|exec_prefixes
argument_list|,
literal|"COMPILER_PATH"
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|putenv_from_prefixes
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|LIBRARY_PATH_ENV
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|value
operator|=
name|do_spec
argument_list|(
name|link_command_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|error_count
operator|=
literal|1
expr_stmt|;
name|linker_was_run
operator|=
operator|(
name|tmp
operator|!=
name|execution_count
operator|)
expr_stmt|;
block|}
comment|/* If options said don't run linker,      complain about input files to be given to the linker.  */
if|if
condition|(
operator|!
name|linker_was_run
operator|&&
name|error_count
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|explicit_link_files
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"%s: linker input file unused because linking not done"
argument_list|,
name|outfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Delete some or all of the temporary files we made.  */
if|if
condition|(
name|error_count
condition|)
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_help_list
condition|)
block|{
name|printf
argument_list|(
operator|(
literal|"\nFor bug reporting instructions, please see:\n"
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|signal_count
operator|!=
literal|0
condition|?
literal|2
else|:
name|error_count
operator|>
literal|0
condition|?
operator|(
name|pass_exit_codes
condition|?
name|greatest_status
else|:
literal|1
operator|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the proper compilation spec for the file name NAME,    whose length is LENGTH.  LANGUAGE is the specified language,    or 0 if this file is to be passed to the linker.  */
end_comment

begin_function
specifier|static
name|struct
name|compiler
modifier|*
name|lookup_compiler
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|language
parameter_list|)
block|{
name|struct
name|compiler
modifier|*
name|cp
decl_stmt|;
comment|/* If this was specified by the user to be a linker input, indicate that.  */
if|if
condition|(
name|language
operator|!=
literal|0
operator|&&
name|language
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, look for the language, if one is spec'd.  */
if|if
condition|(
name|language
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
if|if
condition|(
name|cp
operator|->
name|suffix
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
operator|+
literal|1
argument_list|,
name|language
argument_list|)
condition|)
return|return
name|cp
return|;
name|error
argument_list|(
literal|"language %s not recognized"
argument_list|,
name|language
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Look for a suffix.  */
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
block|{
if|if
condition|(
comment|/* The suffix `-' matches only the file name `-'.  */
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"-"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
operator|<
name|length
comment|/* See if the suffix matches the end of NAME.  */
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_DOS_BASED_FILE_SYSTEM
argument_list|)
comment|/* Look again, but case-insensitively this time.  */
if|if
condition|(
name|cp
operator|<
name|compilers
condition|)
for|for
control|(
name|cp
operator|=
name|compilers
operator|+
name|n_compilers
operator|-
literal|1
init|;
name|cp
operator|>=
name|compilers
condition|;
name|cp
operator|--
control|)
block|{
if|if
condition|(
comment|/* The suffix `-' matches only the file name `-'.  */
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"-"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
operator|<
name|length
comment|/* See if the suffix matches the end of NAME.  */
operator|&&
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|||
operator|!
name|strpbrk
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|)
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|name
operator|+
name|length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|cp
operator|>=
name|compilers
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|spec
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
comment|/* A non-alias entry: return it.  */
return|return
name|cp
return|;
comment|/* An alias entry maps a suffix to a language. 	 Search for the language; pass 0 for NAME and LENGTH 	 to avoid infinite recursion if language not found.  */
return|return
name|lookup_compiler
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|cp
operator|->
name|spec
operator|+
literal|1
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|result
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|pfatal_with_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_with_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an error message and exit.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|fatal_ice
argument_list|(
literal|"internal gcc abort in %s, at %s:%d"
argument_list|,
name|func
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an error message and exit.  */
end_comment

begin_function
name|void
name|fatal_ice
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|pass_exit_codes
condition|?
name|ICE_EXIT_CODE
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The argument is actually c-format, not gcc-internal-format,    but because functions with identical names are used through    the rest of the compiler with gcc-internal-format, we just    need to hope all users of these functions use the common    subset between c-format and gcc-internal-format.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|gmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notice
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|inline
name|void
name|validate_switches_from_spec
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|spec
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'{'
operator|||
operator|*
name|p
operator|==
literal|'<'
operator|||
operator|(
operator|*
name|p
operator|==
literal|'W'
operator|&&
operator|*
operator|++
name|p
operator|==
literal|'{'
operator|)
operator|)
condition|)
comment|/* We have a switch spec.  */
name|p
operator|=
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|validate_all_switches
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|compiler
modifier|*
name|comp
decl_stmt|;
name|struct
name|spec_list
modifier|*
name|spec
decl_stmt|;
for|for
control|(
name|comp
operator|=
name|compilers
init|;
name|comp
operator|->
name|spec
condition|;
name|comp
operator|++
control|)
name|validate_switches_from_spec
argument_list|(
name|comp
operator|->
name|spec
argument_list|)
expr_stmt|;
comment|/* Look through the linked list of specs read from the specs file.  */
for|for
control|(
name|spec
operator|=
name|specs
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
name|validate_switches_from_spec
argument_list|(
operator|*
name|spec
operator|->
name|ptr_spec
argument_list|)
expr_stmt|;
name|validate_switches_from_spec
argument_list|(
name|link_command_spec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at the switch-name that comes after START    and mark as valid all supplied switches that match it.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|validate_switches
parameter_list|(
specifier|const
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|atom
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|suffix
init|=
name|false
decl_stmt|;
name|bool
name|starred
init|=
name|false
decl_stmt|;
define|#
directive|define
name|SKIP_WHITE
parameter_list|()
value|do { while (*p == ' ' || *p == '\t') p++; } while (0)
name|next_member
label|:
name|SKIP_WHITE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
name|p
operator|++
expr_stmt|;
name|SKIP_WHITE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|suffix
operator|=
name|true
operator|,
name|p
operator|++
expr_stmt|;
name|atom
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|ISIDNUM
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'='
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|'@'
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|atom
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
name|starred
operator|=
name|true
operator|,
name|p
operator|++
expr_stmt|;
name|SKIP_WHITE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|suffix
condition|)
block|{
comment|/* Mark all matching switches as valid.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|atom
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|starred
operator|||
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|len
index|]
operator|==
literal|0
operator|)
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|validated
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'|'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'&'
operator|)
condition|)
goto|goto
name|next_member
goto|;
if|if
condition|(
operator|*
name|p
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
operator|||
operator|*
name|p
operator|==
literal|'<'
condition|)
name|p
operator|=
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'W'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
name|p
operator|=
name|validate_switches
argument_list|(
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
goto|goto
name|next_member
goto|;
block|}
return|return
name|p
return|;
undef|#
directive|undef
name|SKIP_WHITE
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|mdswitchstr
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mdswitchstr
modifier|*
name|mdswitches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_mdswitches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check whether a particular argument was used.  The first time we    canonicalize the switches to keep only the ones we care about.  */
end_comment

begin_function
specifier|static
name|int
name|used_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
struct|struct
name|mswitchstr
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|replace
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|rep_len
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|mswitchstr
modifier|*
name|mswitches
decl_stmt|;
specifier|static
name|int
name|n_mswitches
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|mswitches
condition|)
block|{
name|struct
name|mswitchstr
modifier|*
name|matches
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Break multilib_matches into the component strings of string          and replacement string.  */
for|for
control|(
name|q
operator|=
name|multilib_matches
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|';'
condition|)
name|cnt
operator|++
expr_stmt|;
name|matches
operator|=
name|alloca
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mswitchstr
argument_list|)
operator|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|multilib_matches
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
name|matches
index|[
name|i
index|]
operator|.
name|str
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|invalid_matches
label|:
name|fatal
argument_list|(
literal|"multilib spec '%s' is invalid"
argument_list|,
name|multilib_matches
argument_list|)
expr_stmt|;
block|}
name|q
operator|++
expr_stmt|;
block|}
name|matches
index|[
name|i
index|]
operator|.
name|len
operator|=
name|q
operator|-
name|matches
index|[
name|i
index|]
operator|.
name|str
expr_stmt|;
name|matches
index|[
name|i
index|]
operator|.
name|replace
operator|=
operator|++
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
goto|goto
name|invalid_matches
goto|;
name|q
operator|++
expr_stmt|;
block|}
name|matches
index|[
name|i
index|]
operator|.
name|rep_len
operator|=
name|q
operator|-
name|matches
index|[
name|i
index|]
operator|.
name|replace
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|';'
condition|)
name|q
operator|++
expr_stmt|;
block|}
comment|/* Now build a list of the replacement string for switches that we care 	 about.  Make sure we allocate at least one entry.  This prevents 	 xmalloc from calling fatal, and prevents us from re-executing this 	 block of code.  */
name|mswitches
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|mswitchstr
argument_list|,
name|n_mdswitches
operator|+
operator|(
name|n_switches
condition|?
name|n_switches
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|switches
index|[
name|i
index|]
operator|.
name|live_cond
operator|!=
name|SWITCH_IGNORE
condition|)
block|{
name|int
name|xlen
init|=
name|strlen
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|xlen
operator|==
name|matches
index|[
name|j
index|]
operator|.
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|matches
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|xlen
argument_list|)
condition|)
block|{
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|str
operator|=
name|matches
index|[
name|j
index|]
operator|.
name|replace
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|len
operator|=
name|matches
index|[
name|j
index|]
operator|.
name|rep_len
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|replace
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|rep_len
operator|=
literal|0
expr_stmt|;
name|n_mswitches
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* Add MULTILIB_DEFAULTS switches too, as long as they were not present 	 on the command line nor any options mutually incompatible with 	 them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_mdswitches
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|q
operator|=
name|multilib_options
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
name|q
operator|++
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
while|while
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|mdswitches
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|mdswitches
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
literal|" /"
argument_list|,
name|q
index|[
name|mdswitches
index|[
name|i
index|]
operator|.
name|len
index|]
argument_list|)
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'/'
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|!=
literal|'/'
condition|)
break|break;
name|q
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|r
operator|!=
literal|' '
operator|&&
operator|*
name|r
operator|!=
literal|'\0'
condition|)
block|{
name|q
operator|=
name|r
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'/'
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|used_arg
argument_list|(
name|r
argument_list|,
name|q
operator|-
name|r
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|q
operator|!=
literal|'/'
condition|)
block|{
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|str
operator|=
name|mdswitches
index|[
name|i
index|]
operator|.
name|str
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|len
operator|=
name|mdswitches
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|replace
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|mswitches
index|[
name|n_mswitches
index|]
operator|.
name|rep_len
operator|=
literal|0
expr_stmt|;
name|n_mswitches
operator|++
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_mswitches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|len
operator|==
name|mswitches
index|[
name|i
index|]
operator|.
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|mswitches
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|default_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_mdswitches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|len
operator|==
name|mdswitches
index|[
name|i
index|]
operator|.
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|mdswitches
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Work out the subdirectory to use based on the options. The format of    multilib_select is a list of elements. Each element is a subdirectory    name followed by a list of options followed by a semicolon. The format    of multilib_exclusions is the same, but without the preceding    directory. First gcc will check the exclusions, if none of the options    beginning with an exclamation point are present, and all of the other    options are present, then we will ignore this completely. Passing    that, gcc will consider each multilib_select in turn using the same    rules for matching the options. If a match is found, that subdirectory    will be used.  */
end_comment

begin_function
specifier|static
name|void
name|set_multilib_dir
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|this_path_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_path
decl_stmt|,
modifier|*
name|this_arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|not_arg
decl_stmt|;
name|int
name|ok
decl_stmt|,
name|ndfltok
decl_stmt|,
name|first
decl_stmt|;
name|n_mdswitches
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|multilib_defaults
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|)
name|start
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
literal|'\0'
condition|)
block|{
name|n_mdswitches
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
literal|' '
operator|&&
operator|*
name|start
operator|!=
literal|'\t'
operator|&&
operator|*
name|start
operator|!=
literal|'\0'
condition|)
name|start
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|)
name|start
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n_mdswitches
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|mdswitches
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|mdswitchstr
argument_list|,
name|n_mdswitches
argument_list|)
expr_stmt|;
for|for
control|(
name|start
operator|=
name|multilib_defaults
init|;
operator|*
name|start
operator|!=
literal|'\0'
condition|;
name|start
operator|=
name|end
operator|+
literal|1
control|)
block|{
while|while
condition|(
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'\0'
condition|)
break|break;
for|for
control|(
name|end
operator|=
name|start
operator|+
literal|1
init|;
operator|*
name|end
operator|!=
literal|' '
operator|&&
operator|*
name|end
operator|!=
literal|'\t'
operator|&&
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
empty_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mdswitches
index|[
name|i
index|]
operator|.
name|str
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|multilib_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|mdswitches
index|[
name|i
operator|++
index|]
operator|.
name|len
operator|=
name|end
operator|-
name|start
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
name|p
operator|=
name|multilib_exclusions
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Check the arguments.  */
name|ok
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|invalid_exclusions
label|:
name|fatal
argument_list|(
literal|"multilib exclusions '%s' is invalid"
argument_list|,
name|multilib_exclusions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|this_arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_exclusions
goto|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|this_arg
operator|!=
literal|'!'
condition|)
name|not_arg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|not_arg
operator|=
literal|1
expr_stmt|;
operator|++
name|this_arg
expr_stmt|;
block|}
name|ok
operator|=
name|used_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_arg
condition|)
name|ok
operator|=
operator|!
name|ok
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
return|return;
operator|++
name|p
expr_stmt|;
block|}
name|first
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|multilib_select
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Get the initial path.  */
name|this_path
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|invalid_select
label|:
name|fatal
argument_list|(
literal|"multilib select '%s' is invalid"
argument_list|,
name|multilib_select
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|this_path_len
operator|=
name|p
operator|-
name|this_path
expr_stmt|;
comment|/* Check the arguments.  */
name|ok
operator|=
literal|1
expr_stmt|;
name|ndfltok
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|this_arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|this_arg
operator|!=
literal|'!'
condition|)
name|not_arg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|not_arg
operator|=
literal|1
expr_stmt|;
operator|++
name|this_arg
expr_stmt|;
block|}
comment|/* If this is a default argument, we can just ignore it. 	     This is true even if this_arg begins with '!'.  Beginning 	     with '!' does not mean that this argument is necessarily 	     inappropriate for this library: it merely means that 	     there is a more specific library which uses this 	     argument.  If this argument is a default, we need not 	     consider that more specific library.  */
name|ok
operator|=
name|used_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_arg
condition|)
name|ok
operator|=
operator|!
name|ok
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|ndfltok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|default_arg
argument_list|(
name|this_arg
argument_list|,
name|p
operator|-
name|this_arg
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|&&
name|first
condition|)
block|{
if|if
condition|(
name|this_path_len
operator|!=
literal|1
operator|||
name|this_path
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
name|char
modifier|*
name|new_multilib_dir
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|this_path_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|strncpy
argument_list|(
name|new_multilib_dir
argument_list|,
name|this_path
argument_list|,
name|this_path_len
argument_list|)
expr_stmt|;
name|new_multilib_dir
index|[
name|this_path_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|strchr
argument_list|(
name|new_multilib_dir
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|multilib_dir
operator|=
name|new_multilib_dir
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ndfltok
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|this_path
decl_stmt|,
modifier|*
name|end
init|=
name|this_path
operator|+
name|this_path_len
decl_stmt|;
while|while
condition|(
name|q
operator|<
name|end
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|end
condition|)
block|{
name|char
modifier|*
name|new_multilib_os_dir
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|end
operator|-
name|q
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_multilib_os_dir
argument_list|,
name|q
operator|+
literal|1
argument_list|,
name|end
operator|-
name|q
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new_multilib_os_dir
index|[
name|end
operator|-
name|q
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|multilib_os_dir
operator|=
name|new_multilib_os_dir
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|multilib_dir
operator|==
name|NULL
operator|&&
name|multilib_os_dir
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|multilib_os_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multilib_os_dir
argument_list|)
expr_stmt|;
name|multilib_os_dir
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|multilib_dir
operator|!=
name|NULL
operator|&&
name|multilib_os_dir
operator|==
name|NULL
condition|)
name|multilib_os_dir
operator|=
name|multilib_dir
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the multiple library subdirectory selection    information.  This prints out a series of lines.  Each line looks    like SUBDIRECTORY;@OPTION@OPTION, with as many options as is    required.  Only the desired options are printed out, the negative    matches.  The options are print without a leading dash.  There are    no spaces to make it easy to use the information in the shell.    Each subdirectory is printed only once.  This assumes the ordering    generated by the genmultilib script. Also, we leave out ones that match    the exclusions.  */
end_comment

begin_function
specifier|static
name|void
name|print_multilib_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|multilib_select
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_path
init|=
literal|0
decl_stmt|,
modifier|*
name|this_path
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|unsigned
name|int
name|last_path_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Get the initial path.  */
name|this_path
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|invalid_select
label|:
name|fatal
argument_list|(
literal|"multilib select '%s' is invalid"
argument_list|,
name|multilib_select
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
comment|/* When --disable-multilib was used but target defines 	 MULTILIB_OSDIRNAMES, entries starting with .: are there just 	 to find multilib_os_dir, so skip them from output.  */
if|if
condition|(
name|this_path
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|this_path
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
comment|/* Check for matches with the multilib_exclusions. We don't bother          with the '!' in either list. If any of the exclusion rules match          all of its options with the select rule, we skip it.  */
block|{
specifier|const
name|char
modifier|*
name|e
init|=
name|multilib_exclusions
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_arg
decl_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|m
init|=
literal|1
decl_stmt|;
comment|/* Ignore newlines.  */
if|if
condition|(
operator|*
name|e
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|e
expr_stmt|;
continue|continue;
block|}
comment|/* Check the arguments.  */
while|while
condition|(
operator|*
name|e
operator|!=
literal|';'
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|mp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
block|{
name|invalid_exclusion
label|:
name|fatal
argument_list|(
literal|"multilib exclusion '%s' is invalid"
argument_list|,
name|multilib_exclusions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m
condition|)
block|{
operator|++
name|e
expr_stmt|;
continue|continue;
block|}
name|this_arg
operator|=
name|e
expr_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|' '
operator|&&
operator|*
name|e
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_exclusion
goto|;
operator|++
name|e
expr_stmt|;
block|}
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|len
init|=
name|e
operator|-
name|this_arg
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
name|arg
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
name|this_arg
argument_list|,
operator|(
name|len
operator|<
name|q
operator|-
name|arg
operator|)
condition|?
name|q
operator|-
name|arg
else|:
name|len
argument_list|)
operator|||
name|default_arg
argument_list|(
name|this_arg
argument_list|,
name|e
operator|-
name|this_arg
argument_list|)
condition|)
block|{
name|mp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mp
condition|)
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
literal|' '
condition|)
operator|++
name|e
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|e
operator|!=
literal|'\0'
condition|)
operator|++
name|e
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|/* If this is a duplicate, skip it.  */
name|skip
operator|=
operator|(
name|last_path
operator|!=
literal|0
operator|&&
call|(
name|unsigned
name|int
call|)
argument_list|(
name|p
operator|-
name|this_path
argument_list|)
operator|==
name|last_path_len
operator|&&
operator|!
name|strncmp
argument_list|(
name|last_path
argument_list|,
name|this_path
argument_list|,
name|last_path_len
argument_list|)
operator|)
expr_stmt|;
name|last_path
operator|=
name|this_path
expr_stmt|;
name|last_path_len
operator|=
name|p
operator|-
name|this_path
expr_stmt|;
block|}
comment|/* If this directory requires any default arguments, we can skip 	 it.  We will already have printed a directory identical to 	 this one which does not require that default argument.  */
if|if
condition|(
operator|!
name|skip
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'!'
condition|)
name|arg
operator|=
name|NULL
expr_stmt|;
else|else
name|arg
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|default_arg
argument_list|(
name|arg
argument_list|,
name|q
operator|-
name|arg
argument_list|)
condition|)
block|{
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
operator|++
name|q
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|last_path
init|;
name|p1
operator|<
name|p
operator|&&
operator|*
name|p1
operator|!=
literal|':'
condition|;
name|p1
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|int
name|use_arg
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
if|if
condition|(
name|skip
condition|)
block|{
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|use_arg
operator|=
operator|*
name|p
operator|!=
literal|'!'
expr_stmt|;
if|if
condition|(
name|use_arg
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid_select
goto|;
if|if
condition|(
name|use_arg
condition|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|/* If there are extra options, print them now.  */
if|if
condition|(
name|multilib_extra
operator|&&
operator|*
name|multilib_extra
condition|)
block|{
name|int
name|print_at
init|=
name|TRUE
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|multilib_extra
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
condition|)
name|print_at
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_at
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
name|print_at
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* if-exists built-in spec function.     Checks to see if the file specified by the absolute pathname in    ARGS exists.  Returns that pathname if found.     The usual use for this function is to check for a library file    (whose name has been expanded with %s).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|if_exists_spec_function
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|/* Must have only one argument.  */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|IS_ABSOLUTE_PATH
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|access
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|R_OK
argument_list|)
condition|)
return|return
name|argv
index|[
literal|0
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* if-exists-else built-in spec function.     This is like if-exists, but takes an additional argument which    is returned if the first argument does not exist.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|if_exists_else_spec_function
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|/* Must have exactly two arguments.  */
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|access
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|R_OK
argument_list|)
condition|)
return|return
name|argv
index|[
literal|0
index|]
return|;
return|return
name|argv
index|[
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* replace-outfile built-in spec function.     This looks for the first argument in the outfiles array's name and    replaces it with the second argument.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|replace_outfile_spec_function
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Must have exactly two arguments.  */
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|outfiles
index|[
name|i
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|outfiles
index|[
name|i
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
name|outfiles
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given two version numbers, compares the two numbers.    A version number must match the regular expression    ([1-9][0-9]*|0)(\.([1-9][0-9]*|0))* */
end_comment

begin_function
specifier|static
name|int
name|compare_version_strings
parameter_list|(
specifier|const
name|char
modifier|*
name|v1
parameter_list|,
specifier|const
name|char
modifier|*
name|v2
parameter_list|)
block|{
name|int
name|rresult
decl_stmt|;
name|regex_t
name|r
decl_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|r
argument_list|,
literal|"^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$"
argument_list|,
name|REG_EXTENDED
operator||
name|REG_NOSUB
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rresult
operator|=
name|regexec
argument_list|(
operator|&
name|r
argument_list|,
name|v1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rresult
operator|==
name|REG_NOMATCH
condition|)
name|fatal
argument_list|(
literal|"invalid version number `%s'"
argument_list|,
name|v1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rresult
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rresult
operator|=
name|regexec
argument_list|(
operator|&
name|r
argument_list|,
name|v2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rresult
operator|==
name|REG_NOMATCH
condition|)
name|fatal
argument_list|(
literal|"invalid version number `%s'"
argument_list|,
name|v2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rresult
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|strverscmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* version_compare built-in spec function.     This takes an argument of the following form:<comparison-op><arg1> [<arg2>]<switch><result>     and produces "result" if the comparison evaluates to true,    and nothing if it doesn't.     The supported<comparison-op> values are:>=  true if switch is a later (or same) version than arg1    !>  opposite of>=<   true if switch is an earlier version than arg1    !<  opposite of<><  true if switch is arg1 or later, and earlier than arg2<>  true if switch is earlier than arg1 or is arg2 or later     If the switch is not present, the condition is false unless    the first character of the<comparison-op> is '!'.     For example,    %:version-compare(>= 10.3 mmacosx-version-min= -lmx)    adds -lmx if -mmacosx-version-min=10.3.9 was passed.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|version_compare_spec_function
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|comp1
decl_stmt|,
name|comp2
decl_stmt|;
name|size_t
name|switch_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|switch_value
init|=
name|NULL
decl_stmt|;
name|int
name|nargs
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|result
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|fatal
argument_list|(
literal|"too few arguments to %%:version-compare"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'<'
operator|||
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'!'
condition|)
name|nargs
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
name|nargs
operator|+
literal|3
condition|)
name|fatal
argument_list|(
literal|"too many arguments to %%:version-compare"
argument_list|)
expr_stmt|;
name|switch_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|nargs
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|argv
index|[
name|nargs
operator|+
literal|1
index|]
argument_list|,
name|switch_len
argument_list|)
operator|&&
name|check_live_switch
argument_list|(
name|i
argument_list|,
name|switch_len
argument_list|)
condition|)
name|switch_value
operator|=
name|switches
index|[
name|i
index|]
operator|.
name|part1
operator|+
name|switch_len
expr_stmt|;
if|if
condition|(
name|switch_value
operator|==
name|NULL
condition|)
name|comp1
operator|=
name|comp2
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|comp1
operator|=
name|compare_version_strings
argument_list|(
name|switch_value
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|2
condition|)
name|comp2
operator|=
name|compare_version_strings
argument_list|(
name|switch_value
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|comp2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This value unused.  */
block|}
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'>'
operator|<<
literal|8
operator||
literal|'='
case|:
name|result
operator|=
name|comp1
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
literal|'!'
operator|<<
literal|8
operator||
literal|'<'
case|:
name|result
operator|=
name|comp1
operator|>=
literal|0
operator|||
name|switch_value
operator|==
name|NULL
expr_stmt|;
break|break;
case|case
literal|'<'
operator|<<
literal|8
case|:
name|result
operator|=
name|comp1
operator|<
literal|0
expr_stmt|;
break|break;
case|case
literal|'!'
operator|<<
literal|8
operator||
literal|'>'
case|:
name|result
operator|=
name|comp1
operator|<
literal|0
operator|||
name|switch_value
operator|==
name|NULL
expr_stmt|;
break|break;
case|case
literal|'>'
operator|<<
literal|8
operator||
literal|'<'
case|:
name|result
operator|=
name|comp1
operator|>=
literal|0
operator|&&
name|comp2
operator|<
literal|0
expr_stmt|;
break|break;
case|case
literal|'<'
operator|<<
literal|8
operator||
literal|'>'
case|:
name|result
operator|=
name|comp1
operator|<
literal|0
operator|||
name|comp2
operator|>=
literal|0
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown operator '%s' in %%:version-compare"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|NULL
return|;
return|return
name|argv
index|[
name|nargs
operator|+
literal|2
index|]
return|;
block|}
end_function

begin_comment
comment|/* %:include builtin spec function.  This differs from %include in that it    can be nested inside a spec, and thus be conditionalized.  It takes    one argument, the filename, and looks for it in the startfile path.    The result is always NULL, i.e. an empty expansion.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|include_spec_function
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|file
operator|=
name|find_a_file
argument_list|(
operator|&
name|startfile_prefixes
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|R_OK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_specs
argument_list|(
name|file
condition|?
name|file
else|:
name|argv
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

