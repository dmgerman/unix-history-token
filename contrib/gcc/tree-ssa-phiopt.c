begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Optimization of PHI nodes by converting them into straightline code.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_function_decl
specifier|static
name|unsigned
name|int
name|tree_ssa_phiopt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|conditional_replacement
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|value_replacement
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|minmax_replacement
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|abs_replacement
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_phi_edge_with_variable
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
modifier|*
name|blocks_in_phiopt_order
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This pass tries to replaces an if-then-else block with an    assignment.  We have four kinds of transformations.  Some of these    transformations are also performed by the ifcvt RTL optimizer.     Conditional Replacement    -----------------------     This transformation, implemented in conditional_replacement,    replaces       bb0:       if (cond) goto bb2; else goto bb1;      bb1:      bb2:       x = PHI<0 (bb1), 1 (bb0), ...>;     with       bb0:       x' = cond;       goto bb2;      bb2:       x = PHI<x' (bb0), ...>;     We remove bb1 as it becomes unreachable.  This occurs often due to    gimplification of conditionals.     Value Replacement    -----------------     This transformation, implemented in value_replacement, replaces       bb0:        if (a != b) goto bb2; else goto bb1;      bb1:      bb2:        x = PHI<a (bb1), b (bb0), ...>;     with       bb0:      bb2:        x = PHI<b (bb0), ...>;     This opportunity can sometimes occur as a result of other    optimizations.     ABS Replacement    ---------------     This transformation, implemented in abs_replacement, replaces       bb0:        if (a>= 0) goto bb2; else goto bb1;      bb1:        x = -a;      bb2:        x = PHI<x (bb1), a (bb0), ...>;     with       bb0:        x' = ABS_EXPR< a>;      bb2:        x = PHI<x' (bb0), ...>;     MIN/MAX Replacement    -------------------     This transformation, minmax_replacement replaces       bb0:        if (a<= b) goto bb2; else goto bb1;      bb1:      bb2:        x = PHI<b (bb1), a (bb0), ...>;     with       bb0:        x' = MIN_EXPR (a, b)      bb2:        x = PHI<x' (bb0), ...>;     A similar transformation is done for MAX_EXPR.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_phiopt
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|basic_block
modifier|*
name|bb_order
decl_stmt|;
name|unsigned
name|n
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|cfgchanged
init|=
name|false
decl_stmt|;
comment|/* Search every basic block for COND_EXPR we may be able to optimize.       We walk the blocks in order that guarantees that a block with      a single predecessor is processed before the predecessor.      This ensures that we collapse inner ifs before visiting the      outer ones, and also that we do not try to visit a removed      block.  */
name|bb_order
operator|=
name|blocks_in_phiopt_order
argument_list|()
expr_stmt|;
name|n
operator|=
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|cond_expr
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|basic_block
name|bb1
decl_stmt|,
name|bb2
decl_stmt|;
name|edge
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|bb
operator|=
name|bb_order
index|[
name|i
index|]
expr_stmt|;
name|cond_expr
operator|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Check to see if the last statement is a COND_EXPR.  */
if|if
condition|(
operator|!
name|cond_expr
operator|||
name|TREE_CODE
argument_list|(
name|cond_expr
argument_list|)
operator|!=
name|COND_EXPR
condition|)
continue|continue;
name|e1
operator|=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bb1
operator|=
name|e1
operator|->
name|dest
expr_stmt|;
name|e2
operator|=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bb2
operator|=
name|e2
operator|->
name|dest
expr_stmt|;
comment|/* We cannot do the optimization on abnormal edges.  */
if|if
condition|(
operator|(
name|e1
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If either bb1's succ or bb2 or bb2's succ is non NULL.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb1
operator|->
name|succs
argument_list|)
operator|==
literal|0
operator|||
name|bb2
operator|==
name|NULL
operator|||
name|EDGE_COUNT
argument_list|(
name|bb2
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Find the bb which is the fall through to the other.  */
if|if
condition|(
name|EDGE_SUCC
argument_list|(
name|bb1
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
operator|==
name|bb2
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|EDGE_SUCC
argument_list|(
name|bb2
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
operator|==
name|bb1
condition|)
block|{
name|basic_block
name|bb_tmp
init|=
name|bb1
decl_stmt|;
name|edge
name|e_tmp
init|=
name|e1
decl_stmt|;
name|bb1
operator|=
name|bb2
expr_stmt|;
name|bb2
operator|=
name|bb_tmp
expr_stmt|;
name|e1
operator|=
name|e2
expr_stmt|;
name|e2
operator|=
name|e_tmp
expr_stmt|;
block|}
else|else
continue|continue;
name|e1
operator|=
name|EDGE_SUCC
argument_list|(
name|bb1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that bb1 is just a fall through.  */
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb1
argument_list|)
operator|||
operator|(
name|e1
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Also make sure that bb1 only have one predecessor and that it 	 is bb.  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|bb1
argument_list|)
operator|||
name|single_pred
argument_list|(
name|bb1
argument_list|)
operator|!=
name|bb
condition|)
continue|continue;
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
comment|/* Check to make sure that there is only one PHI node.          TODO: we could do it with more than one iff the other PHI nodes 	 have the same elements for these two edges.  */
if|if
condition|(
operator|!
name|phi
operator|||
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|arg0
operator|=
name|PHI_ARG_DEF_TREE
argument_list|(
name|phi
argument_list|,
name|e1
operator|->
name|dest_idx
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|PHI_ARG_DEF_TREE
argument_list|(
name|phi
argument_list|,
name|e2
operator|->
name|dest_idx
argument_list|)
expr_stmt|;
comment|/* Something is wrong if we cannot find the arguments in the PHI 	 node.  */
name|gcc_assert
argument_list|(
name|arg0
operator|!=
name|NULL
operator|&&
name|arg1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do the replacement of conditional if it can be done.  */
if|if
condition|(
name|conditional_replacement
argument_list|(
name|bb
argument_list|,
name|bb1
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|phi
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
name|cfgchanged
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|value_replacement
argument_list|(
name|bb
argument_list|,
name|bb1
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|phi
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
name|cfgchanged
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|abs_replacement
argument_list|(
name|bb
argument_list|,
name|bb1
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|phi
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
name|cfgchanged
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|minmax_replacement
argument_list|(
name|bb
argument_list|,
name|bb1
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|phi
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
name|cfgchanged
operator|=
name|true
expr_stmt|;
block|}
name|free
argument_list|(
name|bb_order
argument_list|)
expr_stmt|;
comment|/* If the CFG has changed, we should cleanup the CFG. */
return|return
name|cfgchanged
condition|?
name|TODO_cleanup_cfg
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the list of basic blocks in the function in an order that guarantees    that if a block X has just a single predecessor Y, then Y is after X in the    ordering.  */
end_comment

begin_function
specifier|static
name|basic_block
modifier|*
name|blocks_in_phiopt_order
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|x
decl_stmt|,
name|y
decl_stmt|;
name|basic_block
modifier|*
name|order
init|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|unsigned
name|n
init|=
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
decl_stmt|;
name|unsigned
name|np
decl_stmt|,
name|i
decl_stmt|;
name|sbitmap
name|visited
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
define|#
directive|define
name|MARK_VISITED
parameter_list|(
name|BB
parameter_list|)
value|(SET_BIT (visited, (BB)->index))
define|#
directive|define
name|VISITED_P
parameter_list|(
name|BB
parameter_list|)
value|(TEST_BIT (visited, (BB)->index))
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|MARK_VISITED
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|x
argument_list|)
block|{
if|if
condition|(
name|VISITED_P
argument_list|(
name|x
argument_list|)
condition|)
continue|continue;
comment|/* Walk the predecessors of x as long as they have precisely one 	 predecessor and add them to the list, so that they get stored 	 after x.  */
for|for
control|(
name|y
operator|=
name|x
operator|,
name|np
operator|=
literal|1
init|;
name|single_pred_p
argument_list|(
name|y
argument_list|)
operator|&&
operator|!
name|VISITED_P
argument_list|(
name|single_pred
argument_list|(
name|y
argument_list|)
argument_list|)
condition|;
name|y
operator|=
name|single_pred
argument_list|(
name|y
argument_list|)
control|)
name|np
operator|++
expr_stmt|;
for|for
control|(
name|y
operator|=
name|x
operator|,
name|i
operator|=
name|n
operator|-
name|np
init|;
name|single_pred_p
argument_list|(
name|y
argument_list|)
operator|&&
operator|!
name|VISITED_P
argument_list|(
name|single_pred
argument_list|(
name|y
argument_list|)
argument_list|)
condition|;
name|y
operator|=
name|single_pred
argument_list|(
name|y
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|order
index|[
name|i
index|]
operator|=
name|y
expr_stmt|;
name|MARK_VISITED
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|order
index|[
name|i
index|]
operator|=
name|y
expr_stmt|;
name|MARK_VISITED
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|==
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n
operator|-=
name|np
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|n
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|order
return|;
undef|#
directive|undef
name|MARK_VISITED
undef|#
directive|undef
name|VISITED_P
block|}
end_function

begin_comment
comment|/* Return TRUE if block BB has no executable statements, otherwise return    FALSE.  */
end_comment

begin_function
name|bool
name|empty_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* BB must have no executable statements.  */
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|LABEL_EXPR
operator|||
name|IS_EMPTY_STMT
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|)
condition|)
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Replace PHI node element whose edge is E in block BB with variable NEW.    Remove the edge from COND_BLOCK which does not lead to BB (COND_BLOCK    is known to have two edges, one of which must reach BB).  */
end_comment

begin_function
specifier|static
name|void
name|replace_phi_edge_with_variable
parameter_list|(
name|basic_block
name|cond_block
parameter_list|,
name|edge
name|e
parameter_list|,
name|tree
name|phi
parameter_list|,
name|tree
name|new
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|basic_block
name|block_to_remove
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* Change the PHI argument to new.  */
name|SET_USE
argument_list|(
name|PHI_ARG_DEF_PTR
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* Remove the empty basic block.  */
if|if
condition|(
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
operator|==
name|bb
condition|)
block|{
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|0
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|0
argument_list|)
operator|->
name|count
operator|+=
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|1
argument_list|)
operator|->
name|count
expr_stmt|;
name|block_to_remove
operator|=
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|1
argument_list|)
operator|->
name|dest
expr_stmt|;
block|}
else|else
block|{
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|1
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|1
argument_list|)
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|1
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|1
argument_list|)
operator|->
name|count
operator|+=
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|0
argument_list|)
operator|->
name|count
expr_stmt|;
name|block_to_remove
operator|=
name|EDGE_SUCC
argument_list|(
name|cond_block
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
expr_stmt|;
block|}
name|delete_basic_block
argument_list|(
name|block_to_remove
argument_list|)
expr_stmt|;
comment|/* Eliminate the COND_EXPR at the end of COND_BLOCK.  */
name|bsi
operator|=
name|bsi_last
argument_list|(
name|cond_block
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"COND_EXPR in block %d and PHI in block %d converted to straightline code.\n"
argument_list|,
name|cond_block
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  The function conditional_replacement does the main work of doing the     conditional replacement.  Return true if the replacement is done.     Otherwise return false.     BB is the basic block where the replacement is going to be done on.  ARG0     is argument 0 from PHI.  Likewise for ARG1.  */
end_comment

begin_function
specifier|static
name|bool
name|conditional_replacement
parameter_list|(
name|basic_block
name|cond_bb
parameter_list|,
name|basic_block
name|middle_bb
parameter_list|,
name|edge
name|e0
parameter_list|,
name|edge
name|e1
parameter_list|,
name|tree
name|phi
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|old_result
init|=
name|NULL
decl_stmt|;
name|tree
name|new
decl_stmt|,
name|cond
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
name|tree
name|new_var
init|=
name|NULL
decl_stmt|;
name|tree
name|new_var1
decl_stmt|;
comment|/* The PHI arguments have the constants 0 and 1, then convert      it to the conditional.  */
if|if
condition|(
operator|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|)
operator|||
operator|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
name|false
return|;
if|if
condition|(
operator|!
name|empty_block_p
argument_list|(
name|middle_bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the condition is not a naked SSA_NAME and its type does not      match the type of the result, then we have to create a new      variable to optimize this case as it would likely create      non-gimple code when the condition was converted to the      result's type.  */
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|last_stmt
argument_list|(
name|cond_bb
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
return|return
name|false
return|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|new_var
operator|=
name|make_ssa_name
argument_list|(
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|old_result
operator|=
name|cond
expr_stmt|;
name|cond
operator|=
name|new_var
expr_stmt|;
block|}
comment|/* If the condition was a naked SSA_NAME and the type is not the      same as the type of the result, then convert the type of the      condition.  */
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
name|cond
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|cond
argument_list|)
expr_stmt|;
comment|/* We need to know which is the true edge and which is the false      edge so that we know when to invert the condition below.  */
name|extract_true_false_edges_from_block
argument_list|(
name|cond_bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* Insert our new statement at the end of conditional block before the      COND_EXPR.  */
name|bsi
operator|=
name|bsi_last
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|build_empty_stmt
argument_list|()
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_result
condition|)
block|{
name|tree
name|new1
decl_stmt|;
name|new1
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|old_result
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|old_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|old_result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|old_result
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|old_result
argument_list|)
argument_list|,
name|new_var
argument_list|,
name|new1
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|new_var
argument_list|)
operator|=
name|new1
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|new1
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
name|new_var1
operator|=
name|duplicate_ssa_name
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* At this point we know we have a COND_EXPR with two successors.      One successor is BB, the other successor is an empty block which      falls through into BB.       There is a single PHI node at the join point (BB) and its arguments      are constants (0, 1).       So, given the condition COND, and the two PHI arguments, we can      rewrite this PHI into non-branching code:         dest = (COND) or dest = COND'       We use the condition as-is if the argument associated with the      true edge has the value one or the argument associated with the      false edge as the value zero.  Note that those conditions are not      the same since only one of the outgoing edges from the COND_EXPR      will directly reach BB and thus be associated with an argument.  */
if|if
condition|(
operator|(
name|e0
operator|==
name|true_edge
operator|&&
name|integer_onep
argument_list|(
name|arg0
argument_list|)
operator|)
operator|||
operator|(
name|e0
operator|==
name|false_edge
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
operator|)
operator|||
operator|(
name|e1
operator|==
name|true_edge
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|)
operator|||
operator|(
name|e1
operator|==
name|false_edge
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
block|{
name|new
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|new_var1
argument_list|)
argument_list|,
name|new_var1
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|cond1
init|=
name|invert_truthvalue
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|cond
operator|=
name|cond1
expr_stmt|;
comment|/* If what we get back is a conditional expression, there is no 	  way that it can be gimple.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|release_ssa_name
argument_list|(
name|new_var1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If COND is not something we can expect to be reducible to a GIMPLE 	 condition, return early.  */
if|if
condition|(
name|is_gimple_cast
argument_list|(
name|cond
argument_list|)
condition|)
name|cond1
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond1
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|release_ssa_name
argument_list|(
name|new_var1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If what we get back is not gimple try to create it as gimple by 	 using a temporary variable.  */
if|if
condition|(
name|is_gimple_cast
argument_list|(
name|cond
argument_list|)
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|op0
decl_stmt|,
name|tmp
decl_stmt|,
name|cond_tmp
decl_stmt|;
comment|/* Only "real" casts are OK here, not everything that is 	     acceptable to is_gimple_cast.  Make sure we don't do 	     anything stupid here.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|cond_tmp
operator|=
name|make_ssa_name
argument_list|(
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond_tmp
argument_list|)
argument_list|,
name|cond_tmp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|cond_tmp
argument_list|)
operator|=
name|new
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|new
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|cond_tmp
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|new_var1
argument_list|)
argument_list|,
name|new_var1
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|new
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|new_var1
argument_list|)
operator|=
name|new
expr_stmt|;
name|replace_phi_edge_with_variable
argument_list|(
name|cond_bb
argument_list|,
name|e1
argument_list|,
name|phi
argument_list|,
name|new_var1
argument_list|)
expr_stmt|;
comment|/* Note that we optimized this PHI.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  The function value_replacement does the main work of doing the value     replacement.  Return true if the replacement is done.  Otherwise return     false.     BB is the basic block where the replacement is going to be done on.  ARG0     is argument 0 from the PHI.  Likewise for ARG1.  */
end_comment

begin_function
specifier|static
name|bool
name|value_replacement
parameter_list|(
name|basic_block
name|cond_bb
parameter_list|,
name|basic_block
name|middle_bb
parameter_list|,
name|edge
name|e0
parameter_list|,
name|edge
name|e1
parameter_list|,
name|tree
name|phi
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|;
name|edge
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
comment|/* If the type says honor signed zeros we cannot do this      optimization.  */
if|if
condition|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|empty_block_p
argument_list|(
name|middle_bb
argument_list|)
condition|)
return|return
name|false
return|;
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|last_stmt
argument_list|(
name|cond_bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This transformation is only valid for equality comparisons.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|NE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|EQ_EXPR
condition|)
return|return
name|false
return|;
comment|/* We need to know which is the true edge and which is the false       edge so that we know if have abs or negative abs.  */
name|extract_true_false_edges_from_block
argument_list|(
name|cond_bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* At this point we know we have a COND_EXPR with two successors.      One successor is BB, the other successor is an empty block which      falls through into BB.       The condition for the COND_EXPR is known to be NE_EXPR or EQ_EXPR.       There is a single PHI node at the join point (BB) with two arguments.       We now need to verify that the two arguments in the PHI node match      the two arguments to the equality comparison.  */
if|if
condition|(
operator|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|tree
name|arg
decl_stmt|;
comment|/* For NE_EXPR, we want to build an assignment result = arg where 	 arg is the PHI argument associated with the true edge.  For 	 EQ_EXPR we want the PHI argument associated with the false edge.  */
name|e
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
condition|?
name|true_edge
else|:
name|false_edge
operator|)
expr_stmt|;
comment|/* Unfortunately, E may not reach BB (it may instead have gone to 	 OTHER_BLOCK).  If that is the case, then we want the single outgoing 	 edge from OTHER_BLOCK which reaches BB and represents the desired 	 path from COND_BLOCK.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|middle_bb
condition|)
name|e
operator|=
name|single_succ_edge
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* Now we know the incoming edge to BB that has the argument for the 	 RHS of our new assignment statement.  */
if|if
condition|(
name|e0
operator|==
name|e
condition|)
name|arg
operator|=
name|arg0
expr_stmt|;
else|else
name|arg
operator|=
name|arg1
expr_stmt|;
name|replace_phi_edge_with_variable
argument_list|(
name|cond_bb
argument_list|,
name|e1
argument_list|,
name|phi
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Note that we optimized this PHI.  */
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  The function minmax_replacement does the main work of doing the minmax     replacement.  Return true if the replacement is done.  Otherwise return     false.     BB is the basic block where the replacement is going to be done on.  ARG0     is argument 0 from the PHI.  Likewise for ARG1.  */
end_comment

begin_function
specifier|static
name|bool
name|minmax_replacement
parameter_list|(
name|basic_block
name|cond_bb
parameter_list|,
name|basic_block
name|middle_bb
parameter_list|,
name|edge
name|e0
parameter_list|,
name|edge
name|e1
parameter_list|,
name|tree
name|phi
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|result
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|cond
decl_stmt|,
name|new
decl_stmt|;
name|edge
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
name|enum
name|tree_code
name|cmp
decl_stmt|,
name|minmax
decl_stmt|,
name|ass_code
decl_stmt|;
name|tree
name|smaller
decl_stmt|,
name|larger
decl_stmt|,
name|arg_true
decl_stmt|,
name|arg_false
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|bsi_from
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The optimization may be unsafe due to NaNs.  */
if|if
condition|(
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|last_stmt
argument_list|(
name|cond_bb
argument_list|)
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|result
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
comment|/* This transformation is only valid for order comparisons.  Record which      operand is smaller/larger if the result of the comparison is true.  */
if|if
condition|(
name|cmp
operator|==
name|LT_EXPR
operator|||
name|cmp
operator|==
name|LE_EXPR
condition|)
block|{
name|smaller
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|larger
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
name|GT_EXPR
operator|||
name|cmp
operator|==
name|GE_EXPR
condition|)
block|{
name|smaller
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|larger
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
comment|/* We need to know which is the true edge and which is the false       edge so that we know if have abs or negative abs.  */
name|extract_true_false_edges_from_block
argument_list|(
name|cond_bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* Forward the edges over the middle basic block.  */
if|if
condition|(
name|true_edge
operator|->
name|dest
operator|==
name|middle_bb
condition|)
name|true_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|true_edge
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|false_edge
operator|->
name|dest
operator|==
name|middle_bb
condition|)
name|false_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|false_edge
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_edge
operator|==
name|e0
condition|)
block|{
name|gcc_assert
argument_list|(
name|false_edge
operator|==
name|e1
argument_list|)
expr_stmt|;
name|arg_true
operator|=
name|arg0
expr_stmt|;
name|arg_false
operator|=
name|arg1
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|false_edge
operator|==
name|e0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|true_edge
operator|==
name|e1
argument_list|)
expr_stmt|;
name|arg_true
operator|=
name|arg1
expr_stmt|;
name|arg_false
operator|=
name|arg0
expr_stmt|;
block|}
if|if
condition|(
name|empty_block_p
argument_list|(
name|middle_bb
argument_list|)
condition|)
block|{
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_true
argument_list|,
name|smaller
argument_list|)
operator|&&
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_false
argument_list|,
name|larger
argument_list|)
condition|)
block|{
comment|/* Case 	  	     if (smaller< larger) 	     rslt = smaller; 	     else 	     rslt = larger;  */
name|minmax
operator|=
name|MIN_EXPR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_false
argument_list|,
name|smaller
argument_list|)
operator|&&
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_true
argument_list|,
name|larger
argument_list|)
condition|)
name|minmax
operator|=
name|MAX_EXPR
expr_stmt|;
else|else
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* Recognize the following case, assuming d<= u:  	 if (a<= u) 	   b = MAX (a, d); 	 x = PHI<b, u>  	 This is equivalent to  	 b = MAX (a, d); 	 x = MIN (b, u);  */
name|tree
name|assign
init|=
name|last_and_only_stmt
argument_list|(
name|middle_bb
argument_list|)
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|bound
decl_stmt|;
if|if
condition|(
operator|!
name|assign
operator|||
name|TREE_CODE
argument_list|(
name|assign
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|assign
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|assign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ass_code
operator|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ass_code
operator|!=
name|MAX_EXPR
operator|&&
name|ass_code
operator|!=
name|MIN_EXPR
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_edge
operator|->
name|src
operator|==
name|middle_bb
condition|)
block|{
comment|/* We got here if the condition is true, i.e., SMALLER< LARGER.  */
if|if
condition|(
operator|!
name|operand_equal_for_phi_arg_p
argument_list|(
name|lhs
argument_list|,
name|arg_true
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_false
argument_list|,
name|larger
argument_list|)
condition|)
block|{
comment|/* Case  		 if (smaller< larger) 		   { 		     r' = MAX_EXPR (smaller, bound) 		   } 		 r = PHI<r', larger>  --> to be turned to MIN_EXPR.  */
if|if
condition|(
name|ass_code
operator|!=
name|MAX_EXPR
condition|)
return|return
name|false
return|;
name|minmax
operator|=
name|MIN_EXPR
expr_stmt|;
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op0
argument_list|,
name|smaller
argument_list|)
condition|)
name|bound
operator|=
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op1
argument_list|,
name|smaller
argument_list|)
condition|)
name|bound
operator|=
name|op0
expr_stmt|;
else|else
return|return
name|false
return|;
comment|/* We need BOUND<= LARGER.  */
if|if
condition|(
operator|!
name|integer_nonzerop
argument_list|(
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|bound
argument_list|,
name|larger
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_false
argument_list|,
name|smaller
argument_list|)
condition|)
block|{
comment|/* Case  		 if (smaller< larger) 		   { 		     r' = MIN_EXPR (larger, bound) 		   } 		 r = PHI<r', smaller>  --> to be turned to MAX_EXPR.  */
if|if
condition|(
name|ass_code
operator|!=
name|MIN_EXPR
condition|)
return|return
name|false
return|;
name|minmax
operator|=
name|MAX_EXPR
expr_stmt|;
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op0
argument_list|,
name|larger
argument_list|)
condition|)
name|bound
operator|=
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op1
argument_list|,
name|larger
argument_list|)
condition|)
name|bound
operator|=
name|op0
expr_stmt|;
else|else
return|return
name|false
return|;
comment|/* We need BOUND>= SMALLER.  */
if|if
condition|(
operator|!
name|integer_nonzerop
argument_list|(
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|bound
argument_list|,
name|smaller
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* We got here if the condition is false, i.e., SMALLER> LARGER.  */
if|if
condition|(
operator|!
name|operand_equal_for_phi_arg_p
argument_list|(
name|lhs
argument_list|,
name|arg_false
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_true
argument_list|,
name|larger
argument_list|)
condition|)
block|{
comment|/* Case  		 if (smaller> larger) 		   { 		     r' = MIN_EXPR (smaller, bound) 		   } 		 r = PHI<r', larger>  --> to be turned to MAX_EXPR.  */
if|if
condition|(
name|ass_code
operator|!=
name|MIN_EXPR
condition|)
return|return
name|false
return|;
name|minmax
operator|=
name|MAX_EXPR
expr_stmt|;
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op0
argument_list|,
name|smaller
argument_list|)
condition|)
name|bound
operator|=
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op1
argument_list|,
name|smaller
argument_list|)
condition|)
name|bound
operator|=
name|op0
expr_stmt|;
else|else
return|return
name|false
return|;
comment|/* We need BOUND>= LARGER.  */
if|if
condition|(
operator|!
name|integer_nonzerop
argument_list|(
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|bound
argument_list|,
name|larger
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|arg_true
argument_list|,
name|smaller
argument_list|)
condition|)
block|{
comment|/* Case  		 if (smaller> larger) 		   { 		     r' = MAX_EXPR (larger, bound) 		   } 		 r = PHI<r', smaller>  --> to be turned to MIN_EXPR.  */
if|if
condition|(
name|ass_code
operator|!=
name|MAX_EXPR
condition|)
return|return
name|false
return|;
name|minmax
operator|=
name|MIN_EXPR
expr_stmt|;
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op0
argument_list|,
name|larger
argument_list|)
condition|)
name|bound
operator|=
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|op1
argument_list|,
name|larger
argument_list|)
condition|)
name|bound
operator|=
name|op0
expr_stmt|;
else|else
return|return
name|false
return|;
comment|/* We need BOUND<= SMALLER.  */
if|if
condition|(
operator|!
name|integer_nonzerop
argument_list|(
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|bound
argument_list|,
name|smaller
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
return|return
name|false
return|;
block|}
comment|/* Move the statement from the middle block.  */
name|bsi
operator|=
name|bsi_last
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|bsi_from
operator|=
name|bsi_last
argument_list|(
name|middle_bb
argument_list|)
expr_stmt|;
name|bsi_move_before
argument_list|(
operator|&
name|bsi_from
argument_list|,
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the statement to compute min/max.  */
name|result
operator|=
name|duplicate_ssa_name
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|result
argument_list|,
name|build2
argument_list|(
name|minmax
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|result
argument_list|)
operator|=
name|new
expr_stmt|;
name|bsi
operator|=
name|bsi_last
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|new
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|replace_phi_edge_with_variable
argument_list|(
name|cond_bb
argument_list|,
name|e1
argument_list|,
name|phi
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  The function absolute_replacement does the main work of doing the absolute     replacement.  Return true if the replacement is done.  Otherwise return     false.     bb is the basic block where the replacement is going to be done on.  arg0     is argument 0 from the phi.  Likewise for arg1.  */
end_comment

begin_function
specifier|static
name|bool
name|abs_replacement
parameter_list|(
name|basic_block
name|cond_bb
parameter_list|,
name|basic_block
name|middle_bb
parameter_list|,
name|edge
name|e0
name|ATTRIBUTE_UNUSED
parameter_list|,
name|edge
name|e1
parameter_list|,
name|tree
name|phi
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|new
decl_stmt|,
name|cond
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
name|tree
name|assign
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|rhs
decl_stmt|,
name|lhs
decl_stmt|;
name|bool
name|negate
decl_stmt|;
name|enum
name|tree_code
name|cond_code
decl_stmt|;
comment|/* If the type says honor signed zeros we cannot do this      optimization.  */
if|if
condition|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* OTHER_BLOCK must have only one executable statement which must have the      form arg0 = -arg1 or arg1 = -arg0.  */
name|assign
operator|=
name|last_and_only_stmt
argument_list|(
name|middle_bb
argument_list|)
expr_stmt|;
comment|/* If we did not find the proper negation assignment, then we can not      optimize.  */
if|if
condition|(
name|assign
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* If we got here, then we have found the only executable statement      in OTHER_BLOCK.  If it is anything other than arg = -arg1 or      arg1 = -arg0, then we can not optimize.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|assign
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|assign
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|assign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NEGATE_EXPR
condition|)
return|return
name|false
return|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */
if|if
condition|(
operator|!
operator|(
name|lhs
operator|==
name|arg0
operator|&&
name|rhs
operator|==
name|arg1
operator|)
operator|&&
operator|!
operator|(
name|lhs
operator|==
name|arg1
operator|&&
name|rhs
operator|==
name|arg0
operator|)
condition|)
return|return
name|false
return|;
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|last_stmt
argument_list|(
name|cond_bb
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
comment|/* Only relationals comparing arg[01] against zero are interesting.  */
name|cond_code
operator|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_code
operator|!=
name|GT_EXPR
operator|&&
name|cond_code
operator|!=
name|GE_EXPR
operator|&&
name|cond_code
operator|!=
name|LT_EXPR
operator|&&
name|cond_code
operator|!=
name|LE_EXPR
condition|)
return|return
name|false
return|;
comment|/* Make sure the conditional is arg[01] OP y.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|!=
name|rhs
condition|)
return|return
name|false
return|;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
name|false
return|;
comment|/* We need to know which is the true edge and which is the false      edge so that we know if have abs or negative abs.  */
name|extract_true_false_edges_from_block
argument_list|(
name|cond_bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* For GT_EXPR/GE_EXPR, if the true edge goes to OTHER_BLOCK, then we      will need to negate the result.  Similarly for LT_EXPR/LE_EXPR if      the false edge goes to OTHER_BLOCK.  */
if|if
condition|(
name|cond_code
operator|==
name|GT_EXPR
operator|||
name|cond_code
operator|==
name|GE_EXPR
condition|)
name|e
operator|=
name|true_edge
expr_stmt|;
else|else
name|e
operator|=
name|false_edge
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|middle_bb
condition|)
name|negate
operator|=
name|true
expr_stmt|;
else|else
name|negate
operator|=
name|false
expr_stmt|;
name|result
operator|=
name|duplicate_ssa_name
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate
condition|)
block|{
name|tree
name|tmp
init|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|make_ssa_name
argument_list|(
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|lhs
operator|=
name|result
expr_stmt|;
comment|/* Build the modify expression with abs expression.  */
name|new
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|lhs
argument_list|)
operator|=
name|new
expr_stmt|;
name|bsi
operator|=
name|bsi_last
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|new
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate
condition|)
block|{
comment|/* Get the right BSI.  We want to insert after the recently 	 added ABS_EXPR statement (which we know is the first statement 	 in the block.  */
name|new
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|result
argument_list|)
operator|=
name|new
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|new
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
name|replace_phi_edge_with_variable
argument_list|(
name|cond_bb
argument_list|,
name|e1
argument_list|,
name|phi
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* Note that we optimized this PHI.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Always do these optimizations if we have SSA    trees to work on.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_phiopt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_phiopt
init|=
block|{
literal|"phiopt"
block|,
comment|/* name */
name|gate_phiopt
block|,
comment|/* gate */
name|tree_ssa_phiopt
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_PHIOPT
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_verify_flow
operator||
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

