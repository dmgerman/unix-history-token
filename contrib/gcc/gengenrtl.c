begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code to allocate RTL structures.    Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_define
define|#
directive|define
name|NO_GENRTL_H
end_define

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_comment
comment|/* Calculate the format for CONST_DOUBLE.  This depends on the relative    widths of HOST_WIDE_INT and REAL_VALUE_TYPE.     We need to go out to e0wwwww, since REAL_ARITHMETIC assumes 16-bits    per element in REAL_VALUE_TYPE.     This is duplicated in rtl.c.     A number of places assume that there are always at least two 'w'    slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_if
if|#
directive|if
name|MAX_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
define|\
value|(11*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|MAX_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
define|\
value|(19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
define|\
value|(7*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REAL_ARITHMETIC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REAL_WIDTH
end_ifndef

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|>=
name|MAX_LONG_DOUBLE_TYPE_SIZE
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|3
operator|>=
name|MAX_LONG_DOUBLE_TYPE_SIZE
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|4
operator|>=
name|MAX_LONG_DOUBLE_TYPE_SIZE
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REAL_WIDTH */
end_comment

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0ww"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|2
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0ww"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|3
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0www"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|4
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0wwww"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|5
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0wwwww"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
end_define

begin_comment
comment|/* nothing - will cause syntax error */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|rtx_definition
block|{
specifier|const
name|char
modifier|*
specifier|const
name|enumname
decl_stmt|,
modifier|*
decl_stmt|const
name|name
decl_stmt|,
modifier|*
decl_stmt|const
name|format
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|{ STRINGX(ENUM), NAME, FORMAT },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|rtx_definition
name|defs
index|[]
init|=
block|{
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|formats
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|type_from_format
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|accessor_from_format
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|special_format
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|special_rtx
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_formats
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gendecl
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genmacro
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gendef
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genlegend
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genheader
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gencode
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Decode a format letter into a C type string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_from_format
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
return|return
literal|"int "
return|;
case|case
literal|'w'
case|:
return|return
literal|"HOST_WIDE_INT "
return|;
case|case
literal|'s'
case|:
return|return
literal|"const char *"
return|;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
return|return
literal|"rtx "
return|;
case|case
literal|'E'
case|:
return|return
literal|"rtvec "
return|;
case|case
literal|'b'
case|:
return|return
literal|"struct bitmap_head_def *"
return|;
comment|/* bitmap - typedef not available */
case|case
literal|'t'
case|:
return|return
literal|"union tree_node *"
return|;
comment|/* tree - typedef not available */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode a format letter into the proper accessor function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|accessor_from_format
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
return|return
literal|"XINT"
return|;
case|case
literal|'w'
case|:
return|return
literal|"XWINT"
return|;
case|case
literal|'s'
case|:
return|return
literal|"XSTR"
return|;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
return|return
literal|"XEXP"
return|;
case|case
literal|'E'
case|:
return|return
literal|"XVEC"
return|;
case|case
literal|'b'
case|:
return|return
literal|"XBITMAP"
return|;
case|case
literal|'t'
case|:
return|return
literal|"XTREE"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if we should ignore FMT, an RTL format, when making    the list of formats we write routines to create.  */
end_comment

begin_function
specifier|static
name|int
name|special_format
parameter_list|(
name|fmt
parameter_list|)
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
block|{
return|return
operator|(
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'V'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'S'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'n'
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the RTL code given by index IDX is one that we should not    generate a gen_RTX_FOO function foo (because that function is present    elsewhere in the compiler).  */
end_comment

begin_function
specifier|static
name|int
name|special_rtx
parameter_list|(
name|idx
parameter_list|)
name|int
name|idx
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"CONST_INT"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"CONST_DOUBLE"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"REG"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"SUBREG"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"MEM"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Place a list of all format specifiers we use into the array FORMAT.  */
end_comment

begin_function
specifier|static
name|void
name|find_formats
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|special_format
argument_list|(
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|f
operator|=
name|formats
init|;
operator|*
name|f
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|f
argument_list|,
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|f
operator|==
literal|0
condition|)
operator|*
name|f
operator|=
name|defs
index|[
name|i
index|]
operator|.
name|format
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the declarations for the routine to allocate RTL with FORMAT.  */
end_comment

begin_function
specifier|static
name|void
name|gendecl
parameter_list|(
name|format
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pos
decl_stmt|;
name|printf
argument_list|(
literal|"extern rtx gen_rtx_fmt_%s\tPARAMS ((RTX_CODE, "
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enum machine_mode mode"
argument_list|)
expr_stmt|;
comment|/* Write each parameter that is needed and start a new line when the line      would overflow.  */
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
literal|75
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
block|{
name|int
name|ourlen
init|=
name|strlen
argument_list|(
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|+
literal|6
operator|+
operator|(
name|i
operator|>
literal|9
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|ourlen
operator|>
literal|76
condition|)
name|printf
argument_list|(
literal|"\n\t\t\t\t      "
argument_list|)
operator|,
name|pos
operator|=
literal|39
expr_stmt|;
name|printf
argument_list|(
literal|" %sarg%d"
argument_list|,
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|ourlen
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"));\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate macros to generate RTL of code IDX using the functions we    write.  */
end_comment

begin_function
specifier|static
name|void
name|genmacro
parameter_list|(
name|idx
parameter_list|)
name|int
name|idx
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We write a macro that defines gen_rtx_RTLCODE to be an equivalent to      gen_rtx_fmt_FORMAT where FORMAT is the RTX_FORMAT of RTLCODE.  */
name|printf
argument_list|(
literal|"#define gen_rtx_%s%s(MODE"
argument_list|,
name|special_rtx
argument_list|(
name|idx
argument_list|)
condition|?
literal|"raw_"
else|:
literal|""
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|defs
index|[
name|idx
index|]
operator|.
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|", ARG%d"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|") \\\n  gen_rtx_fmt_%s (%s, (MODE)"
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|format
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|defs
index|[
name|idx
index|]
operator|.
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|", (ARG%d)"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code for the function to generate RTL whose    format is FORMAT.  */
end_comment

begin_function
specifier|static
name|void
name|gendef
parameter_list|(
name|format
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Start by writing the definition of the function name and the types      of the arguments.  */
name|printf
argument_list|(
literal|"rtx\ngen_rtx_fmt_%s (code, mode"
argument_list|,
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|", arg%d"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|")\n     RTX_CODE code;\n     enum machine_mode mode;"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|"     %sarg%d;\n"
argument_list|,
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
comment|/* Now write out the body of the function itself, which allocates      the memory and initializes it.  */
name|puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  rtx rt;"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rt = ggc_alloc_rtx (%d);\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  PUT_CODE (rt, code);"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  PUT_MODE (rt, mode);"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
name|j
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
operator|,
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|"  %s (rt, %d) = arg%d;\n"
argument_list|,
name|accessor_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  X0EXP (rt, %d) = NULL_RTX;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n  return rt;\n}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the documentation header for files we write.  */
end_comment

begin_function
specifier|static
name|void
name|genlegend
parameter_list|()
block|{
name|puts
argument_list|(
literal|"/* Generated automatically by gengenrtl from rtl.def.  */\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the text of the header file we make, genrtl.h.  */
end_comment

begin_function
specifier|static
name|void
name|genheader
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|fmt
decl_stmt|;
name|puts
argument_list|(
literal|"#ifndef GCC_GENRTL_H"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#define GCC_GENRTL_H\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|formats
init|;
operator|*
name|fmt
condition|;
operator|++
name|fmt
control|)
name|gendecl
argument_list|(
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|special_format
argument_list|(
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
name|genmacro
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n#endif /* GCC_GENRTL_H */"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the text of the code file we write, genrtl.c.  */
end_comment

begin_function
specifier|static
name|void
name|gencode
parameter_list|()
block|{
specifier|const
name|char
modifier|*
modifier|*
name|fmt
decl_stmt|;
name|puts
argument_list|(
literal|"#include \"config.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"system.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"obstack.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"rtl.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"ggc.h\"\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"extern struct obstack *rtl_obstack;\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#define obstack_alloc_rtx(n)					\\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    ((rtx) obstack_alloc (rtl_obstack,				\\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"			  sizeof (struct rtx_def)		\\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"			  + ((n) - 1) * sizeof (rtunion)))\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|formats
init|;
operator|*
name|fmt
operator|!=
literal|0
condition|;
name|fmt
operator|++
control|)
name|gendef
argument_list|(
operator|*
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the main program.  We accept only one argument, "-h", which    says we are writing the genrtl.h file.  Otherwise we are writing the    genrtl.c file.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|find_formats
argument_list|()
expr_stmt|;
name|genlegend
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
name|genheader
argument_list|()
expr_stmt|;
else|else
name|gencode
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

end_unit

