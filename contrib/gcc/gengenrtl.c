begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code to allocate RTL structures.    Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_define
define|#
directive|define
name|NO_GENRTL_H
end_define

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_struct
struct|struct
name|rtx_definition
block|{
specifier|const
name|char
modifier|*
name|enumname
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|format
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|{ STRINGIFY(ENUM), NAME, FORMAT },
end_define

begin_decl_stmt
name|struct
name|rtx_definition
name|defs
index|[]
init|=
block|{
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|formats
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|type_from_format
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|accessor_from_format
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|special_format
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|special_rtx
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_formats
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gendecl
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genmacro
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gendef
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genlegend
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genheader
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gencode
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode a format letter into a C type string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_from_format
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
return|return
literal|"int"
return|;
case|case
literal|'w'
case|:
return|return
literal|"HOST_WIDE_INT"
return|;
case|case
literal|'s'
case|:
return|return
literal|"char *"
return|;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
return|return
literal|"rtx"
return|;
case|case
literal|'E'
case|:
return|return
literal|"rtvec"
return|;
comment|/* ?!? These should be bitmap and tree respectively, but those types        are not available in many of the files which include the output        of gengenrtl.         These are only used in prototypes, so I think we can assume that        void * is useable.  */
case|case
literal|'b'
case|:
return|return
literal|"void *"
return|;
case|case
literal|'t'
case|:
return|return
literal|"void *"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode a format letter into the proper accessor function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|accessor_from_format
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
return|return
literal|"XINT"
return|;
case|case
literal|'w'
case|:
return|return
literal|"XWINT"
return|;
case|case
literal|'s'
case|:
return|return
literal|"XSTR"
return|;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
return|return
literal|"XEXP"
return|;
case|case
literal|'E'
case|:
return|return
literal|"XVEC"
return|;
case|case
literal|'b'
case|:
return|return
literal|"XBITMAP"
return|;
case|case
literal|'t'
case|:
return|return
literal|"XTREE"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if a format character doesn't need normal processing.  */
end_comment

begin_function
specifier|static
name|int
name|special_format
parameter_list|(
name|fmt
parameter_list|)
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
block|{
return|return
operator|(
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'V'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'S'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'n'
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if an rtx requires special processing.  */
end_comment

begin_function
specifier|static
name|int
name|special_rtx
parameter_list|(
name|idx
parameter_list|)
name|int
name|idx
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"CONST_INT"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"CONST_DOUBLE"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"REG"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"MEM"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fill `formats' with all unique format strings.  */
end_comment

begin_function
specifier|static
name|void
name|find_formats
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|special_format
argument_list|(
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|f
operator|=
name|formats
init|;
operator|*
name|f
condition|;
operator|++
name|f
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|f
argument_list|,
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|f
condition|)
operator|*
name|f
operator|=
name|defs
index|[
name|i
index|]
operator|.
name|format
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a prototype for the rtx generator for a format.  */
end_comment

begin_function
specifier|static
name|void
name|gendecl
parameter_list|(
name|f
parameter_list|,
name|format
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"extern rtx gen_rtx_fmt_%s PROTO((RTX_CODE, enum machine_mode mode"
argument_list|,
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", %s arg%d"
argument_list|,
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"));\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a define mapping an rtx code to the generator for its format.  */
end_comment

begin_function
specifier|static
name|void
name|genmacro
parameter_list|(
name|f
parameter_list|,
name|idx
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define gen_rtx_%s%s(mode"
argument_list|,
operator|(
name|special_rtx
argument_list|(
name|idx
argument_list|)
condition|?
literal|"raw_"
else|:
literal|""
operator|)
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|defs
index|[
name|idx
index|]
operator|.
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", arg%d"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")   "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"gen_rtx_fmt_%s(%s,(mode)"
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|format
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|defs
index|[
name|idx
index|]
operator|.
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|",(arg%d)"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the implementation for the rtx generator for a format.  */
end_comment

begin_function
specifier|static
name|void
name|gendef
parameter_list|(
name|f
parameter_list|,
name|format
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"rtx\ngen_rtx_fmt_%s (code, mode"
argument_list|,
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", arg%d"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")\n     RTX_CODE code;\n     enum machine_mode mode;\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"     %s arg%d;\n"
argument_list|,
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
comment|/* See rtx_alloc in rtl.c for comments.  */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  rtx rt = obstack_alloc_rtx (sizeof (struct rtx_def) + %d * sizeof (rtunion));\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|format
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  PUT_CODE (rt, code);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  PUT_MODE (rt, mode);\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
name|j
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
operator|,
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  %s (rt, %d) = arg%d;\n"
argument_list|,
name|accessor_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  return rt;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the `do not edit' banner.  */
end_comment

begin_function
specifier|static
name|void
name|genlegend
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"/* Generated automaticaly by the program `gengenrtl'\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"   from the RTL description file `rtl.def' */\n\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit "genrtl.h".  */
end_comment

begin_function
specifier|static
name|void
name|genheader
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|fmt
decl_stmt|;
for|for
control|(
name|fmt
operator|=
name|formats
init|;
operator|*
name|fmt
condition|;
operator|++
name|fmt
control|)
name|gendecl
argument_list|(
name|f
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|special_format
argument_list|(
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
continue|continue;
name|genmacro
argument_list|(
name|f
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit "genrtl.c".  */
end_comment

begin_function
specifier|static
name|void
name|gencode
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
modifier|*
name|fmt
decl_stmt|;
name|fputs
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#include \"obstack.h\"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#include \"rtl.h\"\n\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"extern struct obstack *rtl_obstack;\n\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"static rtx obstack_alloc_rtx PROTO((int length));\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"static rtx obstack_alloc_rtx (length)\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"     register int length;\n{\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  rtx rt = (rtx) obstack_alloc (rtl_obstack, length);\n\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  memset(rt, 0, sizeof(struct rtx_def) - sizeof(rtunion));\n\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  return rt;\n}\n\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|formats
init|;
operator|*
name|fmt
condition|;
operator|++
name|fmt
control|)
name|gendef
argument_list|(
name|f
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_C_ALLOCA
argument_list|)
end_if

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|nbytes
parameter_list|)
name|size_t
name|nbytes
decl_stmt|;
block|{
specifier|register
name|PTR
name|tmp
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't allocate %d bytes (out of virtual memory)\n"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_C_ALLOCA */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|find_formats
argument_list|()
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|genlegend
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|genheader
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|genlegend
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|gencode
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

