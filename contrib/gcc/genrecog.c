begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to recognize rtl as insns.    Copyright (C) 1987, 88, 92-95, 97-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This program is used to produce insn-recog.c, which contains    a function called `recog' plus its subroutines.    These functions contain a decision tree    that recognizes whether an rtx, the argument given to recog,    is a valid instruction.     recog returns -1 if the rtx is not valid.    If the rtx is valid, recog returns a nonnegative number    which is the insn code number for the pattern that matched.    This is the same as the order in the machine description of the    entry that matched.  This number can be used as an index into various    insn_* tables, such as insn_template, insn_outfun, and insn_n_operands    (found in insn-output.c).     The third argument to recog is an optional pointer to an int.    If present, recog will accept a pattern if it matches except for    missing CLOBBER expressions at the end.  In that case, the value    pointed to by the optional pointer will be set to the number of    CLOBBERs that need to be added (it should be initialized to zero by    the caller).  If it is set nonzero, the caller should allocate a    PARALLEL of the appropriate size, copy the initial entries, and call    add_clobbers (found in insn-emit.c) to fill in the CLOBBERs.     This program also generates the function `split_insns',    which returns 0 if the rtl could not be split, or    it returns the split rtl in a SEQUENCE.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|OUTPUT_LABEL
parameter_list|(
name|INDENT_STRING
parameter_list|,
name|LABEL_NUMBER
parameter_list|)
define|\
value|printf("%sL%d: ATTRIBUTE_UNUSED_LABEL\n", (INDENT_STRING), (LABEL_NUMBER))
end_define

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Holds an array of names indexed by insn_code_number.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insn_name_ptr_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for a listhead of decision trees.  The alternatives    to a node are kept in a doublely-linked list so we can easily add nodes    to the proper place when merging.  */
end_comment

begin_struct
struct|struct
name|decision_head
block|{
name|struct
name|decision
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Data structure for decision tree for recognizing    legitimate instructions.  */
end_comment

begin_struct
struct|struct
name|decision
block|{
name|int
name|number
decl_stmt|;
comment|/* Node number, used for labels */
name|char
modifier|*
name|position
decl_stmt|;
comment|/* String denoting position in pattern */
name|RTX_CODE
name|code
decl_stmt|;
comment|/* Code to test for or UNKNOWN to suppress */
name|char
name|ignore_code
decl_stmt|;
comment|/* If non-zero, need not test code */
name|char
name|ignore_mode
decl_stmt|;
comment|/* If non-zero, need not test mode */
name|int
name|veclen
decl_stmt|;
comment|/* Length of vector, if nonzero */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Machine mode of node */
name|char
name|enforce_mode
decl_stmt|;
comment|/* If non-zero, test `mode' */
name|char
name|retest_code
decl_stmt|,
name|retest_mode
decl_stmt|;
comment|/* See write_tree_1 */
name|int
name|test_elt_zero_int
decl_stmt|;
comment|/* Nonzero if should test XINT (rtl, 0) */
name|int
name|elt_zero_int
decl_stmt|;
comment|/* Required value for XINT (rtl, 0) */
name|int
name|test_elt_one_int
decl_stmt|;
comment|/* Nonzero if should test XINT (rtl, 1) */
name|int
name|elt_one_int
decl_stmt|;
comment|/* Required value for XINT (rtl, 1) */
name|int
name|test_elt_zero_wide
decl_stmt|;
comment|/* Nonzero if should test XWINT (rtl, 0) */
name|HOST_WIDE_INT
name|elt_zero_wide
decl_stmt|;
comment|/* Required value for XWINT (rtl, 0) */
specifier|const
name|char
modifier|*
name|tests
decl_stmt|;
comment|/* If nonzero predicate to call */
name|int
name|pred
decl_stmt|;
comment|/* `preds' index of predicate or -1 */
name|char
modifier|*
name|c_test
decl_stmt|;
comment|/* Additional test to perform */
name|struct
name|decision_head
name|success
decl_stmt|;
comment|/* Nodes to test on success */
name|int
name|insn_code_number
decl_stmt|;
comment|/* Insn number matched, if success */
name|int
name|num_clobbers_to_add
decl_stmt|;
comment|/* Number of CLOBBERs to be added to pattern */
name|struct
name|decision
modifier|*
name|next
decl_stmt|;
comment|/* Node to test on failure */
name|struct
name|decision
modifier|*
name|prev
decl_stmt|;
comment|/* Node whose failure tests us */
name|struct
name|decision
modifier|*
name|afterward
decl_stmt|;
comment|/* Node to test on success, but failure of 				   successor nodes */
name|int
name|opno
decl_stmt|;
comment|/* Operand number, if>= 0 */
name|int
name|dupno
decl_stmt|;
comment|/* Number of operand to compare against */
name|int
name|label_needed
decl_stmt|;
comment|/* Nonzero if label needed when writing tree */
name|int
name|subroutine_number
decl_stmt|;
comment|/* Number of subroutine this node starts */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SUBROUTINE_THRESHOLD
value|50
end_define

begin_decl_stmt
specifier|static
name|int
name|next_subroutine_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We can write two types of subroutines: One for insn recognition and    one to split insns.  This defines which type is being written.  */
end_comment

begin_enum
enum|enum
name|routine_type
block|{
name|RECOG
block|,
name|SPLIT
block|}
enum|;
end_enum

begin_comment
comment|/* Next available node number for tree nodes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next number to use as an insn_code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_insn_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but counts all expressions in the MD file; used for    error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the highest depth we ever have so we know how many variables to    allocate in each subroutine we make.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_depth
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This table contains a list of the rtl codes that can possibly match a    predicate defined in recog.c.  The function `not_both_true' uses it to    deduce that there are no expressions that can be matches by certain pairs    of tree nodes.  Also, if a predicate can match only one code, we can    hardwire that code into the node testing the predicate.  */
end_comment

begin_struct
specifier|static
struct|struct
name|pred_table
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|RTX_CODE
name|codes
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
block|}
name|preds
index|[]
init|=
block|{
block|{
literal|"general_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|PREDICATE_CODES
name|PREDICATE_CODES
endif|#
directive|endif
block|{
literal|"address_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|,
name|PLUS
block|,
name|MINUS
block|,
name|MULT
block|}
block|}
block|,
block|{
literal|"register_operand"
block|,
block|{
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"scratch_operand"
block|,
block|{
name|SCRATCH
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"immediate_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|}
block|}
block|,
block|{
literal|"const_int_operand"
block|,
block|{
name|CONST_INT
block|}
block|}
block|,
block|{
literal|"const_double_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|}
block|}
block|,
block|{
literal|"nonimmediate_operand"
block|,
block|{
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"nonmemory_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"push_operand"
block|,
block|{
name|MEM
block|}
block|}
block|,
block|{
literal|"pop_operand"
block|,
block|{
name|MEM
block|}
block|}
block|,
block|{
literal|"memory_operand"
block|,
block|{
name|SUBREG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"indirect_operand"
block|,
block|{
name|SUBREG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"comparison_operator"
block|,
block|{
name|EQ
block|,
name|NE
block|,
name|LE
block|,
name|LT
block|,
name|GE
block|,
name|GT
block|,
name|LEU
block|,
name|LTU
block|,
name|GEU
block|,
name|GTU
block|}
block|}
block|,
block|{
literal|"mode_independent_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_KNOWN_PREDS
value|(sizeof preds / sizeof preds[0])
end_define

begin_decl_stmt
specifier|static
name|struct
name|decision_head
name|make_insn_sequence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|decision
modifier|*
name|add_to_sequence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|decision_head
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|not_both_true
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|position_merit
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|decision_head
name|merge_trees
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision_head
operator|,
expr|struct
name|decision_head
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|break_out_subroutines
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision_head
operator|,
expr|enum
name|routine_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_subroutine
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_tree_1
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_code
name|PROTO
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|same_codes
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_codes
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|same_modes
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_modes
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_tree
name|PROTO
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|,
name|int
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|change_state
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Construct and return a sequence of decisions    that will recognize INSN.     TYPE says what type of routine we are recognizing (RECOG or SPLIT).  */
end_comment

begin_function
specifier|static
name|struct
name|decision_head
name|make_insn_sequence
parameter_list|(
name|insn
parameter_list|,
name|type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|char
modifier|*
name|c_test
init|=
name|XSTR
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
condition|?
literal|2
else|:
literal|1
argument_list|)
decl_stmt|;
name|struct
name|decision
modifier|*
name|last
decl_stmt|;
name|struct
name|decision_head
name|head
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|last_real_name
init|=
literal|"insn"
decl_stmt|;
specifier|static
name|int
name|last_real_code
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|insn_name_ptr_size
operator|<=
name|next_insn_code
condition|)
block|{
name|int
name|new_size
decl_stmt|;
name|new_size
operator|=
operator|(
name|insn_name_ptr_size
condition|?
name|insn_name_ptr_size
operator|*
literal|2
else|:
literal|512
operator|)
expr_stmt|;
name|insn_name_ptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|insn_name_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|new_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|insn_name_ptr
operator|+
name|insn_name_ptr_size
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|new_size
operator|-
name|insn_name_ptr_size
operator|)
argument_list|)
expr_stmt|;
name|insn_name_ptr_size
operator|=
name|new_size
expr_stmt|;
block|}
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|last_real_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s+%d"
argument_list|,
name|last_real_name
argument_list|,
name|next_insn_code
operator|-
name|last_real_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last_real_name
operator|=
name|name
expr_stmt|;
name|last_real_code
operator|=
name|next_insn_code
expr_stmt|;
block|}
name|insn_name_ptr
index|[
name|next_insn_code
index|]
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
argument_list|)
operator|==
literal|1
condition|)
name|x
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|x
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XVEC
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|add_to_sequence
argument_list|(
name|x
argument_list|,
operator|&
name|head
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_test
index|[
literal|0
index|]
condition|)
name|last
operator|->
name|c_test
operator|=
name|c_test
expr_stmt|;
name|last
operator|->
name|insn_code_number
operator|=
name|next_insn_code
expr_stmt|;
name|last
operator|->
name|num_clobbers_to_add
operator|=
literal|0
expr_stmt|;
comment|/* If this is not a DEFINE_SPLIT and X is a PARALLEL, see if it ends with a      group of CLOBBERs of (hard) registers or MATCH_SCRATCHes.  If so, set up      to recognize the pattern without these CLOBBERs.  */
if|if
condition|(
name|type
operator|==
name|RECOG
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MATCH_SCRATCH
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|new
decl_stmt|;
name|struct
name|decision_head
name|clobber_head
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|new
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|new
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|XVECEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|add_to_sequence
argument_list|(
name|new
argument_list|,
operator|&
name|clobber_head
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_test
index|[
literal|0
index|]
condition|)
name|last
operator|->
name|c_test
operator|=
name|c_test
expr_stmt|;
name|last
operator|->
name|insn_code_number
operator|=
name|next_insn_code
expr_stmt|;
name|last
operator|->
name|num_clobbers_to_add
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
name|i
expr_stmt|;
name|head
operator|=
name|merge_trees
argument_list|(
name|head
argument_list|,
name|clobber_head
argument_list|)
expr_stmt|;
block|}
block|}
name|next_insn_code
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SPLIT
condition|)
comment|/* Define the subroutine we will call below and emit in genemit.  */
name|printf
argument_list|(
literal|"extern rtx gen_split_%d ();\n"
argument_list|,
name|last
operator|->
name|insn_code_number
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a chain of nodes to verify that an rtl expression matches    PATTERN.     LAST is a pointer to the listhead in the previous node in the chain (or    in the calling function, for the first node).     POSITION is the string representing the current position in the insn.     A pointer to the final node in the chain is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|decision
modifier|*
name|add_to_sequence
parameter_list|(
name|pattern
parameter_list|,
name|last
parameter_list|,
name|position
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|struct
name|decision_head
modifier|*
name|last
decl_stmt|;
specifier|const
name|char
modifier|*
name|position
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|struct
name|decision
modifier|*
name|new
init|=
operator|(
expr|struct
name|decision
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decision
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|decision
modifier|*
name|this
decl_stmt|;
name|char
modifier|*
name|newpos
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
name|int
name|depth
init|=
name|strlen
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|max_depth
condition|)
name|max_depth
operator|=
name|depth
expr_stmt|;
name|new
operator|->
name|number
operator|=
name|next_number
operator|++
expr_stmt|;
name|new
operator|->
name|position
operator|=
name|xstrdup
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|new
operator|->
name|ignore_code
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|ignore_mode
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|retest_code
operator|=
name|new
operator|->
name|retest_mode
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|veclen
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|test_elt_zero_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|test_elt_one_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|test_elt_zero_wide
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|elt_zero_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|elt_one_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|elt_zero_wide
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|pred
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|c_test
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|success
operator|.
name|first
operator|=
name|new
operator|->
name|success
operator|.
name|last
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|insn_code_number
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|num_clobbers_to_add
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|afterward
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|opno
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|dupno
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|label_needed
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|subroutine_number
operator|=
literal|0
expr_stmt|;
name|this
operator|=
name|new
expr_stmt|;
name|last
operator|->
name|first
operator|=
name|last
operator|->
name|last
operator|=
name|new
expr_stmt|;
name|newpos
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpos
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|newpos
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|restart
label|:
name|new
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_PARALLEL
case|:
case|case
name|MATCH_INSN2
case|:
name|new
operator|->
name|opno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|code
operator|=
operator|(
name|code
operator|==
name|MATCH_PARALLEL
condition|?
name|PARALLEL
else|:
name|UNKNOWN
operator|)
expr_stmt|;
name|new
operator|->
name|enforce_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_SCRATCH
condition|)
name|new
operator|->
name|tests
operator|=
literal|"scratch_operand"
expr_stmt|;
else|else
name|new
operator|->
name|tests
operator|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|new
operator|->
name|tests
operator|==
literal|0
condition|)
name|new
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
comment|/* See if we know about this predicate and save its number.  If we do, 	 and it only accepts one code, note that fact.  The predicate 	 `const_int_operand' only tests for a CONST_INT, so if we do so we 	 can avoid calling it at all.  	 Finally, if we know that the predicate does not allow CONST_INT, we 	 know that the only way the predicate can match is if the modes match 	 (here we use the kludge of relying on the fact that "address_operand" 	 accepts CONST_INT; otherwise, it would have to be a special case), 	 so we can test the mode (but we need not).  This fact should 	 considerably simplify the generated code.  */
if|if
condition|(
name|new
operator|->
name|tests
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_KNOWN_PREDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|preds
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|new
operator|->
name|tests
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|allows_const_int
init|=
literal|0
decl_stmt|;
name|new
operator|->
name|pred
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|new
operator|->
name|code
operator|==
name|UNKNOWN
condition|)
block|{
name|new
operator|->
name|code
operator|=
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"const_int_operand"
argument_list|,
name|new
operator|->
name|tests
argument_list|)
condition|)
name|new
operator|->
name|tests
operator|=
literal|0
operator|,
name|new
operator|->
name|pred
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_RTX_CODE
operator|&&
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|==
name|CONST_INT
condition|)
name|allows_const_int
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|allows_const_int
condition|)
name|new
operator|->
name|enforce_mode
operator|=
name|new
operator|->
name|ignore_mode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PREDICATE_CODES
comment|/* If the port has a list of the predicates it uses but omits 	     one, warn.  */
if|if
condition|(
name|i
operator|==
name|NUM_KNOWN_PREDS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: `%s' not in PREDICATE_CODES\n"
argument_list|,
name|new
operator|->
name|tests
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|code
operator|==
name|MATCH_OPERATOR
operator|||
name|code
operator|==
name|MATCH_PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|newpos
index|[
name|depth
index|]
operator|=
name|i
operator|+
operator|(
name|code
operator|==
name|MATCH_OPERATOR
condition|?
literal|'0'
else|:
literal|'a'
operator|)
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|new
return|;
case|case
name|MATCH_OP_DUP
case|:
name|new
operator|->
name|opno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|dupno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|new
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|newpos
index|[
name|depth
index|]
operator|=
name|i
operator|+
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
name|new
operator|->
name|dupno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|new
operator|->
name|enforce_mode
operator|=
literal|0
expr_stmt|;
return|return
name|new
return|;
case|case
name|ADDRESS
case|:
name|pattern
operator|=
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|SET
case|:
comment|/* The operands of a SET must have the same mode unless one is VOIDmode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
comment|/* The mode of an ADDRESS_OPERAND is the mode of the memory reference, 	     not the mode of the address.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|MATCH_OPERAND
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|"address_operand"
argument_list|)
operator|)
condition|)
block|{
name|print_rtl
argument_list|(
name|stderr
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"mode mismatch in SET"
argument_list|)
expr_stmt|;
block|}
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|.
name|first
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'1'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
comment|/* If set are setting CC0 from anything other than a COMPARE, we 	 must enforce the mode so that we do not produce ambiguous insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|COMPARE
condition|)
name|this
operator|->
name|success
operator|.
name|first
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
return|return
name|new
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|STRICT_LOW_PART
case|:
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|.
name|first
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
return|return
name|new
return|;
case|case
name|SUBREG
case|:
name|this
operator|->
name|test_elt_one_int
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|elt_one_int
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|.
name|first
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
return|return
name|new
return|;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|.
name|first
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'1'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'2'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
return|return
name|new
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* If the first operand is (cc0), we don't have to do anything 	 special.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CC0
condition|)
break|break;
comment|/* ... fall through ...  */
case|case
name|COMPARE
case|:
comment|/* Enforce the mode on the first operand to avoid ambiguous insns.  */
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|.
name|first
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'1'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
return|return
name|new
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|len
condition|;
name|i
operator|++
control|)
block|{
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|this
operator|->
name|test_elt_zero_int
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|elt_zero_int
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
operator|&&
name|i
operator|==
literal|1
condition|)
block|{
name|this
operator|->
name|test_elt_one_int
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|elt_one_int
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'w'
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|this
operator|->
name|test_elt_zero_wide
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|elt_zero_wide
operator|=
name|XWINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
comment|/* We do not handle a vector appearing as other than 	     the first item, just because nothing uses them 	     and by handling only the special case 	     we can use one element in newpos for either 	     the item number of a subexpression 	     or the element number in a vector.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|this
operator|->
name|veclen
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|newpos
index|[
name|depth
index|]
operator|=
literal|'a'
operator|+
name|j
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|new
operator|->
name|success
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|!=
literal|'0'
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if we can prove that there is no RTL that can match both    D1 and D2.  Otherwise, return 0 (it may be that there is an RTL that    can match both or just that we couldn't prove there wasn't such an RTL).     TOPLEVEL is non-zero if we are to only look at the top level and not    recursively descend.  */
end_comment

begin_function
specifier|static
name|int
name|not_both_true
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|,
name|toplevel
parameter_list|)
name|struct
name|decision
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|toplevel
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|decision
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
comment|/* If they are both to test modes and the modes are different, they aren't      both true.  Similarly for codes, integer elements, and vector lengths.  */
if|if
condition|(
operator|(
name|d1
operator|->
name|enforce_mode
operator|&&
name|d2
operator|->
name|enforce_mode
operator|&&
name|d1
operator|->
name|mode
operator|!=
name|VOIDmode
operator|&&
name|d2
operator|->
name|mode
operator|!=
name|VOIDmode
operator|&&
name|d1
operator|->
name|mode
operator|!=
name|d2
operator|->
name|mode
operator|)
operator|||
operator|(
name|d1
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
name|d2
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
name|d1
operator|->
name|code
operator|!=
name|d2
operator|->
name|code
operator|)
operator|||
operator|(
name|d1
operator|->
name|test_elt_zero_int
operator|&&
name|d2
operator|->
name|test_elt_zero_int
operator|&&
name|d1
operator|->
name|elt_zero_int
operator|!=
name|d2
operator|->
name|elt_zero_int
operator|)
operator|||
operator|(
name|d1
operator|->
name|test_elt_one_int
operator|&&
name|d2
operator|->
name|test_elt_one_int
operator|&&
name|d1
operator|->
name|elt_one_int
operator|!=
name|d2
operator|->
name|elt_one_int
operator|)
operator|||
operator|(
name|d1
operator|->
name|test_elt_zero_wide
operator|&&
name|d2
operator|->
name|test_elt_zero_wide
operator|&&
name|d1
operator|->
name|elt_zero_wide
operator|!=
name|d2
operator|->
name|elt_zero_wide
operator|)
operator|||
operator|(
name|d1
operator|->
name|veclen
operator|&&
name|d2
operator|->
name|veclen
operator|&&
name|d1
operator|->
name|veclen
operator|!=
name|d2
operator|->
name|veclen
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If either is a wild-card MATCH_OPERAND without a predicate, it can match      absolutely anything, so we can't say that no intersection is possible.      This case is detected by having a zero TESTS field with a code of      UNKNOWN.  */
if|if
condition|(
operator|(
name|d1
operator|->
name|tests
operator|==
literal|0
operator|&&
name|d1
operator|->
name|code
operator|==
name|UNKNOWN
operator|)
operator|||
operator|(
name|d2
operator|->
name|tests
operator|==
literal|0
operator|&&
name|d2
operator|->
name|code
operator|==
name|UNKNOWN
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If either has a predicate that we know something about, set things up so      that D1 is the one that always has a known predicate.  Then see if they      have any codes in common.  */
if|if
condition|(
name|d1
operator|->
name|pred
operator|>=
literal|0
operator|||
name|d2
operator|->
name|pred
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|d2
operator|->
name|pred
operator|>=
literal|0
condition|)
name|p1
operator|=
name|d1
operator|,
name|d1
operator|=
name|d2
operator|,
name|d2
operator|=
name|p1
expr_stmt|;
comment|/* If D2 tests an explicit code, see if it is in the list of valid codes 	 for D1's predicate.  */
if|if
condition|(
name|d2
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
operator|&&
name|preds
index|[
name|d1
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|preds
index|[
name|d1
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|==
name|d2
operator|->
name|code
condition|)
break|break;
if|if
condition|(
name|preds
index|[
name|d1
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Otherwise see if the predicates have any codes in common.  */
elseif|else
if|if
condition|(
name|d2
operator|->
name|pred
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
operator|&&
name|preds
index|[
name|d1
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_RTX_CODE
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|preds
index|[
name|d2
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|==
literal|0
operator|||
name|preds
index|[
name|d2
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|==
name|preds
index|[
name|d1
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|preds
index|[
name|d2
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|preds
index|[
name|d1
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* If we got here, we can't prove that D1 and D2 cannot both be true.      If we are only to check the top level, return 0.  Otherwise, see if      we can prove that all choices in both successors are mutually      exclusive.  If either does not have any successors, we can't prove      they can't both be true.  */
if|if
condition|(
name|toplevel
operator|||
name|d1
operator|->
name|success
operator|.
name|first
operator|==
literal|0
operator|||
name|d2
operator|->
name|success
operator|.
name|first
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p1
operator|=
name|d1
operator|->
name|success
operator|.
name|first
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
for|for
control|(
name|p2
operator|=
name|d2
operator|->
name|success
operator|.
name|first
init|;
name|p2
condition|;
name|p2
operator|=
name|p2
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|not_both_true
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Assuming that we can reorder all the alternatives at a specific point in    the tree (see discussion in merge_trees), we would prefer an ordering of    nodes where groups of consecutive nodes test the same mode and, within each    mode, groups of nodes test the same code.  With this order, we can    construct nested switch statements, the inner one to test the code and    the outer one to test the mode.     We would like to list nodes testing for specific codes before those    that test predicates to avoid unnecessary function calls.  Similarly,    tests for specific modes should precede nodes that allow any mode.     This function returns the merit (with 0 being the best) of inserting    a test involving the specified MODE and CODE after node P.  If P is    zero, we are to determine the merit of inserting the test at the front    of the list.  */
end_comment

begin_function
specifier|static
name|int
name|position_merit
parameter_list|(
name|p
parameter_list|,
name|mode
parameter_list|,
name|code
parameter_list|)
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|machine_mode
name|p_mode
decl_stmt|;
comment|/* The only time the front of the list is anything other than the worst      position is if we are testing a mode that isn't VOIDmode.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
name|mode
operator|==
name|VOIDmode
condition|?
literal|3
else|:
literal|2
return|;
name|p_mode
operator|=
name|p
operator|->
name|enforce_mode
condition|?
name|p
operator|->
name|mode
else|:
name|VOIDmode
expr_stmt|;
comment|/* The best case is if the codes and modes both match.  */
if|if
condition|(
name|p_mode
operator|==
name|mode
operator|&&
name|p
operator|->
name|code
operator|==
name|code
condition|)
return|return
literal|0
return|;
comment|/* If the codes don't match, the next best case is if the modes match.      In that case, the best position for this node depends on whether      we are testing for a specific code or not.  If we are, the best place      is after some other test for an explicit code and our mode or after      the last test in the previous mode if every test in our mode is for      an unknown code.       If we are testing for UNKNOWN, then the next best case is at the end of      our mode.  */
if|if
condition|(
operator|(
name|code
operator|!=
name|UNKNOWN
operator|&&
operator|(
operator|(
name|p_mode
operator|==
name|mode
operator|&&
name|p
operator|->
name|code
operator|!=
name|UNKNOWN
operator|)
operator|||
operator|(
name|p_mode
operator|!=
name|mode
operator|&&
name|p
operator|->
name|next
operator|&&
operator|(
name|p
operator|->
name|next
operator|->
name|enforce_mode
condition|?
name|p
operator|->
name|next
operator|->
name|mode
else|:
name|VOIDmode
operator|)
operator|==
name|mode
operator|&&
operator|(
name|p
operator|->
name|next
operator|->
name|code
operator|==
name|UNKNOWN
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|code
operator|==
name|UNKNOWN
operator|&&
name|p_mode
operator|==
name|mode
operator|&&
operator|(
name|p
operator|->
name|next
operator|==
literal|0
operator|||
operator|(
name|p
operator|->
name|next
operator|->
name|enforce_mode
condition|?
name|p
operator|->
name|next
operator|->
name|mode
else|:
name|VOIDmode
operator|)
operator|!=
name|mode
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* The third best case occurs when nothing is testing MODE.  If MODE      is not VOIDmode, then the third best case is after something of any      mode that is not VOIDmode.  If we are testing VOIDmode, the third best      place is the end of the list.  */
if|if
condition|(
name|p_mode
operator|!=
name|mode
operator|&&
operator|(
operator|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|p_mode
operator|!=
name|VOIDmode
operator|)
operator|||
operator|(
name|mode
operator|==
name|VOIDmode
operator|&&
name|p
operator|->
name|next
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|2
return|;
comment|/* Otherwise, we have the worst case.  */
return|return
literal|3
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Merge two decision tree listheads OLDH and ADDH,    modifying OLDH destructively, and return the merged tree.  */
end_comment

begin_function
specifier|static
name|struct
name|decision_head
name|merge_trees
parameter_list|(
name|oldh
parameter_list|,
name|addh
parameter_list|)
specifier|register
name|struct
name|decision_head
name|oldh
decl_stmt|,
name|addh
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|add
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|oldh
operator|.
name|first
operator|==
literal|0
condition|)
return|return
name|addh
return|;
if|if
condition|(
name|addh
operator|.
name|first
operator|==
literal|0
condition|)
return|return
name|oldh
return|;
comment|/* If we are adding things at different positions, something is wrong.  */
if|if
condition|(
name|strcmp
argument_list|(
name|oldh
operator|.
name|first
operator|->
name|position
argument_list|,
name|addh
operator|.
name|first
operator|->
name|position
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|add
operator|=
name|addh
operator|.
name|first
init|;
name|add
condition|;
name|add
operator|=
name|next
control|)
block|{
name|enum
name|machine_mode
name|add_mode
init|=
name|add
operator|->
name|enforce_mode
condition|?
name|add
operator|->
name|mode
else|:
name|VOIDmode
decl_stmt|;
name|struct
name|decision
modifier|*
name|best_position
init|=
literal|0
decl_stmt|;
name|int
name|best_merit
init|=
literal|4
decl_stmt|;
name|struct
name|decision
modifier|*
name|old
decl_stmt|;
name|next
operator|=
name|add
operator|->
name|next
expr_stmt|;
comment|/* The semantics of pattern matching state that the tests are done in 	 the order given in the MD file so that if an insn matches two 	 patterns, the first one will be used.  However, in practice, most, 	 if not all, patterns are unambiguous so that their order is  	 independent.  In that case, we can merge identical tests and 	 group all similar modes and codes together.  	 Scan starting from the end of OLDH until we reach a point 	 where we reach the head of the list or where we pass a pattern 	 that could also be true if NEW is true.  If we find an identical 	 pattern, we can merge them.  Also, record the last node that tests 	 the same code and mode and the last one that tests just the same mode.  	 If we have no match, place NEW after the closest match we found.  */
for|for
control|(
name|old
operator|=
name|oldh
operator|.
name|last
init|;
name|old
condition|;
name|old
operator|=
name|old
operator|->
name|prev
control|)
block|{
name|int
name|our_merit
decl_stmt|;
comment|/* If we don't have anything to test except an additional test, 	     do not consider the two nodes equal.  If we did, the test below 	     would cause an infinite recursion.  */
if|if
condition|(
name|old
operator|->
name|tests
operator|==
literal|0
operator|&&
name|old
operator|->
name|test_elt_zero_int
operator|==
literal|0
operator|&&
name|old
operator|->
name|test_elt_one_int
operator|==
literal|0
operator|&&
name|old
operator|->
name|veclen
operator|==
literal|0
operator|&&
name|old
operator|->
name|test_elt_zero_wide
operator|==
literal|0
operator|&&
name|old
operator|->
name|dupno
operator|==
operator|-
literal|1
operator|&&
name|old
operator|->
name|mode
operator|==
name|VOIDmode
operator|&&
name|old
operator|->
name|code
operator|==
name|UNKNOWN
operator|&&
operator|(
name|old
operator|->
name|c_test
operator|!=
literal|0
operator|||
name|add
operator|->
name|c_test
operator|!=
literal|0
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|old
operator|->
name|tests
operator|==
name|add
operator|->
name|tests
operator|||
operator|(
name|old
operator|->
name|pred
operator|>=
literal|0
operator|&&
name|old
operator|->
name|pred
operator|==
name|add
operator|->
name|pred
operator|)
operator|||
operator|(
name|old
operator|->
name|tests
operator|&&
name|add
operator|->
name|tests
operator|&&
operator|!
name|strcmp
argument_list|(
name|old
operator|->
name|tests
argument_list|,
name|add
operator|->
name|tests
argument_list|)
operator|)
operator|)
operator|&&
name|old
operator|->
name|test_elt_zero_int
operator|==
name|add
operator|->
name|test_elt_zero_int
operator|&&
name|old
operator|->
name|elt_zero_int
operator|==
name|add
operator|->
name|elt_zero_int
operator|&&
name|old
operator|->
name|test_elt_one_int
operator|==
name|add
operator|->
name|test_elt_one_int
operator|&&
name|old
operator|->
name|elt_one_int
operator|==
name|add
operator|->
name|elt_one_int
operator|&&
name|old
operator|->
name|test_elt_zero_wide
operator|==
name|add
operator|->
name|test_elt_zero_wide
operator|&&
name|old
operator|->
name|elt_zero_wide
operator|==
name|add
operator|->
name|elt_zero_wide
operator|&&
name|old
operator|->
name|veclen
operator|==
name|add
operator|->
name|veclen
operator|&&
name|old
operator|->
name|dupno
operator|==
name|add
operator|->
name|dupno
operator|&&
name|old
operator|->
name|opno
operator|==
name|add
operator|->
name|opno
operator|&&
name|old
operator|->
name|code
operator|==
name|add
operator|->
name|code
operator|&&
name|old
operator|->
name|enforce_mode
operator|==
name|add
operator|->
name|enforce_mode
operator|&&
name|old
operator|->
name|mode
operator|==
name|add
operator|->
name|mode
condition|)
block|{
comment|/* If the additional test is not the same, split both nodes 		 into nodes that just contain all things tested before the 		 additional test and nodes that contain the additional test 		 and actions when it is true.  This optimization is important 		 because of the case where we have almost identical patterns 		 with different tests on target flags.  */
if|if
condition|(
name|old
operator|->
name|c_test
operator|!=
name|add
operator|->
name|c_test
operator|&&
operator|!
operator|(
name|old
operator|->
name|c_test
operator|&&
name|add
operator|->
name|c_test
operator|&&
operator|!
name|strcmp
argument_list|(
name|old
operator|->
name|c_test
argument_list|,
name|add
operator|->
name|c_test
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|old
operator|->
name|insn_code_number
operator|>=
literal|0
operator|||
name|old
operator|->
name|opno
operator|>=
literal|0
condition|)
block|{
name|struct
name|decision
modifier|*
name|split
init|=
operator|(
expr|struct
name|decision
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decision
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|split
argument_list|,
name|old
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|decision
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|->
name|success
operator|.
name|first
operator|=
name|old
operator|->
name|success
operator|.
name|last
operator|=
name|split
expr_stmt|;
name|old
operator|->
name|c_test
operator|=
literal|0
expr_stmt|;
name|old
operator|->
name|opno
operator|=
operator|-
literal|1
expr_stmt|;
name|old
operator|->
name|insn_code_number
operator|=
operator|-
literal|1
expr_stmt|;
name|old
operator|->
name|num_clobbers_to_add
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|number
operator|=
name|next_number
operator|++
expr_stmt|;
name|split
operator|->
name|next
operator|=
name|split
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|split
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|split
operator|->
name|veclen
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|test_elt_zero_int
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|test_elt_one_int
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|test_elt_zero_wide
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|pred
operator|=
operator|-
literal|1
expr_stmt|;
name|split
operator|->
name|dupno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|add
operator|->
name|insn_code_number
operator|>=
literal|0
operator|||
name|add
operator|->
name|opno
operator|>=
literal|0
condition|)
block|{
name|struct
name|decision
modifier|*
name|split
init|=
operator|(
expr|struct
name|decision
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decision
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|split
argument_list|,
name|add
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|decision
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|->
name|success
operator|.
name|first
operator|=
name|add
operator|->
name|success
operator|.
name|last
operator|=
name|split
expr_stmt|;
name|add
operator|->
name|c_test
operator|=
literal|0
expr_stmt|;
name|add
operator|->
name|opno
operator|=
operator|-
literal|1
expr_stmt|;
name|add
operator|->
name|insn_code_number
operator|=
operator|-
literal|1
expr_stmt|;
name|add
operator|->
name|num_clobbers_to_add
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|number
operator|=
name|next_number
operator|++
expr_stmt|;
name|split
operator|->
name|next
operator|=
name|split
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|split
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|split
operator|->
name|veclen
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|test_elt_zero_int
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|test_elt_one_int
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|test_elt_zero_wide
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
name|split
operator|->
name|pred
operator|=
operator|-
literal|1
expr_stmt|;
name|split
operator|->
name|dupno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old
operator|->
name|insn_code_number
operator|>=
literal|0
operator|&&
name|add
operator|->
name|insn_code_number
operator|>=
literal|0
condition|)
block|{
comment|/* If one node is for a normal insn and the second is 		     for the base insn with clobbers stripped off, the 		     second node should be ignored.  */
if|if
condition|(
name|old
operator|->
name|num_clobbers_to_add
operator|==
literal|0
operator|&&
name|add
operator|->
name|num_clobbers_to_add
operator|>
literal|0
condition|)
comment|/* Nothing to do here.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|old
operator|->
name|num_clobbers_to_add
operator|>
literal|0
operator|&&
name|add
operator|->
name|num_clobbers_to_add
operator|==
literal|0
condition|)
block|{
comment|/* In this case, replace OLD with ADD.  */
name|old
operator|->
name|insn_code_number
operator|=
name|add
operator|->
name|insn_code_number
expr_stmt|;
name|old
operator|->
name|num_clobbers_to_add
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"Two actions at one point in tree for insns \"%s\" (%d) and \"%s\" (%d)"
argument_list|,
name|insn_name_ptr
index|[
name|old
operator|->
name|insn_code_number
index|]
argument_list|,
name|old
operator|->
name|insn_code_number
argument_list|,
name|insn_name_ptr
index|[
name|add
operator|->
name|insn_code_number
index|]
argument_list|,
name|add
operator|->
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old
operator|->
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|old
operator|->
name|insn_code_number
operator|=
name|add
operator|->
name|insn_code_number
expr_stmt|;
name|old
operator|->
name|success
operator|=
name|merge_trees
argument_list|(
name|old
operator|->
name|success
argument_list|,
name|add
operator|->
name|success
argument_list|)
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Unless we have already found the best possible insert point, 	     see if this position is better.  If so, record it.  */
if|if
condition|(
name|best_merit
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|our_merit
operator|=
name|position_merit
argument_list|(
name|old
argument_list|,
name|add_mode
argument_list|,
name|add
operator|->
name|code
argument_list|)
operator|)
operator|<
name|best_merit
operator|)
condition|)
name|best_merit
operator|=
name|our_merit
operator|,
name|best_position
operator|=
name|old
expr_stmt|;
if|if
condition|(
operator|!
name|not_both_true
argument_list|(
name|old
argument_list|,
name|add
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
comment|/* If ADD was duplicate, we are done.  */
if|if
condition|(
name|add
operator|==
literal|0
condition|)
continue|continue;
comment|/* Otherwise, find the best place to insert ADD.  Normally this is 	 BEST_POSITION.  However, if we went all the way to the top of 	 the list, it might be better to insert at the top.  */
if|if
condition|(
name|best_position
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
operator|&&
name|position_merit
argument_list|(
name|NULL_PTR
argument_list|,
name|add_mode
argument_list|,
name|add
operator|->
name|code
argument_list|)
operator|<
name|best_merit
condition|)
block|{
name|add
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|add
operator|->
name|next
operator|=
name|oldh
operator|.
name|first
expr_stmt|;
name|oldh
operator|.
name|first
operator|->
name|prev
operator|=
name|add
expr_stmt|;
name|oldh
operator|.
name|first
operator|=
name|add
expr_stmt|;
block|}
else|else
block|{
name|add
operator|->
name|prev
operator|=
name|best_position
expr_stmt|;
name|add
operator|->
name|next
operator|=
name|best_position
operator|->
name|next
expr_stmt|;
name|best_position
operator|->
name|next
operator|=
name|add
expr_stmt|;
if|if
condition|(
name|best_position
operator|==
name|oldh
operator|.
name|last
condition|)
name|oldh
operator|.
name|last
operator|=
name|add
expr_stmt|;
else|else
name|add
operator|->
name|next
operator|->
name|prev
operator|=
name|add
expr_stmt|;
block|}
block|}
return|return
name|oldh
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count the number of subnodes of HEAD.  If the number is high enough,    make the first node in HEAD start a separate subroutine in the C code    that is generated.     TYPE gives the type of routine we are writing.     INITIAL is non-zero if this is the highest-level node.  We never write    it out here.  */
end_comment

begin_function
specifier|static
name|int
name|break_out_subroutines
parameter_list|(
name|head
parameter_list|,
name|type
parameter_list|,
name|initial
parameter_list|)
name|struct
name|decision_head
name|head
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
name|int
name|initial
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|struct
name|decision
modifier|*
name|sub
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|head
operator|.
name|first
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|size
operator|+=
literal|1
operator|+
name|break_out_subroutines
argument_list|(
name|sub
operator|->
name|success
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|SUBROUTINE_THRESHOLD
operator|&&
operator|!
name|initial
condition|)
block|{
name|head
operator|.
name|first
operator|->
name|subroutine_number
operator|=
operator|++
name|next_subroutine_number
expr_stmt|;
name|write_subroutine
argument_list|(
name|head
operator|.
name|first
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a subroutine of type TYPE to do comparisons starting at node    TREE.  */
end_comment

begin_function
specifier|static
name|void
name|write_subroutine
parameter_list|(
name|tree
parameter_list|,
name|type
parameter_list|)
name|struct
name|decision
modifier|*
name|tree
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SPLIT
condition|)
name|printf
argument_list|(
literal|"rtx\nsplit"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"int\nrecog"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|!=
literal|0
operator|&&
name|tree
operator|->
name|subroutine_number
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"_%d"
argument_list|,
name|tree
operator|->
name|subroutine_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SPLIT
condition|)
name|printf
argument_list|(
literal|"_insns"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (x0, insn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RECOG
condition|)
name|printf
argument_list|(
literal|", pnum_clobbers"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     register rtx x0;\n     rtx insn ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RECOG
condition|)
name|printf
argument_list|(
literal|"     int *pnum_clobbers ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  register rtx *ro =&recog_operand[0];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  register rtx "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max_depth
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"x%d ATTRIBUTE_UNUSED, "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x%d ATTRIBUTE_UNUSED;\n"
argument_list|,
name|max_depth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %s tem ATTRIBUTE_UNUSED;\n"
argument_list|,
name|type
operator|==
name|SPLIT
condition|?
literal|"rtx"
else|:
literal|"int"
argument_list|)
expr_stmt|;
name|write_tree
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ret0: return %d;\n}\n\n"
argument_list|,
name|type
operator|==
name|SPLIT
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This table is used to indent the recog_* functions when we are inside    conditions or switch statements.  We only support small indentations    and always indent at least two spaces.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|indents
index|[]
init|=
block|{
literal|"  "
block|,
literal|"  "
block|,
literal|"  "
block|,
literal|"   "
block|,
literal|"    "
block|,
literal|"     "
block|,
literal|"      "
block|,
literal|"       "
block|,
literal|"\t"
block|,
literal|"\t "
block|,
literal|"\t  "
block|,
literal|"\t   "
block|,
literal|"\t    "
block|,
literal|"\t     "
block|,
literal|"\t      "
block|,
literal|"\t\t"
block|,
literal|"\t\t "
block|,
literal|"\t\t  "
block|,
literal|"\t\t   "
block|,
literal|"\t\t    "
block|,
literal|"\t\t     "
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write out C code to perform the decisions in TREE for a subroutine of    type TYPE.  If all of the choices fail, branch to node AFTERWARD, if    non-zero, otherwise return.  PREVPOS is the position of the node that    branched to this test.     When we merged all alternatives, we tried to set up a convenient order.    Specifically, tests involving the same mode are all grouped together,    followed by a group that does not contain a mode test.  Within each group    of the same mode, we also group tests with the same code, followed by a    group that does not test a code.     Occasionally, we cannot arbitrarily reorder the tests so that multiple    sequence of groups as described above are present.     We generate two nested switch statements, the outer statement for    testing modes, and the inner switch for testing RTX codes.  It is    not worth optimizing cases when only a small number of modes or     codes is tested, since the compiler can do that when compiling the    resulting function.   We do check for when every test is the same mode    or code.  */
end_comment

begin_function
specifier|static
name|void
name|write_tree_1
parameter_list|(
name|tree
parameter_list|,
name|prevpos
parameter_list|,
name|afterward
parameter_list|,
name|type
parameter_list|)
name|struct
name|decision
modifier|*
name|tree
decl_stmt|;
specifier|const
name|char
modifier|*
name|prevpos
decl_stmt|;
name|struct
name|decision
modifier|*
name|afterward
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|depth
init|=
name|tree
condition|?
name|strlen
argument_list|(
name|tree
operator|->
name|position
argument_list|)
else|:
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|switch_mode
init|=
name|VOIDmode
decl_stmt|;
name|RTX_CODE
name|switch_code
init|=
name|UNKNOWN
decl_stmt|;
name|int
name|uncond
init|=
literal|0
decl_stmt|;
name|char
name|modemap
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
name|char
name|codemap
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
name|int
name|indent
init|=
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* One tricky area is what is the exact state when we branch to a      node's label.  There are two cases where we branch: when looking at      successors to a node, or when a set of tests fails.       In the former case, we are always branching to the first node in a      decision list and we want all required tests to be performed.  We      put the labels for such nodes in front of any switch or test statements.      These branches are done without updating the position to that of the      target node.       In the latter case, we are branching to a node that is not the first      node in a decision list.  We have already checked that it is possible      for both the node we originally tested at this level and the node we      are branching to to both match some pattern.  That means that they      usually will be testing the same mode and code.  So it is normally safe      for such labels to be inside switch statements, since the tests done      by virtue of arriving at that label will usually already have been      done.  The exception is a branch from a node that does not test a      mode or code to one that does.  In such cases, we set the `retest_mode'      or `retest_code' flags.  That will ensure that we start a new switch      at that position and put the label before the switch.        The branches in the latter case must set the position to that of the      target node.  */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|&&
name|tree
operator|->
name|subroutine_number
operator|==
literal|0
condition|)
block|{
name|OUTPUT_LABEL
argument_list|(
literal|"  "
argument_list|,
name|tree
operator|->
name|number
argument_list|)
expr_stmt|;
name|tree
operator|->
name|label_needed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tree
condition|)
block|{
name|change_state
argument_list|(
name|prevpos
argument_list|,
name|tree
operator|->
name|position
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|prevpos
operator|=
name|tree
operator|->
name|position
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|tree
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|p
operator|->
name|enforce_mode
condition|?
name|p
operator|->
name|mode
else|:
name|VOIDmode
decl_stmt|;
name|int
name|need_bracket
decl_stmt|;
name|int
name|wrote_bracket
init|=
literal|0
decl_stmt|;
name|int
name|inner_indent
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|success
operator|.
name|first
operator|==
literal|0
operator|&&
name|p
operator|->
name|insn_code_number
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the next alternative to p that might be true when p is true. 	 Test that one next if p's successors fail.  */
for|for
control|(
name|p1
operator|=
name|p
operator|->
name|next
init|;
name|p1
operator|&&
name|not_both_true
argument_list|(
name|p
argument_list|,
name|p1
argument_list|,
literal|1
argument_list|)
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|afterward
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|p1
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
name|p1
operator|->
name|enforce_mode
operator|&&
name|p1
operator|->
name|mode
operator|!=
name|VOIDmode
condition|)
name|p1
operator|->
name|retest_mode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|code
operator|==
name|UNKNOWN
operator|&&
name|p1
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|p1
operator|->
name|retest_code
operator|=
literal|1
expr_stmt|;
name|p1
operator|->
name|label_needed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we have a different code or mode than the last node and 	 are in a switch on codes, we must either end the switch or 	 go to another case.  We must also end the switch if this 	 node needs a label and to retest either the mode or code.  */
if|if
condition|(
name|switch_code
operator|!=
name|UNKNOWN
operator|&&
operator|(
name|switch_code
operator|!=
name|p
operator|->
name|code
operator|||
name|switch_mode
operator|!=
name|mode
operator|||
operator|(
name|p
operator|->
name|label_needed
operator|&&
operator|(
name|p
operator|->
name|retest_mode
operator|||
name|p
operator|->
name|retest_code
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|p
operator|->
name|code
decl_stmt|;
comment|/* If P is testing a predicate that we know about and we haven't 	     seen any of the codes that are valid for the predicate, we 	     can write a series of "case" statement, one for each possible 	     code.  Since we are already in a switch, these redundant tests 	     are very cheap and will reduce the number of predicate called.  */
if|if
condition|(
name|p
operator|->
name|pred
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
operator|&&
name|preds
index|[
name|p
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|codemap
index|[
operator|(
name|int
operator|)
name|preds
index|[
name|p
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
index|]
condition|)
break|break;
if|if
condition|(
name|preds
index|[
name|p
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|code
operator|=
name|MATCH_OPERAND
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|UNKNOWN
operator|||
name|codemap
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|||
name|switch_mode
operator|!=
name|mode
operator|||
operator|(
name|p
operator|->
name|label_needed
operator|&&
operator|(
name|p
operator|->
name|retest_mode
operator|||
name|p
operator|->
name|retest_code
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s}\n"
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|switch_code
operator|=
name|UNKNOWN
expr_stmt|;
name|indent
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|uncond
condition|)
name|printf
argument_list|(
literal|"%sbreak;\n"
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
operator|&&
name|preds
index|[
name|p
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%scase "
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|preds
index|[
name|p
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|codemap
index|[
operator|(
name|int
operator|)
name|preds
index|[
name|p
operator|->
name|pred
index|]
operator|.
name|codes
index|[
name|i
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%scase "
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|codemap
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|switch_code
operator|=
name|code
expr_stmt|;
block|}
name|uncond
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we were previously in a switch on modes and now have a different 	 mode, end at least the case, and maybe end the switch if we are 	 not testing a mode or testing a mode whose case we already saw.  */
if|if
condition|(
name|switch_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
name|switch_mode
operator|!=
name|mode
operator|||
operator|(
name|p
operator|->
name|label_needed
operator|&&
name|p
operator|->
name|retest_mode
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|modemap
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|||
operator|(
name|p
operator|->
name|label_needed
operator|&&
name|p
operator|->
name|retest_mode
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s}\n"
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|switch_mode
operator|=
name|VOIDmode
expr_stmt|;
name|indent
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|uncond
condition|)
name|printf
argument_list|(
literal|"      break;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    case %smode:\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|switch_mode
operator|=
name|mode
expr_stmt|;
name|modemap
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|uncond
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we are about to write dead code, something went wrong.  */
if|if
condition|(
operator|!
name|p
operator|->
name|label_needed
operator|&&
name|uncond
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we need a label and we will want to retest the mode or code at 	 that label, write the label now.  We have already ensured that 	 things will be valid for the test.  */
if|if
condition|(
name|p
operator|->
name|label_needed
operator|&&
operator|(
name|p
operator|->
name|retest_mode
operator|||
name|p
operator|->
name|retest_code
operator|)
condition|)
block|{
name|OUTPUT_LABEL
argument_list|(
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|,
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
name|p
operator|->
name|label_needed
operator|=
literal|0
expr_stmt|;
block|}
name|uncond
operator|=
literal|0
expr_stmt|;
comment|/* If we are not in any switches, see if we can shortcut things 	 by checking for identical modes and codes.  */
if|if
condition|(
name|switch_mode
operator|==
name|VOIDmode
operator|&&
name|switch_code
operator|==
name|UNKNOWN
condition|)
block|{
comment|/* If p and its alternatives all want the same mode, 	     reject all others at once, first, then ignore the mode.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|p
operator|->
name|next
operator|&&
name|same_modes
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  if (GET_MODE (x%d) != %smode)\n"
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
block|{
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|change_state
argument_list|(
name|p
operator|->
name|position
argument_list|,
name|afterward
operator|->
name|position
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      goto L%d;\n    }\n"
argument_list|,
name|afterward
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"    goto ret0;\n"
argument_list|)
expr_stmt|;
name|clear_modes
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* If p and its alternatives all want the same code, 	     reject all others at once, first, then ignore the code.  */
if|if
condition|(
name|p
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
name|p
operator|->
name|next
operator|&&
name|same_codes
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  if (GET_CODE (x%d) != "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|p
operator|->
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
block|{
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|change_state
argument_list|(
name|p
operator|->
name|position
argument_list|,
name|afterward
operator|->
name|position
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    goto L%d;\n    }\n"
argument_list|,
name|afterward
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"    goto ret0;\n"
argument_list|)
expr_stmt|;
name|clear_codes
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are not in a mode switch and we are testing for a specific 	 mode, start a mode switch unless we have just one node or the next 	 node is not testing a mode (we have already tested for the case of 	 more than one mode, but all of the same mode).  */
if|if
condition|(
name|switch_mode
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|p
operator|->
name|next
operator|!=
literal|0
operator|&&
name|p
operator|->
name|next
operator|->
name|enforce_mode
operator|&&
name|p
operator|->
name|next
operator|->
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
name|memset
argument_list|(
name|modemap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|modemap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sswitch (GET_MODE (x%d))\n"
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s{\n"
argument_list|,
name|indents
index|[
name|indent
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"%sdefault:\n%sbreak;\n"
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%scase %smode:\n"
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|modemap
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|switch_mode
operator|=
name|mode
expr_stmt|;
block|}
comment|/* Similarly for testing codes.  */
if|if
condition|(
name|switch_code
operator|==
name|UNKNOWN
operator|&&
name|p
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
operator|!
name|p
operator|->
name|ignore_code
operator|&&
name|p
operator|->
name|next
operator|!=
literal|0
operator|&&
name|p
operator|->
name|next
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
block|{
name|memset
argument_list|(
name|codemap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|codemap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sswitch (GET_CODE (x%d))\n"
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s{\n"
argument_list|,
name|indents
index|[
name|indent
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"%sdefault:\n%sbreak;\n"
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%scase "
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|p
operator|->
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|codemap
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|switch_code
operator|=
name|p
operator|->
name|code
expr_stmt|;
block|}
comment|/* Now that most mode and code tests have been done, we can write out 	 a label for an inner node, if we haven't already.  */
if|if
condition|(
name|p
operator|->
name|label_needed
condition|)
name|OUTPUT_LABEL
argument_list|(
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|,
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
name|inner_indent
operator|=
name|indent
expr_stmt|;
comment|/* The only way we can have to do a mode or code test here is if 	 this node needs such a test but is the only node to be tested. 	 In that case, we won't have started a switch.  Note that this is 	 the only way the switch and test modes can disagree.  */
if|if
condition|(
operator|(
name|mode
operator|!=
name|switch_mode
operator|&&
operator|!
name|p
operator|->
name|ignore_mode
operator|)
operator|||
operator|(
name|p
operator|->
name|code
operator|!=
name|switch_code
operator|&&
name|p
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
operator|!
name|p
operator|->
name|ignore_code
operator|)
operator|||
name|p
operator|->
name|test_elt_zero_int
operator|||
name|p
operator|->
name|test_elt_one_int
operator|||
name|p
operator|->
name|test_elt_zero_wide
operator|||
name|p
operator|->
name|veclen
operator|||
name|p
operator|->
name|dupno
operator|>=
literal|0
operator|||
name|p
operator|->
name|tests
operator|||
name|p
operator|->
name|num_clobbers_to_add
condition|)
block|{
name|printf
argument_list|(
literal|"%sif ("
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|switch_mode
operator|&&
operator|!
name|p
operator|->
name|ignore_mode
condition|)
name|printf
argument_list|(
literal|"GET_MODE (x%d) == %smode&& "
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|code
operator|!=
name|switch_code
operator|&&
name|p
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
operator|!
name|p
operator|->
name|ignore_code
condition|)
block|{
name|printf
argument_list|(
literal|"GET_CODE (x%d) == "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|p
operator|->
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|test_elt_zero_int
condition|)
name|printf
argument_list|(
literal|"XINT (x%d, 0) == %d&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|elt_zero_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|test_elt_one_int
condition|)
name|printf
argument_list|(
literal|"XINT (x%d, 1) == %d&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|elt_one_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|test_elt_zero_wide
condition|)
block|{
comment|/* Set offset to 1 iff the number might get propagated to 	         unsigned long by ANSI C rules, else 0. 	         Prospective hosts are required to have at least 32 bit 	         ints, and integer constants in machine descriptions 	         must fit in 32 bit, thus it suffices to check only 	         for 1<< 31 .  */
name|HOST_WIDE_INT
name|offset
init|=
name|p
operator|->
name|elt_zero_wide
operator|==
operator|-
literal|2147483647
operator|-
literal|1
decl_stmt|;
name|printf
argument_list|(
literal|"XWINT (x%d, 0) == "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|p
operator|->
name|elt_zero_wide
operator|+
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s&& "
argument_list|,
name|offset
condition|?
literal|"-1"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|veclen
condition|)
name|printf
argument_list|(
literal|"XVECLEN (x%d, 0) == %d&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|veclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dupno
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"rtx_equal_p (x%d, ro[%d])&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|dupno
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|num_clobbers_to_add
condition|)
name|printf
argument_list|(
literal|"pnum_clobbers != 0&& "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tests
condition|)
name|printf
argument_list|(
literal|"%s (x%d, %smode)"
argument_list|,
name|p
operator|->
name|tests
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|inner_indent
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|uncond
operator|=
literal|1
expr_stmt|;
name|need_bracket
operator|=
operator|!
name|uncond
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opno
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|need_bracket
condition|)
block|{
name|printf
argument_list|(
literal|"%s{\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|)
expr_stmt|;
name|inner_indent
operator|+=
literal|2
expr_stmt|;
name|wrote_bracket
operator|=
literal|1
expr_stmt|;
name|need_bracket
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%sro[%d] = x%d;\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|,
name|p
operator|->
name|opno
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|c_test
condition|)
block|{
name|printf
argument_list|(
literal|"%sif (%s)\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|,
name|p
operator|->
name|c_test
argument_list|)
expr_stmt|;
name|inner_indent
operator|+=
literal|2
expr_stmt|;
name|uncond
operator|=
literal|0
expr_stmt|;
name|need_bracket
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|insn_code_number
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|SPLIT
condition|)
name|printf
argument_list|(
literal|"%sreturn gen_split_%d (operands);\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|,
name|p
operator|->
name|insn_code_number
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|num_clobbers_to_add
condition|)
block|{
if|if
condition|(
name|need_bracket
condition|)
block|{
name|printf
argument_list|(
literal|"%s{\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|)
expr_stmt|;
name|inner_indent
operator|+=
literal|2
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s*pnum_clobbers = %d;\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|,
name|p
operator|->
name|num_clobbers_to_add
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sreturn %d;\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|,
name|p
operator|->
name|insn_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_bracket
condition|)
block|{
name|inner_indent
operator|-=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%s}\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"%sreturn %d;\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|,
name|p
operator|->
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"%sgoto L%d;\n"
argument_list|,
name|indents
index|[
name|inner_indent
index|]
argument_list|,
name|p
operator|->
name|success
operator|.
name|first
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote_bracket
condition|)
name|printf
argument_list|(
literal|"%s}\n"
argument_list|,
name|indents
index|[
name|inner_indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* We have now tested all alternatives.  End any switches we have open      and branch to the alternative node unless we know that we can't fall      through to the branch.  */
if|if
condition|(
name|switch_code
operator|!=
name|UNKNOWN
condition|)
block|{
name|printf
argument_list|(
literal|"%s}\n"
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|4
expr_stmt|;
name|uncond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|switch_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|printf
argument_list|(
literal|"%s}\n"
argument_list|,
name|indents
index|[
name|indent
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|4
expr_stmt|;
name|uncond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|indent
operator|!=
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|uncond
condition|)
return|return;
if|if
condition|(
name|afterward
condition|)
block|{
name|change_state
argument_list|(
name|prevpos
argument_list|,
name|afterward
operator|->
name|position
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  goto L%d;\n"
argument_list|,
name|afterward
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  goto ret0;\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|>=
literal|'a'
operator|&&
operator|*
name|p1
operator|<=
literal|'z'
condition|)
name|putchar
argument_list|(
operator|*
name|p1
operator|+
literal|'A'
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|same_codes
parameter_list|(
name|p
parameter_list|,
name|code
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|code
operator|!=
name|code
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_codes
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|ignore_code
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|same_modes
parameter_list|(
name|p
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|p
operator|->
name|enforce_mode
condition|?
name|p
operator|->
name|mode
else|:
name|VOIDmode
operator|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_modes
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|enforce_mode
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out the decision tree starting at TREE for a subroutine of type TYPE.     PREVPOS is the position at the node that branched to this node.     INITIAL is nonzero if this is the first node we are writing in a subroutine.     If all nodes are false, branch to the node AFTERWARD.  */
end_comment

begin_function
specifier|static
name|void
name|write_tree
parameter_list|(
name|tree
parameter_list|,
name|prevpos
parameter_list|,
name|afterward
parameter_list|,
name|initial
parameter_list|,
name|type
parameter_list|)
name|struct
name|decision
modifier|*
name|tree
decl_stmt|;
specifier|const
name|char
modifier|*
name|prevpos
decl_stmt|;
name|struct
name|decision
modifier|*
name|afterward
decl_stmt|;
name|int
name|initial
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_prefix
init|=
operator|(
name|type
operator|==
name|SPLIT
condition|?
literal|"split"
else|:
literal|"recog"
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|call_suffix
init|=
operator|(
name|type
operator|==
name|SPLIT
condition|?
literal|""
else|:
literal|", pnum_clobbers"
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|initial
operator|&&
name|tree
operator|->
name|subroutine_number
operator|>
literal|0
condition|)
block|{
name|OUTPUT_LABEL
argument_list|(
literal|" "
argument_list|,
name|tree
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
block|{
name|printf
argument_list|(
literal|"  tem = %s_%d (x0, insn%s);\n"
argument_list|,
name|name_prefix
argument_list|,
name|tree
operator|->
name|subroutine_number
argument_list|,
name|call_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SPLIT
condition|)
name|printf
argument_list|(
literal|"  if (tem != 0) return tem;\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  if (tem>= 0) return tem;\n"
argument_list|)
expr_stmt|;
name|change_state
argument_list|(
name|tree
operator|->
name|position
argument_list|,
name|afterward
operator|->
name|position
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  goto L%d;\n"
argument_list|,
name|afterward
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  return %s_%d (x0, insn%s);\n"
argument_list|,
name|name_prefix
argument_list|,
name|tree
operator|->
name|subroutine_number
argument_list|,
name|call_suffix
argument_list|)
expr_stmt|;
return|return;
block|}
name|write_tree_1
argument_list|(
name|tree
argument_list|,
name|prevpos
argument_list|,
name|afterward
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tree
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|success
operator|.
name|first
condition|)
name|write_tree
argument_list|(
name|p
operator|->
name|success
operator|.
name|first
argument_list|,
name|p
operator|->
name|position
argument_list|,
name|p
operator|->
name|afterward
condition|?
name|p
operator|->
name|afterward
else|:
name|afterward
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming that the state of argument is denoted by OLDPOS, take whatever    actions are necessary to move to NEWPOS.     INDENT says how many blanks to place at the front of lines.  */
end_comment

begin_function
specifier|static
name|void
name|change_state
parameter_list|(
name|oldpos
parameter_list|,
name|newpos
parameter_list|,
name|indent
parameter_list|)
specifier|const
name|char
modifier|*
name|oldpos
decl_stmt|;
specifier|const
name|char
modifier|*
name|newpos
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|int
name|odepth
init|=
name|strlen
argument_list|(
name|oldpos
argument_list|)
decl_stmt|;
name|int
name|depth
init|=
name|odepth
decl_stmt|;
name|int
name|ndepth
init|=
name|strlen
argument_list|(
name|newpos
argument_list|)
decl_stmt|;
comment|/* Pop up as many levels as necessary.  */
while|while
condition|(
name|strncmp
argument_list|(
name|oldpos
argument_list|,
name|newpos
argument_list|,
name|depth
argument_list|)
condition|)
operator|--
name|depth
expr_stmt|;
comment|/* Go down to desired level.  */
while|while
condition|(
name|depth
operator|<
name|ndepth
condition|)
block|{
if|if
condition|(
name|newpos
index|[
name|depth
index|]
operator|>=
literal|'a'
operator|&&
name|newpos
index|[
name|depth
index|]
operator|<=
literal|'z'
condition|)
name|printf
argument_list|(
literal|"%sx%d = XVECEXP (x%d, 0, %d);\n"
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
argument_list|,
name|newpos
index|[
name|depth
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%sx%d = XEXP (x%d, %c);\n"
argument_list|,
name|indents
index|[
name|indent
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
argument_list|,
name|newpos
index|[
name|depth
index|]
argument_list|)
expr_stmt|;
operator|++
name|depth
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|input
parameter_list|)
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
block|{
specifier|register
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genrecog: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"after %d definitions\n"
argument_list|,
name|next_index
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|struct
name|decision_head
name|recog_tree
decl_stmt|;
name|struct
name|decision_head
name|split_tree
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|recog_tree
operator|.
name|first
operator|=
name|recog_tree
operator|.
name|last
operator|=
name|split_tree
operator|.
name|first
operator|=
name|split_tree
operator|.
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|next_insn_code
operator|=
literal|0
expr_stmt|;
name|next_index
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genrecog'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|recog_tree
operator|=
name|merge_trees
argument_list|(
name|recog_tree
argument_list|,
name|make_insn_sequence
argument_list|(
name|desc
argument_list|,
name|RECOG
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
name|split_tree
operator|=
name|merge_trees
argument_list|(
name|split_tree
argument_list|,
name|make_insn_sequence
argument_list|(
name|desc
argument_list|,
name|SPLIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|next_insn_code
operator|++
expr_stmt|;
name|next_index
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\ /* `recog' contains a decision tree\n\    that recognizes whether the rtx X0 is a valid instruction.\n\ \n\    recog returns -1 if the rtx is not valid.\n\    If the rtx is valid, recog returns a nonnegative number\n\    which is the insn code number for the pattern that matched.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   This is the same as the order in the machine description of\n\    the entry that matched.  This number can be used as an index into various\n\    insn_* tables, such as insn_templates, insn_outfun, and insn_n_operands\n\    (found in insn-output.c).\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   The third argument to recog is an optional pointer to an int.\n\    If present, recog will accept a pattern if it matches except for\n\    missing CLOBBER expressions at the end.  In that case, the value\n\    pointed to by the optional pointer will be set to the number of\n\    CLOBBERs that need to be added (it should be initialized to zero by\n\    the caller).  If it is set nonzero, the caller should allocate a\n\    PARALLEL of the appropriate size, copy the initial entries, and call\n\    add_clobbers (found in insn-emit.c) to fill in the CLOBBERs."
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_tree
operator|.
name|first
condition|)
name|printf
argument_list|(
literal|"\n\n   The function split_insns returns 0 if the rtl could not\n\    be split or the split rtl in a SEQUENCE if it can be."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*/\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands recog_operand\n\n"
argument_list|)
expr_stmt|;
name|next_subroutine_number
operator|=
literal|0
expr_stmt|;
name|break_out_subroutines
argument_list|(
name|recog_tree
argument_list|,
name|RECOG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_subroutine
argument_list|(
name|recog_tree
operator|.
name|first
argument_list|,
name|RECOG
argument_list|)
expr_stmt|;
name|next_subroutine_number
operator|=
literal|0
expr_stmt|;
name|break_out_subroutines
argument_list|(
name|split_tree
argument_list|,
name|SPLIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_subroutine
argument_list|(
name|split_tree
operator|.
name|first
argument_list|,
name|SPLIT
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

