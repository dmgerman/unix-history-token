begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to recognize rtl as insns.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This program is used to produce insn-recog.c, which contains a    function called `recog' plus its subroutines.  These functions    contain a decision tree that recognizes whether an rtx, the    argument given to recog, is a valid instruction.     recog returns -1 if the rtx is not valid.  If the rtx is valid,    recog returns a nonnegative number which is the insn code number    for the pattern that matched.  This is the same as the order in the    machine description of the entry that matched.  This number can be    used as an index into various insn_* tables, such as insn_template,    insn_outfun, and insn_n_operands (found in insn-output.c).     The third argument to recog is an optional pointer to an int.  If    present, recog will accept a pattern if it matches except for    missing CLOBBER expressions at the end.  In that case, the value    pointed to by the optional pointer will be set to the number of    CLOBBERs that need to be added (it should be initialized to zero by    the caller).  If it is set nonzero, the caller should allocate a    PARALLEL of the appropriate size, copy the initial entries, and    call add_clobbers (found in insn-emit.c) to fill in the CLOBBERs.     This program also generates the function `split_insns', which    returns 0 if the rtl could not be split, or it returns the split    rtl in a SEQUENCE.     This program also generates the function `peephole2_insns', which    returns 0 if the rtl could not be matched.  If there was a match,    the new rtl is returned in a SEQUENCE, and LAST_INSN will point    to the last recognized insn in the old sequence.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_define
define|#
directive|define
name|OUTPUT_LABEL
parameter_list|(
name|INDENT_STRING
parameter_list|,
name|LABEL_NUMBER
parameter_list|)
define|\
value|printf("%sL%d: ATTRIBUTE_UNUSED_LABEL\n", (INDENT_STRING), (LABEL_NUMBER))
end_define

begin_comment
comment|/* Holds an array of names indexed by insn_code_number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_name_ptr_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A listhead of decision trees.  The alternatives to a node are kept    in a doublely-linked list so we can easily add nodes to the proper    place when merging.  */
end_comment

begin_struct
struct|struct
name|decision_head
block|{
name|struct
name|decision
modifier|*
name|first
decl_stmt|;
name|struct
name|decision
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A single test.  The two accept types aren't tests per-se, but    their equality (or lack thereof) does affect tree merging so    it is convenient to keep them here.  */
end_comment

begin_struct
struct|struct
name|decision_test
block|{
comment|/* A linked list through the tests attached to a node.  */
name|struct
name|decision_test
modifier|*
name|next
decl_stmt|;
comment|/* These types are roughly in the order in which we'd like to test them.  */
enum|enum
name|decision_type
block|{
name|DT_mode
block|,
name|DT_code
block|,
name|DT_veclen
block|,
name|DT_elt_zero_int
block|,
name|DT_elt_one_int
block|,
name|DT_elt_zero_wide
block|,
name|DT_elt_zero_wide_safe
block|,
name|DT_veclen_ge
block|,
name|DT_dup
block|,
name|DT_pred
block|,
name|DT_c_test
block|,
name|DT_accept_op
block|,
name|DT_accept_insn
block|}
name|type
enum|;
union|union
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Machine mode of node.  */
name|RTX_CODE
name|code
decl_stmt|;
comment|/* Code to test.  */
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Predicate to call.  */
name|int
name|index
decl_stmt|;
comment|/* Index into `preds' or -1.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Machine mode for node.  */
block|}
name|pred
struct|;
specifier|const
name|char
modifier|*
name|c_test
decl_stmt|;
comment|/* Additional test to perform.  */
name|int
name|veclen
decl_stmt|;
comment|/* Length of vector.  */
name|int
name|dup
decl_stmt|;
comment|/* Number of operand to compare against.  */
name|HOST_WIDE_INT
name|intval
decl_stmt|;
comment|/* Value for XINT for XWINT.  */
name|int
name|opno
decl_stmt|;
comment|/* Operand number matched.  */
struct|struct
block|{
name|int
name|code_number
decl_stmt|;
comment|/* Insn number matched.  */
name|int
name|lineno
decl_stmt|;
comment|/* Line number of the insn.  */
name|int
name|num_clobbers_to_add
decl_stmt|;
comment|/* Number of CLOBBERs to be added.  */
block|}
name|insn
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Data structure for decision tree for recognizing legitimate insns.  */
end_comment

begin_struct
struct|struct
name|decision
block|{
name|struct
name|decision_head
name|success
decl_stmt|;
comment|/* Nodes to test on success.  */
name|struct
name|decision
modifier|*
name|next
decl_stmt|;
comment|/* Node to test on failure.  */
name|struct
name|decision
modifier|*
name|prev
decl_stmt|;
comment|/* Node whose failure tests us.  */
name|struct
name|decision
modifier|*
name|afterward
decl_stmt|;
comment|/* Node to test on success, 				   but failure of successor nodes.  */
specifier|const
name|char
modifier|*
name|position
decl_stmt|;
comment|/* String denoting position in pattern.  */
name|struct
name|decision_test
modifier|*
name|tests
decl_stmt|;
comment|/* The tests for this node.  */
name|int
name|number
decl_stmt|;
comment|/* Node number, used for labels */
name|int
name|subroutine_number
decl_stmt|;
comment|/* Number of subroutine this node starts */
name|int
name|need_label
decl_stmt|;
comment|/* Label needs to be output.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SUBROUTINE_THRESHOLD
value|100
end_define

begin_decl_stmt
specifier|static
name|int
name|next_subroutine_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We can write three types of subroutines: One for insn recognition,    one to split insns, and one for peephole-type optimizations.  This    defines which type is being written.  */
end_comment

begin_enum
enum|enum
name|routine_type
block|{
name|RECOG
block|,
name|SPLIT
block|,
name|PEEPHOLE2
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IS_SPLIT
parameter_list|(
name|X
parameter_list|)
value|((X) != RECOG)
end_define

begin_comment
comment|/* Next available node number for tree nodes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next number to use as an insn_code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_insn_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but counts all expressions in the MD file; used for    error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the highest depth we ever have so we know how many variables to    allocate in each subroutine we make.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line number of the start of the pattern currently being processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pattern_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of errors.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error_count
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This table contains a list of the rtl codes that can possibly match a    predicate defined in recog.c.  The function `maybe_both_true' uses it to    deduce that there are no expressions that can be matches by certain pairs    of tree nodes.  Also, if a predicate can match only one code, we can    hardwire that code into the node testing the predicate.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|pred_table
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|RTX_CODE
name|codes
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
block|}
name|preds
index|[]
init|=
block|{
block|{
literal|"general_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|PREDICATE_CODES
name|PREDICATE_CODES
endif|#
directive|endif
block|{
literal|"address_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|,
name|PLUS
block|,
name|MINUS
block|,
name|MULT
block|}
block|}
block|,
block|{
literal|"register_operand"
block|,
block|{
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"pmode_register_operand"
block|,
block|{
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"scratch_operand"
block|,
block|{
name|SCRATCH
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"immediate_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|}
block|}
block|,
block|{
literal|"const_int_operand"
block|,
block|{
name|CONST_INT
block|}
block|}
block|,
block|{
literal|"const_double_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|}
block|}
block|,
block|{
literal|"nonimmediate_operand"
block|,
block|{
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"nonmemory_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"push_operand"
block|,
block|{
name|MEM
block|}
block|}
block|,
block|{
literal|"pop_operand"
block|,
block|{
name|MEM
block|}
block|}
block|,
block|{
literal|"memory_operand"
block|,
block|{
name|SUBREG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"indirect_operand"
block|,
block|{
name|SUBREG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"comparison_operator"
block|,
block|{
name|EQ
block|,
name|NE
block|,
name|LE
block|,
name|LT
block|,
name|GE
block|,
name|GT
block|,
name|LEU
block|,
name|LTU
block|,
name|GEU
block|,
name|GTU
block|,
name|UNORDERED
block|,
name|ORDERED
block|,
name|UNEQ
block|,
name|UNGE
block|,
name|UNGT
block|,
name|UNLE
block|,
name|UNLT
block|,
name|LTGT
block|}
block|}
block|,
block|{
literal|"mode_independent_operand"
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_KNOWN_PREDS
value|ARRAY_SIZE (preds)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special_mode_pred_table
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SPECIAL_MODE_PREDICATES
name|SPECIAL_MODE_PREDICATES
endif|#
directive|endif
literal|"pmode_register_operand"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_SPECIAL_MODE_PREDS
value|ARRAY_SIZE (special_mode_pred_table)
end_define

begin_decl_stmt
specifier|static
name|struct
name|decision
modifier|*
name|new_decision
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|decision_head
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|decision_test
modifier|*
name|new_decision_test
name|PARAMS
argument_list|(
operator|(
expr|enum
name|decision_type
operator|,
expr|struct
name|decision_test
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_matching_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_pattern
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|decision
modifier|*
name|add_to_sequence
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|decision_head
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|routine_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_both_true_mode
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_both_true_2
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_test
operator|*
operator|,
expr|struct
name|decision_test
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_both_true_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_test
operator|*
operator|,
expr|struct
name|decision_test
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_both_true
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nodes_identical_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_test
operator|*
operator|,
expr|struct
name|decision_test
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nodes_identical
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_accept_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_trees
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
expr|struct
name|decision_head
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|factor_tests
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|simplify_tests
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|break_out_subroutines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_afterward
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|change_state
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_code
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_afterward
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|struct
name|decision
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|decision
modifier|*
name|write_switch
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_cond
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_test
operator|*
operator|,
name|int
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_action
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
expr|struct
name|decision_test
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|decision
operator|*
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_unconditional
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_test
operator|*
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_node
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
name|int
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_tree_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
name|int
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_tree
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|routine_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_subroutine
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_subroutines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_header
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|decision_head
name|make_insn_sequence
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_tree
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_head
operator|*
operator|,
expr|enum
name|routine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_insn_name
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_decision_0
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_decision_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_decision_2
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision_test
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|debug_decision
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|debug_decision_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|decision
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Create a new node in sequence after LAST.  */
end_comment

begin_function
specifier|static
name|struct
name|decision
modifier|*
name|new_decision
parameter_list|(
name|position
parameter_list|,
name|last
parameter_list|)
specifier|const
name|char
modifier|*
name|position
decl_stmt|;
name|struct
name|decision_head
modifier|*
name|last
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|new
init|=
operator|(
expr|struct
name|decision
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decision
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|success
operator|=
operator|*
name|last
expr_stmt|;
name|new
operator|->
name|position
operator|=
name|xstrdup
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|new
operator|->
name|number
operator|=
name|next_number
operator|++
expr_stmt|;
name|last
operator|->
name|first
operator|=
name|last
operator|->
name|last
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Create a new test and link it in at PLACE.  */
end_comment

begin_function
specifier|static
name|struct
name|decision_test
modifier|*
name|new_decision_test
parameter_list|(
name|type
parameter_list|,
name|pplace
parameter_list|)
name|enum
name|decision_type
name|type
decl_stmt|;
name|struct
name|decision_test
modifier|*
modifier|*
modifier|*
name|pplace
decl_stmt|;
block|{
name|struct
name|decision_test
modifier|*
modifier|*
name|place
init|=
operator|*
name|pplace
decl_stmt|;
name|struct
name|decision_test
modifier|*
name|test
decl_stmt|;
name|test
operator|=
operator|(
expr|struct
name|decision_test
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|test
argument_list|)
argument_list|)
expr_stmt|;
name|test
operator|->
name|next
operator|=
operator|*
name|place
expr_stmt|;
name|test
operator|->
name|type
operator|=
name|type
expr_stmt|;
operator|*
name|place
operator|=
name|test
expr_stmt|;
name|place
operator|=
operator|&
name|test
operator|->
name|next
expr_stmt|;
operator|*
name|pplace
operator|=
name|place
expr_stmt|;
return|return
name|test
return|;
block|}
end_function

begin_comment
comment|/* Search for and return operand N.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_operand
parameter_list|(
name|pattern
parameter_list|,
name|n
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|MATCH_SCRATCH
operator|||
name|code
operator|==
name|MATCH_INSN
operator|||
name|code
operator|==
name|MATCH_OPERAND
operator|||
name|code
operator|==
name|MATCH_OPERATOR
operator|||
name|code
operator|==
name|MATCH_PARALLEL
operator|)
operator|&&
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|==
name|n
condition|)
return|return
name|pattern
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|find_operand
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|n
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
return|return
name|r
return|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
operator|!
name|XVEC
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|r
operator|=
name|find_operand
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|n
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
return|return
name|r
return|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Search for and return operand M, such that it has a matching    constraint for operand N.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_matching_operand
parameter_list|(
name|pattern
parameter_list|,
name|n
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|&&
operator|(
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'0'
operator|+
name|n
operator|||
operator|(
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'0'
operator|+
name|n
operator|)
operator|)
condition|)
return|return
name|pattern
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|find_matching_operand
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|n
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
operator|!
name|XVEC
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|r
operator|=
name|find_matching_operand
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|n
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check for various errors in patterns.  SET is nonnull for a destination,    and is the complete set pattern.  SET_CODE is '=' for normal sets, and    '+' within a context that requires in-out constraints.  */
end_comment

begin_function
specifier|static
name|void
name|validate_pattern
parameter_list|(
name|pattern
parameter_list|,
name|insn
parameter_list|,
name|set
parameter_list|,
name|set_code
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|set_code
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|j
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_SCRATCH
case|:
return|return;
case|case
name|MATCH_INSN
case|:
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_OPERATOR
case|:
block|{
specifier|const
name|char
modifier|*
name|pred_name
init|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|allows_non_lvalue
init|=
literal|1
decl_stmt|,
name|allows_non_const
init|=
literal|1
decl_stmt|;
name|int
name|special_mode_pred
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_test
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|c_test
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|c_test
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred_name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_KNOWN_PREDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|preds
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pred_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|NUM_KNOWN_PREDS
condition|)
block|{
name|int
name|j
decl_stmt|;
name|allows_non_lvalue
operator|=
name|allows_non_const
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
block|{
name|RTX_CODE
name|c
init|=
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|LABEL_REF
operator|&&
name|c
operator|!=
name|SYMBOL_REF
operator|&&
name|c
operator|!=
name|CONST_INT
operator|&&
name|c
operator|!=
name|CONST_DOUBLE
operator|&&
name|c
operator|!=
name|CONST
operator|&&
name|c
operator|!=
name|HIGH
operator|&&
name|c
operator|!=
name|CONSTANT_P_RTX
condition|)
name|allows_non_const
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|REG
operator|&&
name|c
operator|!=
name|SUBREG
operator|&&
name|c
operator|!=
name|MEM
operator|&&
name|c
operator|!=
name|CONCAT
operator|&&
name|c
operator|!=
name|PARALLEL
operator|&&
name|c
operator|!=
name|STRICT_LOW_PART
condition|)
name|allows_non_lvalue
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PREDICATE_CODES
comment|/* If the port has a list of the predicates it uses but 		   omits one, warn.  */
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"warning: `%s' not in PREDICATE_CODES"
argument_list|,
name|pred_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SPECIAL_MODE_PREDS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|pred_name
argument_list|,
name|special_mode_pred_table
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_mode_pred
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
condition|)
block|{
specifier|const
name|char
name|constraints0
init|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
comment|/* In DEFINE_EXPAND, DEFINE_SPLIT, and DEFINE_PEEPHOLE2, we  	       don't use the MATCH_OPERAND constraint, only the predicate. 	       This is confusing to folks doing new ports, so help them 	       not make the mistake.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|DEFINE_EXPAND
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|DEFINE_SPLIT
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|DEFINE_PEEPHOLE2
condition|)
block|{
if|if
condition|(
name|constraints0
condition|)
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"warning: constraints not supported in %s"
argument_list|,
name|rtx_name
index|[
name|GET_CODE
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* A MATCH_OPERAND that is a SET should have an output reload.  */
elseif|else
if|if
condition|(
name|set
operator|&&
name|constraints0
condition|)
block|{
if|if
condition|(
name|set_code
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|constraints0
operator|==
literal|'+'
condition|)
empty_stmt|;
comment|/* If we've only got an output reload for this operand, 		       we'd better have a matching input operand.  */
elseif|else
if|if
condition|(
name|constraints0
operator|==
literal|'='
operator|&&
name|find_matching_operand
argument_list|(
name|insn
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"operand %d missing in-out reload"
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|constraints0
operator|!=
literal|'='
operator|&&
name|constraints0
operator|!=
literal|'+'
condition|)
block|{
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"operand %d missing output reload"
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Allowing non-lvalues in destinations -- particularly CONST_INT -- 	   while not likely to occur at runtime, results in less efficient 	   code from insn-recog.c.  */
if|if
condition|(
name|set
operator|&&
name|pred_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|allows_non_lvalue
condition|)
block|{
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"warning: destination operand %d allows non-lvalue"
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A modeless MATCH_OPERAND can be handy when we can 	   check for multiple modes in the c_test.  In most other cases, 	   it is a mistake.  Only DEFINE_INSN is eligible, since SPLIT 	   and PEEP2 can FAIL within the output pattern.  Exclude 	   address_operand, since its mode is related to the mode of 	   the memory not the operand.  Exclude the SET_DEST of a call 	   instruction, as that is a common idiom.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|code
operator|==
name|MATCH_OPERAND
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|DEFINE_INSN
operator|&&
name|allows_non_const
operator|&&
operator|!
name|special_mode_pred
operator|&&
name|pred_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|pred_name
argument_list|,
literal|"address_operand"
argument_list|)
operator|!=
literal|0
operator|&&
name|strstr
argument_list|(
name|c_test
argument_list|,
literal|"operands"
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
condition|)
block|{
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"warning: operand %d missing mode?"
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|SET
case|:
block|{
name|enum
name|machine_mode
name|dmode
decl_stmt|,
name|smode
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* STRICT_LOW_PART is a wrapper.  Its argument is the real 	   destination, and it's mode should match the source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find the referant for a DUP.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MATCH_DUP
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MATCH_OP_DUP
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MATCH_PAR_DUP
condition|)
name|dest
operator|=
name|find_operand
argument_list|(
name|insn
argument_list|,
name|XINT
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MATCH_DUP
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MATCH_OP_DUP
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MATCH_PAR_DUP
condition|)
name|src
operator|=
name|find_operand
argument_list|(
name|insn
argument_list|,
name|XINT
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dmode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|smode
operator|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* The mode of an ADDRESS_OPERAND is the mode of the memory 	   reference, not the mode of the address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MATCH_OPERAND
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|"address_operand"
argument_list|)
condition|)
empty_stmt|;
comment|/* The operands of a SET must have the same mode unless one 	   is VOIDmode.  */
elseif|else
if|if
condition|(
name|dmode
operator|!=
name|VOIDmode
operator|&&
name|smode
operator|!=
name|VOIDmode
operator|&&
name|dmode
operator|!=
name|smode
condition|)
block|{
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"mode mismatch in set: %smode vs %smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|dmode
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|smode
argument_list|)
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
comment|/* If only one of the operands is VOIDmode, and PC or CC0 is 	   not involved, it's probably a mistake.  */
elseif|else
if|if
condition|(
name|dmode
operator|!=
name|smode
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
specifier|const
name|char
modifier|*
name|which
decl_stmt|;
name|which
operator|=
operator|(
name|dmode
operator|==
name|VOIDmode
condition|?
literal|"destination"
else|:
literal|"source"
operator|)
expr_stmt|;
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"warning: %s missing a mode?"
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dest
operator|!=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
condition|)
name|validate_pattern
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|,
name|pattern
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|validate_pattern
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|insn
argument_list|,
name|pattern
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|validate_pattern
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|CLOBBER
case|:
name|validate_pattern
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|insn
argument_list|,
name|pattern
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTRACT
case|:
name|validate_pattern
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|set
argument_list|,
name|set
condition|?
literal|'+'
else|:
literal|0
argument_list|)
expr_stmt|;
name|validate_pattern
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_pattern
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|validate_pattern
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|set
argument_list|,
name|set
condition|?
literal|'+'
else|:
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|message_with_line
argument_list|(
name|pattern_lineno
argument_list|,
literal|"operand to label_ref %smode not VOIDmode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|validate_pattern
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|validate_pattern
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create a chain of nodes to verify that an rtl expression matches    PATTERN.     LAST is a pointer to the listhead in the previous node in the chain (or    in the calling function, for the first node).     POSITION is the string representing the current position in the insn.     INSN_TYPE is the type of insn for which we are emitting code.     A pointer to the final node in the chain is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|decision
modifier|*
name|add_to_sequence
parameter_list|(
name|pattern
parameter_list|,
name|last
parameter_list|,
name|position
parameter_list|,
name|insn_type
parameter_list|,
name|top
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|struct
name|decision_head
modifier|*
name|last
decl_stmt|;
specifier|const
name|char
modifier|*
name|position
decl_stmt|;
name|enum
name|routine_type
name|insn_type
decl_stmt|;
name|int
name|top
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|struct
name|decision
modifier|*
name|this
decl_stmt|,
modifier|*
name|sub
decl_stmt|;
name|struct
name|decision_test
modifier|*
name|test
decl_stmt|;
name|struct
name|decision_test
modifier|*
modifier|*
name|place
decl_stmt|;
name|char
modifier|*
name|subpos
decl_stmt|;
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|depth
init|=
name|strlen
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|max_depth
condition|)
name|max_depth
operator|=
name|depth
expr_stmt|;
name|subpos
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|subpos
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|subpos
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|=
name|this
operator|=
name|new_decision
argument_list|(
name|position
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|place
operator|=
operator|&
name|this
operator|->
name|tests
expr_stmt|;
name|restart
label|:
name|mode
operator|=
name|GET_MODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PARALLEL
case|:
comment|/* Toplevel peephole pattern.  */
if|if
condition|(
name|insn_type
operator|==
name|PEEPHOLE2
operator|&&
name|top
condition|)
block|{
comment|/* We don't need the node we just created -- unlink it.  */
name|last
operator|->
name|first
operator|=
name|last
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Which insn we're looking at is represented by A-Z. We don't 	         ever use 'A', however; it is always implied.  */
name|subpos
index|[
name|depth
index|]
operator|=
operator|(
name|i
operator|>
literal|0
condition|?
literal|'A'
operator|+
name|i
else|:
literal|0
operator|)
expr_stmt|;
name|sub
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|last
argument_list|,
name|subpos
argument_list|,
name|insn_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
operator|&
name|sub
operator|->
name|success
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
comment|/* Else nothing special.  */
break|break;
case|case
name|MATCH_PARALLEL
case|:
comment|/* The explicit patterns within a match_parallel enforce a minimum 	 length on the vector.  The match_parallel predicate may allow 	 for more elements.  We do need to check for this minimum here 	 or the code generated to match the internals may reference data 	 beyond the end of the vector.  */
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_veclen_ge
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|veclen
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_INSN
case|:
block|{
specifier|const
name|char
modifier|*
name|pred_name
decl_stmt|;
name|RTX_CODE
name|was_code
init|=
name|code
decl_stmt|;
name|int
name|allows_const_int
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_SCRATCH
condition|)
block|{
name|pred_name
operator|=
literal|"scratch_operand"
expr_stmt|;
name|code
operator|=
name|UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|pred_name
operator|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_PARALLEL
condition|)
name|code
operator|=
name|PARALLEL
expr_stmt|;
else|else
name|code
operator|=
name|UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|pred_name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_pred
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|pred
operator|.
name|name
operator|=
name|pred_name
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|pred
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
comment|/* See if we know about this predicate and save its number. 	       If we do, and it only accepts one code, note that fact.  	       If we know that the predicate does not allow CONST_INT, 	       we know that the only way the predicate can match is if 	       the modes match (here we use the kludge of relying on the 	       fact that "address_operand" accepts CONST_INT; otherwise, 	       it would have to be a special case), so we can test the 	       mode (but we need not).  This fact should considerably 	       simplify the generated code.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_KNOWN_PREDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|preds
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pred_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|NUM_KNOWN_PREDS
condition|)
block|{
name|int
name|j
decl_stmt|;
name|test
operator|->
name|u
operator|.
name|pred
operator|.
name|index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|code
operator|==
name|UNKNOWN
condition|)
name|code
operator|=
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
literal|0
index|]
expr_stmt|;
name|allows_const_int
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|==
name|CONST_INT
condition|)
block|{
name|allows_const_int
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
name|test
operator|->
name|u
operator|.
name|pred
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Can't enforce a mode if we allow const_int.  */
if|if
condition|(
name|allows_const_int
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Accept the operand, ie. record it in `operands'.  */
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_accept_op
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|opno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_code
operator|==
name|MATCH_OPERATOR
operator|||
name|was_code
operator|==
name|MATCH_PARALLEL
condition|)
block|{
name|char
name|base
init|=
operator|(
name|was_code
operator|==
name|MATCH_OPERATOR
condition|?
literal|'0'
else|:
literal|'a'
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|subpos
index|[
name|depth
index|]
operator|=
name|i
operator|+
name|base
expr_stmt|;
name|sub
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|sub
operator|->
name|success
argument_list|,
name|subpos
argument_list|,
name|insn_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|fini
goto|;
block|}
case|case
name|MATCH_OP_DUP
case|:
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_dup
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|dup
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_accept_op
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|opno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|subpos
index|[
name|depth
index|]
operator|=
name|i
operator|+
literal|'0'
expr_stmt|;
name|sub
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|sub
operator|->
name|success
argument_list|,
name|subpos
argument_list|,
name|insn_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fini
goto|;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_dup
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|dup
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|fini
goto|;
case|case
name|ADDRESS
case|:
name|pattern
operator|=
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Do tests against the current node first.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_elt_zero_int
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|intval
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_elt_one_int
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|intval
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'w'
condition|)
block|{
comment|/* If this value actually fits in an int, we can use a switch 	     statement here, so indicate that.  */
name|enum
name|decision_type
name|type
init|=
operator|(
operator|(
name|int
operator|)
name|XWINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|==
name|XWINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|)
condition|?
name|DT_elt_zero_wide_safe
else|:
name|DT_elt_zero_wide
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|test
operator|=
name|new_decision_test
argument_list|(
name|type
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|intval
operator|=
name|XWINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_veclen
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|veclen
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now test our sub-patterns.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|subpos
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
name|sub
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|sub
operator|->
name|success
argument_list|,
name|subpos
argument_list|,
name|insn_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|subpos
index|[
name|depth
index|]
operator|=
literal|'a'
operator|+
name|j
expr_stmt|;
name|sub
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|sub
operator|->
name|success
argument_list|,
name|subpos
argument_list|,
name|insn_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
comment|/* Handled above.  */
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|fini
label|:
comment|/* Insert nodes testing mode and code, if they're still relevant,      before any of the nodes we may have added above.  */
if|if
condition|(
name|code
operator|!=
name|UNKNOWN
condition|)
block|{
name|place
operator|=
operator|&
name|this
operator|->
name|tests
expr_stmt|;
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_code
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
name|place
operator|=
operator|&
name|this
operator|->
name|tests
expr_stmt|;
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_mode
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
comment|/* If we didn't insert any tests or accept nodes, hork.  */
if|if
condition|(
name|this
operator|->
name|tests
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
label|:
name|free
argument_list|(
name|subpos
argument_list|)
expr_stmt|;
return|return
name|sub
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of maybe_both_true; compares two modes.    Returns> 0 for "definitely both true" and< 0 for "maybe both true".  */
end_comment

begin_function
specifier|static
name|int
name|maybe_both_true_mode
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|enum
name|machine_mode
name|m1
decl_stmt|,
name|m2
decl_stmt|;
block|{
name|enum
name|mode_class
name|other_mode_class
decl_stmt|;
comment|/* Pmode is not a distinct mode.  We do know that it is      either MODE_INT or MODE_PARTIAL_INT though.  */
if|if
condition|(
name|m1
operator|==
name|Pmode
condition|)
name|other_mode_class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|m2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m2
operator|==
name|Pmode
condition|)
name|other_mode_class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|m1
argument_list|)
expr_stmt|;
else|else
return|return
name|m1
operator|==
name|m2
return|;
return|return
operator|(
name|other_mode_class
operator|==
name|MODE_INT
operator|||
name|other_mode_class
operator|==
name|MODE_PARTIAL_INT
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of maybe_both_true; examines only one test.    Returns> 0 for "definitely both true" and< 0 for "maybe both true".  */
end_comment

begin_function
specifier|static
name|int
name|maybe_both_true_2
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|struct
name|decision_test
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|d1
operator|->
name|type
operator|==
name|d2
operator|->
name|type
condition|)
block|{
switch|switch
condition|(
name|d1
operator|->
name|type
condition|)
block|{
case|case
name|DT_mode
case|:
return|return
name|maybe_both_true_mode
argument_list|(
name|d1
operator|->
name|u
operator|.
name|mode
argument_list|,
name|d2
operator|->
name|u
operator|.
name|mode
argument_list|)
return|;
case|case
name|DT_code
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|code
operator|==
name|d2
operator|->
name|u
operator|.
name|code
return|;
case|case
name|DT_veclen
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|veclen
operator|==
name|d2
operator|->
name|u
operator|.
name|veclen
return|;
case|case
name|DT_elt_zero_int
case|:
case|case
name|DT_elt_one_int
case|:
case|case
name|DT_elt_zero_wide
case|:
case|case
name|DT_elt_zero_wide_safe
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|intval
operator|==
name|d2
operator|->
name|u
operator|.
name|intval
return|;
default|default:
break|break;
block|}
block|}
comment|/* If either has a predicate that we know something about, set      things up so that D1 is the one that always has a known      predicate.  Then see if they have any codes in common.  */
if|if
condition|(
name|d1
operator|->
name|type
operator|==
name|DT_pred
operator|||
name|d2
operator|->
name|type
operator|==
name|DT_pred
condition|)
block|{
if|if
condition|(
name|d2
operator|->
name|type
operator|==
name|DT_pred
condition|)
block|{
name|struct
name|decision_test
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|d1
operator|,
name|d1
operator|=
name|d2
operator|,
name|d2
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* If D2 tests a mode, see if it matches D1.  */
if|if
condition|(
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|d2
operator|->
name|type
operator|==
name|DT_mode
condition|)
block|{
if|if
condition|(
name|maybe_both_true_mode
argument_list|(
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|mode
argument_list|,
name|d2
operator|->
name|u
operator|.
name|mode
argument_list|)
operator|==
literal|0
comment|/* The mode of an address_operand predicate is the 		     mode of the memory, not the operand.  It can only 		     be used for testing the predicate, so we must 		     ignore it here.  */
operator|&&
name|strcmp
argument_list|(
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|name
argument_list|,
literal|"address_operand"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Don't check two predicate modes here, because if both predicates 	     accept CONST_INT, then both can still be true even if the modes 	     are different.  If they don't accept CONST_INT, there will be a 	     separate DT_mode that will make maybe_both_true_1 return 0.  */
block|}
if|if
condition|(
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|index
operator|>=
literal|0
condition|)
block|{
comment|/* If D2 tests a code, see if it is in the list of valid 	     codes for D1's predicate.  */
if|if
condition|(
name|d2
operator|->
name|type
operator|==
name|DT_code
condition|)
block|{
specifier|const
name|RTX_CODE
modifier|*
name|c
init|=
operator|&
name|preds
index|[
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|index
index|]
operator|.
name|codes
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
name|d2
operator|->
name|u
operator|.
name|code
condition|)
break|break;
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Otherwise see if the predicates have any codes in common.  */
elseif|else
if|if
condition|(
name|d2
operator|->
name|type
operator|==
name|DT_pred
operator|&&
name|d2
operator|->
name|u
operator|.
name|pred
operator|.
name|index
operator|>=
literal|0
condition|)
block|{
specifier|const
name|RTX_CODE
modifier|*
name|c1
init|=
operator|&
name|preds
index|[
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|index
index|]
operator|.
name|codes
index|[
literal|0
index|]
decl_stmt|;
name|int
name|common
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|c1
operator|!=
literal|0
operator|&&
operator|!
name|common
condition|)
block|{
specifier|const
name|RTX_CODE
modifier|*
name|c2
init|=
operator|&
name|preds
index|[
name|d2
operator|->
name|u
operator|.
name|pred
operator|.
name|index
index|]
operator|.
name|codes
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|c2
operator|!=
literal|0
operator|&&
operator|!
name|common
condition|)
block|{
name|common
operator|=
operator|(
operator|*
name|c1
operator|==
operator|*
name|c2
operator|)
expr_stmt|;
operator|++
name|c2
expr_stmt|;
block|}
operator|++
name|c1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|common
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* Tests vs veclen may be known when strict equality is involved.  */
if|if
condition|(
name|d1
operator|->
name|type
operator|==
name|DT_veclen
operator|&&
name|d2
operator|->
name|type
operator|==
name|DT_veclen_ge
condition|)
return|return
name|d1
operator|->
name|u
operator|.
name|veclen
operator|>=
name|d2
operator|->
name|u
operator|.
name|veclen
return|;
if|if
condition|(
name|d1
operator|->
name|type
operator|==
name|DT_veclen_ge
operator|&&
name|d2
operator|->
name|type
operator|==
name|DT_veclen
condition|)
return|return
name|d2
operator|->
name|u
operator|.
name|veclen
operator|>=
name|d1
operator|->
name|u
operator|.
name|veclen
return|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_comment
comment|/* A subroutine of maybe_both_true; examines all the tests for a given node.    Returns> 0 for "definitely both true" and< 0 for "maybe both true".  */
end_comment

begin_function
specifier|static
name|int
name|maybe_both_true_1
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|struct
name|decision_test
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|decision_test
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
comment|/* A match_operand with no predicate can match anything.  Recognize      this by the existence of a lone DT_accept_op test.  */
if|if
condition|(
name|d1
operator|->
name|type
operator|==
name|DT_accept_op
operator|||
name|d2
operator|->
name|type
operator|==
name|DT_accept_op
condition|)
return|return
literal|1
return|;
comment|/* Eliminate pairs of tests while they can exactly match.  */
while|while
condition|(
name|d1
operator|&&
name|d2
operator|&&
name|d1
operator|->
name|type
operator|==
name|d2
operator|->
name|type
condition|)
block|{
if|if
condition|(
name|maybe_both_true_2
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|d1
operator|=
name|d1
operator|->
name|next
operator|,
name|d2
operator|=
name|d2
operator|->
name|next
expr_stmt|;
block|}
comment|/* After that, consider all pairs.  */
for|for
control|(
name|t1
operator|=
name|d1
init|;
name|t1
condition|;
name|t1
operator|=
name|t1
operator|->
name|next
control|)
for|for
control|(
name|t2
operator|=
name|d2
init|;
name|t2
condition|;
name|t2
operator|=
name|t2
operator|->
name|next
control|)
if|if
condition|(
name|maybe_both_true_2
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Return 0 if we can prove that there is no RTL that can match both    D1 and D2.  Otherwise, return 1 (it may be that there is an RTL that    can match both or just that we couldn't prove there wasn't such an RTL).     TOPLEVEL is non-zero if we are to only look at the top level and not    recursively descend.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_both_true
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|,
name|toplevel
parameter_list|)
name|struct
name|decision
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|toplevel
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|decision
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
comment|/* Don't compare strings on the different positions in insn.  Doing so      is incorrect and results in false matches from constructs like  	[(set (subreg:HI (match_operand:SI "register_operand" "r") 0) 	      (subreg:HI (match_operand:SI "register_operand" "r") 0))]      vs 	[(set (match_operand:HI "register_operand" "r") 	      (match_operand:HI "register_operand" "r"))]       If we are presented with such, we are recursing through the remainder      of a node's success nodes (from the loop at the end of this function).      Skip forward until we come to a position that matches.       Due to the way position strings are constructed, we know that iterating      forward from the lexically lower position (e.g. "00") will run into      the lexically higher position (e.g. "1") and not the other way around.      This saves a bit of effort.  */
name|cmp
operator|=
name|strcmp
argument_list|(
name|d1
operator|->
name|position
argument_list|,
name|d2
operator|->
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|toplevel
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the d2->position was lexically lower, swap.  */
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|p1
operator|=
name|d1
operator|,
name|d1
operator|=
name|d2
operator|,
name|d2
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|d1
operator|->
name|success
operator|.
name|first
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p1
operator|=
name|d1
operator|->
name|success
operator|.
name|first
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
if|if
condition|(
name|maybe_both_true
argument_list|(
name|p1
argument_list|,
name|d2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* Test the current level.  */
name|cmp
operator|=
name|maybe_both_true_1
argument_list|(
name|d1
operator|->
name|tests
argument_list|,
name|d2
operator|->
name|tests
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>=
literal|0
condition|)
return|return
name|cmp
return|;
comment|/* We can't prove that D1 and D2 cannot both be true.  If we are only      to check the top level, return 1.  Otherwise, see if we can prove      that all choices in both successors are mutually exclusive.  If      either does not have any successors, we can't prove they can't both      be true.  */
if|if
condition|(
name|toplevel
operator|||
name|d1
operator|->
name|success
operator|.
name|first
operator|==
literal|0
operator|||
name|d2
operator|->
name|success
operator|.
name|first
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p1
operator|=
name|d1
operator|->
name|success
operator|.
name|first
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
for|for
control|(
name|p2
operator|=
name|d2
operator|->
name|success
operator|.
name|first
init|;
name|p2
condition|;
name|p2
operator|=
name|p2
operator|->
name|next
control|)
if|if
condition|(
name|maybe_both_true
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* A subroutine of nodes_identical.  Examine two tests for equivalence.  */
end_comment

begin_function
specifier|static
name|int
name|nodes_identical_1
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|struct
name|decision_test
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
switch|switch
condition|(
name|d1
operator|->
name|type
condition|)
block|{
case|case
name|DT_mode
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|mode
operator|==
name|d2
operator|->
name|u
operator|.
name|mode
return|;
case|case
name|DT_code
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|code
operator|==
name|d2
operator|->
name|u
operator|.
name|code
return|;
case|case
name|DT_pred
case|:
return|return
operator|(
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|mode
operator|==
name|d2
operator|->
name|u
operator|.
name|pred
operator|.
name|mode
operator|&&
name|strcmp
argument_list|(
name|d1
operator|->
name|u
operator|.
name|pred
operator|.
name|name
argument_list|,
name|d2
operator|->
name|u
operator|.
name|pred
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
return|;
case|case
name|DT_c_test
case|:
return|return
name|strcmp
argument_list|(
name|d1
operator|->
name|u
operator|.
name|c_test
argument_list|,
name|d2
operator|->
name|u
operator|.
name|c_test
argument_list|)
operator|==
literal|0
return|;
case|case
name|DT_veclen
case|:
case|case
name|DT_veclen_ge
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|veclen
operator|==
name|d2
operator|->
name|u
operator|.
name|veclen
return|;
case|case
name|DT_dup
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|dup
operator|==
name|d2
operator|->
name|u
operator|.
name|dup
return|;
case|case
name|DT_elt_zero_int
case|:
case|case
name|DT_elt_one_int
case|:
case|case
name|DT_elt_zero_wide
case|:
case|case
name|DT_elt_zero_wide_safe
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|intval
operator|==
name|d2
operator|->
name|u
operator|.
name|intval
return|;
case|case
name|DT_accept_op
case|:
return|return
name|d1
operator|->
name|u
operator|.
name|opno
operator|==
name|d2
operator|->
name|u
operator|.
name|opno
return|;
case|case
name|DT_accept_insn
case|:
comment|/* Differences will be handled in merge_accept_insn.  */
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* True iff the two nodes are identical (on one level only).  Due    to the way these lists are constructed, we shouldn't have to    consider different orderings on the tests.  */
end_comment

begin_function
specifier|static
name|int
name|nodes_identical
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|struct
name|decision
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|decision_test
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|d1
operator|->
name|tests
operator|,
name|t2
operator|=
name|d2
operator|->
name|tests
init|;
name|t1
operator|&&
name|t2
condition|;
name|t1
operator|=
name|t1
operator|->
name|next
operator|,
name|t2
operator|=
name|t2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t1
operator|->
name|type
operator|!=
name|t2
operator|->
name|type
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|nodes_identical_1
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* For success, they should now both be null.  */
if|if
condition|(
name|t1
operator|!=
name|t2
condition|)
return|return
literal|0
return|;
comment|/* Check that their subnodes are at the same position, as any one set      of sibling decisions must be at the same position.  Allowing this      requires complications to find_afterward and when change_state is      invoked.  */
if|if
condition|(
name|d1
operator|->
name|success
operator|.
name|first
operator|&&
name|d2
operator|->
name|success
operator|.
name|first
operator|&&
name|strcmp
argument_list|(
name|d1
operator|->
name|success
operator|.
name|first
operator|->
name|position
argument_list|,
name|d2
operator|->
name|success
operator|.
name|first
operator|->
name|position
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* A subroutine of merge_trees; given two nodes that have been declared    identical, cope with two insn accept states.  If they differ in the    number of clobbers, then the conflict was created by make_insn_sequence    and we can drop the with-clobbers version on the floor.  If both    nodes have no additional clobbers, we have found an ambiguity in the    source machine description.  */
end_comment

begin_function
specifier|static
name|void
name|merge_accept_insn
parameter_list|(
name|oldd
parameter_list|,
name|addd
parameter_list|)
name|struct
name|decision
modifier|*
name|oldd
decl_stmt|,
decl|*
name|addd
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|decision_test
modifier|*
name|old
decl_stmt|,
modifier|*
name|add
decl_stmt|;
for|for
control|(
name|old
operator|=
name|oldd
operator|->
name|tests
init|;
name|old
condition|;
name|old
operator|=
name|old
operator|->
name|next
control|)
if|if
condition|(
name|old
operator|->
name|type
operator|==
name|DT_accept_insn
condition|)
break|break;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|add
operator|=
name|addd
operator|->
name|tests
init|;
name|add
condition|;
name|add
operator|=
name|add
operator|->
name|next
control|)
if|if
condition|(
name|add
operator|->
name|type
operator|==
name|DT_accept_insn
condition|)
break|break;
if|if
condition|(
name|add
operator|==
name|NULL
condition|)
return|return;
comment|/* If one node is for a normal insn and the second is for the base      insn with clobbers stripped off, the second node should be ignored.  */
if|if
condition|(
name|old
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|==
literal|0
operator|&&
name|add
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|>
literal|0
condition|)
block|{
comment|/* Nothing to do here.  */
block|}
elseif|else
if|if
condition|(
name|old
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|>
literal|0
operator|&&
name|add
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|==
literal|0
condition|)
block|{
comment|/* In this case, replace OLD with ADD.  */
name|old
operator|->
name|u
operator|.
name|insn
operator|=
name|add
operator|->
name|u
operator|.
name|insn
expr_stmt|;
block|}
else|else
block|{
name|message_with_line
argument_list|(
name|add
operator|->
name|u
operator|.
name|insn
operator|.
name|lineno
argument_list|,
literal|"`%s' matches `%s'"
argument_list|,
name|get_insn_name
argument_list|(
name|add
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
argument_list|)
argument_list|,
name|get_insn_name
argument_list|(
name|old
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
argument_list|)
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
name|old
operator|->
name|u
operator|.
name|insn
operator|.
name|lineno
argument_list|,
literal|"previous definition of `%s'"
argument_list|,
name|get_insn_name
argument_list|(
name|old
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
argument_list|)
argument_list|)
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Merge two decision trees OLDH and ADDH, modifying OLDH destructively.  */
end_comment

begin_function
specifier|static
name|void
name|merge_trees
parameter_list|(
name|oldh
parameter_list|,
name|addh
parameter_list|)
name|struct
name|decision_head
modifier|*
name|oldh
decl_stmt|,
decl|*
name|addh
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|decision
modifier|*
name|next
decl_stmt|,
modifier|*
name|add
decl_stmt|;
if|if
condition|(
name|addh
operator|->
name|first
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|oldh
operator|->
name|first
operator|==
literal|0
condition|)
block|{
operator|*
name|oldh
operator|=
operator|*
name|addh
expr_stmt|;
return|return;
block|}
comment|/* Trying to merge bits at different positions isn't possible.  */
if|if
condition|(
name|strcmp
argument_list|(
name|oldh
operator|->
name|first
operator|->
name|position
argument_list|,
name|addh
operator|->
name|first
operator|->
name|position
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|add
operator|=
name|addh
operator|->
name|first
init|;
name|add
condition|;
name|add
operator|=
name|next
control|)
block|{
name|struct
name|decision
modifier|*
name|old
decl_stmt|,
modifier|*
name|insert_before
init|=
name|NULL
decl_stmt|;
name|next
operator|=
name|add
operator|->
name|next
expr_stmt|;
comment|/* The semantics of pattern matching state that the tests are 	 done in the order given in the MD file so that if an insn 	 matches two patterns, the first one will be used.  However, 	 in practice, most, if not all, patterns are unambiguous so 	 that their order is independent.  In that case, we can merge 	 identical tests and group all similar modes and codes together.  	 Scan starting from the end of OLDH until we reach a point 	 where we reach the head of the list or where we pass a 	 pattern that could also be true if NEW is true.  If we find 	 an identical pattern, we can merge them.  Also, record the 	 last node that tests the same code and mode and the last one 	 that tests just the same mode.  	 If we have no match, place NEW after the closest match we found.  */
for|for
control|(
name|old
operator|=
name|oldh
operator|->
name|last
init|;
name|old
condition|;
name|old
operator|=
name|old
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|nodes_identical
argument_list|(
name|old
argument_list|,
name|add
argument_list|)
condition|)
block|{
name|merge_accept_insn
argument_list|(
name|old
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|merge_trees
argument_list|(
operator|&
name|old
operator|->
name|success
argument_list|,
operator|&
name|add
operator|->
name|success
argument_list|)
expr_stmt|;
goto|goto
name|merged_nodes
goto|;
block|}
if|if
condition|(
name|maybe_both_true
argument_list|(
name|old
argument_list|,
name|add
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
comment|/* Insert the nodes in DT test type order, which is roughly 	     how expensive/important the test is.  Given that the tests 	     are also ordered within the list, examining the first is 	     sufficient.  */
if|if
condition|(
operator|(
name|int
operator|)
name|add
operator|->
name|tests
operator|->
name|type
operator|<
operator|(
name|int
operator|)
name|old
operator|->
name|tests
operator|->
name|type
condition|)
name|insert_before
operator|=
name|old
expr_stmt|;
block|}
if|if
condition|(
name|insert_before
operator|==
name|NULL
condition|)
block|{
name|add
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|add
operator|->
name|prev
operator|=
name|oldh
operator|->
name|last
expr_stmt|;
name|oldh
operator|->
name|last
operator|->
name|next
operator|=
name|add
expr_stmt|;
name|oldh
operator|->
name|last
operator|=
name|add
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|add
operator|->
name|prev
operator|=
name|insert_before
operator|->
name|prev
operator|)
operator|!=
name|NULL
condition|)
name|add
operator|->
name|prev
operator|->
name|next
operator|=
name|add
expr_stmt|;
else|else
name|oldh
operator|->
name|first
operator|=
name|add
expr_stmt|;
name|add
operator|->
name|next
operator|=
name|insert_before
expr_stmt|;
name|insert_before
operator|->
name|prev
operator|=
name|add
expr_stmt|;
block|}
name|merged_nodes
label|:
empty_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Walk the tree looking for sub-nodes that perform common tests.    Factor out the common test into a new node.  This enables us    (depending on the test type) to emit switch statements later.  */
end_comment

begin_function
specifier|static
name|void
name|factor_tests
parameter_list|(
name|head
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|first
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|first
operator|=
name|head
operator|->
name|first
init|;
name|first
operator|&&
name|first
operator|->
name|next
condition|;
name|first
operator|=
name|next
control|)
block|{
name|enum
name|decision_type
name|type
decl_stmt|;
name|struct
name|decision
modifier|*
name|new
decl_stmt|,
modifier|*
name|old_last
decl_stmt|;
name|type
operator|=
name|first
operator|->
name|tests
operator|->
name|type
expr_stmt|;
name|next
operator|=
name|first
operator|->
name|next
expr_stmt|;
comment|/* Want at least two compatible sequential nodes.  */
if|if
condition|(
name|next
operator|->
name|tests
operator|->
name|type
operator|!=
name|type
condition|)
continue|continue;
comment|/* Don't want all node types, just those we can turn into 	 switch statements.  */
if|if
condition|(
name|type
operator|!=
name|DT_mode
operator|&&
name|type
operator|!=
name|DT_code
operator|&&
name|type
operator|!=
name|DT_veclen
operator|&&
name|type
operator|!=
name|DT_elt_zero_int
operator|&&
name|type
operator|!=
name|DT_elt_one_int
operator|&&
name|type
operator|!=
name|DT_elt_zero_wide_safe
condition|)
continue|continue;
comment|/* If we'd been performing more than one test, create a new node          below our first test.  */
if|if
condition|(
name|first
operator|->
name|tests
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|new
operator|=
name|new_decision
argument_list|(
name|first
operator|->
name|position
argument_list|,
operator|&
name|first
operator|->
name|success
argument_list|)
expr_stmt|;
name|new
operator|->
name|tests
operator|=
name|first
operator|->
name|tests
operator|->
name|next
expr_stmt|;
name|first
operator|->
name|tests
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Crop the node tree off after our first test.  */
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|old_last
operator|=
name|head
operator|->
name|last
expr_stmt|;
name|head
operator|->
name|last
operator|=
name|first
expr_stmt|;
comment|/* For each compatible test, adjust to perform only one test in 	 the top level node, then merge the node back into the tree.  */
do|do
block|{
name|struct
name|decision_head
name|h
decl_stmt|;
if|if
condition|(
name|next
operator|->
name|tests
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|new
operator|=
name|new_decision
argument_list|(
name|next
operator|->
name|position
argument_list|,
operator|&
name|next
operator|->
name|success
argument_list|)
expr_stmt|;
name|new
operator|->
name|tests
operator|=
name|next
operator|->
name|tests
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|tests
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|new
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|h
operator|.
name|first
operator|=
name|h
operator|.
name|last
operator|=
name|new
expr_stmt|;
name|merge_trees
argument_list|(
name|head
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|&&
name|next
operator|->
name|tests
operator|->
name|type
operator|==
name|type
condition|)
do|;
comment|/* After we run out of compatible tests, graft the remaining nodes 	 back onto the tree.  */
if|if
condition|(
name|next
condition|)
block|{
name|next
operator|->
name|prev
operator|=
name|head
operator|->
name|last
expr_stmt|;
name|head
operator|->
name|last
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|head
operator|->
name|last
operator|=
name|old_last
expr_stmt|;
block|}
block|}
comment|/* Recurse.  */
for|for
control|(
name|first
operator|=
name|head
operator|->
name|first
init|;
name|first
condition|;
name|first
operator|=
name|first
operator|->
name|next
control|)
name|factor_tests
argument_list|(
operator|&
name|first
operator|->
name|success
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After factoring, try to simplify the tests on any one node.    Tests that are useful for switch statements are recognizable    by having only a single test on a node -- we'll be manipulating    nodes with multiple tests:     If we have mode tests or code tests that are redundant with    predicates, remove them.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_tests
parameter_list|(
name|head
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|tree
decl_stmt|;
for|for
control|(
name|tree
operator|=
name|head
operator|->
name|first
init|;
name|tree
condition|;
name|tree
operator|=
name|tree
operator|->
name|next
control|)
block|{
name|struct
name|decision_test
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|a
operator|=
name|tree
operator|->
name|tests
expr_stmt|;
name|b
operator|=
name|a
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Find a predicate node.  */
while|while
condition|(
name|b
operator|&&
name|b
operator|->
name|type
operator|!=
name|DT_pred
condition|)
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
comment|/* Due to how these tests are constructed, we don't even need 	     to check that the mode and code are compatible -- they were 	     generated from the predicate in the first place.  */
while|while
condition|(
name|a
operator|->
name|type
operator|==
name|DT_mode
operator|||
name|a
operator|->
name|type
operator|==
name|DT_code
condition|)
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
name|tree
operator|->
name|tests
operator|=
name|a
expr_stmt|;
block|}
block|}
comment|/* Recurse.  */
for|for
control|(
name|tree
operator|=
name|head
operator|->
name|first
init|;
name|tree
condition|;
name|tree
operator|=
name|tree
operator|->
name|next
control|)
name|simplify_tests
argument_list|(
operator|&
name|tree
operator|->
name|success
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of subnodes of HEAD.  If the number is high enough,    make the first node in HEAD start a separate subroutine in the C code    that is generated.  */
end_comment

begin_function
specifier|static
name|int
name|break_out_subroutines
parameter_list|(
name|head
parameter_list|,
name|initial
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
name|int
name|initial
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|struct
name|decision
modifier|*
name|sub
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|head
operator|->
name|first
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|size
operator|+=
literal|1
operator|+
name|break_out_subroutines
argument_list|(
operator|&
name|sub
operator|->
name|success
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|SUBROUTINE_THRESHOLD
operator|&&
operator|!
name|initial
condition|)
block|{
name|head
operator|->
name|first
operator|->
name|subroutine_number
operator|=
operator|++
name|next_subroutine_number
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* For each node p, find the next alternative that might be true    when p is true.  */
end_comment

begin_function
specifier|static
name|void
name|find_afterward
parameter_list|(
name|head
parameter_list|,
name|real_afterward
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
name|struct
name|decision
modifier|*
name|real_afterward
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|afterward
decl_stmt|;
comment|/* We can't propagate alternatives across subroutine boundaries.      This is not incorrect, merely a minor optimization loss.  */
name|p
operator|=
name|head
operator|->
name|first
expr_stmt|;
name|afterward
operator|=
operator|(
name|p
operator|->
name|subroutine_number
operator|>
literal|0
condition|?
name|NULL
else|:
name|real_afterward
operator|)
expr_stmt|;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* Find the next node that might be true if this one fails.  */
for|for
control|(
name|q
operator|=
name|p
operator|->
name|next
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|maybe_both_true
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
comment|/* If we reached the end of the list without finding one, 	 use the incoming afterward position.  */
if|if
condition|(
operator|!
name|q
condition|)
name|q
operator|=
name|afterward
expr_stmt|;
name|p
operator|->
name|afterward
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|q
operator|->
name|need_label
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Recurse.  */
for|for
control|(
name|p
operator|=
name|head
operator|->
name|first
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|success
operator|.
name|first
condition|)
name|find_afterward
argument_list|(
operator|&
name|p
operator|->
name|success
argument_list|,
name|p
operator|->
name|afterward
argument_list|)
expr_stmt|;
comment|/* When we are generating a subroutine, record the real afterward      position in the first node where write_tree can find it, and we      can do the right thing at the subroutine call site.  */
name|p
operator|=
name|head
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|subroutine_number
operator|>
literal|0
condition|)
name|p
operator|->
name|afterward
operator|=
name|real_afterward
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming that the state of argument is denoted by OLDPOS, take whatever    actions are necessary to move to NEWPOS.  If we fail to move to the    new state, branch to node AFTERWARD if non-zero, otherwise return.     Failure to move to the new state can only occur if we are trying to    match multiple insns and we try to step past the end of the stream.  */
end_comment

begin_function
specifier|static
name|void
name|change_state
parameter_list|(
name|oldpos
parameter_list|,
name|newpos
parameter_list|,
name|afterward
parameter_list|,
name|indent
parameter_list|)
specifier|const
name|char
modifier|*
name|oldpos
decl_stmt|;
specifier|const
name|char
modifier|*
name|newpos
decl_stmt|;
name|struct
name|decision
modifier|*
name|afterward
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|;
block|{
name|int
name|odepth
init|=
name|strlen
argument_list|(
name|oldpos
argument_list|)
decl_stmt|;
name|int
name|ndepth
init|=
name|strlen
argument_list|(
name|newpos
argument_list|)
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|old_has_insn
decl_stmt|,
name|new_has_insn
decl_stmt|;
comment|/* Pop up as many levels as necessary.  */
for|for
control|(
name|depth
operator|=
name|odepth
init|;
name|strncmp
argument_list|(
name|oldpos
argument_list|,
name|newpos
argument_list|,
name|depth
argument_list|)
operator|!=
literal|0
condition|;
operator|--
name|depth
control|)
continue|continue;
comment|/* Hunt for the last [A-Z] in both strings.  */
for|for
control|(
name|old_has_insn
operator|=
name|odepth
operator|-
literal|1
init|;
name|old_has_insn
operator|>=
literal|0
condition|;
operator|--
name|old_has_insn
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|oldpos
index|[
name|old_has_insn
index|]
argument_list|)
condition|)
break|break;
for|for
control|(
name|new_has_insn
operator|=
name|ndepth
operator|-
literal|1
init|;
name|new_has_insn
operator|>=
literal|0
condition|;
operator|--
name|new_has_insn
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|newpos
index|[
name|new_has_insn
index|]
argument_list|)
condition|)
break|break;
comment|/* Go down to desired level.  */
while|while
condition|(
name|depth
operator|<
name|ndepth
condition|)
block|{
comment|/* It's a different insn from the first one.  */
if|if
condition|(
name|ISUPPER
argument_list|(
name|newpos
index|[
name|depth
index|]
argument_list|)
condition|)
block|{
comment|/* We can only fail if we're moving down the tree.  */
if|if
condition|(
name|old_has_insn
operator|>=
literal|0
operator|&&
name|oldpos
index|[
name|old_has_insn
index|]
operator|>=
name|newpos
index|[
name|depth
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%stem = peep2_next_insn (%d);\n"
argument_list|,
name|indent
argument_list|,
name|newpos
index|[
name|depth
index|]
operator|-
literal|'A'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%stem = peep2_next_insn (%d);\n"
argument_list|,
name|indent
argument_list|,
name|newpos
index|[
name|depth
index|]
operator|-
literal|'A'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sif (tem == NULL_RTX)\n"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
name|printf
argument_list|(
literal|"%s  goto L%d;\n"
argument_list|,
name|indent
argument_list|,
name|afterward
operator|->
name|number
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s  goto ret0;\n"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%sx%d = PATTERN (tem);\n"
argument_list|,
name|indent
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|newpos
index|[
name|depth
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%sx%d = XVECEXP (x%d, 0, %d);\n"
argument_list|,
name|indent
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
argument_list|,
name|newpos
index|[
name|depth
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%sx%d = XEXP (x%d, %c);\n"
argument_list|,
name|indent
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
argument_list|,
name|newpos
index|[
name|depth
index|]
argument_list|)
expr_stmt|;
operator|++
name|depth
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the enumerator constant for CODE -- the upcase version of    the name.  */
end_comment

begin_function
specifier|static
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to cross an afterward link -- change state and branch.  */
end_comment

begin_function
specifier|static
name|void
name|write_afterward
parameter_list|(
name|start
parameter_list|,
name|afterward
parameter_list|,
name|indent
parameter_list|)
name|struct
name|decision
modifier|*
name|start
decl_stmt|;
name|struct
name|decision
modifier|*
name|afterward
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|afterward
operator|||
name|start
operator|->
name|subroutine_number
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%sgoto ret0;\n"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
else|else
block|{
name|change_state
argument_list|(
name|start
operator|->
name|position
argument_list|,
name|afterward
operator|->
name|position
argument_list|,
name|NULL
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sgoto L%d;\n"
argument_list|,
name|indent
argument_list|,
name|afterward
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a switch statement, if possible, for an initial sequence of    nodes at START.  Return the first node yet untested.  */
end_comment

begin_function
specifier|static
name|struct
name|decision
modifier|*
name|write_switch
parameter_list|(
name|start
parameter_list|,
name|depth
parameter_list|)
name|struct
name|decision
modifier|*
name|start
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|enum
name|decision_type
name|type
init|=
name|p
operator|->
name|tests
operator|->
name|type
decl_stmt|;
name|struct
name|decision
modifier|*
name|needs_label
init|=
name|NULL
decl_stmt|;
comment|/* If we have two or more nodes in sequence that test the same one      thing, we may be able to use a switch statement.  */
if|if
condition|(
operator|!
name|p
operator|->
name|next
operator|||
name|p
operator|->
name|tests
operator|->
name|next
operator|||
name|p
operator|->
name|next
operator|->
name|tests
operator|->
name|type
operator|!=
name|type
operator|||
name|p
operator|->
name|next
operator|->
name|tests
operator|->
name|next
operator|||
name|nodes_identical_1
argument_list|(
name|p
operator|->
name|tests
argument_list|,
name|p
operator|->
name|next
operator|->
name|tests
argument_list|)
condition|)
return|return
name|p
return|;
comment|/* DT_code is special in that we can do interesting things with      known predicates at the same time.  */
if|if
condition|(
name|type
operator|==
name|DT_code
condition|)
block|{
name|char
name|codemap
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
name|struct
name|decision
modifier|*
name|ret
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|memset
argument_list|(
name|codemap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|codemap
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (GET_CODE (x%d))\n    {\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|code
operator|=
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|code
expr_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|!=
name|start
operator|&&
name|p
operator|->
name|need_label
operator|&&
name|needs_label
operator|==
name|NULL
condition|)
name|needs_label
operator|=
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"    case "
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n      goto L%d;\n"
argument_list|,
name|p
operator|->
name|success
operator|.
name|first
operator|->
name|number
argument_list|)
expr_stmt|;
name|p
operator|->
name|success
operator|.
name|first
operator|->
name|need_label
operator|=
literal|1
expr_stmt|;
name|codemap
index|[
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|&&
operator|!
name|p
operator|->
name|tests
operator|->
name|next
operator|&&
name|p
operator|->
name|tests
operator|->
name|type
operator|==
name|DT_code
operator|&&
operator|!
name|codemap
index|[
name|code
operator|=
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|code
index|]
condition|)
do|;
comment|/* If P is testing a predicate that we know about and we haven't 	 seen any of the codes that are valid for the predicate, we can 	 write a series of "case" statement, one for each possible code. 	 Since we are already in a switch, these redundant tests are very 	 cheap and will reduce the number of predicates called.  */
comment|/* Note that while we write out cases for these predicates here, 	 we don't actually write the test here, as it gets kinda messy. 	 It is trivial to leave this to later by telling our caller that 	 we only processed the CODE tests.  */
if|if
condition|(
name|needs_label
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|needs_label
expr_stmt|;
else|else
name|ret
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|tests
operator|->
name|type
operator|==
name|DT_pred
operator|&&
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|pred
operator|.
name|index
operator|>=
literal|0
condition|)
block|{
specifier|const
name|RTX_CODE
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|&
name|preds
index|[
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|pred
operator|.
name|index
index|]
operator|.
name|codes
index|[
literal|0
index|]
init|;
operator|*
name|c
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|codemap
index|[
operator|(
name|int
operator|)
operator|*
name|c
index|]
operator|!=
literal|0
condition|)
goto|goto
name|pred_done
goto|;
for|for
control|(
name|c
operator|=
operator|&
name|preds
index|[
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|pred
operator|.
name|index
index|]
operator|.
name|codes
index|[
literal|0
index|]
init|;
operator|*
name|c
condition|;
operator|++
name|c
control|)
block|{
name|printf
argument_list|(
literal|"    case "
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|codemap
index|[
operator|(
name|int
operator|)
operator|*
name|c
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"      goto L%d;\n"
argument_list|,
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
name|p
operator|->
name|need_label
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|pred_done
label|:
comment|/* Make the default case skip the predicates we managed to match.  */
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|ret
condition|)
block|{
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"      goto L%d;\n"
argument_list|,
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
name|p
operator|->
name|need_label
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|write_afterward
argument_list|(
name|start
argument_list|,
name|start
operator|->
name|afterward
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"     break;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   }\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|DT_mode
operator|||
name|type
operator|==
name|DT_veclen
operator|||
name|type
operator|==
name|DT_elt_zero_int
operator|||
name|type
operator|==
name|DT_elt_one_int
operator|||
name|type
operator|==
name|DT_elt_zero_wide_safe
condition|)
block|{
specifier|const
name|char
modifier|*
name|indent
init|=
literal|""
decl_stmt|;
comment|/* Pmode may not be a compile-time constant.  */
if|if
condition|(
name|type
operator|==
name|DT_mode
operator|&&
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|mode
operator|==
name|Pmode
condition|)
return|return
name|p
return|;
comment|/* We cast switch parameter to integer, so we must ensure that the value 	 fits.  */
if|if
condition|(
name|type
operator|==
name|DT_elt_zero_wide_safe
condition|)
block|{
name|indent
operator|=
literal|"  "
expr_stmt|;
name|printf
argument_list|(
literal|"  if ((int) XWINT (x%d, 0) == XWINT (x%d, 0))\n"
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s  switch ("
argument_list|,
name|indent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_mode
case|:
name|printf
argument_list|(
literal|"GET_MODE (x%d)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_veclen
case|:
name|printf
argument_list|(
literal|"XVECLEN (x%d, 0)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_int
case|:
name|printf
argument_list|(
literal|"XINT (x%d, 0)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_one_int
case|:
name|printf
argument_list|(
literal|"XINT (x%d, 1)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_wide_safe
case|:
comment|/* Convert result of XWINT to int for portability since some C 	     compilers won't do it and some will.  */
name|printf
argument_list|(
literal|"(int) XWINT (x%d, 0)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")\n%s    {\n"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Merge trees will not unify identical nodes if their 	     sub-nodes are at different levels.  Thus we must check 	     for duplicate cases.  */
name|struct
name|decision
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|start
init|;
name|q
operator|!=
name|p
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|nodes_identical_1
argument_list|(
name|p
operator|->
name|tests
argument_list|,
name|q
operator|->
name|tests
argument_list|)
condition|)
goto|goto
name|case_done
goto|;
comment|/* Pmode may not be a compile-time constant.  */
if|if
condition|(
name|type
operator|==
name|DT_mode
operator|&&
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|mode
operator|==
name|Pmode
condition|)
goto|goto
name|case_done
goto|;
if|if
condition|(
name|p
operator|!=
name|start
operator|&&
name|p
operator|->
name|need_label
operator|&&
name|needs_label
operator|==
name|NULL
condition|)
name|needs_label
operator|=
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"%s    case "
argument_list|,
name|indent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_mode
case|:
name|printf
argument_list|(
literal|"%smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_veclen
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|veclen
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_int
case|:
case|case
name|DT_elt_one_int
case|:
case|case
name|DT_elt_zero_wide
case|:
case|case
name|DT_elt_zero_wide_safe
case|:
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|p
operator|->
name|tests
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|":\n%s      goto L%d;\n"
argument_list|,
name|indent
argument_list|,
name|p
operator|->
name|success
operator|.
name|first
operator|->
name|number
argument_list|)
expr_stmt|;
name|p
operator|->
name|success
operator|.
name|first
operator|->
name|need_label
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|&&
name|p
operator|->
name|tests
operator|->
name|type
operator|==
name|type
operator|&&
operator|!
name|p
operator|->
name|tests
operator|->
name|next
condition|)
do|;
name|case_done
label|:
name|printf
argument_list|(
literal|"%s    default:\n%s      break;\n%s    }\n"
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|)
expr_stmt|;
return|return
name|needs_label
operator|!=
name|NULL
condition|?
name|needs_label
else|:
name|p
return|;
block|}
else|else
block|{
comment|/* None of the other tests are ameanable.  */
return|return
name|p
return|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code for one test.  */
end_comment

begin_function
specifier|static
name|void
name|write_cond
parameter_list|(
name|p
parameter_list|,
name|depth
parameter_list|,
name|subroutine_type
parameter_list|)
name|struct
name|decision_test
modifier|*
name|p
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|enum
name|routine_type
name|subroutine_type
decl_stmt|;
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|DT_mode
case|:
name|printf
argument_list|(
literal|"GET_MODE (x%d) == %smode"
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|u
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_code
case|:
name|printf
argument_list|(
literal|"GET_CODE (x%d) == "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|p
operator|->
name|u
operator|.
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_veclen
case|:
name|printf
argument_list|(
literal|"XVECLEN (x%d, 0) == %d"
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|u
operator|.
name|veclen
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_int
case|:
name|printf
argument_list|(
literal|"XINT (x%d, 0) == %d"
argument_list|,
name|depth
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_one_int
case|:
name|printf
argument_list|(
literal|"XINT (x%d, 1) == %d"
argument_list|,
name|depth
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_wide
case|:
case|case
name|DT_elt_zero_wide_safe
case|:
name|printf
argument_list|(
literal|"XWINT (x%d, 0) == "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|p
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_veclen_ge
case|:
name|printf
argument_list|(
literal|"XVECLEN (x%d, 0)>= %d"
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|u
operator|.
name|veclen
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_dup
case|:
name|printf
argument_list|(
literal|"rtx_equal_p (x%d, operands[%d])"
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|u
operator|.
name|dup
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_pred
case|:
name|printf
argument_list|(
literal|"%s (x%d, %smode)"
argument_list|,
name|p
operator|->
name|u
operator|.
name|pred
operator|.
name|name
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|u
operator|.
name|pred
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_c_test
case|:
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|p
operator|->
name|u
operator|.
name|c_test
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_accept_insn
case|:
switch|switch
condition|(
name|subroutine_type
condition|)
block|{
case|case
name|RECOG
case|:
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"pnum_clobbers != NULL"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code for one action.  The previous tests have succeeded;    TEST is the last of the chain.  In the normal case we simply    perform a state change.  For the `accept' tests we must do more work.  */
end_comment

begin_function
specifier|static
name|void
name|write_action
parameter_list|(
name|p
parameter_list|,
name|test
parameter_list|,
name|depth
parameter_list|,
name|uncond
parameter_list|,
name|success
parameter_list|,
name|subroutine_type
parameter_list|)
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
name|struct
name|decision_test
modifier|*
name|test
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|uncond
decl_stmt|;
name|struct
name|decision
modifier|*
name|success
decl_stmt|;
name|enum
name|routine_type
name|subroutine_type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|indent
decl_stmt|;
name|int
name|want_close
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uncond
condition|)
name|indent
operator|=
literal|"  "
expr_stmt|;
elseif|else
if|if
condition|(
name|test
operator|->
name|type
operator|==
name|DT_accept_op
operator|||
name|test
operator|->
name|type
operator|==
name|DT_accept_insn
condition|)
block|{
name|fputs
argument_list|(
literal|"    {\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|"      "
expr_stmt|;
name|want_close
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|indent
operator|=
literal|"    "
expr_stmt|;
if|if
condition|(
name|test
operator|->
name|type
operator|==
name|DT_accept_op
condition|)
block|{
name|printf
argument_list|(
literal|"%soperands[%d] = x%d;\n"
argument_list|,
name|indent
argument_list|,
name|test
operator|->
name|u
operator|.
name|opno
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Only allow DT_accept_insn to follow.  */
if|if
condition|(
name|test
operator|->
name|next
condition|)
block|{
name|test
operator|=
name|test
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|test
operator|->
name|type
operator|!=
name|DT_accept_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Sanity check that we're now at the end of the list of tests.  */
if|if
condition|(
name|test
operator|->
name|next
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|test
operator|->
name|type
operator|==
name|DT_accept_insn
condition|)
block|{
switch|switch
condition|(
name|subroutine_type
condition|)
block|{
case|case
name|RECOG
case|:
if|if
condition|(
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s*pnum_clobbers = %d;\n"
argument_list|,
name|indent
argument_list|,
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sreturn %d;\n"
argument_list|,
name|indent
argument_list|,
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPLIT
case|:
name|printf
argument_list|(
literal|"%sreturn gen_split_%d (operands);\n"
argument_list|,
name|indent
argument_list|,
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|PEEPHOLE2
case|:
block|{
name|int
name|match_len
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|position
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|p
operator|->
name|position
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|match_len
operator|=
name|p
operator|->
name|position
index|[
name|i
index|]
operator|-
literal|'A'
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s*_pmatch_len = %d;\n"
argument_list|,
name|indent
argument_list|,
name|match_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%stem = gen_peephole2_%d (insn, operands);\n"
argument_list|,
name|indent
argument_list|,
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sif (tem != 0)\n%s  return tem;\n"
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%sgoto L%d;\n"
argument_list|,
name|indent
argument_list|,
name|success
operator|->
name|number
argument_list|)
expr_stmt|;
name|success
operator|->
name|need_label
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|want_close
condition|)
name|fputs
argument_list|(
literal|"    }\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the test is always true and has no fallthru path.  Return -1    if the test does have a fallthru path, but requires that the condition be    terminated.  Otherwise return 0 for a normal test.  */
end_comment

begin_comment
comment|/* ??? is_unconditional is a stupid name for a tri-state function.  */
end_comment

begin_function
specifier|static
name|int
name|is_unconditional
parameter_list|(
name|t
parameter_list|,
name|subroutine_type
parameter_list|)
name|struct
name|decision_test
modifier|*
name|t
decl_stmt|;
name|enum
name|routine_type
name|subroutine_type
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|DT_accept_op
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|DT_accept_insn
condition|)
block|{
switch|switch
condition|(
name|subroutine_type
condition|)
block|{
case|case
name|RECOG
case|:
return|return
operator|(
name|t
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|==
literal|0
operator|)
return|;
case|case
name|SPLIT
case|:
return|return
literal|1
return|;
case|case
name|PEEPHOLE2
case|:
return|return
operator|-
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit code for one node -- the conditional and the accompanying action.    Return true if there is no fallthru path.  */
end_comment

begin_function
specifier|static
name|int
name|write_node
parameter_list|(
name|p
parameter_list|,
name|depth
parameter_list|,
name|subroutine_type
parameter_list|)
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|enum
name|routine_type
name|subroutine_type
decl_stmt|;
block|{
name|struct
name|decision_test
modifier|*
name|test
decl_stmt|,
modifier|*
name|last_test
decl_stmt|;
name|int
name|uncond
decl_stmt|;
name|last_test
operator|=
name|test
operator|=
name|p
operator|->
name|tests
expr_stmt|;
name|uncond
operator|=
name|is_unconditional
argument_list|(
name|test
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|uncond
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  if ("
argument_list|)
expr_stmt|;
name|write_cond
argument_list|(
name|test
argument_list|,
name|depth
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|test
operator|=
name|test
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|uncond2
decl_stmt|;
name|last_test
operator|=
name|test
expr_stmt|;
name|uncond2
operator|=
name|is_unconditional
argument_list|(
name|test
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|uncond2
operator|!=
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"\n&& "
argument_list|)
expr_stmt|;
name|write_cond
argument_list|(
name|test
argument_list|,
name|depth
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|write_action
argument_list|(
name|p
argument_list|,
name|last_test
argument_list|,
name|depth
argument_list|,
name|uncond
argument_list|,
name|p
operator|->
name|success
operator|.
name|first
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
return|return
name|uncond
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit code for all of the sibling nodes of HEAD.  */
end_comment

begin_function
specifier|static
name|void
name|write_tree_1
parameter_list|(
name|head
parameter_list|,
name|depth
parameter_list|,
name|subroutine_type
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|enum
name|routine_type
name|subroutine_type
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|uncond
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|first
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
comment|/* The label for the first element was printed in write_tree.  */
if|if
condition|(
name|p
operator|!=
name|head
operator|->
name|first
operator|&&
name|p
operator|->
name|need_label
condition|)
name|OUTPUT_LABEL
argument_list|(
literal|" "
argument_list|,
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Attempt to write a switch statement for a whole sequence.  */
name|next
operator|=
name|write_switch
argument_list|(
name|p
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|next
condition|)
name|uncond
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Failed -- fall back and write one node.  */
name|uncond
operator|=
name|write_node
argument_list|(
name|p
argument_list|,
name|depth
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Finished with this chain.  Close a fallthru path by branching      to the afterward node.  */
if|if
condition|(
operator|!
name|uncond
condition|)
name|write_afterward
argument_list|(
name|head
operator|->
name|last
argument_list|,
name|head
operator|->
name|last
operator|->
name|afterward
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the decision tree starting at HEAD.  PREVPOS is the    position at the node that branched to this node.  */
end_comment

begin_function
specifier|static
name|void
name|write_tree
parameter_list|(
name|head
parameter_list|,
name|prevpos
parameter_list|,
name|type
parameter_list|,
name|initial
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
specifier|const
name|char
modifier|*
name|prevpos
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
name|int
name|initial
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|p
init|=
name|head
operator|->
name|first
decl_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|need_label
condition|)
name|OUTPUT_LABEL
argument_list|(
literal|" "
argument_list|,
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initial
operator|&&
name|p
operator|->
name|subroutine_number
operator|>
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|name_prefix
index|[]
init|=
block|{
literal|"recog"
block|,
literal|"split"
block|,
literal|"peephole2"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|call_suffix
index|[]
init|=
block|{
literal|", pnum_clobbers"
block|,
literal|""
block|,
literal|", _pmatch_len"
block|}
decl_stmt|;
comment|/* This node has been broken out into a separate subroutine. 	 Call it, test the result, and branch accordingly.  */
if|if
condition|(
name|p
operator|->
name|afterward
condition|)
block|{
name|printf
argument_list|(
literal|"  tem = %s_%d (x0, insn%s);\n"
argument_list|,
name|name_prefix
index|[
name|type
index|]
argument_list|,
name|p
operator|->
name|subroutine_number
argument_list|,
name|call_suffix
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPLIT
argument_list|(
name|type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"  if (tem != 0)\n    return tem;\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  if (tem>= 0)\n    return tem;\n"
argument_list|)
expr_stmt|;
name|change_state
argument_list|(
name|p
operator|->
name|position
argument_list|,
name|p
operator|->
name|afterward
operator|->
name|position
argument_list|,
name|NULL
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  goto L%d;\n"
argument_list|,
name|p
operator|->
name|afterward
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  return %s_%d (x0, insn%s);\n"
argument_list|,
name|name_prefix
index|[
name|type
index|]
argument_list|,
name|p
operator|->
name|subroutine_number
argument_list|,
name|call_suffix
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|depth
init|=
name|strlen
argument_list|(
name|p
operator|->
name|position
argument_list|)
decl_stmt|;
name|change_state
argument_list|(
name|prevpos
argument_list|,
name|p
operator|->
name|position
argument_list|,
name|head
operator|->
name|last
operator|->
name|afterward
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|write_tree_1
argument_list|(
name|head
argument_list|,
name|depth
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|first
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|success
operator|.
name|first
condition|)
name|write_tree
argument_list|(
operator|&
name|p
operator|->
name|success
argument_list|,
name|p
operator|->
name|position
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out a subroutine of type TYPE to do comparisons starting at    node TREE.  */
end_comment

begin_function
specifier|static
name|void
name|write_subroutine
parameter_list|(
name|head
parameter_list|,
name|type
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
block|{
name|int
name|subfunction
init|=
name|head
operator|->
name|first
condition|?
name|head
operator|->
name|first
operator|->
name|subroutine_number
else|:
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|s_or_e
decl_stmt|;
name|char
name|extension
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s_or_e
operator|=
name|subfunction
condition|?
literal|"static "
else|:
literal|""
expr_stmt|;
if|if
condition|(
name|subfunction
condition|)
name|sprintf
argument_list|(
name|extension
argument_list|,
literal|"_%d"
argument_list|,
name|subfunction
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|RECOG
condition|)
name|extension
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|extension
argument_list|,
literal|"_insns"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RECOG
case|:
name|printf
argument_list|(
literal|"%sint recog%s PARAMS ((rtx, rtx, int *));\n"
argument_list|,
name|s_or_e
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sint\n\ recog%s (x0, insn, pnum_clobbers)\n\      rtx x0 ATTRIBUTE_UNUSED;\n\      rtx insn ATTRIBUTE_UNUSED;\n\      int *pnum_clobbers ATTRIBUTE_UNUSED;\n"
argument_list|,
name|s_or_e
argument_list|,
name|extension
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPLIT
case|:
name|printf
argument_list|(
literal|"%srtx split%s PARAMS ((rtx, rtx));\n"
argument_list|,
name|s_or_e
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%srtx\n\ split%s (x0, insn)\n\      rtx x0 ATTRIBUTE_UNUSED;\n\      rtx insn ATTRIBUTE_UNUSED;\n"
argument_list|,
name|s_or_e
argument_list|,
name|extension
argument_list|)
expr_stmt|;
break|break;
case|case
name|PEEPHOLE2
case|:
name|printf
argument_list|(
literal|"%srtx peephole2%s PARAMS ((rtx, rtx, int *));\n"
argument_list|,
name|s_or_e
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%srtx\n\ peephole2%s (x0, insn, _pmatch_len)\n\      rtx x0 ATTRIBUTE_UNUSED;\n\      rtx insn ATTRIBUTE_UNUSED;\n\      int *_pmatch_len ATTRIBUTE_UNUSED;\n"
argument_list|,
name|s_or_e
argument_list|,
name|extension
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"{\n  rtx * const operands ATTRIBUTE_UNUSED =&recog_data.operand[0];\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|max_depth
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  rtx x%d ATTRIBUTE_UNUSED;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %s tem ATTRIBUTE_UNUSED;\n"
argument_list|,
name|IS_SPLIT
argument_list|(
name|type
argument_list|)
condition|?
literal|"rtx"
else|:
literal|"int"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subfunction
condition|)
name|printf
argument_list|(
literal|"  recog_data.insn = NULL_RTX;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|first
condition|)
name|write_tree
argument_list|(
name|head
argument_list|,
literal|""
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  goto ret0;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ret0:\n  return %d;\n}\n\n"
argument_list|,
name|IS_SPLIT
argument_list|(
name|type
argument_list|)
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In break_out_subroutines, we discovered the boundaries for the    subroutines, but did not write them out.  Do so now.  */
end_comment

begin_function
specifier|static
name|void
name|write_subroutines
parameter_list|(
name|head
parameter_list|,
name|type
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|first
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|success
operator|.
name|first
condition|)
name|write_subroutines
argument_list|(
operator|&
name|p
operator|->
name|success
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|first
operator|->
name|subroutine_number
operator|>
literal|0
condition|)
name|write_subroutine
argument_list|(
name|head
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin the output file.  */
end_comment

begin_function
specifier|static
name|void
name|write_header
parameter_list|()
block|{
name|puts
argument_list|(
literal|"\ /* Generated automatically by the program `genrecog' from the target\n\    machine description file.  */\n\ \n\ #include \"config.h\"\n\ #include \"system.h\"\n\ #include \"rtl.h\"\n\ #include \"tm_p.h\"\n\ #include \"function.h\"\n\ #include \"insn-config.h\"\n\ #include \"recog.h\"\n\ #include \"real.h\"\n\ #include \"output.h\"\n\ #include \"flags.h\"\n\ #include \"hard-reg-set.h\"\n\ #include \"resource.h\"\n\ #include \"toplev.h\"\n\ #include \"reload.h\"\n\ \n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n\ /* `recog' contains a decision tree that recognizes whether the rtx\n\    X0 is a valid instruction.\n\ \n\    recog returns -1 if the rtx is not valid.  If the rtx is valid, recog\n\    returns a nonnegative number which is the insn code number for the\n\    pattern that matched.  This is the same as the order in the machine\n\    description of the entry that matched.  This number can be used as an\n\    index into `insn_data' and other tables.\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\    The third argument to recog is an optional pointer to an int.  If\n\    present, recog will accept a pattern if it matches except for missing\n\    CLOBBER expressions at the end.  In that case, the value pointed to by\n\    the optional pointer will be set to the number of CLOBBERs that need\n\    to be added (it should be initialized to zero by the caller).  If it"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\    is set nonzero, the caller should allocate a PARALLEL of the\n\    appropriate size, copy the initial entries, and call add_clobbers\n\    (found in insn-emit.c) to fill in the CLOBBERs.\n\ "
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n\    The function split_insns returns 0 if the rtl could not\n\    be split or the split rtl in a SEQUENCE if it can be.\n\ \n\    The function peephole2_insns returns 0 if the rtl could not\n\    be matched. If there was a match, the new rtl is returned in a SEQUENCE,\n\    and LAST_INSN will point to the last recognized insn in the old sequence.\n\ */\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct and return a sequence of decisions    that will recognize INSN.     TYPE says what type of routine we are recognizing (RECOG or SPLIT).  */
end_comment

begin_function
specifier|static
name|struct
name|decision_head
name|make_insn_sequence
parameter_list|(
name|insn
parameter_list|,
name|type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|routine_type
name|type
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_test
init|=
name|XSTR
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
condition|?
literal|2
else|:
literal|1
argument_list|)
decl_stmt|;
name|struct
name|decision
modifier|*
name|last
decl_stmt|;
name|struct
name|decision_test
modifier|*
name|test
decl_stmt|,
modifier|*
modifier|*
name|place
decl_stmt|;
name|struct
name|decision_head
name|head
decl_stmt|;
name|char
name|c_test_pos
index|[
literal|2
index|]
decl_stmt|;
name|record_insn_name
argument_list|(
name|next_insn_code
argument_list|,
operator|(
name|type
operator|==
name|RECOG
condition|?
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|c_test_pos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PEEPHOLE2
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* peephole2 gets special treatment: 	 - X always gets an outer parallel even if it's only one entry 	 - we remove all traces of outer-level match_scratch and match_dup            expressions here.  */
name|x
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tmp
init|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|MATCH_SCRATCH
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|MATCH_DUP
condition|)
block|{
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|j
expr_stmt|;
name|c_test_pos
index|[
literal|0
index|]
operator|=
literal|'A'
operator|+
name|j
operator|-
literal|1
expr_stmt|;
name|c_test_pos
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
argument_list|)
operator|==
literal|1
condition|)
name|x
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|x
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XVEC
argument_list|(
name|insn
argument_list|,
name|type
operator|==
name|RECOG
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
name|validate_pattern
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|head
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|add_to_sequence
argument_list|(
name|x
argument_list|,
operator|&
name|head
argument_list|,
literal|""
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Find the end of the test chain on the last node.  */
for|for
control|(
name|test
operator|=
name|last
operator|->
name|tests
init|;
name|test
operator|->
name|next
condition|;
name|test
operator|=
name|test
operator|->
name|next
control|)
continue|continue;
name|place
operator|=
operator|&
name|test
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|c_test
index|[
literal|0
index|]
condition|)
block|{
comment|/* Need a new node if we have another test to add.  */
if|if
condition|(
name|test
operator|->
name|type
operator|==
name|DT_accept_op
condition|)
block|{
name|last
operator|=
name|new_decision
argument_list|(
name|c_test_pos
argument_list|,
operator|&
name|last
operator|->
name|success
argument_list|)
expr_stmt|;
name|place
operator|=
operator|&
name|last
operator|->
name|tests
expr_stmt|;
block|}
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_c_test
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|c_test
operator|=
name|c_test
expr_stmt|;
block|}
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_accept_insn
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
operator|=
name|next_insn_code
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|lineno
operator|=
name|pattern_lineno
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RECOG
case|:
comment|/* If this is an DEFINE_INSN and X is a PARALLEL, see if it ends 	 with a group of CLOBBERs of (hard) registers or MATCH_SCRATCHes. 	 If so, set up to recognize the pattern without these CLOBBERs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Find the last non-clobber in the parallel.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|CLOBBER
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MATCH_SCRATCH
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|new
decl_stmt|;
name|struct
name|decision_head
name|clobber_head
decl_stmt|;
comment|/* Build a similar insn without the clobbers.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|new
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|new
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|XVECEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Recognize it.  */
name|memset
argument_list|(
operator|&
name|clobber_head
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|clobber_head
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|add_to_sequence
argument_list|(
name|new
argument_list|,
operator|&
name|clobber_head
argument_list|,
literal|""
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Find the end of the test chain on the last node.  */
for|for
control|(
name|test
operator|=
name|last
operator|->
name|tests
init|;
name|test
operator|->
name|next
condition|;
name|test
operator|=
name|test
operator|->
name|next
control|)
continue|continue;
comment|/* We definitely have a new test to add -- create a new 		 node if needed.  */
name|place
operator|=
operator|&
name|test
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|test
operator|->
name|type
operator|==
name|DT_accept_op
condition|)
block|{
name|last
operator|=
name|new_decision
argument_list|(
literal|""
argument_list|,
operator|&
name|last
operator|->
name|success
argument_list|)
expr_stmt|;
name|place
operator|=
operator|&
name|last
operator|->
name|tests
expr_stmt|;
block|}
if|if
condition|(
name|c_test
index|[
literal|0
index|]
condition|)
block|{
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_c_test
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|c_test
operator|=
name|c_test
expr_stmt|;
block|}
name|test
operator|=
name|new_decision_test
argument_list|(
name|DT_accept_insn
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
operator|=
name|next_insn_code
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|lineno
operator|=
name|pattern_lineno
expr_stmt|;
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
name|i
expr_stmt|;
name|merge_trees
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|clobber_head
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SPLIT
case|:
comment|/* Define the subroutine we will call below and emit in genemit.  */
name|printf
argument_list|(
literal|"extern rtx gen_split_%d PARAMS ((rtx *));\n"
argument_list|,
name|next_insn_code
argument_list|)
expr_stmt|;
break|break;
case|case
name|PEEPHOLE2
case|:
comment|/* Define the subroutine we will call below and emit in genemit.  */
name|printf
argument_list|(
literal|"extern rtx gen_peephole2_%d PARAMS ((rtx, rtx *));\n"
argument_list|,
name|next_insn_code
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|head
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_tree
parameter_list|(
name|head
parameter_list|,
name|subroutine_type
parameter_list|)
name|struct
name|decision_head
modifier|*
name|head
decl_stmt|;
name|enum
name|routine_type
name|subroutine_type
decl_stmt|;
block|{
if|if
condition|(
name|head
operator|->
name|first
operator|==
name|NULL
condition|)
block|{
comment|/* We can elide peephole2_insns, but not recog or split_insns.  */
if|if
condition|(
name|subroutine_type
operator|==
name|PEEPHOLE2
condition|)
return|return;
block|}
else|else
block|{
name|factor_tests
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|next_subroutine_number
operator|=
literal|0
expr_stmt|;
name|break_out_subroutines
argument_list|(
name|head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|find_afterward
argument_list|(
name|head
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We run this after find_afterward, because find_afterward needs 	 the redundant DT_mode tests on predicates to determine whether 	 two tests can both be true or not.  */
name|simplify_tests
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|write_subroutines
argument_list|(
name|head
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
block|}
name|write_subroutine
argument_list|(
name|head
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|struct
name|decision_head
name|recog_tree
decl_stmt|,
name|split_tree
decl_stmt|,
name|peephole2_tree
decl_stmt|,
name|h
decl_stmt|;
name|progname
operator|=
literal|"genrecog"
expr_stmt|;
name|memset
argument_list|(
operator|&
name|recog_tree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|recog_tree
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|split_tree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|split_tree
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|peephole2_tree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|peephole2_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"no input file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|next_insn_code
operator|=
literal|0
expr_stmt|;
name|next_index
operator|=
literal|0
expr_stmt|;
name|write_header
argument_list|()
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|pattern_lineno
argument_list|,
operator|&
name|next_insn_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
block|{
name|h
operator|=
name|make_insn_sequence
argument_list|(
name|desc
argument_list|,
name|RECOG
argument_list|)
expr_stmt|;
name|merge_trees
argument_list|(
operator|&
name|recog_tree
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
block|{
name|h
operator|=
name|make_insn_sequence
argument_list|(
name|desc
argument_list|,
name|SPLIT
argument_list|)
expr_stmt|;
name|merge_trees
argument_list|(
operator|&
name|split_tree
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE2
condition|)
block|{
name|h
operator|=
name|make_insn_sequence
argument_list|(
name|desc
argument_list|,
name|PEEPHOLE2
argument_list|)
expr_stmt|;
name|merge_trees
argument_list|(
operator|&
name|peephole2_tree
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
block|}
name|next_index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|error_count
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
name|puts
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|process_tree
argument_list|(
operator|&
name|recog_tree
argument_list|,
name|RECOG
argument_list|)
expr_stmt|;
name|process_tree
argument_list|(
operator|&
name|split_tree
argument_list|,
name|SPLIT
argument_list|)
expr_stmt|;
name|process_tree
argument_list|(
operator|&
name|peephole2_tree
argument_list|,
name|PEEPHOLE2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_insn_name
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|code
operator|<
name|insn_name_ptr_size
condition|)
return|return
name|insn_name_ptr
index|[
name|code
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_insn_name
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|int
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|last_real_name
init|=
literal|"insn"
decl_stmt|;
specifier|static
name|int
name|last_real_code
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|insn_name_ptr_size
operator|<=
name|code
condition|)
block|{
name|int
name|new_size
decl_stmt|;
name|new_size
operator|=
operator|(
name|insn_name_ptr_size
condition|?
name|insn_name_ptr_size
operator|*
literal|2
else|:
literal|512
operator|)
expr_stmt|;
name|insn_name_ptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|insn_name_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|new_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|insn_name_ptr
operator|+
name|insn_name_ptr_size
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|new_size
operator|-
name|insn_name_ptr_size
operator|)
argument_list|)
expr_stmt|;
name|insn_name_ptr_size
operator|=
name|new_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|name
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|last_real_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s+%d"
argument_list|,
name|last_real_name
argument_list|,
name|code
operator|-
name|last_real_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last_real_name
operator|=
name|new
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|last_real_code
operator|=
name|code
expr_stmt|;
block|}
name|insn_name_ptr
index|[
name|code
index|]
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|debug_decision_2
parameter_list|(
name|test
parameter_list|)
name|struct
name|decision_test
modifier|*
name|test
decl_stmt|;
block|{
switch|switch
condition|(
name|test
operator|->
name|type
condition|)
block|{
case|case
name|DT_mode
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mode=%s"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|test
operator|->
name|u
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_code
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"code=%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|test
operator|->
name|u
operator|.
name|code
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_veclen
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"veclen=%d"
argument_list|,
name|test
operator|->
name|u
operator|.
name|veclen
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_int
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elt0_i=%d"
argument_list|,
operator|(
name|int
operator|)
name|test
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_one_int
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elt1_i=%d"
argument_list|,
operator|(
name|int
operator|)
name|test
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_wide
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elt0_w="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|test
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_elt_zero_wide_safe
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elt0_ws="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|test
operator|->
name|u
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_veclen_ge
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"veclen>=%d"
argument_list|,
name|test
operator|->
name|u
operator|.
name|veclen
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_dup
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dup=%d"
argument_list|,
name|test
operator|->
name|u
operator|.
name|dup
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_pred
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pred=(%s,%s)"
argument_list|,
name|test
operator|->
name|u
operator|.
name|pred
operator|.
name|name
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|test
operator|->
name|u
operator|.
name|pred
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_c_test
case|:
block|{
name|char
name|sub
index|[
literal|16
operator|+
literal|4
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|sub
argument_list|,
name|test
operator|->
name|u
operator|.
name|c_test
argument_list|,
sizeof|sizeof
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sub
operator|+
literal|16
argument_list|,
literal|"..."
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_test=\"%s\""
argument_list|,
name|sub
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_accept_op
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"A_op=%d"
argument_list|,
name|test
operator|->
name|u
operator|.
name|opno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_accept_insn
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"A_insn=(%d,%d)"
argument_list|,
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|code_number
argument_list|,
name|test
operator|->
name|u
operator|.
name|insn
operator|.
name|num_clobbers_to_add
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|debug_decision_1
parameter_list|(
name|d
parameter_list|,
name|indent
parameter_list|)
name|struct
name|decision
modifier|*
name|d
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|decision_test
modifier|*
name|test
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
operator|++
name|i
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"(nil)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
operator|++
name|i
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'{'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|test
operator|=
name|d
operator|->
name|tests
expr_stmt|;
if|if
condition|(
name|test
condition|)
block|{
name|debug_decision_2
argument_list|(
name|test
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|test
operator|=
name|test
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|" + "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|debug_decision_2
argument_list|(
name|test
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"} %d n %d a %d\n"
argument_list|,
name|d
operator|->
name|number
argument_list|,
operator|(
name|d
operator|->
name|next
condition|?
name|d
operator|->
name|next
operator|->
name|number
else|:
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|d
operator|->
name|afterward
condition|?
name|d
operator|->
name|afterward
operator|->
name|number
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_decision_0
parameter_list|(
name|d
parameter_list|,
name|indent
parameter_list|,
name|maxdepth
parameter_list|)
name|struct
name|decision
modifier|*
name|d
decl_stmt|;
name|int
name|indent
decl_stmt|,
name|maxdepth
decl_stmt|;
block|{
name|struct
name|decision
modifier|*
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|maxdepth
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
operator|++
name|i
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"(nil)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug_decision_1
argument_list|(
name|d
argument_list|,
name|indent
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|d
operator|->
name|success
operator|.
name|first
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|debug_decision_0
argument_list|(
name|n
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|maxdepth
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_decision
parameter_list|(
name|d
parameter_list|)
name|struct
name|decision
modifier|*
name|d
decl_stmt|;
block|{
name|debug_decision_0
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_decision_list
parameter_list|(
name|d
parameter_list|)
name|struct
name|decision
modifier|*
name|d
decl_stmt|;
block|{
while|while
condition|(
name|d
condition|)
block|{
name|debug_decision_0
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

