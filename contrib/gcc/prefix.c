begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utility to update paths from internal to external forms.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains routines to update a path, both to canonicalize    the directory format and to handle any prefix translation.     This file must be compiled with -DPREFIX= to specify the "prefix"    value used by configure.  If a filename does not begin with this    prefix, it will not be affected other than by directory canonicalization.     Each caller of 'update_path' may specify both a filename and    a translation prefix and consist of the name of the package that contains    the file ("@GCC", "@BINUTIL", "@GNU", etc).     If the prefix is not specified, the filename will only undergo    directory canonicalization.     If it is specified, the string given by PREFIX will be replaced    by the specified prefix (with a '@' in front unless the prefix begins    with a '$') and further translation will be done as follows    until none of the two conditions below are met:     1) If the filename begins with '@', the string between the '@' and    the end of the name or the first '/' or directory separator will    be considered a "key" and looked up as follows:     -- If this is a Win32 OS, then the Registry will be examined for       an entry of "key" in        HKEY_LOCAL_MACHINE\SOFTWARE\Free Software Foundation\<KEY>        if found, that value will be used.<KEY> defaults to GCC version       string, but can be overridden at configuration time.     -- If not found (or not a Win32 OS), the environment variable       key_ROOT (the value of "key" concatenated with the constant "_ROOT")       is tried.  If that fails, then PREFIX (see above) is used.     2) If the filename begins with a '$', the rest of the string up    to the end or the first '/' or directory separator will be used    as an environment variable, whose value will be returned.     Once all this is done, any '/' will be converted to DIR_SEPARATOR,    if they are different.     NOTE:  using resolve_keyed_path under Win32 requires linking with    advapi32.dll.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_WIN32_REGISTRY
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|std_prefix
init|=
name|PREFIX
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_key_value
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|translate_name
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_WIN32_REGISTRY
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|lookup_key
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|HKEY
name|reg_key
init|=
operator|(
name|HKEY
operator|)
name|INVALID_HANDLE_VALUE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given KEY, as above, return its value.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_key_value
parameter_list|(
name|char
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|temp
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_WIN32_REGISTRY
argument_list|)
name|prefix
operator|=
name|lookup_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prefix
operator|==
literal|0
condition|)
name|prefix
operator|=
name|getenv
argument_list|(
name|temp
operator|=
name|concat
argument_list|(
name|key
argument_list|,
literal|"_ROOT"
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|0
condition|)
name|prefix
operator|=
name|std_prefix
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|prefix
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of a string that has been placed in the heap.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|result
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_WIN32_REGISTRY
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32_REGISTRY_KEY
end_ifndef

begin_define
define|#
directive|define
name|WIN32_REGISTRY_KEY
value|BASEVER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Look up "key" in the registry, as above.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookup_key
parameter_list|(
name|char
modifier|*
name|key
parameter_list|)
block|{
name|char
modifier|*
name|dst
decl_stmt|;
name|DWORD
name|size
decl_stmt|;
name|DWORD
name|type
decl_stmt|;
name|LONG
name|res
decl_stmt|;
if|if
condition|(
name|reg_key
operator|==
operator|(
name|HKEY
operator|)
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|res
operator|=
name|RegOpenKeyExA
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
literal|"SOFTWARE"
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|reg_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|ERROR_SUCCESS
condition|)
name|res
operator|=
name|RegOpenKeyExA
argument_list|(
name|reg_key
argument_list|,
literal|"Free Software Foundation"
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|reg_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|ERROR_SUCCESS
condition|)
name|res
operator|=
name|RegOpenKeyExA
argument_list|(
name|reg_key
argument_list|,
name|WIN32_REGISTRY_KEY
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|reg_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|reg_key
operator|=
operator|(
name|HKEY
operator|)
name|INVALID_HANDLE_VALUE
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|size
operator|=
literal|32
expr_stmt|;
name|dst
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|res
operator|=
name|RegQueryValueExA
argument_list|(
name|reg_key
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
operator|(
name|LPBYTE
operator|)
name|dst
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|ERROR_MORE_DATA
operator|&&
name|type
operator|==
name|REG_SZ
condition|)
block|{
name|dst
operator|=
name|xrealloc
argument_list|(
name|dst
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|res
operator|=
name|RegQueryValueExA
argument_list|(
name|reg_key
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
operator|(
name|LPBYTE
operator|)
name|dst
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|REG_SZ
operator|||
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If NAME, a malloc-ed string, starts with a '@' or '$', apply the    translation rules above and return a newly malloc-ed name.    Otherwise, return the given name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|translate_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|code
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|old_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|keylen
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|code
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|'@'
operator|&&
name|code
operator|!=
literal|'$'
condition|)
break|break;
for|for
control|(
name|keylen
operator|=
literal|0
init|;
operator|(
name|name
index|[
name|keylen
operator|+
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
name|keylen
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|;
name|keylen
operator|++
control|)
empty_stmt|;
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|keylen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|key
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|key
index|[
name|keylen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'@'
condition|)
block|{
name|prefix
operator|=
name|get_key_value
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|0
condition|)
name|prefix
operator|=
name|std_prefix
expr_stmt|;
block|}
else|else
name|prefix
operator|=
name|getenv
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|0
condition|)
name|prefix
operator|=
name|PREFIX
expr_stmt|;
comment|/* We used to strip trailing DIR_SEPARATORs here, but that can 	 sometimes yield a result with no separator when one was coded 	 and intended by the user, causing two path components to run 	 together.  */
name|old_name
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
operator|&
name|name
index|[
name|keylen
operator|+
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* In a NUL-terminated STRING, replace character C1 with C2 in-place.  */
end_comment

begin_function
specifier|static
name|void
name|tr
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|c1
parameter_list|,
name|int
name|c2
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
operator|*
name|string
operator|==
name|c1
condition|)
operator|*
name|string
operator|=
name|c2
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|string
operator|++
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Update PATH using KEY if PATH starts with PREFIX as a directory.    The returned string is always malloc-ed, and the caller is    responsible for freeing it.  */
end_comment

begin_function
name|char
modifier|*
name|update_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|strlen
argument_list|(
name|std_prefix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|path
argument_list|,
name|std_prefix
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|path
index|[
name|len
index|]
argument_list|)
operator|||
name|path
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|key
operator|!=
literal|0
condition|)
block|{
name|bool
name|free_key
init|=
name|false
decl_stmt|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
name|key
operator|=
name|concat
argument_list|(
literal|"@"
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_key
operator|=
name|true
expr_stmt|;
block|}
name|result
operator|=
name|concat
argument_list|(
name|key
argument_list|,
operator|&
name|path
index|[
name|len
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_key
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
name|result
operator|=
name|translate_name
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ALWAYS_STRIP_DOTDOT
define|#
directive|define
name|ALWAYS_STRIP_DOTDOT
value|0
endif|#
directive|endif
name|p
operator|=
name|result
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
comment|/* Look for `/../'  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|p
operator|!=
name|result
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ALWAYS_STRIP_DOTDOT
operator|&&
name|access
argument_list|(
name|result
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* We can't access the dir, so we won't be able to 		 access dir/.. either.  Strip out `dir/../'.  If `dir' 		 turns out to be `.', strip one more path component.  */
name|dest
operator|=
name|p
expr_stmt|;
do|do
block|{
operator|--
name|dest
expr_stmt|;
while|while
condition|(
name|dest
operator|!=
name|result
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
operator|--
name|dest
expr_stmt|;
while|while
condition|(
name|dest
operator|!=
name|result
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|dest
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|dest
expr_stmt|;
block|}
do|while
condition|(
name|dest
operator|!=
name|result
operator|&&
operator|*
name|dest
operator|==
literal|'.'
condition|)
do|;
comment|/* If we have something like `./..' or `/..', don't 		 strip anything more.  */
if|if
condition|(
operator|*
name|dest
operator|==
literal|'.'
operator|||
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
break|break;
block|}
name|src
operator|=
name|p
operator|+
literal|3
expr_stmt|;
while|while
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|src
argument_list|)
condition|)
operator|++
name|src
expr_stmt|;
name|p
operator|=
name|dest
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
block|}
block|}
else|else
operator|++
name|p
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UPDATE_PATH_HOST_CANONICALIZE
comment|/* Perform host dependent canonicalization when needed.  */
name|UPDATE_PATH_HOST_CANONICALIZE
argument_list|(
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
comment|/* Convert DIR_SEPARATOR_2 to DIR_SEPARATOR.  */
if|if
condition|(
name|DIR_SEPARATOR_2
operator|!=
name|DIR_SEPARATOR
condition|)
name|tr
argument_list|(
name|result
argument_list|,
name|DIR_SEPARATOR_2
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DIR_SEPARATOR
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DIR_SEPARATOR_2
argument_list|)
if|if
condition|(
name|DIR_SEPARATOR
operator|!=
literal|'/'
condition|)
name|tr
argument_list|(
name|result
argument_list|,
literal|'/'
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Reset the standard prefix.  */
end_comment

begin_function
name|void
name|set_std_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|std_prefix
operator|=
name|save_string
argument_list|(
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

