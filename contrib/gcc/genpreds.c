begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate from machine description:    - prototype declarations for operand predicates (tm-preds.h)    - function definitions of operand predicates, if defined new-style      (insn-preds.c)    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* Given a predicate expression EXP, from form NAME at line LINENO,    verify that it does not contain any RTL constructs which are not    valid in predicate definitions.  Returns true if EXP is    INvalid; issues error messages, caller need not.  */
end_comment

begin_function
specifier|static
name|bool
name|validate_exp
parameter_list|(
name|rtx
name|exp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"%s: must give a predicate expression"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* Ternary, binary, unary expressions: recurse into subexpressions.  */
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|validate_exp
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* else fall through */
case|case
name|AND
case|:
case|case
name|IOR
case|:
if|if
condition|(
name|validate_exp
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* else fall through */
case|case
name|NOT
case|:
return|return
name|validate_exp
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|)
return|;
comment|/* MATCH_CODE might have a syntax error in its path expression.  */
case|case
name|MATCH_CODE
case|:
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|ISLOWER
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"%s: invalid character in path "
literal|"string '%s'"
argument_list|,
name|name
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
comment|/* fall through */
comment|/* These need no special checking.  */
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_TEST
case|:
return|return
name|false
return|;
default|default:
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"%s: cannot use '%s' in a predicate expression"
argument_list|,
name|name
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Predicates are defined with (define_predicate) or    (define_special_predicate) expressions in the machine description.  */
end_comment

begin_function
specifier|static
name|void
name|process_define_predicate
parameter_list|(
name|rtx
name|defn
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|pred_data
modifier|*
name|pred
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|XSTR
argument_list|(
name|defn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|defn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
goto|goto
name|bad_name
goto|;
for|for
control|(
name|p
operator|=
name|XSTR
argument_list|(
name|defn
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'_'
condition|)
goto|goto
name|bad_name
goto|;
if|if
condition|(
name|validate_exp
argument_list|(
name|XEXP
argument_list|(
name|defn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|defn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lineno
argument_list|)
condition|)
return|return;
name|pred
operator|=
name|XCNEW
argument_list|(
expr|struct
name|pred_data
argument_list|)
expr_stmt|;
name|pred
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|defn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pred
operator|->
name|exp
operator|=
name|XEXP
argument_list|(
name|defn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pred
operator|->
name|c_block
operator|=
name|XSTR
argument_list|(
name|defn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|defn
argument_list|)
operator|==
name|DEFINE_SPECIAL_PREDICATE
condition|)
name|pred
operator|->
name|special
operator|=
name|true
expr_stmt|;
name|add_predicate
argument_list|(
name|pred
argument_list|)
expr_stmt|;
return|return;
name|bad_name
label|:
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"%s: predicate name must be a valid C function name"
argument_list|,
name|XSTR
argument_list|(
name|defn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Given a predicate, if it has an embedded C block, write the block    out as a static inline subroutine, and augment the RTL test with a    match_test that calls that subroutine.  For instance,         (define_predicate "basereg_operand"          (match_operand 0 "register_operand")        {          if (GET_CODE (op) == SUBREG)            op = SUBREG_REG (op);          return REG_POINTER (op);        })     becomes         static inline int basereg_operand_1(rtx op, enum machine_mode mode)        {          if (GET_CODE (op) == SUBREG)            op = SUBREG_REG (op);          return REG_POINTER (op);        }         (define_predicate "basereg_operand"          (and (match_operand 0 "register_operand") 	      (match_test "basereg_operand_1 (op, mode)")))     The only wart is that there's no way to insist on a { } string in    an RTL template, so we have to handle "" strings.  */
end_comment

begin_function
specifier|static
name|void
name|write_predicate_subfunction
parameter_list|(
name|struct
name|pred_data
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|match_test_str
decl_stmt|;
name|rtx
name|match_test_exp
decl_stmt|,
name|and_exp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|c_block
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
comment|/* Construct the function-call expression.  */
name|obstack_grow
argument_list|(
name|rtl_obstack
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|rtl_obstack
argument_list|,
literal|"_1 (op, mode)"
argument_list|,
sizeof|sizeof
expr|"_1 (op, mode)"
argument_list|)
expr_stmt|;
name|match_test_str
operator|=
name|XOBFINISH
argument_list|(
name|rtl_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* Add the function-call expression to the complete expression to be      evaluated.  */
name|match_test_exp
operator|=
name|rtx_alloc
argument_list|(
name|MATCH_TEST
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|match_test_exp
argument_list|,
literal|0
argument_list|)
operator|=
name|match_test_str
expr_stmt|;
name|and_exp
operator|=
name|rtx_alloc
argument_list|(
name|AND
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|and_exp
argument_list|,
literal|0
argument_list|)
operator|=
name|p
operator|->
name|exp
expr_stmt|;
name|XEXP
argument_list|(
name|and_exp
argument_list|,
literal|1
argument_list|)
operator|=
name|match_test_exp
expr_stmt|;
name|p
operator|->
name|exp
operator|=
name|and_exp
expr_stmt|;
name|printf
argument_list|(
literal|"static inline int\n"
literal|"%s_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_rtx_ptr_loc
argument_list|(
name|p
operator|->
name|c_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_block
index|[
literal|0
index|]
operator|==
literal|'{'
condition|)
name|fputs
argument_list|(
name|p
operator|->
name|c_block
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"{\n  %s\n}"
argument_list|,
name|p
operator|->
name|c_block
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a predicate expression EXP, from form NAME, determine whether    it refers to the variable given as VAR.  */
end_comment

begin_function
specifier|static
name|bool
name|needs_variable
parameter_list|(
name|rtx
name|exp
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* Ternary, binary, unary expressions need a variable if 	 any of their subexpressions do.  */
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|needs_variable
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|var
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* else fall through */
case|case
name|AND
case|:
case|case
name|IOR
case|:
if|if
condition|(
name|needs_variable
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|var
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* else fall through */
case|case
name|NOT
case|:
return|return
name|needs_variable
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
return|;
comment|/* MATCH_CODE uses "op", but nothing else.  */
case|case
name|MATCH_CODE
case|:
return|return
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"op"
argument_list|)
return|;
comment|/* MATCH_OPERAND uses "op" and may use "mode".  */
case|case
name|MATCH_OPERAND
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"op"
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"mode"
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
comment|/* MATCH_TEST uses var if XSTR (exp, 0) =~ /\b${var}\b/o; */
case|case
name|MATCH_TEST
case|:
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
init|=
name|strstr
argument_list|(
name|p
argument_list|,
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|false
return|;
if|if
condition|(
name|q
operator|!=
name|p
operator|&&
operator|(
name|ISALNUM
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|)
condition|)
return|return
name|false
return|;
name|q
operator|+=
name|strlen
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISALNUM
argument_list|(
name|q
index|[
literal|0
index|]
operator|||
name|q
index|[
literal|0
index|]
operator|==
literal|'_'
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given an RTL expression EXP, find all subexpressions which we may    assume to perform mode tests.  Normal MATCH_OPERAND does;    MATCH_CODE does if it applies to the whole expression and accepts    CONST_INT or CONST_DOUBLE; and we have to assume that MATCH_TEST    does not.  These combine in almost-boolean fashion - the only    exception is that (not X) must be assumed not to perform a mode    test, whether or not X does.     The mark is the RTL /v flag, which is true for subexpressions which    do *not* perform mode tests. */
end_comment

begin_define
define|#
directive|define
name|NO_MODE_TEST
parameter_list|(
name|EXP
parameter_list|)
value|RTX_FLAG (EXP, volatil)
end_define

begin_function
specifier|static
name|void
name|mark_mode_tests
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
block|{
name|struct
name|pred_data
modifier|*
name|p
init|=
name|lookup_predicate
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
literal|"reference to undefined predicate '%s'"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|special
operator|||
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|NO_MODE_TEST
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|MATCH_CODE
case|:
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
operator|(
operator|!
name|strstr
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"const_int"
argument_list|)
operator|&&
operator|!
name|strstr
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"const_double"
argument_list|)
operator|)
condition|)
name|NO_MODE_TEST
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MATCH_TEST
case|:
case|case
name|NOT
case|:
name|NO_MODE_TEST
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|mark_mode_tests
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mark_mode_tests
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|NO_MODE_TEST
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|mark_mode_tests
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mark_mode_tests
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|NO_MODE_TEST
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
comment|/* A ? B : C does a mode test if (one of A and B) does a mode 	 test, and C does too.  */
name|mark_mode_tests
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mark_mode_tests
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mark_mode_tests
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|NO_MODE_TEST
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
operator|(
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine whether the expression EXP is a MATCH_CODE that should    be written as a switch statement.  */
end_comment

begin_function
specifier|static
name|bool
name|generate_switch_p
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|MATCH_CODE
operator|&&
name|strchr
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|','
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a predicate, work out where in its RTL expression to add    tests for proper modes.  Special predicates do not get any such    tests.  We try to avoid adding tests when we don't have to; in    particular, other normal predicates can be counted on to do it for    us.  */
end_comment

begin_function
specifier|static
name|void
name|add_mode_tests
parameter_list|(
name|struct
name|pred_data
modifier|*
name|p
parameter_list|)
block|{
name|rtx
name|match_test_exp
decl_stmt|,
name|and_exp
decl_stmt|;
name|rtx
modifier|*
name|pos
decl_stmt|;
comment|/* Don't touch special predicates.  */
if|if
condition|(
name|p
operator|->
name|special
condition|)
return|return;
name|mark_mode_tests
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
comment|/* If the whole expression already tests the mode, we're done.  */
if|if
condition|(
operator|!
name|NO_MODE_TEST
argument_list|(
name|p
operator|->
name|exp
argument_list|)
condition|)
return|return;
name|match_test_exp
operator|=
name|rtx_alloc
argument_list|(
name|MATCH_TEST
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|match_test_exp
argument_list|,
literal|0
argument_list|)
operator|=
literal|"mode == VOIDmode || GET_MODE (op) == mode"
expr_stmt|;
name|and_exp
operator|=
name|rtx_alloc
argument_list|(
name|AND
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|and_exp
argument_list|,
literal|1
argument_list|)
operator|=
name|match_test_exp
expr_stmt|;
comment|/* It is always correct to rewrite p->exp as          (and (...) (match_test "mode == VOIDmode || GET_MODE (op) == mode"))       but there are a couple forms where we can do better.  If the      top-level pattern is an IOR, and one of the two branches does test      the mode, we can wrap just the branch that doesn't.  Likewise, if      we have an IF_THEN_ELSE, and one side of it tests the mode, we can      wrap just the side that doesn't.  And, of course, we can repeat this      descent as many times as it works.  */
name|pos
operator|=
operator|&
name|p
operator|->
name|exp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rtx
name|subexp
init|=
operator|*
name|pos
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|subexp
argument_list|)
condition|)
block|{
case|case
name|AND
case|:
comment|/* The switch code generation in write_predicate_stmts prefers 	     rtx code tests to be at the top of the expression tree.  So 	     push this AND down into the second operand of an existing 	     AND expression.  */
if|if
condition|(
name|generate_switch_p
argument_list|(
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|pos
operator|=
operator|&
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|break_loop
goto|;
case|case
name|IOR
case|:
block|{
name|int
name|test0
init|=
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|test1
init|=
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|test0
operator|||
name|test1
argument_list|)
expr_stmt|;
if|if
condition|(
name|test0
operator|&&
name|test1
condition|)
goto|goto
name|break_loop
goto|;
name|pos
operator|=
name|test0
condition|?
operator|&
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|0
argument_list|)
else|:
operator|&
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
block|{
name|int
name|test0
init|=
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|test1
init|=
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|test2
init|=
name|NO_MODE_TEST
argument_list|(
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|test0
operator|&&
name|test1
operator|)
operator|||
name|test2
argument_list|)
expr_stmt|;
if|if
condition|(
name|test0
operator|&&
name|test1
operator|&&
name|test2
condition|)
goto|goto
name|break_loop
goto|;
if|if
condition|(
name|test0
operator|&&
name|test1
condition|)
comment|/* Must put it on the dependent clause, not the 	      	 controlling expression, or we change the meaning of 	      	 the test.  */
name|pos
operator|=
operator|&
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|pos
operator|=
operator|&
name|XEXP
argument_list|(
name|subexp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|break_loop
goto|;
block|}
block|}
name|break_loop
label|:
name|XEXP
argument_list|(
name|and_exp
argument_list|,
literal|0
argument_list|)
operator|=
operator|*
name|pos
expr_stmt|;
operator|*
name|pos
operator|=
name|and_exp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PATH is a string describing a path from the root of an RTL    expression to an inner subexpression to be tested.  Output    code which computes the subexpression from the variable    holding the root of the expression.  */
end_comment

begin_function
specifier|static
name|void
name|write_extract_subexp
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We first write out the operations (XEXP or XVECEXP) in reverse      order, then write "op", then the indices in forward order.  */
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ISLOWER
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"XVECEXP ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"XEXP ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"op"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISLOWER
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", 0, %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* CODES is a list of RTX codes.  Write out an expression which    determines whether the operand has one of those codes.  */
end_comment

begin_function
specifier|static
name|void
name|write_match_code
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|codes
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|code
decl_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|scan_comma_elt
argument_list|(
operator|&
name|codes
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"GET_CODE ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_extract_subexp
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") == "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|code
operator|<
name|codes
condition|)
block|{
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
operator|*
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|codes
operator|==
literal|','
condition|)
name|fputs
argument_list|(
literal|" || "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EXP is an RTL (sub)expression for a predicate.  Recursively    descend the expression and write out an equivalent C expression.  */
end_comment

begin_function
specifier|static
name|void
name|write_predicate_expr
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|AND
case|:
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")&& ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") || ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|fputs
argument_list|(
literal|"!("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") ? ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") : ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_OPERAND
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
name|printf
argument_list|(
literal|"%s (op, mode)"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s (op, %smode)"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode_name
index|[
name|GET_MODE
argument_list|(
name|exp
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_CODE
case|:
name|write_match_code
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_TEST
case|:
name|print_c_condition
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the MATCH_CODE expression EXP as a switch statement.  */
end_comment

begin_function
specifier|static
name|void
name|write_match_code_switch
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|codes
init|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|code
decl_stmt|;
name|fputs
argument_list|(
literal|"  switch (GET_CODE ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_extract_subexp
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"))\n    {\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|scan_comma_elt
argument_list|(
operator|&
name|codes
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"    case "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|code
operator|<
name|codes
condition|)
block|{
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
operator|*
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a predicate expression EXP, write out a sequence of stmts    to evaluate it.  This is similar to write_predicate_expr but can    generate efficient switch statements.  */
end_comment

begin_function
specifier|static
name|void
name|write_predicate_stmts
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|MATCH_CODE
case|:
if|if
condition|(
name|generate_switch_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|write_match_code_switch
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"      return true;\n"
literal|"    default:\n"
literal|"      break;\n"
literal|"    }\n"
literal|"  return false;"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|generate_switch_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|write_match_code_switch
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"      break;\n"
literal|"    default:\n"
literal|"      return false;\n"
literal|"    }"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|generate_switch_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|write_match_code_switch
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"      return true;\n"
literal|"    default:\n"
literal|"      break;\n"
literal|"    }"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOT
case|:
if|if
condition|(
name|generate_switch_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|write_match_code_switch
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"      return false;\n"
literal|"    default:\n"
literal|"      break;\n"
literal|"    }\n"
literal|"  return true;"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
name|fputs
argument_list|(
literal|"  return "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|write_predicate_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a predicate, write out a complete C function to compute it.  */
end_comment

begin_function
specifier|static
name|void
name|write_one_predicate_function
parameter_list|(
name|struct
name|pred_data
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|exp
condition|)
return|return;
name|write_predicate_subfunction
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|add_mode_tests
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* A normal predicate can legitimately not look at enum machine_mode      if it accepts only CONST_INTs and/or CONST_DOUBLEs.  */
name|printf
argument_list|(
literal|"int\n%s (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n{\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|write_predicate_stmts
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"}\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constraints fall into two categories: register constraints    (define_register_constraint), and others (define_constraint,    define_memory_constraint, define_address_constraint).  We    work out automatically which of the various old-style macros    they correspond to, and produce appropriate code.  They all    go in the same hash table so we can verify that there are no    duplicate names.  */
end_comment

begin_comment
comment|/* All data from one constraint definition.  */
end_comment

begin_struct
struct|struct
name|constraint_data
block|{
name|struct
name|constraint_data
modifier|*
name|next_this_letter
decl_stmt|;
name|struct
name|constraint_data
modifier|*
name|next_textual
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_name
decl_stmt|;
comment|/* same as .name unless mangling is necessary */
name|size_t
name|namelen
decl_stmt|;
specifier|const
name|char
modifier|*
name|regclass
decl_stmt|;
comment|/* for register constraints */
name|rtx
name|exp
decl_stmt|;
comment|/* for other constraints */
name|unsigned
name|int
name|lineno
decl_stmt|;
comment|/* line of definition */
name|unsigned
name|int
name|is_register
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_const_int
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_const_dbl
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_extra
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_memory
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_address
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Overview of all constraints beginning with a given letter.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|constraint_data
modifier|*
name|constraints_by_letter_table
index|[
literal|1
operator|<<
name|CHAR_BIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For looking up all the constraints in the order that they appeared    in the machine description.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|constraint_data
modifier|*
name|first_constraint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constraint_data
modifier|*
modifier|*
name|last_constraint_ptr
init|=
operator|&
name|first_constraint
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FOR_ALL_CONSTRAINTS
parameter_list|(
name|iter_
parameter_list|)
define|\
value|for (iter_ = first_constraint; iter_; iter_ = iter_->next_textual)
end_define

begin_comment
comment|/* These letters, and all names beginning with them, are reserved for    generic constraints.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|generic_constraint_letters
index|[]
init|=
literal|"EFVXgimnoprs"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machine-independent code expects that constraints with these    (initial) letters will allow only (a subset of all) CONST_INTs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|const_int_constraints
index|[]
init|=
literal|"IJKLMNOP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machine-independent code expects that constraints with these    (initial) letters will allow only (a subset of all) CONST_DOUBLEs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|const_dbl_constraints
index|[]
init|=
literal|"GH"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Summary data used to decide whether to output various functions and    macro definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|constraint_max_namelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|have_register_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|have_memory_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|have_address_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|have_extra_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|have_const_int_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|have_const_dbl_constraints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert NAME, which contains angle brackets and/or underscores, to    a string that can be used as part of a C identifier.  The string    comes from the rtl_obstack.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mangle
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|name
condition|;
name|name
operator|++
control|)
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'_'
case|:
name|obstack_grow
argument_list|(
name|rtl_obstack
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|obstack_grow
argument_list|(
name|rtl_obstack
argument_list|,
literal|"_l"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|obstack_grow
argument_list|(
name|rtl_obstack
argument_list|,
literal|"_g"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|obstack_1grow
argument_list|(
name|rtl_obstack
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|obstack_1grow
argument_list|(
name|rtl_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
name|rtl_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add one constraint, of any sort, to the tables.  NAME is its name;    REGCLASS is the register class, if any; EXP is the expression to    test, if any;  IS_MEMORY and IS_ADDRESS indicate memory and address    constraints, respectively; LINENO is the line number from the MD reader.    Not all combinations of arguments are valid; most importantly, REGCLASS    is mutually exclusive with EXP, and IS_MEMORY/IS_ADDRESS are only    meaningful for constraints with EXP.     This function enforces all syntactic and semantic rules about what    constraints can be defined.  */
end_comment

begin_function
specifier|static
name|void
name|add_constraint
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|regclass
parameter_list|,
name|rtx
name|exp
parameter_list|,
name|bool
name|is_memory
parameter_list|,
name|bool
name|is_address
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|,
modifier|*
modifier|*
name|iter
decl_stmt|,
modifier|*
modifier|*
name|slot
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|need_mangled_name
init|=
name|false
decl_stmt|;
name|bool
name|is_const_int
decl_stmt|;
name|bool
name|is_const_dbl
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
if|if
condition|(
name|exp
operator|&&
name|validate_exp
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint name '%s' is not "
literal|"a letter or underscore"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint name '%s' does not begin "
literal|"with a letter or underscore"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
operator|||
operator|*
name|p
operator|==
literal|'>'
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
name|need_mangled_name
operator|=
name|true
expr_stmt|;
else|else
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint name '%s' must be composed of "
literal|"letters, digits, underscores, and "
literal|"angle brackets"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|strchr
argument_list|(
name|generic_constraint_letters
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint letter '%s' cannot be "
literal|"redefined by the machine description"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint name '%s' cannot be defined by "
literal|"the machine description, as it begins with '%c'"
argument_list|,
name|name
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|&
name|constraints_by_letter_table
index|[
operator|(
name|unsigned
name|int
operator|)
name|name
index|[
literal|0
index|]
index|]
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|slot
init|;
operator|*
name|iter
condition|;
name|iter
operator|=
operator|&
operator|(
operator|*
name|iter
operator|)
operator|->
name|next_this_letter
control|)
block|{
comment|/* This causes slot to end up pointing to the 	 next_this_letter field of the last constraint with a name 	 of equal or greater length than the new constraint; hence 	 the new constraint will be inserted after all previous 	 constraints with names of the same length.  */
if|if
condition|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|namelen
operator|>=
name|namelen
condition|)
name|slot
operator|=
name|iter
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"redefinition of constraint '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|lineno
argument_list|,
literal|"previous definition is here"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|,
operator|(
operator|*
name|iter
operator|)
operator|->
name|namelen
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"defining constraint '%s' here"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|lineno
argument_list|,
literal|"renders constraint '%s' "
literal|"(defined here) a prefix"
argument_list|,
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint '%s' is a prefix"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|lineno
argument_list|,
literal|"of constraint '%s' "
literal|"(defined here)"
argument_list|,
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|is_const_int
operator|=
name|strchr
argument_list|(
name|const_int_constraints
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|is_const_dbl
operator|=
name|strchr
argument_list|(
name|const_dbl_constraints
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|is_const_int
operator|||
name|is_const_dbl
condition|)
block|{
name|enum
name|rtx_code
name|appropriate_code
init|=
name|is_const_int
condition|?
name|CONST_INT
else|:
name|CONST_DOUBLE
decl_stmt|;
comment|/* Consider relaxing this requirement in the future.  */
if|if
condition|(
name|regclass
operator|||
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|AND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MATCH_CODE
operator|||
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|appropriate_code
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint letter '%c' is reserved "
literal|"for %s constraints"
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|appropriate_code
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint names beginning with '%c' "
literal|"(%s) are reserved for %s constraints"
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|appropriate_code
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_memory
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint letter '%c' cannot be a "
literal|"memory constraint"
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint name '%s' begins with '%c', "
literal|"and therefore cannot be a memory constraint"
argument_list|,
name|name
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|is_address
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint letter '%c' cannot be a "
literal|"memory constraint"
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint name '%s' begins with '%c', "
literal|"and therefore cannot be a memory constraint"
argument_list|,
name|name
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|c
operator|=
name|obstack_alloc
argument_list|(
name|rtl_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|constraint_data
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|c
operator|->
name|c_name
operator|=
name|need_mangled_name
condition|?
name|mangle
argument_list|(
name|name
argument_list|)
else|:
name|name
expr_stmt|;
name|c
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|c
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
name|c
operator|->
name|regclass
operator|=
name|regclass
expr_stmt|;
name|c
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|c
operator|->
name|is_register
operator|=
name|regclass
operator|!=
literal|0
expr_stmt|;
name|c
operator|->
name|is_const_int
operator|=
name|is_const_int
expr_stmt|;
name|c
operator|->
name|is_const_dbl
operator|=
name|is_const_dbl
expr_stmt|;
name|c
operator|->
name|is_extra
operator|=
operator|!
operator|(
name|regclass
operator|||
name|is_const_int
operator|||
name|is_const_dbl
operator|)
expr_stmt|;
name|c
operator|->
name|is_memory
operator|=
name|is_memory
expr_stmt|;
name|c
operator|->
name|is_address
operator|=
name|is_address
expr_stmt|;
name|c
operator|->
name|next_this_letter
operator|=
operator|*
name|slot
expr_stmt|;
operator|*
name|slot
operator|=
name|c
expr_stmt|;
comment|/* Insert this constraint in the list of all constraints in textual      order.  */
name|c
operator|->
name|next_textual
operator|=
literal|0
expr_stmt|;
operator|*
name|last_constraint_ptr
operator|=
name|c
expr_stmt|;
name|last_constraint_ptr
operator|=
operator|&
name|c
operator|->
name|next_textual
expr_stmt|;
name|constraint_max_namelen
operator|=
name|MAX
argument_list|(
name|constraint_max_namelen
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|have_register_constraints
operator||=
name|c
operator|->
name|is_register
expr_stmt|;
name|have_const_int_constraints
operator||=
name|c
operator|->
name|is_const_int
expr_stmt|;
name|have_const_dbl_constraints
operator||=
name|c
operator|->
name|is_const_dbl
expr_stmt|;
name|have_extra_constraints
operator||=
name|c
operator|->
name|is_extra
expr_stmt|;
name|have_memory_constraints
operator||=
name|c
operator|->
name|is_memory
expr_stmt|;
name|have_address_constraints
operator||=
name|c
operator|->
name|is_address
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_CONSTRAINT, DEFINE_MEMORY_CONSTRAINT, or    DEFINE_ADDRESS_CONSTRAINT expression, C.  */
end_comment

begin_function
specifier|static
name|void
name|process_define_constraint
parameter_list|(
name|rtx
name|c
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|add_constraint
argument_list|(
name|XSTR
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|c
argument_list|,
literal|2
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|DEFINE_MEMORY_CONSTRAINT
argument_list|,
name|GET_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|DEFINE_ADDRESS_CONSTRAINT
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_REGISTER_CONSTRAINT expression, C.  */
end_comment

begin_function
specifier|static
name|void
name|process_define_register_constraint
parameter_list|(
name|rtx
name|c
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|add_constraint
argument_list|(
name|XSTR
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out an enumeration with one entry per machine-specific    constraint.  */
end_comment

begin_function
specifier|static
name|void
name|write_enum_constraint_num
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
name|fputs
argument_list|(
literal|"enum constraint_num\n"
literal|"{\n"
literal|"  CONSTRAINT__UNKNOWN = 0"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
name|printf
argument_list|(
literal|",\n  CONSTRAINT_%s"
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a function which looks at a string and determines what    constraint name, if any, it begins with.  */
end_comment

begin_function
specifier|static
name|void
name|write_lookup_constraint
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|puts
argument_list|(
literal|"enum constraint_num\n"
literal|"lookup_constraint (const char *str)\n"
literal|"{\n"
literal|"  switch (str[0])\n"
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|constraints_by_letter_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
init|=
name|constraints_by_letter_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
continue|continue;
name|printf
argument_list|(
literal|"    case '%c':\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|namelen
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"      return CONSTRAINT_%s;\n"
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
else|else
block|{
do|do
block|{
name|printf
argument_list|(
literal|"      if (!strncmp (str, \"%s\", %lu))\n"
literal|"        return CONSTRAINT_%s;\n"
argument_list|,
name|c
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
name|int
operator|)
name|c
operator|->
name|namelen
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next_this_letter
expr_stmt|;
block|}
do|while
condition|(
name|c
condition|)
do|;
name|puts
argument_list|(
literal|"      break;"
argument_list|)
expr_stmt|;
block|}
block|}
name|puts
argument_list|(
literal|"    default: break;\n"
literal|"    }\n"
literal|"  return CONSTRAINT__UNKNOWN;\n"
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the function which computes constraint name lengths from    their enumerators. */
end_comment

begin_function
specifier|static
name|void
name|write_insn_constraint_len
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|constraint_max_namelen
operator|==
literal|1
condition|)
return|return;
name|puts
argument_list|(
literal|"size_t\n"
literal|"insn_constraint_len (enum constraint_num c)\n"
literal|"{\n"
literal|"  switch (c)\n"
literal|"    {"
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|->
name|namelen
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"    case CONSTRAINT_%s: return %lu;\n"
argument_list|,
name|c
operator|->
name|c_name
argument_list|,
operator|(
name|unsigned
name|long
name|int
operator|)
name|c
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    default: break;\n"
literal|"    }\n"
literal|"  return 1;\n"
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the function which computes the register class corresponding    to a register constraint.  */
end_comment

begin_function
specifier|static
name|void
name|write_regclass_for_constraint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
name|puts
argument_list|(
literal|"enum reg_class\n"
literal|"regclass_for_constraint (enum constraint_num c)\n"
literal|"{\n"
literal|"  switch (c)\n"
literal|"    {"
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|->
name|is_register
condition|)
name|printf
argument_list|(
literal|"    case CONSTRAINT_%s: return %s;\n"
argument_list|,
name|c
operator|->
name|c_name
argument_list|,
name|c
operator|->
name|regclass
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    default: break;\n"
literal|"    }\n"
literal|"  return NO_REGS;\n"
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the functions which compute whether a given value matches    a given non-register constraint.  */
end_comment

begin_function
specifier|static
name|void
name|write_tm_constrs_h
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"\ /* Generated automatically by the program '%s'\n\    from the machine description file '%s'.  */\n\n"
argument_list|,
name|progname
argument_list|,
name|in_fname
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ #ifndef GCC_TM_CONSTRS_H\n\ #define GCC_TM_CONSTRS_H\n"
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
if|if
condition|(
operator|!
name|c
operator|->
name|is_register
condition|)
block|{
name|bool
name|needs_ival
init|=
name|needs_variable
argument_list|(
name|c
operator|->
name|exp
argument_list|,
literal|"ival"
argument_list|)
decl_stmt|;
name|bool
name|needs_hval
init|=
name|needs_variable
argument_list|(
name|c
operator|->
name|exp
argument_list|,
literal|"hval"
argument_list|)
decl_stmt|;
name|bool
name|needs_lval
init|=
name|needs_variable
argument_list|(
name|c
operator|->
name|exp
argument_list|,
literal|"lval"
argument_list|)
decl_stmt|;
name|bool
name|needs_rval
init|=
name|needs_variable
argument_list|(
name|c
operator|->
name|exp
argument_list|,
literal|"rval"
argument_list|)
decl_stmt|;
name|bool
name|needs_mode
init|=
operator|(
name|needs_variable
argument_list|(
name|c
operator|->
name|exp
argument_list|,
literal|"mode"
argument_list|)
operator|||
name|needs_hval
operator|||
name|needs_lval
operator|||
name|needs_rval
operator|)
decl_stmt|;
name|bool
name|needs_op
init|=
operator|(
name|needs_variable
argument_list|(
name|c
operator|->
name|exp
argument_list|,
literal|"op"
argument_list|)
operator|||
name|needs_ival
operator|||
name|needs_mode
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"static inline bool\n"
literal|"satisfies_constraint_%s (rtx %s)\n"
literal|"{\n"
argument_list|,
name|c
operator|->
name|c_name
argument_list|,
name|needs_op
condition|?
literal|"op"
else|:
literal|"ARG_UNUSED (op)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_mode
condition|)
name|puts
argument_list|(
literal|"enum machine_mode mode = GET_MODE (op);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_ival
condition|)
name|puts
argument_list|(
literal|"  HOST_WIDE_INT ival = 0;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_hval
condition|)
name|puts
argument_list|(
literal|"  HOST_WIDE_INT hval = 0;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_lval
condition|)
name|puts
argument_list|(
literal|"  unsigned HOST_WIDE_INT lval = 0;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_rval
condition|)
name|puts
argument_list|(
literal|"  const REAL_VALUE_TYPE *rval = 0;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_ival
condition|)
name|puts
argument_list|(
literal|"  if (GET_CODE (op) == CONST_INT)\n"
literal|"    ival = INTVAL (op);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_hval
condition|)
name|puts
argument_list|(
literal|"  if (GET_CODE (op) == CONST_DOUBLE&& mode == VOIDmode)"
literal|"    hval = CONST_DOUBLE_HIGH (op);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_lval
condition|)
name|puts
argument_list|(
literal|"  if (GET_CODE (op) == CONST_DOUBLE&& mode == VOIDmode)"
literal|"    lval = CONST_DOUBLE_LOW (op);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_rval
condition|)
name|puts
argument_list|(
literal|"  if (GET_CODE (op) == CONST_DOUBLE&& mode != VOIDmode)"
literal|"    rval = CONST_DOUBLE_REAL_VALUE (op);"
argument_list|)
expr_stmt|;
name|write_predicate_stmts
argument_list|(
name|c
operator|->
name|exp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"#endif /* tm-constrs.h */"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the wrapper function, constraint_satisfied_p, that maps    a CONSTRAINT_xxx constant to one of the predicate functions generated    above.  */
end_comment

begin_function
specifier|static
name|void
name|write_constraint_satisfied_p
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
name|puts
argument_list|(
literal|"bool\n"
literal|"constraint_satisfied_p (rtx op, enum constraint_num c)\n"
literal|"{\n"
literal|"  switch (c)\n"
literal|"    {"
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
if|if
condition|(
operator|!
name|c
operator|->
name|is_register
condition|)
name|printf
argument_list|(
literal|"    case CONSTRAINT_%s: "
literal|"return satisfies_constraint_%s (op);\n"
argument_list|,
name|c
operator|->
name|c_name
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    default: break;\n"
literal|"    }\n"
literal|"  return false;\n"
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the function which computes whether a given value matches    a given CONST_INT constraint.  This doesn't just forward to    constraint_satisfied_p because caller passes the INTVAL, not the RTX.  */
end_comment

begin_function
specifier|static
name|void
name|write_insn_const_int_ok_for_constraint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
name|puts
argument_list|(
literal|"bool\n"
literal|"insn_const_int_ok_for_constraint (HOST_WIDE_INT ival, "
literal|"enum constraint_num c)\n"
literal|"{\n"
literal|"  switch (c)\n"
literal|"    {"
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|->
name|is_const_int
condition|)
block|{
name|printf
argument_list|(
literal|"    case CONSTRAINT_%s:\n      return "
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* c->exp is guaranteed to be (and (match_code "const_int") (...)); 	   we know at this point that we have a const_int, so we need not 	   bother with that part of the test.  */
name|write_predicate_expr
argument_list|(
name|XEXP
argument_list|(
name|c
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"    default: break;\n"
literal|"    }\n"
literal|"  return false;\n"
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the function which computes whether a given constraint is    a memory constraint.  */
end_comment

begin_function
specifier|static
name|void
name|write_insn_extra_memory_constraint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
name|puts
argument_list|(
literal|"bool\n"
literal|"insn_extra_memory_constraint (enum constraint_num c)\n"
literal|"{\n"
literal|"  switch (c)\n"
literal|"    {"
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|->
name|is_memory
condition|)
name|printf
argument_list|(
literal|"    case CONSTRAINT_%s:\n      return true;\n\n"
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    default: break;\n"
literal|"    }\n"
literal|"  return false;\n"
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the function which computes whether a given constraint is    an address constraint.  */
end_comment

begin_function
specifier|static
name|void
name|write_insn_extra_address_constraint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|c
decl_stmt|;
name|puts
argument_list|(
literal|"bool\n"
literal|"insn_extra_address_constraint (enum constraint_num c)\n"
literal|"{\n"
literal|"  switch (c)\n"
literal|"    {"
argument_list|)
expr_stmt|;
name|FOR_ALL_CONSTRAINTS
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|->
name|is_address
condition|)
name|printf
argument_list|(
literal|"    case CONSTRAINT_%s:\n      return true;\n\n"
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    default: break;\n"
literal|"    }\n"
literal|"  return false;\n"
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write tm-preds.h.  Unfortunately, it is impossible to forward-declare    an enumeration in portable C, so we have to condition all these    prototypes on HAVE_MACHINE_MODES.  */
end_comment

begin_function
specifier|static
name|void
name|write_tm_preds_h
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pred_data
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"\ /* Generated automatically by the program '%s'\n\    from the machine description file '%s'.  */\n\n"
argument_list|,
name|progname
argument_list|,
name|in_fname
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ #ifndef GCC_TM_PREDS_H\n\ #define GCC_TM_PREDS_H\n\ \n\ #ifdef HAVE_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|FOR_ALL_PREDICATES
argument_list|(
argument|p
argument_list|)
name|printf
argument_list|(
literal|"extern int %s (rtx, enum machine_mode);\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#endif /* HAVE_MACHINE_MODES */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraint_max_namelen
operator|>
literal|0
condition|)
block|{
name|write_enum_constraint_num
argument_list|()
expr_stmt|;
name|puts
argument_list|(
literal|"extern enum constraint_num lookup_constraint (const char *);\n"
literal|"extern bool constraint_satisfied_p (rtx, enum constraint_num);\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraint_max_namelen
operator|>
literal|1
condition|)
name|puts
argument_list|(
literal|"extern size_t insn_constraint_len (enum constraint_num);\n"
literal|"#define CONSTRAINT_LEN(c_,s_) "
literal|"insn_constraint_len (lookup_constraint (s_))\n"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"#define CONSTRAINT_LEN(c_,s_) 1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_register_constraints
condition|)
name|puts
argument_list|(
literal|"extern enum reg_class regclass_for_constraint "
literal|"(enum constraint_num);\n"
literal|"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) \\\n"
literal|"    regclass_for_constraint (lookup_constraint (s_))\n"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) NO_REGS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_const_int_constraints
condition|)
name|puts
argument_list|(
literal|"extern bool insn_const_int_ok_for_constraint "
literal|"(HOST_WIDE_INT, enum constraint_num);\n"
literal|"#define CONST_OK_FOR_CONSTRAINT_P(v_,c_,s_) \\\n"
literal|"    insn_const_int_ok_for_constraint (v_, "
literal|"lookup_constraint (s_))\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_const_dbl_constraints
condition|)
name|puts
argument_list|(
literal|"#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(v_,c_,s_) \\\n"
literal|"    constraint_satisfied_p (v_, lookup_constraint (s_))\n"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(v_,c_,s_) 0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_extra_constraints
condition|)
name|puts
argument_list|(
literal|"#define EXTRA_CONSTRAINT_STR(v_,c_,s_) \\\n"
literal|"    constraint_satisfied_p (v_, lookup_constraint (s_))\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_memory_constraints
condition|)
name|puts
argument_list|(
literal|"extern bool "
literal|"insn_extra_memory_constraint (enum constraint_num);\n"
literal|"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) "
literal|"insn_extra_memory_constraint (lookup_constraint (s_))\n"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) false\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_address_constraints
condition|)
name|puts
argument_list|(
literal|"extern bool "
literal|"insn_extra_address_constraint (enum constraint_num);\n"
literal|"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) "
literal|"insn_extra_address_constraint (lookup_constraint (s_))\n"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) false\n"
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"#endif /* tm-preds.h */"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write insn-preds.c.      N.B. the list of headers to include was copied from genrecog; it    may not be ideal.     FUTURE: Write #line markers referring back to the machine    description.  (Can't practically do this now since we don't know    the line number of the C block - just the line number of the enclosing    expression.)  */
end_comment

begin_function
specifier|static
name|void
name|write_insn_preds_c
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pred_data
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"\ /* Generated automatically by the program '%s'\n\    from the machine description file '%s'.  */\n\n"
argument_list|,
name|progname
argument_list|,
name|in_fname
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ #include \"config.h\"\n\ #include \"system.h\"\n\ #include \"coretypes.h\"\n\ #include \"tm.h\"\n\ #include \"rtl.h\"\n\ #include \"tree.h\"\n\ #include \"tm_p.h\"\n\ #include \"function.h\"\n\ #include \"insn-config.h\"\n\ #include \"recog.h\"\n\ #include \"real.h\"\n\ #include \"output.h\"\n\ #include \"flags.h\"\n\ #include \"hard-reg-set.h\"\n\ #include \"resource.h\"\n\ #include \"toplev.h\"\n\ #include \"reload.h\"\n\ #include \"regs.h\"\n\ #include \"tm-constrs.h\"\n"
argument_list|)
expr_stmt|;
name|FOR_ALL_PREDICATES
argument_list|(
argument|p
argument_list|)
name|write_one_predicate_function
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraint_max_namelen
operator|>
literal|0
condition|)
block|{
name|write_lookup_constraint
argument_list|()
expr_stmt|;
name|write_regclass_for_constraint
argument_list|()
expr_stmt|;
name|write_constraint_satisfied_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|constraint_max_namelen
operator|>
literal|1
condition|)
name|write_insn_constraint_len
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_const_int_constraints
condition|)
name|write_insn_const_int_ok_for_constraint
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_memory_constraints
condition|)
name|write_insn_extra_memory_constraint
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_address_constraints
condition|)
name|write_insn_extra_address_constraint
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Argument parsing.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|gen_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|gen_constrs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|parse_option
parameter_list|(
specifier|const
name|char
modifier|*
name|opt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-h"
argument_list|)
condition|)
block|{
name|gen_header
operator|=
name|true
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-c"
argument_list|)
condition|)
block|{
name|gen_constrs
operator|=
name|true
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Master control.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|rtx
name|defn
decl_stmt|;
name|int
name|pattern_lineno
decl_stmt|,
name|next_insn_code
init|=
literal|0
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"no input file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader_args_cb
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|parse_option
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
while|while
condition|(
operator|(
name|defn
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|pattern_lineno
argument_list|,
operator|&
name|next_insn_code
argument_list|)
operator|)
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|defn
argument_list|)
condition|)
block|{
case|case
name|DEFINE_PREDICATE
case|:
case|case
name|DEFINE_SPECIAL_PREDICATE
case|:
name|process_define_predicate
argument_list|(
name|defn
argument_list|,
name|pattern_lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_CONSTRAINT
case|:
case|case
name|DEFINE_MEMORY_CONSTRAINT
case|:
case|case
name|DEFINE_ADDRESS_CONSTRAINT
case|:
name|process_define_constraint
argument_list|(
name|defn
argument_list|,
name|pattern_lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_REGISTER_CONSTRAINT
case|:
name|process_define_register_constraint
argument_list|(
name|defn
argument_list|,
name|pattern_lineno
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|gen_header
condition|)
name|write_tm_preds_h
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|gen_constrs
condition|)
name|write_tm_constrs_h
argument_list|()
expr_stmt|;
else|else
name|write_insn_preds_c
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_error
operator|||
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

end_unit

