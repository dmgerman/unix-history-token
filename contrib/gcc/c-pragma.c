begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.    Copyright (C) 1992, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_define
define|#
directive|define
name|GCC_BAD
parameter_list|(
name|msgid
parameter_list|)
value|do { warning (msgid); return; } while (0)
end_define

begin_define
define|#
directive|define
name|GCC_BAD2
parameter_list|(
name|msgid
parameter_list|,
name|arg
parameter_list|)
value|do { warning (msgid, arg); return; } while (0)
end_define

begin_typedef
typedef|typedef
name|struct
name|align_stack
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|int
name|alignment
block|;
name|unsigned
name|int
name|num_pushes
block|;
name|tree
name|id
block|;
name|struct
name|align_stack
modifier|*
name|prev
block|; }
end_typedef

begin_expr_stmt
name|align_stack
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|align_stack
operator|*
name|alignment_stack
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_pack
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK_PUSH_POP
end_ifdef

begin_comment
comment|/* If we have a "global" #pragma pack(<n>) in effect when the first    #pragma pack(push,<n>) is encountered, this stores the value of     maximum_field_alignment in effect.  When the final pop_alignment()     happens, we restore the value to this, not to a value of 0 for    maximum_field_alignment.  Value is in bits.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_alignment
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_GLOBAL_ALIGNMENT
parameter_list|(
name|ALIGN
parameter_list|)
define|\
value|(default_alignment = maximum_field_alignment = (ALIGN))
end_define

begin_decl_stmt
specifier|static
name|void
name|push_alignment
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_alignment
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push an alignment value onto the stack.  */
end_comment

begin_function
specifier|static
name|void
name|push_alignment
parameter_list|(
name|alignment
parameter_list|,
name|id
parameter_list|)
name|int
name|alignment
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|{
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
operator|||
name|alignment_stack
operator|->
name|alignment
operator|!=
name|alignment
operator|||
name|id
operator|!=
name|NULL_TREE
condition|)
block|{
name|align_stack
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
name|align_stack
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|entry
operator|->
name|num_pushes
operator|=
literal|1
expr_stmt|;
name|entry
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|alignment_stack
expr_stmt|;
comment|/* The current value of maximum_field_alignment is not necessarily  	 0 since there may be a #pragma pack(<n>) in effect; remember it  	 so that we can restore it after the final #pragma pop().  */
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
condition|)
name|default_alignment
operator|=
name|maximum_field_alignment
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
name|maximum_field_alignment
operator|=
name|alignment
expr_stmt|;
block|}
else|else
name|alignment_stack
operator|->
name|num_pushes
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo a push of an alignment onto the stack.  */
end_comment

begin_function
specifier|static
name|void
name|pop_alignment
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
name|align_stack
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"\ #pragma pack (pop) encountered without matching #pragma pack (push,<n>)"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we got an identifier, strip away everything above the target      entry so that the next step will restore the state just below it.  */
if|if
condition|(
name|id
condition|)
block|{
for|for
control|(
name|entry
operator|=
name|alignment_stack
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|prev
control|)
if|if
condition|(
name|entry
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|entry
operator|->
name|num_pushes
operator|=
literal|1
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"\ #pragma pack(pop, %s) encountered without matching #pragma pack(push, %s,<n>)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|alignment_stack
operator|->
name|num_pushes
operator|==
literal|0
condition|)
block|{
name|entry
operator|=
name|alignment_stack
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|maximum_field_alignment
operator|=
name|default_alignment
expr_stmt|;
else|else
name|maximum_field_alignment
operator|=
name|entry
operator|->
name|alignment
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HANDLE_PRAGMA_PACK_PUSH_POP */
end_comment

begin_define
define|#
directive|define
name|SET_GLOBAL_ALIGNMENT
parameter_list|(
name|ALIGN
parameter_list|)
value|(maximum_field_alignment = (ALIGN))
end_define

begin_define
define|#
directive|define
name|push_alignment
parameter_list|(
name|ID
parameter_list|,
name|N
parameter_list|)
define|\
value|GCC_BAD("#pragma pack(push[, id],<n>) is not supported on this target")
end_define

begin_define
define|#
directive|define
name|pop_alignment
parameter_list|(
name|ID
parameter_list|)
define|\
value|GCC_BAD("#pragma pack(pop[, id],<n>) is not supported on this target")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_PACK_PUSH_POP */
end_comment

begin_comment
comment|/* #pragma pack ()    #pragma pack (N)        #pragma pack (push, N)    #pragma pack (push, ID, N)    #pragma pack (pop)    #pragma pack (pop, ID) */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_pack
parameter_list|(
name|dummy
parameter_list|)
name|cpp_reader
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|,
name|id
init|=
literal|0
decl_stmt|;
name|int
name|align
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|cpp_ttype
name|token
decl_stmt|;
enum|enum
block|{
name|set
block|,
name|push
block|,
name|pop
block|}
name|action
enum|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"missing '(' after '#pragma pack' - ignored"
argument_list|)
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
name|action
operator|=
name|set
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
condition|)
block|{
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|action
operator|=
name|set
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed '#pragma pack' - ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
define|#
directive|define
name|GCC_BAD_ACTION
value|do { if (action == push) \ 	  GCC_BAD ("malformed '#pragma pack(push[, id],<n>)' - ignored"); \ 	else \ 	  GCC_BAD ("malformed '#pragma pack(pop[, id])' - ignored"); \ 	} while (0)
specifier|const
name|char
modifier|*
name|op
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"push"
argument_list|)
condition|)
name|action
operator|=
name|push
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"pop"
argument_list|)
condition|)
name|action
operator|=
name|pop
expr_stmt|;
else|else
name|GCC_BAD2
argument_list|(
literal|"unknown action '%s' for '#pragma pack' - ignored"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_COMMA
operator|&&
name|action
operator|==
name|push
condition|)
name|GCC_BAD_ACTION
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_COMMA
condition|)
block|{
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
name|id
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|push
operator|&&
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_COMMA
condition|)
name|GCC_BAD_ACTION
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|push
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
condition|)
block|{
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|GCC_BAD_ACTION
expr_stmt|;
block|}
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|GCC_BAD_ACTION
expr_stmt|;
undef|#
directive|undef
name|GCC_BAD_ACTION
block|}
else|else
name|GCC_BAD
argument_list|(
literal|"malformed '#pragma pack' - ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of '#pragma pack'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|pop
condition|)
switch|switch
condition|(
name|align
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
case|case
literal|16
case|:
name|align
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
name|GCC_BAD2
argument_list|(
literal|"alignment must be a small power of two, not %d"
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|set
case|:
name|SET_GLOBAL_ALIGNMENT
argument_list|(
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|push
case|:
name|push_alignment
argument_list|(
name|align
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|pop
case|:
name|pop_alignment
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_PACK */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_weaks
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|apply_pragma_weak
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_weak
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|apply_pragma_weak
parameter_list|(
name|decl
parameter_list|,
name|value
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
condition|)
block|{
name|value
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|value
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|build_tree_list
argument_list|(
name|get_identifier
argument_list|(
literal|"alias"
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUPPORTS_WEAK
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"applying #pragma weak `%s' after first use results in unspecified behavior"
argument_list|)
expr_stmt|;
name|declare_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maybe_apply_pragma_weak
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|,
name|id
decl_stmt|;
comment|/* Avoid asking for DECL_ASSEMBLER_NAME when it's not needed.  */
comment|/* No weak symbols pending, take the short-cut.  */
if|if
condition|(
operator|!
name|pending_weaks
condition|)
return|return;
comment|/* If it's not visible outside this file, it doesn't matter whether      it's weak.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If it's not a function or a variable, it can't be weak.      FIXME: what kinds of things are visible outside this file but      aren't functions or variables?   Should this be an abort() instead?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
name|id
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pending_weaks
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|id
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|apply_pragma_weak
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* #pragma weak name [= value] */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_weak
parameter_list|(
name|dummy
parameter_list|)
name|cpp_reader
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|,
name|x
decl_stmt|,
name|decl
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|name
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma weak, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CPP_EQ
condition|)
block|{
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|value
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma weak, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma weak"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|identifier_global_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
block|{
name|apply_pragma_weak
argument_list|(
name|decl
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|pending_weaks
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|pending_weaks
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|maybe_apply_pragma_weak
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_WEAK */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_redefine_extname
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_REDEFINE_EXTNAME
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_redefine_extname
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #pragma redefined_extname oldname newname */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_redefine_extname
parameter_list|(
name|dummy
parameter_list|)
name|cpp_reader
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|oldname
decl_stmt|,
name|newname
decl_stmt|,
name|decl
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|oldname
argument_list|)
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|"malformed #pragma redefine_extname, ignored"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|newname
argument_list|)
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|"malformed #pragma redefine_extname, ignored"
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma redefine_extname"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|identifier_global_value
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|newname
condition|)
name|warning
argument_list|(
literal|"#pragma redefine_extname conflicts with declaration"
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
else|else
name|add_to_renaming_pragma_list
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|add_to_renaming_pragma_list
parameter_list|(
name|oldname
parameter_list|,
name|newname
parameter_list|)
name|tree
name|oldname
decl_stmt|,
name|newname
decl_stmt|;
block|{
name|pending_redefine_extname
operator|=
name|tree_cons
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|,
name|pending_redefine_extname
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pragma_extern_prefix
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_EXTERN_PREFIX
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_extern_prefix
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #pragma extern_prefix "prefix" */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_extern_prefix
parameter_list|(
name|dummy
parameter_list|)
name|cpp_reader
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|prefix
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|prefix
argument_list|)
operator|!=
name|CPP_STRING
condition|)
block|{
name|warning
argument_list|(
literal|"malformed #pragma extern_prefix, ignored"
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma extern_prefix"
argument_list|)
expr_stmt|;
comment|/* Note that the length includes the null terminator.  */
name|pragma_extern_prefix
operator|=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|prefix
argument_list|)
operator|>
literal|1
condition|?
name|prefix
else|:
name|NULL
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hook from the front ends to apply the results of one of the preceeding    pragmas that rename variables.  */
end_comment

begin_function
name|tree
name|maybe_apply_renaming_pragma
parameter_list|(
name|decl
parameter_list|,
name|asmname
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|asmname
decl_stmt|;
block|{
name|tree
name|oldname
decl_stmt|;
comment|/* Copied from the check in set_decl_assembler_name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|oldname
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
return|return
name|asmname
return|;
comment|/* If the name begins with a *, that's a sign of an asmname attached to      a previous declaration.  */
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|oldname
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
specifier|const
name|char
modifier|*
name|oldasmname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|asmname
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|asmname
argument_list|)
argument_list|,
name|oldasmname
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"asm declaration conflicts with previous rename"
argument_list|)
expr_stmt|;
name|asmname
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|oldasmname
argument_list|)
argument_list|,
name|oldasmname
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pending_redefine_extname
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|oldname
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|newname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|asmname
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|asmname
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"#pragma redefine_extname conflicts with declaration"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|build_string
argument_list|(
name|strlen
argument_list|(
name|newname
argument_list|)
argument_list|,
name|newname
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_EXTERN_PREFIX
if|if
condition|(
name|pragma_extern_prefix
operator|&&
operator|!
name|asmname
condition|)
block|{
name|char
modifier|*
name|x
init|=
name|concat
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|pragma_extern_prefix
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|oldname
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|asmname
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|asmname
return|;
block|}
endif|#
directive|endif
return|return
name|asmname
return|;
block|}
end_function

begin_function
name|void
name|init_pragma
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"pack"
argument_list|,
name|handle_pragma_pack
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"weak"
argument_list|,
name|handle_pragma_weak
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_REDEFINE_EXTNAME
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"redefine_extname"
argument_list|,
name|handle_pragma_redefine_extname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_EXTERN_PREFIX
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"extern_prefix"
argument_list|,
name|handle_pragma_extern_prefix
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REGISTER_TARGET_PRAGMAS
name|REGISTER_TARGET_PRAGMAS
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_include
include|#
directive|include
file|"gt-c-pragma.h"
end_include

end_unit

