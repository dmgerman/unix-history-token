begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.    Copyright (C) 1992, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_define
define|#
directive|define
name|GCC_BAD
parameter_list|(
name|msgid
parameter_list|)
value|do { warning (msgid); return; } while (0)
end_define

begin_define
define|#
directive|define
name|GCC_BAD2
parameter_list|(
name|msgid
parameter_list|,
name|arg
parameter_list|)
value|do { warning (msgid, arg); return; } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_pack
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK_PUSH_POP
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|align_stack
block|{
name|int
name|alignment
decl_stmt|;
name|unsigned
name|int
name|num_pushes
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|struct
name|align_stack
modifier|*
name|prev
decl_stmt|;
block|}
name|align_stack
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|align_stack
modifier|*
name|alignment_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we have a "global" #pragma pack(<n>) in effect when the first    #pragma pack(push,<n>) is encountered, this stores the value of     maximum_field_alignment in effect.  When the final pop_alignment()     happens, we restore the value to this, not to a value of 0 for    maximum_field_alignment.  Value is in bits.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_alignment
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_GLOBAL_ALIGNMENT
parameter_list|(
name|ALIGN
parameter_list|)
define|\
value|(default_alignment = maximum_field_alignment = (ALIGN))
end_define

begin_decl_stmt
specifier|static
name|void
name|push_alignment
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_alignment
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_align_stack
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push an alignment value onto the stack.  */
end_comment

begin_function
specifier|static
name|void
name|push_alignment
parameter_list|(
name|alignment
parameter_list|,
name|id
parameter_list|)
name|int
name|alignment
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|{
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
operator|||
name|alignment_stack
operator|->
name|alignment
operator|!=
name|alignment
operator|||
name|id
operator|!=
name|NULL_TREE
condition|)
block|{
name|align_stack
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
name|align_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|entry
operator|->
name|num_pushes
operator|=
literal|1
expr_stmt|;
name|entry
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|alignment_stack
expr_stmt|;
comment|/* The current value of maximum_field_alignment is not necessarily  	 0 since there may be a #pragma pack(<n>) in effect; remember it  	 so that we can restore it after the final #pragma pop().  */
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
condition|)
name|default_alignment
operator|=
name|maximum_field_alignment
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
name|maximum_field_alignment
operator|=
name|alignment
expr_stmt|;
block|}
else|else
name|alignment_stack
operator|->
name|num_pushes
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo a push of an alignment onto the stack.  */
end_comment

begin_function
specifier|static
name|void
name|pop_alignment
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
name|align_stack
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"\ #pragma pack (pop) encountered without matching #pragma pack (push,<n>)"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we got an identifier, strip away everything above the target      entry so that the next step will restore the state just below it.  */
if|if
condition|(
name|id
condition|)
block|{
for|for
control|(
name|entry
operator|=
name|alignment_stack
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|prev
control|)
if|if
condition|(
name|entry
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|entry
operator|->
name|num_pushes
operator|=
literal|1
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"\ #pragma pack(pop, %s) encountered without matching #pragma pack(push, %s,<n>)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|alignment_stack
operator|->
name|num_pushes
operator|==
literal|0
condition|)
block|{
name|entry
operator|=
name|alignment_stack
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|maximum_field_alignment
operator|=
name|default_alignment
expr_stmt|;
else|else
name|maximum_field_alignment
operator|=
name|entry
operator|->
name|alignment
expr_stmt|;
name|free
argument_list|(
name|alignment_stack
argument_list|)
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mark_align_stack
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|align_stack
modifier|*
name|a
init|=
operator|*
operator|(
name|align_stack
operator|*
operator|*
operator|)
name|p
decl_stmt|;
while|while
condition|(
name|a
condition|)
block|{
name|ggc_mark_tree
argument_list|(
name|a
operator|->
name|id
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HANDLE_PRAGMA_PACK_PUSH_POP */
end_comment

begin_define
define|#
directive|define
name|SET_GLOBAL_ALIGNMENT
parameter_list|(
name|ALIGN
parameter_list|)
value|(maximum_field_alignment = (ALIGN))
end_define

begin_define
define|#
directive|define
name|push_alignment
parameter_list|(
name|ID
parameter_list|,
name|N
parameter_list|)
define|\
value|GCC_BAD("#pragma pack(push[, id],<n>) is not supported on this target")
end_define

begin_define
define|#
directive|define
name|pop_alignment
parameter_list|(
name|ID
parameter_list|)
define|\
value|GCC_BAD("#pragma pack(pop[, id],<n>) is not supported on this target")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_PACK_PUSH_POP */
end_comment

begin_comment
comment|/* #pragma pack ()    #pragma pack (N)        #pragma pack (push, N)    #pragma pack (push, ID, N)    #pragma pack (pop)    #pragma pack (pop, ID) */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_pack
parameter_list|(
name|dummy
parameter_list|)
name|cpp_reader
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|,
name|id
init|=
literal|0
decl_stmt|;
name|int
name|align
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|cpp_ttype
name|token
decl_stmt|;
enum|enum
block|{
name|set
block|,
name|push
block|,
name|pop
block|}
name|action
enum|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"missing '(' after '#pragma pack' - ignored"
argument_list|)
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
name|action
operator|=
name|set
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
condition|)
block|{
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|action
operator|=
name|set
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed '#pragma pack' - ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
define|#
directive|define
name|GCC_BAD_ACTION
value|do { if (action == push) \ 	  GCC_BAD ("malformed '#pragma pack(push[, id],<n>)' - ignored"); \ 	else \ 	  GCC_BAD ("malformed '#pragma pack(pop[, id])' - ignored"); \ 	} while (0)
specifier|const
name|char
modifier|*
name|op
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"push"
argument_list|)
condition|)
name|action
operator|=
name|push
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"pop"
argument_list|)
condition|)
name|action
operator|=
name|pop
expr_stmt|;
else|else
name|GCC_BAD2
argument_list|(
literal|"unknown action '%s' for '#pragma pack' - ignored"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_COMMA
operator|&&
name|action
operator|==
name|push
condition|)
name|GCC_BAD_ACTION
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_COMMA
condition|)
block|{
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
name|id
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|push
operator|&&
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_COMMA
condition|)
name|GCC_BAD_ACTION
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|push
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
condition|)
block|{
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|token
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|GCC_BAD_ACTION
expr_stmt|;
block|}
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|GCC_BAD_ACTION
expr_stmt|;
undef|#
directive|undef
name|GCC_BAD_ACTION
block|}
else|else
name|GCC_BAD
argument_list|(
literal|"malformed '#pragma pack' - ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of '#pragma pack'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|pop
condition|)
switch|switch
condition|(
name|align
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
case|case
literal|16
case|:
name|align
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
name|GCC_BAD2
argument_list|(
literal|"alignment must be a small power of two, not %d"
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|set
case|:
name|SET_GLOBAL_ALIGNMENT
argument_list|(
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|push
case|:
name|push_alignment
argument_list|(
name|align
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|pop
case|:
name|pop_alignment
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_PACK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_weak
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #pragma weak name [= value] */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_weak
parameter_list|(
name|dummy
parameter_list|)
name|cpp_reader
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|name
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma weak, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CPP_EQ
condition|)
block|{
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|value
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma weak, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma weak"
argument_list|)
expr_stmt|;
name|add_weak
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|value
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init_pragma
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"pack"
argument_list|,
name|handle_pragma_pack
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"weak"
argument_list|,
name|handle_pragma_weak
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REGISTER_TARGET_PRAGMAS
name|REGISTER_TARGET_PRAGMAS
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK_PUSH_POP
name|ggc_add_root
argument_list|(
operator|&
name|alignment_stack
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|alignment_stack
argument_list|)
argument_list|,
name|mark_align_stack
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

