begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.    Copyright (C) 1992, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_define
define|#
directive|define
name|GCC_BAD
parameter_list|(
name|gmsgid
parameter_list|)
define|\
value|do { warning (OPT_Wpragmas, gmsgid); return; } while (0)
end_define

begin_define
define|#
directive|define
name|GCC_BAD2
parameter_list|(
name|gmsgid
parameter_list|,
name|arg
parameter_list|)
define|\
value|do { warning (OPT_Wpragmas, gmsgid, arg); return; } while (0)
end_define

begin_typedef
typedef|typedef
name|struct
name|align_stack
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|int
name|alignment
block|;
name|tree
name|id
block|;
name|struct
name|align_stack
modifier|*
name|prev
block|; }
end_typedef

begin_expr_stmt
name|align_stack
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|align_stack
operator|*
name|alignment_stack
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK
end_ifdef

begin_function_decl
specifier|static
name|void
name|handle_pragma_pack
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK_PUSH_POP
end_ifdef

begin_comment
comment|/* If we have a "global" #pragma pack(<n>) in effect when the first    #pragma pack(push,<n>) is encountered, this stores the value of    maximum_field_alignment in effect.  When the final pop_alignment()    happens, we restore the value to this, not to a value of 0 for    maximum_field_alignment.  Value is in bits.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_alignment
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_GLOBAL_ALIGNMENT
parameter_list|(
name|ALIGN
parameter_list|)
value|(maximum_field_alignment = *(alignment_stack == NULL \ 	?&default_alignment \ 	:&alignment_stack->alignment) = (ALIGN))
end_define

begin_function_decl
specifier|static
name|void
name|push_alignment
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_alignment
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Push an alignment value onto the stack.  */
end_comment

begin_function
specifier|static
name|void
name|push_alignment
parameter_list|(
name|int
name|alignment
parameter_list|,
name|tree
name|id
parameter_list|)
block|{
name|align_stack
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|GGC_NEW
argument_list|(
name|align_stack
argument_list|)
expr_stmt|;
name|entry
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|entry
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|alignment_stack
expr_stmt|;
comment|/* The current value of maximum_field_alignment is not necessarily      0 since there may be a #pragma pack(<n>) in effect; remember it      so that we can restore it after the final #pragma pop().  */
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
condition|)
name|default_alignment
operator|=
name|maximum_field_alignment
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
name|maximum_field_alignment
operator|=
name|alignment
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo a push of an alignment onto the stack.  */
end_comment

begin_function
specifier|static
name|void
name|pop_alignment
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|align_stack
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|alignment_stack
operator|==
name|NULL
condition|)
name|GCC_BAD
argument_list|(
literal|"#pragma pack (pop) encountered without matching #pragma pack (push)"
argument_list|)
expr_stmt|;
comment|/* If we got an identifier, strip away everything above the target      entry so that the next step will restore the state just below it.  */
if|if
condition|(
name|id
condition|)
block|{
for|for
control|(
name|entry
operator|=
name|alignment_stack
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|prev
control|)
if|if
condition|(
name|entry
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|alignment_stack
operator|=
name|entry
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"\ #pragma pack(pop, %s) encountered without matching #pragma pack(push, %s)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
name|alignment_stack
operator|->
name|prev
expr_stmt|;
name|maximum_field_alignment
operator|=
name|entry
condition|?
name|entry
operator|->
name|alignment
else|:
name|default_alignment
expr_stmt|;
name|alignment_stack
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HANDLE_PRAGMA_PACK_PUSH_POP */
end_comment

begin_define
define|#
directive|define
name|SET_GLOBAL_ALIGNMENT
parameter_list|(
name|ALIGN
parameter_list|)
value|(maximum_field_alignment = (ALIGN))
end_define

begin_define
define|#
directive|define
name|push_alignment
parameter_list|(
name|ID
parameter_list|,
name|N
parameter_list|)
define|\
value|GCC_BAD ("#pragma pack(push[, id],<n>) is not supported on this target")
end_define

begin_define
define|#
directive|define
name|pop_alignment
parameter_list|(
name|ID
parameter_list|)
define|\
value|GCC_BAD ("#pragma pack(pop[, id],<n>) is not supported on this target")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_PACK_PUSH_POP */
end_comment

begin_comment
comment|/* #pragma pack ()    #pragma pack (N)     #pragma pack (push)    #pragma pack (push, N)    #pragma pack (push, ID)    #pragma pack (push, ID, N)    #pragma pack (pop)    #pragma pack (pop, ID) */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_pack
parameter_list|(
name|cpp_reader
modifier|*
name|ARG_UNUSED
parameter_list|(
name|dummy
parameter_list|)
parameter_list|)
block|{
name|tree
name|x
decl_stmt|,
name|id
init|=
literal|0
decl_stmt|;
name|int
name|align
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|cpp_ttype
name|token
decl_stmt|;
enum|enum
block|{
name|set
block|,
name|push
block|,
name|pop
block|}
name|action
enum|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"missing %<(%> after %<#pragma pack%> - ignored"
argument_list|)
expr_stmt|;
name|token
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
name|action
operator|=
name|set
expr_stmt|;
name|align
operator|=
name|initial_max_fld_align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|GCC_BAD
argument_list|(
literal|"invalid constant in %<#pragma pack%> - ignored"
argument_list|)
expr_stmt|;
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|action
operator|=
name|set
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed %<#pragma pack%> - ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
define|#
directive|define
name|GCC_BAD_ACTION
value|do { if (action != pop) \ 	  GCC_BAD ("malformed %<#pragma pack(push[, id][,<n>])%> - ignored"); \ 	else \ 	  GCC_BAD ("malformed %<#pragma pack(pop[, id])%> - ignored"); \ 	} while (0)
specifier|const
name|char
modifier|*
name|op
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"push"
argument_list|)
condition|)
name|action
operator|=
name|push
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"pop"
argument_list|)
condition|)
name|action
operator|=
name|pop
expr_stmt|;
else|else
name|GCC_BAD2
argument_list|(
literal|"unknown action %qs for %<#pragma pack%> - ignored"
argument_list|,
name|op
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|)
operator|==
name|CPP_COMMA
condition|)
block|{
name|token
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_NAME
operator|&&
name|id
operator|==
literal|0
condition|)
block|{
name|id
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
operator|&&
name|action
operator|==
name|push
operator|&&
name|align
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|GCC_BAD
argument_list|(
literal|"invalid constant in %<#pragma pack%> - ignored"
argument_list|)
expr_stmt|;
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
operator|-
literal|1
condition|)
name|action
operator|=
name|set
expr_stmt|;
block|}
else|else
name|GCC_BAD_ACTION
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|GCC_BAD_ACTION
expr_stmt|;
undef|#
directive|undef
name|GCC_BAD_ACTION
block|}
else|else
name|GCC_BAD
argument_list|(
literal|"malformed %<#pragma pack%> - ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"junk at end of %<#pragma pack%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pack_struct
condition|)
name|GCC_BAD
argument_list|(
literal|"#pragma pack has no effect with -fpack-struct - ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|pop
condition|)
switch|switch
condition|(
name|align
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
case|case
literal|16
case|:
name|align
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|action
operator|==
name|push
condition|)
block|{
name|align
operator|=
name|maximum_field_alignment
expr_stmt|;
break|break;
block|}
default|default:
name|GCC_BAD2
argument_list|(
literal|"alignment must be a small power of two, not %d"
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|set
case|:
name|SET_GLOBAL_ALIGNMENT
argument_list|(
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|push
case|:
name|push_alignment
argument_list|(
name|align
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|pop
case|:
name|pop_alignment
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_PACK */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_weaks
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
end_ifdef

begin_function_decl
specifier|static
name|void
name|apply_pragma_weak
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_weak
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|apply_pragma_weak
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
condition|)
block|{
name|value
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|value
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|build_tree_list
argument_list|(
name|get_identifier
argument_list|(
literal|"alias"
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUPPORTS_WEAK
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
comment|/* Don't complain about a redundant #pragma.  */
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"applying #pragma weak %q+D after first use "
literal|"results in unspecified behavior"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|declare_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maybe_apply_pragma_weak
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|,
name|id
decl_stmt|;
comment|/* Avoid asking for DECL_ASSEMBLER_NAME when it's not needed.  */
comment|/* No weak symbols pending, take the short-cut.  */
if|if
condition|(
operator|!
name|pending_weaks
condition|)
return|return;
comment|/* If it's not visible outside this file, it doesn't matter whether      it's weak.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If it's not a function or a variable, it can't be weak.      FIXME: what kinds of things are visible outside this file but      aren't functions or variables?   Should this be an assert instead?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
name|id
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pending_weaks
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|id
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|apply_pragma_weak
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Process all "#pragma weak A = B" directives where we have not seen    a decl for A.  */
end_comment

begin_function
name|void
name|maybe_apply_pending_pragma_weaks
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|,
name|alias_id
decl_stmt|,
name|id
decl_stmt|,
name|decl
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pending_weaks
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|alias_id
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|alias_id
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #pragma weak name [= value] */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_weak
parameter_list|(
name|cpp_reader
modifier|*
name|ARG_UNUSED
parameter_list|(
name|dummy
parameter_list|)
parameter_list|)
block|{
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|,
name|x
decl_stmt|,
name|decl
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|name
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma weak, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CPP_EQ
condition|)
block|{
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|value
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma weak, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"junk at end of %<#pragma weak%>"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|identifier_global_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|apply_pragma_weak
argument_list|(
name|decl
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|pending_weaks
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|pending_weaks
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|maybe_apply_pragma_weak
parameter_list|(
name|tree
name|ARG_UNUSED
parameter_list|(
name|decl
parameter_list|)
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|maybe_apply_pending_pragma_weaks
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_WEAK */
end_comment

begin_comment
comment|/* GCC supports two #pragma directives for renaming the external    symbol associated with a declaration (DECL_ASSEMBLER_NAME), for    compatibility with the Solaris and Tru64 system headers.  GCC also    has its own notation for this, __asm__("name") annotations.     Corner cases of these features and their interaction:     1) Both pragmas silently apply only to declarations with external       linkage (that is, TREE_PUBLIC || DECL_EXTERNAL).  Asm labels       do not have this restriction.     2) In C++, both #pragmas silently apply only to extern "C" declarations.       Asm labels do not have this restriction.     3) If any of the three ways of changing DECL_ASSEMBLER_NAME is       applied to a decl whose DECL_ASSEMBLER_NAME is already set, and the       new name is different, a warning issues and the name does not change.     4) The "source name" for #pragma redefine_extname is the DECL_NAME,       *not* the DECL_ASSEMBLER_NAME.     5) If #pragma extern_prefix is in effect and a declaration occurs       with an __asm__ name, the #pragma extern_prefix is silently       ignored for that declaration.     6) If #pragma extern_prefix and #pragma redefine_extname apply to       the same declaration, whichever triggered first wins, and a warning       is issued.  (We would like to have #pragma redefine_extname always       win, but it can appear either before or after the declaration, and       if it appears afterward, we have no way of knowing whether a modified       DECL_ASSEMBLER_NAME is due to #pragma extern_prefix.)  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_redefine_extname
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|handle_pragma_redefine_extname
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* #pragma redefine_extname oldname newname */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_redefine_extname
parameter_list|(
name|cpp_reader
modifier|*
name|ARG_UNUSED
parameter_list|(
name|dummy
parameter_list|)
parameter_list|)
block|{
name|tree
name|oldname
decl_stmt|,
name|newname
decl_stmt|,
name|decl
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|oldname
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma redefine_extname, ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|newname
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma redefine_extname, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"junk at end of %<#pragma redefine_extname%>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_mudflap
operator|&&
operator|!
name|targetm
operator|.
name|handle_pragma_redefine_extname
condition|)
block|{
if|if
condition|(
name|warn_unknown_pragmas
operator|>
name|in_system_header
condition|)
name|warning
argument_list|(
name|OPT_Wunknown_pragmas
argument_list|,
literal|"#pragma redefine_extname not supported on this target"
argument_list|)
expr_stmt|;
return|return;
block|}
name|decl
operator|=
name|identifier_global_value
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|has_c_linkage
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|name
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|newname
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"#pragma redefine_extname ignored due to "
literal|"conflict with previous rename"
argument_list|)
expr_stmt|;
block|}
else|else
name|change_decl_assembler_name
argument_list|(
name|decl
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We have to add this to the rename list even if there's already        a global value that doesn't meet the above criteria, because in        C++ "struct foo {...};" puts "foo" in the current namespace but        does *not* conflict with a subsequent declaration of a function        or variable foo.  See g++.dg/other/pragma-re-2.C.  */
name|add_to_renaming_pragma_list
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from here and from ia64.c.  */
end_comment

begin_function
name|void
name|add_to_renaming_pragma_list
parameter_list|(
name|tree
name|oldname
parameter_list|,
name|tree
name|newname
parameter_list|)
block|{
name|tree
name|previous
init|=
name|purpose_member
argument_list|(
name|oldname
argument_list|,
name|pending_redefine_extname
argument_list|)
decl_stmt|;
if|if
condition|(
name|previous
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|previous
argument_list|)
operator|!=
name|newname
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"#pragma redefine_extname ignored due to "
literal|"conflict with previous #pragma redefine_extname"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pending_redefine_extname
operator|=
name|tree_cons
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|,
name|pending_redefine_extname
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pragma_extern_prefix
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* #pragma extern_prefix "prefix" */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_extern_prefix
parameter_list|(
name|cpp_reader
modifier|*
name|ARG_UNUSED
parameter_list|(
name|dummy
parameter_list|)
parameter_list|)
block|{
name|tree
name|prefix
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|prefix
argument_list|)
operator|!=
name|CPP_STRING
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma extern_prefix, ignored"
argument_list|)
expr_stmt|;
name|t
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"junk at end of %<#pragma extern_prefix%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|handle_pragma_extern_prefix
condition|)
comment|/* Note that the length includes the null terminator.  */
name|pragma_extern_prefix
operator|=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|prefix
argument_list|)
operator|>
literal|1
condition|?
name|prefix
else|:
name|NULL
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_unknown_pragmas
operator|>
name|in_system_header
condition|)
name|warning
argument_list|(
name|OPT_Wunknown_pragmas
argument_list|,
literal|"#pragma extern_prefix not supported on this target"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook from the front ends to apply the results of one of the preceding    pragmas that rename variables.  */
end_comment

begin_function
name|tree
name|maybe_apply_renaming_pragma
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|asmname
parameter_list|)
block|{
name|tree
modifier|*
name|p
decl_stmt|,
name|t
decl_stmt|;
comment|/* The renaming pragmas are only applied to declarations with      external linkage.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|)
operator|||
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|!
name|has_c_linkage
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|asmname
return|;
comment|/* If the DECL_ASSEMBLER_NAME is already set, it does not change,      but we may warn about a rename that conflicts.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|oldname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|oldname
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmname
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|asmname
argument_list|)
argument_list|,
name|oldname
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"asm declaration ignored due to "
literal|"conflict with previous rename"
argument_list|)
expr_stmt|;
comment|/* Take any pending redefine_extname off the list.  */
for|for
control|(
name|p
operator|=
operator|&
name|pending_redefine_extname
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Only warn if there is a conflict.  */
if|if
condition|(
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|oldname
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"#pragma redefine_extname ignored due to "
literal|"conflict with previous rename"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
comment|/* Find out if we have a pending #pragma redefine_extname.  */
for|for
control|(
name|p
operator|=
operator|&
name|pending_redefine_extname
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|newname
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we already have an asmname, #pragma redefine_extname is 	   ignored (with a warning if it conflicts).  */
if|if
condition|(
name|asmname
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|asmname
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|newname
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"#pragma redefine_extname ignored due to "
literal|"conflict with __asm__ declaration"
argument_list|)
expr_stmt|;
return|return
name|asmname
return|;
block|}
comment|/* Otherwise we use what we've got; #pragma extern_prefix is 	   silently ignored.  */
return|return
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|newname
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|newname
argument_list|)
argument_list|)
return|;
block|}
comment|/* If we've got an asmname, #pragma extern_prefix is silently ignored.  */
if|if
condition|(
name|asmname
condition|)
return|return
name|asmname
return|;
comment|/* If #pragma extern_prefix is in effect, apply it.  */
if|if
condition|(
name|pragma_extern_prefix
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|TREE_STRING_POINTER
argument_list|(
name|pragma_extern_prefix
argument_list|)
decl_stmt|;
name|size_t
name|plen
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|pragma_extern_prefix
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|id
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|ilen
init|=
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newname
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|plen
operator|+
name|ilen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newname
argument_list|,
name|prefix
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newname
operator|+
name|plen
argument_list|,
name|id
argument_list|,
name|ilen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|build_string
argument_list|(
name|plen
operator|+
name|ilen
argument_list|,
name|newname
argument_list|)
return|;
block|}
comment|/* Nada.  */
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_VISIBILITY
end_ifdef

begin_function_decl
specifier|static
name|void
name|handle_pragma_visibility
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|enum
name|symbol_visibility
name|visibility
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_I
argument_list|(
name|visibility
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_I
argument_list|(
name|visibility
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|visibility
argument_list|,
name|heap
argument_list|)
operator|*
name|visstack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Push the visibility indicated by STR onto the top of the #pragma    visibility stack.  */
end_comment

begin_function
name|void
name|push_visibility
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|visibility
argument_list|,
name|heap
argument_list|,
name|visstack
argument_list|,
name|default_visibility
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"default"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"internal"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_INTERNAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"hidden"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"protected"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_PROTECTED
expr_stmt|;
else|else
name|GCC_BAD
argument_list|(
literal|"#pragma GCC visibility push() must specify default, internal, hidden or protected"
argument_list|)
expr_stmt|;
name|visibility_options
operator|.
name|inpragma
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a level of the #pragma visibility stack.  */
end_comment

begin_function
name|void
name|pop_visibility
parameter_list|(
name|void
parameter_list|)
block|{
name|default_visibility
operator|=
name|VEC_pop
argument_list|(
name|visibility
argument_list|,
name|visstack
argument_list|)
expr_stmt|;
name|visibility_options
operator|.
name|inpragma
operator|=
name|VEC_length
argument_list|(
name|visibility
argument_list|,
name|visstack
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets the default visibility for symbols to something other than that    specified on the command line.  */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_visibility
parameter_list|(
name|cpp_reader
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Form is #pragma GCC visibility push(hidden)|pop */
name|tree
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|token
decl_stmt|;
enum|enum
block|{
name|bad
block|,
name|push
block|,
name|pop
block|}
name|action
init|=
name|bad
enum|;
name|token
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
specifier|const
name|char
modifier|*
name|op
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"push"
argument_list|)
condition|)
name|action
operator|=
name|push
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op
argument_list|,
literal|"pop"
argument_list|)
condition|)
name|action
operator|=
name|pop
expr_stmt|;
block|}
if|if
condition|(
name|bad
operator|==
name|action
condition|)
name|GCC_BAD
argument_list|(
literal|"#pragma GCC visibility must be followed by push or pop"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pop
operator|==
name|action
condition|)
block|{
if|if
condition|(
operator|!
name|VEC_length
argument_list|(
name|visibility
argument_list|,
name|visstack
argument_list|)
condition|)
name|GCC_BAD
argument_list|(
literal|"no matching push for %<#pragma GCC visibility pop%>"
argument_list|)
expr_stmt|;
else|else
name|pop_visibility
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"missing %<(%> after %<#pragma GCC visibility push%> - ignored"
argument_list|)
expr_stmt|;
name|token
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"malformed #pragma GCC visibility push"
argument_list|)
expr_stmt|;
else|else
name|push_visibility
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|GCC_BAD
argument_list|(
literal|"missing %<(%> after %<#pragma GCC visibility push%> - ignored"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"junk at end of %<#pragma GCC visibility%>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|handle_pragma_diagnostic
parameter_list|(
name|cpp_reader
modifier|*
name|ARG_UNUSED
parameter_list|(
name|dummy
parameter_list|)
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|kind_string
decl_stmt|,
modifier|*
name|option_string
decl_stmt|;
name|unsigned
name|int
name|option_index
decl_stmt|;
name|enum
name|cpp_ttype
name|token
decl_stmt|;
name|diagnostic_t
name|kind
decl_stmt|;
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|cfun
condition|)
block|{
name|error
argument_list|(
literal|"#pragma GCC diagnostic not allowed inside functions"
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_NAME
condition|)
name|GCC_BAD
argument_list|(
literal|"missing [error|warning|ignored] after %<#pragma GCC diagnostic%>"
argument_list|)
expr_stmt|;
name|kind_string
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|kind_string
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
name|kind
operator|=
name|DK_ERROR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|kind_string
argument_list|,
literal|"warning"
argument_list|)
operator|==
literal|0
condition|)
name|kind
operator|=
name|DK_WARNING
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|kind_string
argument_list|,
literal|"ignored"
argument_list|)
operator|==
literal|0
condition|)
name|kind
operator|=
name|DK_IGNORED
expr_stmt|;
else|else
name|GCC_BAD
argument_list|(
literal|"expected [error|warning|ignored] after %<#pragma GCC diagnostic%>"
argument_list|)
expr_stmt|;
name|token
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_STRING
condition|)
name|GCC_BAD
argument_list|(
literal|"missing option after %<#pragma GCC diagnostic%> kind"
argument_list|)
expr_stmt|;
name|option_string
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|option_index
operator|=
literal|0
init|;
name|option_index
operator|<
name|cl_options_count
condition|;
name|option_index
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cl_options
index|[
name|option_index
index|]
operator|.
name|opt_text
argument_list|,
name|option_string
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This overrides -Werror, for example.  */
name|diagnostic_classify_diagnostic
argument_list|(
name|global_dc
argument_list|,
name|option_index
argument_list|,
name|kind
argument_list|)
expr_stmt|;
comment|/* This makes sure the option is enabled, like -Wfoo would do.  */
if|if
condition|(
name|cl_options
index|[
name|option_index
index|]
operator|.
name|var_type
operator|==
name|CLVC_BOOLEAN
operator|&&
name|cl_options
index|[
name|option_index
index|]
operator|.
name|flag_var
operator|&&
name|kind
operator|!=
name|DK_IGNORED
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|cl_options
index|[
name|option_index
index|]
operator|.
name|flag_var
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|GCC_BAD
argument_list|(
literal|"unknown option after %<#pragma GCC diagnostic%> kind"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A vector of registered pragma callbacks.  */
end_comment

begin_expr_stmt
name|DEF_VEC_O
argument_list|(
name|pragma_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_O
argument_list|(
name|pragma_handler
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|pragma_handler
argument_list|,
name|heap
argument_list|)
operator|*
name|registered_pragmas
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Front-end wrappers for pragma registration to avoid dragging    cpplib.h in almost everywhere.  */
end_comment

begin_function
specifier|static
name|void
name|c_register_pragma_1
parameter_list|(
specifier|const
name|char
modifier|*
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|pragma_handler
name|handler
parameter_list|,
name|bool
name|allow_expansion
parameter_list|)
block|{
name|unsigned
name|id
decl_stmt|;
name|VEC_safe_push
argument_list|(
name|pragma_handler
argument_list|,
name|heap
argument_list|,
name|registered_pragmas
argument_list|,
operator|&
name|handler
argument_list|)
expr_stmt|;
name|id
operator|=
name|VEC_length
argument_list|(
name|pragma_handler
argument_list|,
name|registered_pragmas
argument_list|)
expr_stmt|;
name|id
operator|+=
name|PRAGMA_FIRST_EXTERNAL
operator|-
literal|1
expr_stmt|;
comment|/* The C++ front end allocates 6 bits in cp_token; the C front end      allocates 7 bits in c_token.  At present this is sufficient.  */
name|gcc_assert
argument_list|(
name|id
operator|<
literal|64
argument_list|)
expr_stmt|;
name|cpp_register_deferred_pragma
argument_list|(
name|parse_in
argument_list|,
name|space
argument_list|,
name|name
argument_list|,
name|id
argument_list|,
name|allow_expansion
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|c_register_pragma
parameter_list|(
specifier|const
name|char
modifier|*
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|pragma_handler
name|handler
parameter_list|)
block|{
name|c_register_pragma_1
argument_list|(
name|space
argument_list|,
name|name
argument_list|,
name|handler
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|c_register_pragma_with_expansion
parameter_list|(
specifier|const
name|char
modifier|*
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|pragma_handler
name|handler
parameter_list|)
block|{
name|c_register_pragma_1
argument_list|(
name|space
argument_list|,
name|name
argument_list|,
name|handler
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|c_invoke_pragma_handler
parameter_list|(
name|unsigned
name|int
name|id
parameter_list|)
block|{
name|pragma_handler
name|handler
decl_stmt|;
name|id
operator|-=
name|PRAGMA_FIRST_EXTERNAL
expr_stmt|;
name|handler
operator|=
operator|*
name|VEC_index
argument_list|(
name|pragma_handler
argument_list|,
name|registered_pragmas
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|handler
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up front-end pragmas.  */
end_comment

begin_function
name|void
name|init_pragma
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_openmp
operator|&&
operator|!
name|flag_preprocess_only
condition|)
block|{
struct|struct
name|omp_pragma_def
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|struct
name|omp_pragma_def
name|omp_pragmas
index|[]
init|=
block|{
block|{
literal|"atomic"
block|,
name|PRAGMA_OMP_ATOMIC
block|}
block|,
block|{
literal|"barrier"
block|,
name|PRAGMA_OMP_BARRIER
block|}
block|,
block|{
literal|"critical"
block|,
name|PRAGMA_OMP_CRITICAL
block|}
block|,
block|{
literal|"flush"
block|,
name|PRAGMA_OMP_FLUSH
block|}
block|,
block|{
literal|"for"
block|,
name|PRAGMA_OMP_FOR
block|}
block|,
block|{
literal|"master"
block|,
name|PRAGMA_OMP_MASTER
block|}
block|,
block|{
literal|"ordered"
block|,
name|PRAGMA_OMP_ORDERED
block|}
block|,
block|{
literal|"parallel"
block|,
name|PRAGMA_OMP_PARALLEL
block|}
block|,
block|{
literal|"section"
block|,
name|PRAGMA_OMP_SECTION
block|}
block|,
block|{
literal|"sections"
block|,
name|PRAGMA_OMP_SECTIONS
block|}
block|,
block|{
literal|"single"
block|,
name|PRAGMA_OMP_SINGLE
block|}
block|,
block|{
literal|"threadprivate"
block|,
name|PRAGMA_OMP_THREADPRIVATE
block|}
block|}
decl_stmt|;
specifier|const
name|int
name|n_omp_pragmas
init|=
sizeof|sizeof
argument_list|(
name|omp_pragmas
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|omp_pragmas
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_omp_pragmas
condition|;
operator|++
name|i
control|)
name|cpp_register_deferred_pragma
argument_list|(
name|parse_in
argument_list|,
literal|"omp"
argument_list|,
name|omp_pragmas
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|omp_pragmas
index|[
name|i
index|]
operator|.
name|id
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|cpp_register_deferred_pragma
argument_list|(
name|parse_in
argument_list|,
literal|"GCC"
argument_list|,
literal|"pch_preprocess"
argument_list|,
name|PRAGMA_GCC_PCH_PREPROCESS
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_PACK_WITH_EXPANSION
name|c_register_pragma_with_expansion
argument_list|(
literal|0
argument_list|,
literal|"pack"
argument_list|,
name|handle_pragma_pack
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"pack"
argument_list|,
name|handle_pragma_pack
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_WEAK
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"weak"
argument_list|,
name|handle_pragma_weak
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_VISIBILITY
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"visibility"
argument_list|,
name|handle_pragma_visibility
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"diagnostic"
argument_list|,
name|handle_pragma_diagnostic
argument_list|)
expr_stmt|;
name|c_register_pragma_with_expansion
argument_list|(
literal|0
argument_list|,
literal|"redefine_extname"
argument_list|,
name|handle_pragma_redefine_extname
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"extern_prefix"
argument_list|,
name|handle_pragma_extern_prefix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_TARGET_PRAGMAS
name|REGISTER_TARGET_PRAGMAS
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_include
include|#
directive|include
file|"gt-c-pragma.h"
end_include

end_unit

