begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph building code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* find_basic_blocks divides the current function's rtl into basic    blocks and constructs the CFG.  The blocks are recorded in the    basic_block_info array; the CFG exists in the edge structures    referenced by the blocks.     find_basic_blocks also finds any unreachable loops and deletes them.     Available functionality:      - CFG construction          find_basic_blocks      - Local CFG construction          find_sub_basic_blocks		 */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|count_basic_blocks
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_basic_blocks_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_label_refs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_edges
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_label_edge
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_eh_edge
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_bb_boundaries
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_outgoing_frequencies
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|inside_basic_block_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return true if insn is something that should be contained inside basic    block.  */
end_comment

begin_function
specifier|static
name|bool
name|inside_basic_block_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* Avoid creating of basic block for jumptables.  */
return|return
operator|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|)
return|;
case|case
name|JUMP_INSN
case|:
return|return
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
return|;
case|case
name|CALL_INSN
case|:
case|case
name|INSN
case|:
return|return
name|true
return|;
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
return|return
name|false
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if INSN may cause control flow transfer, so it should be last in    the basic block.  */
end_comment

begin_function
name|bool
name|control_flow_insn_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|CODE_LABEL
case|:
return|return
name|false
return|;
case|case
name|JUMP_INSN
case|:
comment|/* Jump insn always causes control transfer except for tablejumps.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
return|;
case|case
name|CALL_INSN
case|:
comment|/* Call insn may return to the nonlocal goto handler.  */
return|return
operator|(
operator|(
name|nonlocal_goto_handler_labels
operator|&&
operator|(
literal|0
operator|==
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|)
comment|/* Or may trap.  */
operator|||
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
operator|)
return|;
case|case
name|INSN
case|:
return|return
operator|(
name|flag_non_call_exceptions
operator|&&
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
operator|)
return|;
case|case
name|BARRIER
case|:
comment|/* It is nonsence to reach barrier when looking for the 	   end of basic block, but before dead code is eliminated 	   this may happen.  */
return|return
name|false
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Count the basic blocks of the function.  */
end_comment

begin_function
specifier|static
name|int
name|count_basic_blocks
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|bool
name|saw_insn
init|=
name|false
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Code labels and barriers causes curent basic block to be          terminated at previous real insn.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|)
operator|&&
name|saw_insn
condition|)
name|count
operator|++
operator|,
name|saw_insn
operator|=
name|false
expr_stmt|;
comment|/* Start basic block if needed.  */
if|if
condition|(
operator|!
name|saw_insn
operator|&&
name|inside_basic_block_p
argument_list|(
name|insn
argument_list|)
condition|)
name|saw_insn
operator|=
name|true
expr_stmt|;
comment|/* Control flow insn causes current basic block to be terminated.  */
if|if
condition|(
name|saw_insn
operator|&&
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|count
operator|++
operator|,
name|saw_insn
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|saw_insn
condition|)
name|count
operator|++
expr_stmt|;
comment|/* The rest of the compiler works a bit smoother when we don't have to      check for the edge case of do-nothing functions with no basic blocks.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Scan a list of insns for labels referred to other than by jumps.    This is used to scan the alternatives of a call placeholder.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_label_refs
parameter_list|(
name|f
parameter_list|,
name|lvl
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|rtx
name|lvl
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Make a list of all labels referred to other than by jumps 	   (which just don't have the REG_LABEL notes).  	   Make a special exception for labels followed by an ADDR*VEC, 	   as this would be a part of the tablejump setup code.  	   Make a special exception to registers loaded with label 	   values just before jump insns that use them.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|lab
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lab
argument_list|)
operator|==
name|NOTE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|find_reg_note
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REG_LABEL
argument_list|,
name|lab
argument_list|)
condition|)
empty_stmt|;
else|else
name|lvl
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lvl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an edge between two basic blocks.  FLAGS are auxiliary information    about the edge that is accumulated between calls.  */
end_comment

begin_comment
comment|/* Create an edge from a basic block to a label.  */
end_comment

begin_function
specifier|static
name|void
name|make_label_edge
parameter_list|(
name|edge_cache
parameter_list|,
name|src
parameter_list|,
name|label
parameter_list|,
name|flags
parameter_list|)
name|sbitmap
modifier|*
name|edge_cache
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the label was never emitted, this insn is junk, but avoid a      crash trying to refer to BLOCK_FOR_INSN (label).  This can happen      as a result of a syntax error and a diagnostic has already been      printed.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|cached_make_edge
argument_list|(
name|edge_cache
argument_list|,
name|src
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|label
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the edges generated by INSN in REGION.  */
end_comment

begin_function
specifier|static
name|void
name|make_eh_edge
parameter_list|(
name|edge_cache
parameter_list|,
name|src
parameter_list|,
name|insn
parameter_list|)
name|sbitmap
modifier|*
name|edge_cache
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|is_call
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|?
name|EDGE_ABNORMAL_CALL
else|:
literal|0
decl_stmt|;
name|rtx
name|handlers
decl_stmt|,
name|i
decl_stmt|;
name|handlers
operator|=
name|reachable_handlers
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|handlers
init|;
name|i
condition|;
name|i
operator|=
name|XEXP
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
control|)
name|make_label_edge
argument_list|(
name|edge_cache
argument_list|,
name|src
argument_list|,
name|XEXP
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_EH
operator||
name|is_call
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|handlers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify the edges between basic blocks MIN to MAX.     NONLOCAL_LABEL_LIST is a list of non-local labels in the function.  Blocks    that are otherwise unreachable may be reachable with a non-local goto.     BB_EH_END is an array indexed by basic block number in which we record    the list of exception regions active at the end of the basic block.  */
end_comment

begin_function
specifier|static
name|void
name|make_edges
parameter_list|(
name|label_value_list
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|update_p
parameter_list|)
name|rtx
name|label_value_list
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|,
name|update_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|sbitmap
modifier|*
name|edge_cache
init|=
name|NULL
decl_stmt|;
comment|/* Assume no computed jump; revise as we create edges.  */
name|current_function_has_computed_jump
operator|=
literal|0
expr_stmt|;
comment|/* Heavy use of computed goto in machine-generated code can lead to      nearly fully-connected CFGs.  In that case we spend a significant      amount of time searching the edge lists for duplicates.  */
if|if
condition|(
name|forced_labels
operator|||
name|label_value_list
condition|)
block|{
name|edge_cache
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|edge_cache
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_p
condition|)
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
operator|++
name|i
control|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|SET_BIT
argument_list|(
name|edge_cache
index|[
name|i
index|]
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* By nature of the way these get numbered, block 0 is always the entry.  */
if|if
condition|(
name|min
operator|==
literal|0
condition|)
name|cached_make_edge
argument_list|(
name|edge_cache
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|,
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|force_fallthru
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb
operator|->
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_ALTERNATE_NAME
argument_list|(
name|bb
operator|->
name|head
argument_list|)
condition|)
name|cached_make_edge
argument_list|(
name|NULL
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Examine the last instruction of the block, and discover the 	 ways we can leave the block.  */
name|insn
operator|=
name|bb
operator|->
name|end
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A branch.  */
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* Recognize exception handling placeholders.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RESX
condition|)
name|make_eh_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Recognize a non-local goto as a branch outside the 	     current function.  */
elseif|else
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NON_LOCAL_GOTO
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
empty_stmt|;
comment|/* ??? Recognize a tablejump and do the right thing.  */
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|make_label_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Some targets (eg, ARM) emit a conditional jump that also 		 contains the out-of-range target.  Scan for these and 		 add an edge if necessary.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|SET_DEST
argument_list|(
name|tmp
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|make_label_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
comment|/* Silly VAXen.  The ADDR_VEC is going to be in the way of 		 us naturally detecting fallthru into the next block.  */
name|force_fallthru
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this is a computed jump, then mark it as reaching 	     everything on the label_value_list and forced_labels list.  */
elseif|else
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|current_function_has_computed_jump
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|make_label_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|make_label_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Returns create an exit out.  */
elseif|else
if|if
condition|(
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|cached_make_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Otherwise, we have a plain conditional or unconditional jump.  */
else|else
block|{
if|if
condition|(
operator|!
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|make_label_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a sibling call insn, then this is in effect a combined call 	 and return, and so we need an edge to the exit block.  No need to 	 worry about EH edges, since we wouldn't have created the sibling call 	 in the first place.  */
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|&&
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|cached_make_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
argument_list|)
expr_stmt|;
comment|/* If this is a CALL_INSN, then mark it as reaching the active EH 	 handler for this CALL_INSN.  If we're handling non-call 	 exceptions then any insn can reach any of the active handlers. 	 Also mark the CALL_INSN as reaching any nonlocal goto handler.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|||
name|flag_non_call_exceptions
condition|)
block|{
comment|/* Add any appropriate EH edges.  */
name|make_eh_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|&&
name|nonlocal_goto_handler_labels
condition|)
block|{
comment|/* ??? This could be made smarter: in some cases it's possible 		 to tell that certain calls will not do a nonlocal goto. 		 For example, if the nested functions that do the nonlocal 		 gotos do not have their addresses taken, then only calls to 		 those functions or to other nested functions that use them 		 could possibly do nonlocal gotos.  */
comment|/* We do know that a REG_EH_REGION note with a value less 		 than 0 is guaranteed not to perform a non-local goto.  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
for|for
control|(
name|x
operator|=
name|nonlocal_goto_handler_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|make_label_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find out if we can drop through to the next block.  */
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|(
name|i
operator|+
literal|1
operator|==
name|n_basic_blocks
operator|&&
name|force_fallthru
operator|)
condition|)
name|cached_make_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|n_basic_blocks
condition|)
block|{
name|rtx
name|tmp
init|=
name|BLOCK_HEAD
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE
condition|)
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_fallthru
operator|||
name|insn
operator|==
name|tmp
condition|)
name|cached_make_edge
argument_list|(
name|edge_cache
argument_list|,
name|bb
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|edge_cache
condition|)
name|sbitmap_vector_free
argument_list|(
name|edge_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all basic blocks of the function whose first insn is F.     Collect and return a list of labels whose addresses are taken.  This    will be used in make_edges for use with computed gotos.  */
end_comment

begin_function
specifier|static
name|void
name|find_basic_blocks_1
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|rtx
name|bb_note
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|lvl
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|trll
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|head
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|end
init|=
name|NULL_RTX
decl_stmt|;
comment|/* We process the instructions in a slightly different way than we did      previously.  This is so that we see a NOTE_BASIC_BLOCK after we have      closed out the previous block, so that it gets attached at the proper      place.  Since this form should be equivalent to the previous,      count_basic_blocks continues to use the old form as a check.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|)
operator|&&
name|head
condition|)
block|{
name|create_basic_block_structure
argument_list|(
name|i
operator|++
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
name|head
operator|=
name|end
operator|=
name|NULL_RTX
expr_stmt|;
name|bb_note
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|inside_basic_block_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|NULL_RTX
condition|)
name|head
operator|=
name|insn
expr_stmt|;
name|end
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|&&
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|create_basic_block_structure
argument_list|(
name|i
operator|++
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
name|head
operator|=
name|end
operator|=
name|NULL_RTX
expr_stmt|;
name|bb_note
operator|=
name|NULL_RTX
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOTE
case|:
block|{
name|int
name|kind
init|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Look for basic block notes with which to keep the 	       basic_block_info pointers stable.  Unthread the note now; 	       we'll put it back at the right place in create_basic_block. 	       Or not at all if we've already found a note in this block.  */
if|if
condition|(
name|kind
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
if|if
condition|(
name|bb_note
operator|==
name|NULL_RTX
condition|)
name|bb_note
operator|=
name|insn
expr_stmt|;
else|else
name|next
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CODE_LABEL
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|INSN
case|:
case|case
name|BARRIER
case|:
break|break;
case|case
name|CALL_INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
comment|/* Scan each of the alternatives for label refs.  */
name|lvl
operator|=
name|find_label_refs
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
name|lvl
operator|=
name|find_label_refs
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
name|lvl
operator|=
name|find_label_refs
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
comment|/* Record its tail recursion label, if any.  */
if|if
condition|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|!=
name|NULL_RTX
condition|)
name|trll
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
argument_list|,
name|trll
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Make a list of all labels referred to other than by jumps.  	     Make a special exception for labels followed by an ADDR*VEC, 	     as this would be a part of the tablejump setup code.  	     Make a special exception to registers loaded with label 	     values just before jump insns that use them.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|lab
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lab
argument_list|)
operator|==
name|NOTE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|find_reg_note
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REG_LABEL
argument_list|,
name|lab
argument_list|)
condition|)
empty_stmt|;
else|else
name|lvl
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|head
operator|!=
name|NULL_RTX
condition|)
name|create_basic_block_structure
argument_list|(
name|i
operator|++
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bb_note
condition|)
name|delete_insn
argument_list|(
name|bb_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|label_value_list
operator|=
name|lvl
expr_stmt|;
name|tail_recursion_label_list
operator|=
name|trll
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find basic blocks of the current function.    F is the first insn of the function and NREGS the number of register    numbers in use.  */
end_comment

begin_function
name|void
name|find_basic_blocks
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|max_uid
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_CFG
argument_list|)
expr_stmt|;
name|basic_block_for_insn
operator|=
literal|0
expr_stmt|;
comment|/* Flush out existing data.  */
if|if
condition|(
name|basic_block_info
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|clear_edges
argument_list|()
expr_stmt|;
comment|/* Clear bb->aux on all extant basic blocks.  We'll use this as a 	 tag for reuse during create_basic_block, just in case some pass 	 copies around basic block notes improperly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|basic_block_info
argument_list|)
expr_stmt|;
block|}
name|n_basic_blocks
operator|=
name|count_basic_blocks
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Size the basic block table.  The actual structures will be allocated      by find_basic_blocks_1, since we want to keep the structure pointers      stable across calls to find_basic_blocks.  */
comment|/* ??? This whole issue would be much simpler if we called find_basic_blocks      exactly once, and thereafter we don't have a single long chain of      instructions at all until close to the end of compilation when we      actually lay them out.  */
name|VARRAY_BB_INIT
argument_list|(
name|basic_block_info
argument_list|,
name|n_basic_blocks
argument_list|,
literal|"basic_block_info"
argument_list|)
expr_stmt|;
name|find_basic_blocks_1
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Record the block to which an insn belongs.  */
comment|/* ??? This should be done another way, by which (perhaps) a label is      tagged directly with the basic block that it starts.  It is used for      more than that currently, but IMO that is the only valid use.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Leave space for insns life_analysis makes in some cases for auto-inc.      These cases are rare, so we don't need too much space.  */
name|max_uid
operator|+=
name|max_uid
operator|/
literal|10
expr_stmt|;
endif|#
directive|endif
name|compute_bb_for_insn
argument_list|(
name|max_uid
argument_list|)
expr_stmt|;
comment|/* Discover the edges of our cfg.  */
name|make_edges
argument_list|(
name|label_value_list
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do very simple cleanup now, for the benefit of code that runs between      here and cleanup_cfg, e.g. thread_prologue_and_epilogue_insns.  */
name|tidy_fallthru_edges
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_CFG
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* State of basic block as seen by find_sub_basic_blocks.  */
end_comment

begin_enum
enum|enum
name|state
block|{
name|BLOCK_NEW
init|=
literal|0
block|,
name|BLOCK_ORIGINAL
block|,
name|BLOCK_TO_SPLIT
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|STATE
parameter_list|(
name|BB
parameter_list|)
value|(enum state) ((size_t) (BB)->aux)
end_define

begin_define
define|#
directive|define
name|SET_STATE
parameter_list|(
name|BB
parameter_list|,
name|STATE
parameter_list|)
value|((BB)->aux = (void *) (size_t) (STATE))
end_define

begin_comment
comment|/* Scan basic block BB for possible BB boundaries inside the block    and create new basic blocks in the progress.  */
end_comment

begin_function
specifier|static
name|void
name|find_bb_boundaries
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|bb
operator|->
name|head
decl_stmt|;
name|rtx
name|end
init|=
name|bb
operator|->
name|end
decl_stmt|;
name|rtx
name|flow_transfer_insn
init|=
name|NULL_RTX
decl_stmt|;
name|edge
name|fallthru
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Scan insn chain and try to find new basic block boundaries.  */
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* On code label, split current basic block.  */
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
block|{
name|fallthru
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_transfer_insn
condition|)
name|bb
operator|->
name|end
operator|=
name|flow_transfer_insn
expr_stmt|;
name|bb
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
name|remove_edge
argument_list|(
name|fallthru
argument_list|)
expr_stmt|;
name|flow_transfer_insn
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|LABEL_ALTERNATE_NAME
argument_list|(
name|insn
argument_list|)
condition|)
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* In case we've previously seen an insn that effects a control 	 flow transfer, split the block.  */
if|if
condition|(
name|flow_transfer_insn
operator|&&
name|inside_basic_block_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|fallthru
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|->
name|end
operator|=
name|flow_transfer_insn
expr_stmt|;
name|bb
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
name|remove_edge
argument_list|(
name|fallthru
argument_list|)
expr_stmt|;
name|flow_transfer_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|flow_transfer_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* In case expander replaced normal insn by sequence terminating by      return and barrier, or possibly other sequence not behaving like      ordinary jump, we need to take care and move basic block boundary.  */
if|if
condition|(
name|flow_transfer_insn
condition|)
name|bb
operator|->
name|end
operator|=
name|flow_transfer_insn
expr_stmt|;
comment|/* We've possibly replaced the conditional jump by conditional jump      followed by cleanup at fallthru edge, so the outgoing edges may      be dead.  */
name|purge_dead_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Assume that frequency of basic block B is known.  Compute frequencies     and probabilities of outgoing edges.  */
end_comment

begin_function
specifier|static
name|void
name|compute_outgoing_frequencies
parameter_list|(
name|b
parameter_list|)
name|basic_block
name|b
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|,
name|f
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|succ
operator|&&
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|!
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|b
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|int
name|probability
decl_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
return|return;
name|probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|find_reg_note
argument_list|(
name|b
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|BRANCH_EDGE
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|probability
expr_stmt|;
name|e
operator|->
name|count
operator|=
operator|(
operator|(
name|b
operator|->
name|count
operator|*
name|probability
operator|+
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|)
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
name|f
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|f
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|f
operator|->
name|count
operator|=
name|b
operator|->
name|count
operator|-
name|e
operator|->
name|count
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|succ
operator|&&
operator|!
name|b
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|e
operator|=
name|b
operator|->
name|succ
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|b
operator|->
name|count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assume that someone emitted code with control flow instructions to the    basic block.  Update the data structure.  */
end_comment

begin_function
name|void
name|find_many_sub_basic_blocks
parameter_list|(
name|blocks
parameter_list|)
name|sbitmap
name|blocks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|SET_STATE
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|,
name|TEST_BIT
argument_list|(
name|blocks
argument_list|,
name|i
argument_list|)
condition|?
name|BLOCK_TO_SPLIT
else|:
name|BLOCK_ORIGINAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STATE
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|BLOCK_TO_SPLIT
condition|)
name|find_bb_boundaries
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STATE
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|BLOCK_ORIGINAL
condition|)
break|break;
name|min
operator|=
name|max
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STATE
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|BLOCK_ORIGINAL
condition|)
name|max
operator|=
name|i
expr_stmt|;
comment|/* Now re-scan and wire in all edges.  This expect simple (conditional)      jumps at the end of each new basic blocks.  */
name|make_edges
argument_list|(
name|NULL
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Update branch probabilities.  Expect only (un)conditional jumps      to be created with only the forward edges.  */
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|STATE
argument_list|(
name|b
argument_list|)
operator|==
name|BLOCK_ORIGINAL
condition|)
continue|continue;
if|if
condition|(
name|STATE
argument_list|(
name|b
argument_list|)
operator|==
name|BLOCK_NEW
condition|)
block|{
name|b
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|b
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|b
operator|->
name|frequency
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|compute_outgoing_frequencies
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|SET_STATE
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like above but for single basic block only.  */
end_comment

begin_function
name|void
name|find_sub_basic_blocks
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
name|basic_block
name|next
init|=
operator|(
name|bb
operator|->
name|index
operator|==
name|n_basic_blocks
operator|-
literal|1
condition|?
name|NULL
else|:
name|BASIC_BLOCK
argument_list|(
name|bb
operator|->
name|index
operator|+
literal|1
argument_list|)
operator|)
decl_stmt|;
name|min
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|find_bb_boundaries
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|max
operator|=
operator|(
name|next
condition|?
name|next
operator|->
name|index
else|:
name|n_basic_blocks
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Now re-scan and wire in all edges.  This expect simple (conditional)      jumps at the end of each new basic blocks.  */
name|make_edges
argument_list|(
name|NULL
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Update branch probabilities.  Expect only (un)conditional jumps      to be created with only the forward edges.  */
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|min
condition|)
block|{
name|b
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|b
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|b
operator|->
name|frequency
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|compute_outgoing_frequencies
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

