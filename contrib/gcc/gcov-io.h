begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine-independent I/O routines for gcov.    Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.    Contributed by Bob Manson<manson@cygnus.com>.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCOV_IO_H
end_ifndef

begin_define
define|#
directive|define
name|GCOV_IO_H
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|__fetch_long
name|PROTO
argument_list|(
operator|(
name|long
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__store_long
name|PROTO
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__read_long
name|PROTO
argument_list|(
operator|(
name|long
operator|*
operator|,
name|FILE
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__write_long
name|PROTO
argument_list|(
operator|(
name|long
operator|,
name|FILE
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These routines only work for signed values. */
end_comment

begin_comment
comment|/* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.    Return a non-zero value if VALUE requires more than BYTES*8-1 bits    to store. */
end_comment

begin_function
specifier|static
name|int
name|__store_long
parameter_list|(
name|value
parameter_list|,
name|dest
parameter_list|,
name|bytes
parameter_list|)
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|int
name|upper_bit
init|=
operator|(
name|value
operator|<
literal|0
condition|?
literal|128
else|:
literal|0
operator|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|long
name|oldvalue
init|=
name|value
decl_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|oldvalue
operator|!=
operator|-
name|value
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|<
name|bytes
condition|?
sizeof|sizeof
argument_list|(
name|value
argument_list|)
else|:
name|bytes
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dest
index|[
name|i
index|]
operator|=
name|value
operator|&
operator|(
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
expr_stmt|;
name|value
operator|=
name|value
operator|/
literal|256
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|&&
name|value
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|++
control|)
name|dest
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
name|bytes
operator|-
literal|1
index|]
operator||=
name|upper_bit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a quantity containing BYTES*8-1 bits from SOURCE and store    the result in DEST. Returns a non-zero value if the value in SOURCE    will not fit in DEST. */
end_comment

begin_function
specifier|static
name|int
name|__fetch_long
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|bytes
parameter_list|)
name|long
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|long
name|value
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bytes
operator|-
literal|1
init|;
operator|(
name|size_t
operator|)
name|i
operator|>
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|dest
argument_list|)
operator|-
literal|1
operator|)
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|source
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|size_t
operator|)
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|value
operator|=
name|value
operator|*
literal|256
operator|+
operator|(
name|source
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|size_t
operator|)
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|source
index|[
name|bytes
operator|-
literal|1
index|]
operator|&
literal|128
operator|)
operator|&&
operator|(
name|value
operator|>
literal|0
operator|)
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
operator|*
name|dest
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write a BYTES*8-bit quantity to FILE, portably. Returns a non-zero    value if the write fails, or if VALUE can't be stored in BYTES*8    bits.     Note that VALUE may not actually be large enough to hold BYTES*8    bits, but BYTES characters will be written anyway.     BYTES may be a maximum of 10. */
end_comment

begin_function
specifier|static
name|int
name|__write_long
parameter_list|(
name|value
parameter_list|,
name|file
parameter_list|,
name|bytes
parameter_list|)
name|long
name|value
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
name|c
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|10
operator|||
name|__store_long
argument_list|(
name|value
argument_list|,
name|c
argument_list|,
name|bytes
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
name|fwrite
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
name|bytes
argument_list|,
name|file
argument_list|)
operator|!=
name|bytes
return|;
block|}
end_function

begin_comment
comment|/* Read a quantity containing BYTES bytes from FILE, portably. Return    a non-zero value if the read fails or if the value will not fit    in DEST.     Note that DEST may not be large enough to hold all of the requested    data, but the function will read BYTES characters anyway.     BYTES may be a maximum of 10. */
end_comment

begin_function
specifier|static
name|int
name|__read_long
parameter_list|(
name|dest
parameter_list|,
name|file
parameter_list|,
name|bytes
parameter_list|)
name|long
modifier|*
name|dest
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
name|c
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|10
operator|||
name|fread
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
name|bytes
argument_list|,
name|file
argument_list|)
operator|!=
name|bytes
condition|)
return|return
literal|1
return|;
else|else
return|return
name|__fetch_long
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

