begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File format for coverage information    Copyright (C) 1996, 1997, 1998, 2000, 2002,    2003, 2004 Free Software Foundation, Inc.    Contributed by Bob Manson<manson@cygnus.com>.    Completely remangled by Nathan Sidwell<nathan@codesourcery.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* Coverage information is held in two files.  A notes file, which is    generated by the compiler, and a data file, which is generated    by the program under test.  Both files use a similar structure.  We    do not attempt to make these files backwards compatible with    previous versions, as you only need coverage information when    developing a program.  We do hold version information, so that    mismatches can be detected, and we use a format that allows tools    to skip information they do not understand or are not interested    in.     Numbers are recorded in the 32 bit unsigned binary form of the    endianness of the machine generating the file. 64 bit numbers are    stored as two 32 bit numbers, the low part first.  Strings are    padded with 1 to 4 NUL bytes, to bring the length up to a multiple    of 4. The number of 4 bytes is stored, followed by the padded    string. Zero length and NULL strings are simply stored as    a length of zero (they have no trailing NUL or padding).     	int32:  byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3 	int64:  int32:low int32:high 	string: int32:0 | int32:length char* char:0 padding 	padding: | char:0 | char:0 char:0 | char:0 char:0 char:0 	item: int32 | int64 | string     The basic format of the files is     	file : int32:magic int32:version int32:stamp record*     The magic ident is different for the notes and the data files.  The    magic ident is used to determine the endianness of the file, when    reading.  The version is the same for both files and is derived    from gcc's version number. The stamp value is used to synchronize    note and data files and to synchronize merging within a data    file. It need not be an absolute time stamp, merely a ticker that    increments fast enough and cycles slow enough to distinguish    different compile/run/compile cycles.        Although the ident and version are formally 32 bit numbers, they    are derived from 4 character ASCII strings.  The version number    consists of the single character major version number, a two    character minor version number (leading zero for versions less than    10), and a single character indicating the status of the release.    That will be 'e' experimental, 'p' prerelease and 'r' for release.    Because, by good fortune, these are in alphabetical order, string    collating can be used to compare version strings.  Be aware that    the 'e' designation will (naturally) be unstable and might be    incompatible with itself.  For gcc 3.4 experimental, it would be    '304e' (0x33303465).  When the major version reaches 10, the    letters A-Z will be used.  Assuming minor increments releases every    6 months, we have to make a major increment every 50 years.    Assuming major increments releases every 5 years, we're ok for the    next 155 years -- good enough for me.     A record has a tag, length and variable amount of data.     	record: header data 	header: int32:tag int32:length 	data: item*     Records are not nested, but there is a record hierarchy.  Tag    numbers reflect this hierarchy.  Tags are unique across note and    data files.  Some record types have a varying amount of data.  The    LENGTH is the number of 4bytes that follow and is usually used to    determine how much data.  The tag value is split into 4 8-bit    fields, one for each of four possible levels.  The most significant    is allocated first.  Unused levels are zero.  Active levels are    odd-valued, so that the LSB of the level is one.  A sub-level    incorporates the values of its superlevels.  This formatting allows    you to determine the tag hierarchy, without understanding the tags    themselves, and is similar to the standard section numbering used    in technical documents.  Level values [1..3f] are used for common    tags, values [41..9f] for the notes file and [a1..ff] for the data    file.     The basic block graph file contains the following records    	note: unit function-graph* 	unit: header int32:checksum string:source 	function-graph: announce_function basic_blocks {arcs | lines}* 	announce_function: header int32:ident int32:checksum 		string:name string:source int32:lineno 	basic_block: header int32:flags* 	arcs: header int32:block_no arc* 	arc:  int32:dest_block int32:flags         lines: header int32:block_no line*                int32:0 string:NULL 	line:  int32:line_no | int32:0 string:filename     The BASIC_BLOCK record holds per-bb flags.  The number of blocks    can be inferred from its data length.  There is one ARCS record per    basic block.  The number of arcs from a bb is implicit from the    data length.  It enumerates the destination bb and per-arc flags.    There is one LINES record per basic block, it enumerates the source    lines which belong to that basic block.  Source file names are    introduced by a line number of 0, following lines are from the new    source file.  The initial source file for the function is NULL, but    the current source file should be remembered from one LINES record    to the next.  The end of a block is indicated by an empty filename    - this does not reset the current source file.  Note there is no    ordering of the ARCS and LINES records: they may be in any order,    interleaved in any manner.  The current filename follows the order    the LINES records are stored in the file, *not* the ordering of the    blocks they are for.     The data file contains the following records.         data: {unit function-data* summary:object summary:program*}* 	unit: header int32:checksum         function-data:	announce_function arc_counts 	announce_function: header int32:ident int32:checksum 	arc_counts: header int64:count* 	summary: int32:checksum {count-summary}GCOV_COUNTERS 	count-summary:	int32:num int32:runs int64:sum 			int64:max int64:sum_max     The ANNOUNCE_FUNCTION record is the same as that in the note file,    but without the source location.  The ARC_COUNTS gives the counter    values for those arcs that are instrumented.  The SUMMARY records    give information about the whole object file and about the whole    program.  The checksum is used for whole program summaries, and    disambiguates different programs which include the same    instrumented object file.  There may be several program summaries,    each with a unique checksum.  The object summary's checksum is zero.    Note that the data file might contain information from several runs    concatenated, or the data might be merged.     This file is included by both the compiler, gcov tools and the    runtime support library libgcov. IN_LIBGCOV and IN_GCOV are used to    distinguish which case is which.  If IN_LIBGCOV is nonzero,    libgcov is being built. If IN_GCOV is nonzero, the gcov tools are    being built. Otherwise the compiler is being built. IN_GCOV may be    positive or negative. If positive, we are compiling a tool that    requires additional functions (see the code for knowledge of what    those functions are).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_GCOV_IO_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_GCOV_IO_H
end_define

begin_if
if|#
directive|if
name|IN_LIBGCOV
end_if

begin_comment
comment|/* About the target */
end_comment

begin_if
if|#
directive|if
name|BITS_PER_UNIT
operator|==
literal|8
end_if

begin_typedef
typedef|typedef
name|unsigned
name|gcov_unsigned_t
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|gcov_position_t
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_if
if|#
directive|if
name|LONG_LONG_TYPE_SIZE
operator|>
literal|32
end_if

begin_typedef
typedef|typedef
name|signed
name|gcov_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|DI
typedef|)));
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|signed
name|gcov_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|BITS_PER_UNIT
operator|==
literal|16
end_if

begin_typedef
typedef|typedef
name|unsigned
name|gcov_unsigned_t
name|__attribute__
typedef|((
name|mode
typedef|(
name|HI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|gcov_position_t
name|__attribute__
typedef|((
name|mode
typedef|(
name|HI
typedef|)));
end_typedef

begin_if
if|#
directive|if
name|LONG_LONG_TYPE_SIZE
operator|>
literal|32
end_if

begin_typedef
typedef|typedef
name|signed
name|gcov_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|signed
name|gcov_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|HI
typedef|)));
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|gcov_unsigned_t
name|__attribute__
typedef|((
name|mode
typedef|(
name|QI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|gcov_position_t
name|__attribute__
typedef|((
name|mode
typedef|(
name|QI
typedef|)));
end_typedef

begin_if
if|#
directive|if
name|LONG_LONG_TYPE_SIZE
operator|>
literal|32
end_if

begin_typedef
typedef|typedef
name|signed
name|gcov_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|HI
typedef|)));
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|signed
name|gcov_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|QI
typedef|)));
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TARGET_HAS_F_SETLKW
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCOV_LOCKED
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCOV_LOCKED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !IN_LIBGCOV */
end_comment

begin_comment
comment|/* About the host */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|gcov_unsigned_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|gcov_position_t
typedef|;
end_typedef

begin_comment
comment|/* gcov_type is typedef'd elsewhere for the compiler */
end_comment

begin_if
if|#
directive|if
name|IN_GCOV
end_if

begin_define
define|#
directive|define
name|GCOV_LINKAGE
value|static
end_define

begin_typedef
typedef|typedef
name|HOST_WIDEST_INT
name|gcov_type
typedef|;
end_typedef

begin_if
if|#
directive|if
name|IN_GCOV
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*!IN_GCOV */
end_comment

begin_if
if|#
directive|if
name|LONG_LONG_TYPE_SIZE
operator|>
literal|32
end_if

begin_define
define|#
directive|define
name|GCOV_TYPE_NODE
value|intDI_type_node
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCOV_TYPE_NODE
value|intSI_type_node
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HOST_HAS_F_SETLKW
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCOV_LOCKED
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCOV_LOCKED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !IN_LIBGCOV */
end_comment

begin_comment
comment|/* In gcov we want function linkage to be static. In libgcov we need    these functions to be extern, so prefix them with __gcov.  In the    compiler we want it extern, so that they can be accessed from    elsewhere.  */
end_comment

begin_if
if|#
directive|if
name|IN_LIBGCOV
end_if

begin_define
define|#
directive|define
name|gcov_var
value|__gcov_var
end_define

begin_define
define|#
directive|define
name|gcov_open
value|__gcov_open
end_define

begin_define
define|#
directive|define
name|gcov_close
value|__gcov_close
end_define

begin_define
define|#
directive|define
name|gcov_write_tag_length
value|__gcov_write_tag_length
end_define

begin_define
define|#
directive|define
name|gcov_position
value|__gcov_position
end_define

begin_define
define|#
directive|define
name|gcov_seek
value|__gcov_seek
end_define

begin_define
define|#
directive|define
name|gcov_rewrite
value|__gcov_rewrite
end_define

begin_define
define|#
directive|define
name|gcov_is_error
value|__gcov_is_error
end_define

begin_define
define|#
directive|define
name|gcov_is_eof
value|__gcov_is_eof
end_define

begin_define
define|#
directive|define
name|gcov_write_unsigned
value|__gcov_write_unsigned
end_define

begin_define
define|#
directive|define
name|gcov_write_counter
value|__gcov_write_counter
end_define

begin_define
define|#
directive|define
name|gcov_write_summary
value|__gcov_write_summary
end_define

begin_define
define|#
directive|define
name|gcov_read_unsigned
value|__gcov_read_unsigned
end_define

begin_define
define|#
directive|define
name|gcov_read_counter
value|__gcov_read_counter
end_define

begin_define
define|#
directive|define
name|gcov_read_summary
value|__gcov_read_summary
end_define

begin_comment
comment|/* Poison these, so they don't accidentally slip in.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|GCC
name|poison
name|gcov_write_string
name|gcov_write_tag
name|gcov_write_length
end_pragma

begin_pragma
pragma|#
directive|pragma
name|GCC
name|poison
name|gcov_read_string
name|gcov_sync
name|gcov_time
name|gcov_magic
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GCOV_LINKAGE
end_ifndef

begin_define
define|#
directive|define
name|GCOV_LINKAGE
value|extern
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* File suffixes.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_DATA_SUFFIX
value|".gcda"
end_define

begin_define
define|#
directive|define
name|GCOV_NOTE_SUFFIX
value|".gcno"
end_define

begin_comment
comment|/* File magic. Must not be palindromes.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_DATA_MAGIC
value|((gcov_unsigned_t)0x67636461)
end_define

begin_comment
comment|/* "gcda" */
end_comment

begin_define
define|#
directive|define
name|GCOV_NOTE_MAGIC
value|((gcov_unsigned_t)0x67636e6f)
end_define

begin_comment
comment|/* "gcno" */
end_comment

begin_comment
comment|/* gcov-iov.h is automatically generated by the makefile from    version.c, it looks like    	#define GCOV_VERSION ((gcov_unsigned_t)0x89abcdef) */
end_comment

begin_include
include|#
directive|include
file|"gcov-iov.h"
end_include

begin_comment
comment|/* Convert a magic or version number to a 4 character string.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_UNSIGNED2STRING
parameter_list|(
name|ARRAY
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|((ARRAY)[0] = (char)((VALUE)>> 24),		\    (ARRAY)[1] = (char)((VALUE)>> 16),		\    (ARRAY)[2] = (char)((VALUE)>> 8),		\    (ARRAY)[3] = (char)((VALUE)>> 0))
end_define

begin_comment
comment|/* The record tags.  Values [1..3f] are for tags which may be in either    file.  Values [41..9f] for those in the note file and [a1..ff] for    the data file.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_TAG_FUNCTION
value|((gcov_unsigned_t)0x01000000)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_FUNCTION_LENGTH
value|(2)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_BLOCKS
value|((gcov_unsigned_t)0x01410000)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_BLOCKS_LENGTH
parameter_list|(
name|NUM
parameter_list|)
value|(NUM)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_BLOCKS_NUM
parameter_list|(
name|LENGTH
parameter_list|)
value|(LENGTH)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_ARCS
value|((gcov_unsigned_t)0x01430000)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_ARCS_LENGTH
parameter_list|(
name|NUM
parameter_list|)
value|(1 + (NUM) * 2)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_ARCS_NUM
parameter_list|(
name|LENGTH
parameter_list|)
value|(((LENGTH) - 1) / 2)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_LINES
value|((gcov_unsigned_t)0x01450000)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_COUNTER_BASE
value|((gcov_unsigned_t)0x01a10000)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_COUNTER_LENGTH
parameter_list|(
name|NUM
parameter_list|)
value|((NUM) * 2)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_COUNTER_NUM
parameter_list|(
name|LENGTH
parameter_list|)
value|((LENGTH) / 2)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_OBJECT_SUMMARY
value|((gcov_unsigned_t)0xa1000000)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_PROGRAM_SUMMARY
value|((gcov_unsigned_t)0xa3000000)
end_define

begin_define
define|#
directive|define
name|GCOV_TAG_SUMMARY_LENGTH
define|\
value|(1 + GCOV_COUNTERS_SUMMABLE * (2 + 3 * 2))
end_define

begin_comment
comment|/* Counters that are collected.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTER_ARCS
value|0
end_define

begin_comment
comment|/* Arc transitions.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTERS_SUMMABLE
value|1
end_define

begin_comment
comment|/* Counters which can be 				      summaried.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_FIRST_VALUE_COUNTER
value|1
end_define

begin_comment
comment|/* The first of counters used for value 				      profiling.  They must form a consecutive 				      interval and their order must match 				      the order of HIST_TYPEs in 				      value-prof.h.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTER_V_INTERVAL
value|1
end_define

begin_comment
comment|/* Histogram of value inside an interval.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTER_V_POW2
value|2
end_define

begin_comment
comment|/* Histogram of exact power2 logarithm 				      of a value.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTER_V_SINGLE
value|3
end_define

begin_comment
comment|/* The most common value of expression.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTER_V_DELTA
value|4
end_define

begin_comment
comment|/* The most common difference between 				      consecutive values of expression.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_LAST_VALUE_COUNTER
value|4
end_define

begin_comment
comment|/* The last of counters used for value 				      profiling.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTERS
value|5
end_define

begin_comment
comment|/* Number of counters used for value profiling.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_N_VALUE_COUNTERS
define|\
value|(GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)
end_define

begin_comment
comment|/* A list of human readable names of the counters */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTER_NAMES
value|{"arcs", "interval", "pow2", "single", "delta"}
end_define

begin_comment
comment|/* Names of merge functions for counters.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_MERGE_FUNCTIONS
value|{"__gcov_merge_add",	\ 				 "__gcov_merge_add",	\ 				 "__gcov_merge_add",	\ 				 "__gcov_merge_single",	\ 				 "__gcov_merge_delta"}
end_define

begin_comment
comment|/* Convert a counter index to a tag.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_TAG_FOR_COUNTER
parameter_list|(
name|COUNT
parameter_list|)
define|\
value|(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT)<< 17))
end_define

begin_comment
comment|/* Convert a tag to a counter.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_COUNTER_FOR_TAG
parameter_list|(
name|TAG
parameter_list|)
define|\
value|((unsigned)(((TAG) - GCOV_TAG_COUNTER_BASE)>> 17))
end_define

begin_comment
comment|/* Check whether a tag is a counter tag.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_TAG_IS_COUNTER
parameter_list|(
name|TAG
parameter_list|)
define|\
value|(!((TAG)& 0xFFFF)&& GCOV_COUNTER_FOR_TAG (TAG)< GCOV_COUNTERS)
end_define

begin_comment
comment|/* The tag level mask has 1's in the position of the inner levels,&    the lsb of the current level, and zero on the current and outer    levels.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_TAG_MASK
parameter_list|(
name|TAG
parameter_list|)
value|(((TAG) - 1) ^ (TAG))
end_define

begin_comment
comment|/* Return nonzero if SUB is an immediate subtag of TAG.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_TAG_IS_SUBTAG
parameter_list|(
name|TAG
parameter_list|,
name|SUB
parameter_list|)
define|\
value|(GCOV_TAG_MASK (TAG)>> 8 == GCOV_TAG_MASK (SUB) 	\&& !(((SUB) ^ (TAG))& ~GCOV_TAG_MASK(TAG)))
end_define

begin_comment
comment|/* Return nonzero if SUB is at a sublevel to TAG.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_TAG_IS_SUBLEVEL
parameter_list|(
name|TAG
parameter_list|,
name|SUB
parameter_list|)
define|\
value|(GCOV_TAG_MASK (TAG)> GCOV_TAG_MASK (SUB))
end_define

begin_comment
comment|/* Basic block flags.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_BLOCK_UNEXPECTED
value|(1<< 1)
end_define

begin_comment
comment|/* Arc flags.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_ARC_ON_TREE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|GCOV_ARC_FAKE
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|GCOV_ARC_FALLTHROUGH
value|(1<< 2)
end_define

begin_comment
comment|/* Structured records.  */
end_comment

begin_comment
comment|/* Cumulative counter data.  */
end_comment

begin_struct
struct|struct
name|gcov_ctr_summary
block|{
name|gcov_unsigned_t
name|num
decl_stmt|;
comment|/* number of counters.  */
name|gcov_unsigned_t
name|runs
decl_stmt|;
comment|/* number of program runs */
name|gcov_type
name|sum_all
decl_stmt|;
comment|/* sum of all counters accumulated.  */
name|gcov_type
name|run_max
decl_stmt|;
comment|/* maximum value on a single run.  */
name|gcov_type
name|sum_max
decl_stmt|;
comment|/* sum of individual run max values.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Object& program summary record.  */
end_comment

begin_struct
struct|struct
name|gcov_summary
block|{
name|gcov_unsigned_t
name|checksum
decl_stmt|;
comment|/* checksum of program */
name|struct
name|gcov_ctr_summary
name|ctrs
index|[
name|GCOV_COUNTERS_SUMMABLE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structures embedded in coveraged program.  The structures generated    by write_profile must match these.  */
end_comment

begin_if
if|#
directive|if
name|IN_LIBGCOV
end_if

begin_comment
comment|/* Information about a single function.  This uses the trailing array    idiom. The number of counters is determined from the counter_mask    in gcov_info.  We hold an array of function info, so have to    explicitly calculate the correct array stride.  */
end_comment

begin_struct
struct|struct
name|gcov_fn_info
block|{
name|gcov_unsigned_t
name|ident
decl_stmt|;
comment|/* unique ident of function */
name|gcov_unsigned_t
name|checksum
decl_stmt|;
comment|/* function checksum */
name|unsigned
name|n_ctrs
index|[
literal|0
index|]
decl_stmt|;
comment|/* instrumented counters */
block|}
struct|;
end_struct

begin_comment
comment|/* Type of function used to merge counters.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|gcov_merge_fn
function_decl|)
parameter_list|(
name|gcov_type
modifier|*
parameter_list|,
name|gcov_unsigned_t
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Information about counters.  */
end_comment

begin_struct
struct|struct
name|gcov_ctr_info
block|{
name|gcov_unsigned_t
name|num
decl_stmt|;
comment|/* number of counters.  */
name|gcov_type
modifier|*
name|values
decl_stmt|;
comment|/* their values.  */
name|gcov_merge_fn
name|merge
decl_stmt|;
comment|/* The function used to merge them.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Information about a single object file.  */
end_comment

begin_struct
struct|struct
name|gcov_info
block|{
name|gcov_unsigned_t
name|version
decl_stmt|;
comment|/* expected version number */
name|struct
name|gcov_info
modifier|*
name|next
decl_stmt|;
comment|/* link to next, used by libgcov */
name|gcov_unsigned_t
name|stamp
decl_stmt|;
comment|/* uniquifying time stamp */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* output file name */
name|unsigned
name|n_functions
decl_stmt|;
comment|/* number of functions */
specifier|const
name|struct
name|gcov_fn_info
modifier|*
name|functions
decl_stmt|;
comment|/* table of functions */
name|unsigned
name|ctr_mask
decl_stmt|;
comment|/* mask of counters instrumented.  */
name|struct
name|gcov_ctr_info
name|counts
index|[
literal|0
index|]
decl_stmt|;
comment|/* count data. The number of bits 				     set in the ctr_mask field 				     determines how big this array 				     is.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Register a new object file module.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__gcov_init
parameter_list|(
name|struct
name|gcov_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called before fork, to avoid double counting.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__gcov_flush
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The merge function that just sums the counters.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__gcov_merge_add
parameter_list|(
name|gcov_type
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The merge function to choose the most common value.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__gcov_merge_single
parameter_list|(
name|gcov_type
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The merge function to choose the most common difference between    consecutive values.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__gcov_merge_delta
parameter_list|(
name|gcov_type
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IN_LIBGCOV */
end_comment

begin_if
if|#
directive|if
name|IN_LIBGCOV
operator|>=
literal|0
end_if

begin_comment
comment|/* Optimum number of gcov_unsigned_t's read from or written to disk.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_BLOCK_SIZE
value|(1<< 10)
end_define

begin_macro
name|GCOV_LINKAGE
end_macro

begin_struct
struct|struct
name|gcov_var
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|gcov_position_t
name|start
decl_stmt|;
comment|/* Position of first byte of block */
name|unsigned
name|offset
decl_stmt|;
comment|/* Read/write position within the block.  */
name|unsigned
name|length
decl_stmt|;
comment|/* Read limit in the block.  */
name|unsigned
name|overread
decl_stmt|;
comment|/* Number of words overread.  */
name|int
name|error
decl_stmt|;
comment|/*< 0 overflow,> 0 disk error.  */
name|int
name|mode
decl_stmt|;
comment|/*< 0 writing,> 0 reading */
if|#
directive|if
name|IN_LIBGCOV
comment|/* Holds one block plus 4 bytes, thus all coverage reads& writes      fit within this buffer and we always can transfer GCOV_BLOCK_SIZE      to and from the disk. libgcov never backtracks and only writes 4      or 8 byte objects.  */
name|gcov_unsigned_t
name|buffer
index|[
name|GCOV_BLOCK_SIZE
operator|+
literal|1
index|]
decl_stmt|;
else|#
directive|else
name|int
name|endian
decl_stmt|;
comment|/* Swap endianness.  */
comment|/* Holds a variable length block, as the compiler can write      strings and needs to backtrack.  */
name|size_t
name|alloc
decl_stmt|;
name|gcov_unsigned_t
modifier|*
name|buffer
decl_stmt|;
endif|#
directive|endif
block|}
name|gcov_var
struct|;
end_struct

begin_comment
comment|/* Functions for reading and writing gcov files. In libgcov you can    open the file for reading then writing. Elsewhere you can open the    file either for reading or for writing. When reading a file you may    use the gcov_read_* functions, gcov_sync, gcov_position,&    gcov_error. When writing a file you may use the gcov_write    functions, gcov_seek& gcov_error. When a file is to be rewritten    you use the functions for reading, then gcov_rewrite then the    functions for writing.  Your file may become corrupted if you break    these invariants.  */
end_comment

begin_if
if|#
directive|if
name|IN_LIBGCOV
end_if

begin_function_decl
name|GCOV_LINKAGE
name|int
name|gcov_open
parameter_list|(
specifier|const
name|char
modifier|*
comment|/*name*/
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|GCOV_LINKAGE
name|int
name|gcov_open
parameter_list|(
specifier|const
name|char
modifier|*
comment|/*name*/
parameter_list|,
name|int
comment|/*direction*/
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|int
name|gcov_magic
parameter_list|(
name|gcov_unsigned_t
parameter_list|,
name|gcov_unsigned_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|GCOV_LINKAGE
name|int
name|gcov_close
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Available everywhere.  */
end_comment

begin_function_decl
specifier|static
name|gcov_position_t
name|gcov_position
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gcov_is_error
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gcov_is_eof
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|gcov_unsigned_t
name|gcov_read_unsigned
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|gcov_type
name|gcov_read_counter
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_read_summary
parameter_list|(
name|struct
name|gcov_summary
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|IN_LIBGCOV
end_if

begin_comment
comment|/* Available only in libgcov */
end_comment

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_write_counter
parameter_list|(
name|gcov_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_write_tag_length
parameter_list|(
name|gcov_unsigned_t
parameter_list|,
name|gcov_unsigned_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_write_summary
parameter_list|(
name|gcov_unsigned_t
comment|/*tag*/
parameter_list|,
specifier|const
name|struct
name|gcov_summary
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gcov_truncate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gcov_rewrite
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_seek
parameter_list|(
name|gcov_position_t
comment|/*position*/
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Available outside libgcov */
end_comment

begin_function_decl
name|GCOV_LINKAGE
specifier|const
name|char
modifier|*
name|gcov_read_string
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_sync
parameter_list|(
name|gcov_position_t
comment|/*base*/
parameter_list|,
name|gcov_unsigned_t
comment|/*length */
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|IN_GCOV
end_if

begin_comment
comment|/* Available outside gcov */
end_comment

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_write_unsigned
parameter_list|(
name|gcov_unsigned_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|IN_GCOV
operator|&&
operator|!
name|IN_LIBGCOV
end_if

begin_comment
comment|/* Available only in compiler */
end_comment

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_write_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|gcov_position_t
name|gcov_write_tag
parameter_list|(
name|gcov_unsigned_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GCOV_LINKAGE
name|void
name|gcov_write_length
parameter_list|(
name|gcov_position_t
comment|/*position*/
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|IN_GCOV
operator|>
literal|0
end_if

begin_comment
comment|/* Available in gcov */
end_comment

begin_function_decl
name|GCOV_LINKAGE
name|time_t
name|gcov_time
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make sure the library is used correctly.  */
end_comment

begin_if
if|#
directive|if
name|ENABLE_CHECKING
end_if

begin_define
define|#
directive|define
name|GCOV_CHECK
parameter_list|(
name|expr
parameter_list|)
value|((expr) ? (void)0 : (void)abort ())
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCOV_CHECK
parameter_list|(
name|expr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GCOV_CHECK_READING
parameter_list|()
value|GCOV_CHECK(gcov_var.mode> 0)
end_define

begin_define
define|#
directive|define
name|GCOV_CHECK_WRITING
parameter_list|()
value|GCOV_CHECK(gcov_var.mode< 0)
end_define

begin_comment
comment|/* Save the current position in the gcov file.  */
end_comment

begin_function
specifier|static
specifier|inline
name|gcov_position_t
name|gcov_position
parameter_list|(
name|void
parameter_list|)
block|{
name|GCOV_CHECK_READING
argument_list|()
expr_stmt|;
return|return
name|gcov_var
operator|.
name|start
operator|+
name|gcov_var
operator|.
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if we read to end of file.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|gcov_is_eof
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|!
name|gcov_var
operator|.
name|overread
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the error flag is set.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|gcov_is_error
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gcov_var
operator|.
name|file
condition|?
name|gcov_var
operator|.
name|error
else|:
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|IN_LIBGCOV
end_if

begin_comment
comment|/* Move to beginning of file and initialize for writing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|gcov_rewrite
parameter_list|(
name|void
parameter_list|)
block|{
name|GCOV_CHECK_READING
argument_list|()
expr_stmt|;
name|gcov_var
operator|.
name|mode
operator|=
operator|-
literal|1
expr_stmt|;
name|gcov_var
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|gcov_var
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|fseek
argument_list|(
name|gcov_var
operator|.
name|file
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__MINGW32__
end_ifdef

begin_define
define|#
directive|define
name|ftruncate
value|_chsize
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|gcov_truncate
parameter_list|(
name|void
parameter_list|)
block|{
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|gcov_var
operator|.
name|file
argument_list|)
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IN_LIBGCOV>= 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC_GCOV_IO_H */
end_comment

end_unit

