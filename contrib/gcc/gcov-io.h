begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine-independent I/O routines for gcov.    Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.    Contributed by Bob Manson<manson@cygnus.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public    License.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_GCOV_IO_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_GCOV_IO_H
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|__fetch_long
name|PARAMS
argument_list|(
operator|(
name|long
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__read_long
name|PARAMS
argument_list|(
operator|(
name|long
operator|*
operator|,
name|FILE
operator|*
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__write_long
name|PARAMS
argument_list|(
operator|(
name|long
operator|,
name|FILE
operator|*
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__fetch_gcov_type
name|PARAMS
argument_list|(
operator|(
name|gcov_type
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__store_gcov_type
name|PARAMS
argument_list|(
operator|(
name|gcov_type
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__read_gcov_type
name|PARAMS
argument_list|(
operator|(
name|gcov_type
operator|*
operator|,
name|FILE
operator|*
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__write_gcov_type
name|PARAMS
argument_list|(
operator|(
name|gcov_type
operator|,
name|FILE
operator|*
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__write_gcov_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
name|FILE
operator|*
operator|,
name|long
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__read_gcov_string
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
name|FILE
operator|*
operator|,
name|long
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These routines only work for signed values.  */
end_comment

begin_comment
comment|/* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.    Return a nonzero value if VALUE requires more than BYTES*8-1 bits    to store.  */
end_comment

begin_function
specifier|static
name|int
name|__store_gcov_type
parameter_list|(
name|value
parameter_list|,
name|dest
parameter_list|,
name|bytes
parameter_list|)
name|gcov_type
name|value
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|int
name|upper_bit
init|=
operator|(
name|value
operator|<
literal|0
condition|?
literal|128
else|:
literal|0
operator|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|gcov_type
name|oldvalue
init|=
name|value
decl_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|oldvalue
operator|!=
operator|-
name|value
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|<
name|bytes
condition|?
sizeof|sizeof
argument_list|(
name|value
argument_list|)
else|:
name|bytes
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dest
index|[
name|i
index|]
operator|=
name|value
operator|&
operator|(
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
expr_stmt|;
name|value
operator|=
name|value
operator|/
literal|256
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|&&
name|value
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|++
control|)
name|dest
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
name|bytes
operator|-
literal|1
index|]
operator||=
name|upper_bit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a quantity containing BYTES*8-1 bits from SOURCE and store    the result in DEST. Returns a nonzero value if the value in SOURCE    will not fit in DEST.  */
end_comment

begin_function
specifier|static
name|int
name|__fetch_gcov_type
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|bytes
parameter_list|)
name|gcov_type
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|gcov_type
name|value
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bytes
operator|-
literal|1
init|;
operator|(
name|size_t
operator|)
name|i
operator|>
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|dest
argument_list|)
operator|-
literal|1
operator|)
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|source
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|size_t
operator|)
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|value
operator|=
name|value
operator|*
literal|256
operator|+
operator|(
name|source
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|size_t
operator|)
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|source
index|[
name|bytes
operator|-
literal|1
index|]
operator|&
literal|128
operator|)
operator|&&
operator|(
name|value
operator|>
literal|0
operator|)
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
operator|*
name|dest
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__fetch_long
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|bytes
parameter_list|)
name|long
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|long
name|value
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bytes
operator|-
literal|1
init|;
operator|(
name|size_t
operator|)
name|i
operator|>
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|dest
argument_list|)
operator|-
literal|1
operator|)
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|source
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|size_t
operator|)
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|value
operator|=
name|value
operator|*
literal|256
operator|+
operator|(
name|source
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|size_t
operator|)
name|i
operator|==
operator|(
name|bytes
operator|-
literal|1
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|source
index|[
name|bytes
operator|-
literal|1
index|]
operator|&
literal|128
operator|)
operator|&&
operator|(
name|value
operator|>
literal|0
operator|)
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
operator|*
name|dest
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write a BYTES*8-bit quantity to FILE, portably. Returns a nonzero    value if the write fails, or if VALUE can't be stored in BYTES*8    bits.     Note that VALUE may not actually be large enough to hold BYTES*8    bits, but BYTES characters will be written anyway.     BYTES may be a maximum of 10.  */
end_comment

begin_function
specifier|static
name|int
name|__write_gcov_type
parameter_list|(
name|value
parameter_list|,
name|file
parameter_list|,
name|bytes
parameter_list|)
name|gcov_type
name|value
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
name|c
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|10
operator|||
name|__store_gcov_type
argument_list|(
name|value
argument_list|,
name|c
argument_list|,
name|bytes
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
name|fwrite
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
name|bytes
argument_list|,
name|file
argument_list|)
operator|!=
name|bytes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__write_long
parameter_list|(
name|value
parameter_list|,
name|file
parameter_list|,
name|bytes
parameter_list|)
name|long
name|value
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
name|c
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|10
operator|||
name|__store_gcov_type
argument_list|(
operator|(
name|gcov_type
operator|)
name|value
argument_list|,
name|c
argument_list|,
name|bytes
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
name|fwrite
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
name|bytes
argument_list|,
name|file
argument_list|)
operator|!=
name|bytes
return|;
block|}
end_function

begin_comment
comment|/* Read a quantity containing BYTES bytes from FILE, portably. Return    a nonzero value if the read fails or if the value will not fit    in DEST.     Note that DEST may not be large enough to hold all of the requested    data, but the function will read BYTES characters anyway.     BYTES may be a maximum of 10.  */
end_comment

begin_function
specifier|static
name|int
name|__read_gcov_type
parameter_list|(
name|dest
parameter_list|,
name|file
parameter_list|,
name|bytes
parameter_list|)
name|gcov_type
modifier|*
name|dest
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
name|c
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|10
operator|||
name|fread
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
name|bytes
argument_list|,
name|file
argument_list|)
operator|!=
name|bytes
condition|)
return|return
literal|1
return|;
else|else
return|return
name|__fetch_gcov_type
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__read_long
parameter_list|(
name|dest
parameter_list|,
name|file
parameter_list|,
name|bytes
parameter_list|)
name|long
modifier|*
name|dest
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
name|c
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|10
operator|||
name|fread
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
name|bytes
argument_list|,
name|file
argument_list|)
operator|!=
name|bytes
condition|)
return|return
literal|1
return|;
else|else
return|return
name|__fetch_long
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Writes string in gcov format.  */
end_comment

begin_function
specifier|static
name|int
name|__write_gcov_string
parameter_list|(
name|string
parameter_list|,
name|length
parameter_list|,
name|file
parameter_list|,
name|delim
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|long
name|delim
decl_stmt|;
block|{
name|size_t
name|temp
init|=
name|length
operator|+
literal|1
decl_stmt|;
comment|/* delimiter */
if|if
condition|(
name|__write_long
argument_list|(
name|delim
argument_list|,
name|file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|__write_long
argument_list|(
name|length
argument_list|,
name|file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fwrite
argument_list|(
name|string
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|1
return|;
name|temp
operator|&=
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
literal|1
index|]
operator|=
name|c
index|[
literal|2
index|]
operator|=
name|c
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|4
operator|-
name|temp
argument_list|,
name|file
argument_list|)
operator|!=
literal|4
operator|-
name|temp
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|__write_long
argument_list|(
name|delim
argument_list|,
name|file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Reads string in gcov format.  */
end_comment

begin_function
specifier|static
name|int
name|__read_gcov_string
parameter_list|(
name|string
parameter_list|,
name|max_length
parameter_list|,
name|file
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|max_length
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|long
name|delim
decl_stmt|;
block|{
name|long
name|delim_from_file
decl_stmt|;
name|long
name|length
decl_stmt|;
name|long
name|read_length
decl_stmt|;
name|long
name|tmp
decl_stmt|;
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|delim_from_file
argument_list|,
name|file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|delim_from_file
operator|!=
name|delim
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|length
argument_list|,
name|file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|length
operator|>
operator|(
name|long
operator|)
name|max_length
condition|)
name|read_length
operator|=
name|max_length
expr_stmt|;
else|else
name|read_length
operator|=
name|length
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
operator|(
name|length
operator|+
literal|1
operator|)
operator|-
literal|1
operator|)
operator|/
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* This is the size occupied by the string in the file */
if|if
condition|(
name|fread
argument_list|(
name|string
argument_list|,
name|read_length
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|1
return|;
name|string
index|[
name|read_length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|tmp
operator|-
name|read_length
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|delim_from_file
argument_list|,
name|file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|delim_from_file
operator|!=
name|delim
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! GCC_GCOV_IO_H */
end_comment

end_unit

