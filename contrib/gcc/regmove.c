begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Move registers around to reduce number of move instructions needed.    Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This module looks for cases where matching constraints would force    an instruction to need a reload, and this reload would be a register    to register move.  It then attempts to change the registers used by the    instruction to avoid the move instruction.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* stdio.h must precede rtl.h for FFS.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|optimize_reg_copy_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_reg_copy_2
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_reg_copy_3
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_add3_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_src_to_dest
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regmove_bb_head
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|match
block|{
name|int
name|with
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
enum|enum
block|{
name|READ
block|,
name|WRITE
block|,
name|READWRITE
block|}
name|use
index|[
name|MAX_RECOG_OPERANDS
index|]
enum|;
name|int
name|commutative
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|early_clobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|try_auto_increment
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|find_matches
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|match
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fixup_match_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_is_remote_constant_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stable_but_for_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate and return an insn body to add r1 and c,    storing the result in r0.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_add3_insn
parameter_list|(
name|r0
parameter_list|,
name|r1
parameter_list|,
name|c
parameter_list|)
name|rtx
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|r0
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|r0
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|r1
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|c
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_comment
comment|/* INC_INSN is an instruction that adds INCREMENT to REG.    Try to fold INC_INSN as a post/pre in/decrement into INSN.    Iff INC_INSN_SET is nonzero, inc_insn has a destination different from src.    Return nonzero for success.  */
end_comment

begin_function
specifier|static
name|int
name|try_auto_increment
parameter_list|(
name|insn
parameter_list|,
name|inc_insn
parameter_list|,
name|inc_insn_set
parameter_list|,
name|reg
parameter_list|,
name|increment
parameter_list|,
name|pre
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|,
name|inc_insn
decl_stmt|,
name|inc_insn_set
decl_stmt|;
name|HOST_WIDE_INT
name|increment
decl_stmt|;
name|int
name|pre
decl_stmt|;
block|{
name|enum
name|rtx_code
name|inc_code
decl_stmt|;
name|rtx
name|pset
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pset
condition|)
block|{
comment|/* Can't use the size of SET_SRC, we might have something like 	 (sign_extend:SI (mem:QI ...  */
name|rtx
name|use
init|=
name|find_use_as_address
argument_list|(
name|pset
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|use
operator|!=
literal|0
operator|&&
name|use
operator|!=
operator|(
name|rtx
operator|)
literal|1
condition|)
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
operator|||
operator|(
name|pre
operator|==
literal|0
operator|&&
operator|(
name|inc_code
operator|=
name|POST_INC
operator|,
name|increment
operator|==
name|size
operator|)
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_INCREMENT
operator|||
operator|(
name|pre
operator|==
literal|1
operator|&&
operator|(
name|inc_code
operator|=
name|PRE_INC
operator|,
name|increment
operator|==
name|size
operator|)
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
operator|||
operator|(
name|pre
operator|==
literal|0
operator|&&
operator|(
name|inc_code
operator|=
name|POST_DEC
operator|,
name|increment
operator|==
operator|-
name|size
operator|)
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
operator|||
operator|(
name|pre
operator|==
literal|1
operator|&&
operator|(
name|inc_code
operator|=
name|PRE_DEC
operator|,
name|increment
operator|==
operator|-
name|size
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|inc_insn_set
condition|)
name|validate_change
argument_list|(
name|inc_insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|inc_insn_set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|inc_insn_set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inc_insn_set
condition|)
block|{
name|PUT_CODE
argument_list|(
name|inc_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|inc_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|inc_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regno_src_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate how good a choice REG (which appears as a source) is to replace    a destination register with.  The higher the returned value, the better    the choice.  The main objective is to avoid using a register that is    a candidate for tying to a hard register, since the output might in    turn be a candidate to be tied to a different hard register.  */
end_comment

begin_function
name|int
name|replacement_quality
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|src_regno
decl_stmt|;
comment|/* Bad if this isn't a register at all.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* If this register is not meant to get a hard register,      it is a poor choice.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
comment|/* If it was not copied from another register, it is fine.  */
if|if
condition|(
name|src_regno
operator|<
literal|0
condition|)
return|return
literal|3
return|;
comment|/* Copied from a hard register?  */
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|1
return|;
comment|/* Copied from a pseudo register - not as bad as from a hard register,      yet still cumbersome, since the register live length will be lengthened      when the registers get tied.  */
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* INSN is a copy from SRC to DEST, both registers, and SRC does not die    in INSN.     Search forward to see if SRC dies before either it or DEST is modified,    but don't scan past the end of a basic block.  If so, we can replace SRC    with DEST and let SRC die in INSN.      This will reduce the number of registers live in that range and may enable    DEST to be tied to SRC, thus often saving one register in addition to a    register-register copy.  */
end_comment

begin_function
specifier|static
name|int
name|optimize_reg_copy_1
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|dest_death
init|=
literal|0
decl_stmt|;
name|int
name|sregno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|dregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* We don't want to mess with hard regs if register classes are small. */
if|if
condition|(
name|sregno
operator|==
name|dregno
operator|||
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|dregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
comment|/* We don't see all updates to SP if they are in an auto-inc memory 	 reference, so we must disallow this optimization on them.  */
operator|||
name|sregno
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|dregno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start). 	 A CALL_INSN might be the last insn of a basic block, if it is inside 	 an EH region.  There is no easy way to tell, so we just always break 	 when we see a CALL_INSN if flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|dest
argument_list|,
name|p
argument_list|)
comment|/* Don't change a USE of a register.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* See if all of SRC dies in P.  This test is slightly more 	 conservative than it needs to be.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_regno_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|sregno
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|int
name|d_length
init|=
literal|0
decl_stmt|;
name|int
name|s_length
init|=
literal|0
decl_stmt|;
name|int
name|d_n_calls
init|=
literal|0
decl_stmt|;
name|int
name|s_n_calls
init|=
literal|0
decl_stmt|;
comment|/* We can do the optimization.  Scan forward from INSN again, 	     replacing regs as we go.  Set FAILED if a replacement can't 	     be done.  In that case, we can't move the death note for SRC. 	     This should be rare.  */
comment|/* Set to stop at next insn.  */
for|for
control|(
name|q
operator|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
init|;
name|q
operator|!=
name|next_real_insn
argument_list|(
name|p
argument_list|)
condition|;
name|q
operator|=
name|next_real_insn
argument_list|(
name|q
argument_list|)
control|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If SRC is a hard register, we might miss some 		     overlapping registers with validate_replace_rtx, 		     so we would have to undo it.  We can't if DEST is 		     present in the insn, so fail in that combination 		     of cases.  */
if|if
condition|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
comment|/* Replace all uses and make sure that the register 		     isn't still present.  */
elseif|else
if|if
condition|(
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|q
argument_list|)
operator|&&
operator|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* We assume that a register is used exactly once per 			 insn in the REG_N_REFS updates below.  If this is not 			 correct, no great harm is done.  			 Since we do not know if we will change the lifetime of 			 SREGNO or DREGNO, we must not update REG_LIVE_LENGTH 			 or REG_N_CALLS_CROSSED at this time.   */
if|if
condition|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|REG_N_REFS
argument_list|(
name|sregno
argument_list|)
operator|-=
name|loop_depth
expr_stmt|;
if|if
condition|(
name|dregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|REG_N_REFS
argument_list|(
name|dregno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
block|}
else|else
block|{
name|validate_replace_rtx
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* For SREGNO, count the total number of insns scanned. 		 For DREGNO, count the total number of insns scanned after 		 passing the death note for DREGNO.  */
name|s_length
operator|++
expr_stmt|;
if|if
condition|(
name|dest_death
condition|)
name|d_length
operator|++
expr_stmt|;
comment|/* If the insn in which SRC dies is a CALL_INSN, don't count it 		 as a call that has been crossed.  Otherwise, count it.  */
if|if
condition|(
name|q
operator|!=
name|p
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Similarly, total calls for SREGNO, total calls beyond 		     the death note for DREGNO.  */
name|s_n_calls
operator|++
expr_stmt|;
if|if
condition|(
name|dest_death
condition|)
name|d_n_calls
operator|++
expr_stmt|;
block|}
comment|/* If DEST dies here, remove the death note and save it for 		 later.  Make sure ALL of DEST dies here; again, this is 		 overly conservative.  */
if|if
condition|(
name|dest_death
operator|==
literal|0
operator|&&
operator|(
name|dest_death
operator|=
name|find_regno_note
argument_list|(
name|q
argument_list|,
name|REG_DEAD
argument_list|,
name|dregno
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dest_death
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
name|failed
operator|=
literal|1
operator|,
name|dest_death
operator|=
literal|0
expr_stmt|;
else|else
name|remove_note
argument_list|(
name|q
argument_list|,
name|dest_death
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
comment|/* These counters need to be updated if and only if we are 		 going to move the REG_DEAD note.  */
if|if
condition|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|-=
name|s_length
expr_stmt|;
comment|/* REG_LIVE_LENGTH is only an approximation after 			 combine if sched is not run, so make sure that we 			 still have a reasonable value.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|<
literal|2
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
name|REG_N_CALLS_CROSSED
argument_list|(
name|sregno
argument_list|)
operator|-=
name|s_n_calls
expr_stmt|;
block|}
comment|/* Move death note of SRC from P to INSN.  */
name|remove_note
argument_list|(
name|p
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* Put death note of DEST on P if we saw it die.  */
if|if
condition|(
name|dest_death
condition|)
block|{
name|XEXP
argument_list|(
name|dest_death
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|dest_death
expr_stmt|;
if|if
condition|(
name|dregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If and only if we are moving the death note for DREGNO, 		     then we need to update its counters.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|dregno
argument_list|)
operator|>=
literal|0
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|dregno
argument_list|)
operator|+=
name|d_length
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|dregno
argument_list|)
operator|+=
name|d_n_calls
expr_stmt|;
block|}
block|}
return|return
operator|!
name|failed
return|;
block|}
comment|/* If SRC is a hard register which is set or killed in some other 	 way, we can't do this optimization.  */
elseif|else
if|if
condition|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dead_or_set_p
argument_list|(
name|p
argument_list|,
name|src
argument_list|)
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have    a sequence of insns that modify DEST followed by an insn that sets    SRC to DEST in which DEST dies, with no prior modification of DEST.    (There is no need to check if the insns in between actually modify    DEST.  We should not have cases where DEST is not modified, but    the optimization is safe if no such modification is detected.)    In that case, we can replace all uses of DEST, starting with INSN and    ending with the set of SRC to DEST, with SRC.  We do not do this    optimization if a CALL_INSN is crossed unless SRC already crosses a    call or if DEST dies before the copy back to SRC.     It is assumed that DEST and SRC are pseudos; it is too complicated to do    this for hard registers since the substitutions we may make might fail.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_reg_copy_2
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|sregno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|dregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start). 	 A CALL_INSN might be the last insn of a basic block, if it is inside 	 an EH region.  There is no easy way to tell, so we just always break 	 when we see a CALL_INSN if flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|dest
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|src
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
condition|)
block|{
comment|/* We can do the optimization.  Scan forward from INSN again, 	     replacing regs as we go.  */
comment|/* Set to stop at next insn.  */
for|for
control|(
name|q
operator|=
name|insn
init|;
name|q
operator|!=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
name|PATTERN
argument_list|(
name|q
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* We assume that a register is used exactly once per 		       insn in the updates below.  If this is not correct, 		       no great harm is done.  */
name|REG_N_REFS
argument_list|(
name|dregno
argument_list|)
operator|-=
name|loop_depth
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|sregno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|REG_N_CALLS_CROSSED
argument_list|(
name|dregno
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|sregno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
name|remove_note
argument_list|(
name|p
argument_list|,
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|dregno
argument_list|)
operator|--
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|sregno
argument_list|)
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|REG_N_CALLS_CROSSED
argument_list|(
name|sregno
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* INSN is a ZERO_EXTEND or SIGN_EXTEND of SRC to DEST.    Look if SRC dies there, and if it is only set once, by loading    it from memory.  If so, try to encorporate the zero/sign extension    into the memory read, change SRC to the mode of DEST, and alter    the remaining accesses to use the appropriate SUBREG.  This allows    SRC and DEST to be tied later.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_reg_copy_3
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|src_reg
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|src_no
init|=
name|REGNO
argument_list|(
name|src_reg
argument_list|)
decl_stmt|;
name|int
name|dst_no
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|,
name|set
decl_stmt|,
name|subreg
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
decl_stmt|;
comment|/* This code has been disabled on the egcs-1.1 release branch due to      a potentially serious bug.       In a nutshell, if we perform a series of substitutions, then have a      later substitution fail we will not be able to undo the previous      substitutions, leaving bogus RTL.       A fix for this can be found in the mainline sources, but it did not      seem worth the trouble and potential problems to migrate the real      fix to the egcs-1.1 branch.  */
return|return;
if|if
condition|(
name|src_no
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|dst_no
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src_reg
argument_list|)
operator|||
name|REG_N_SETS
argument_list|(
name|src_no
argument_list|)
operator|!=
literal|1
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
operator|!
name|reg_set_p
argument_list|(
name|src_reg
argument_list|,
name|p
argument_list|)
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
return|return;
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start). 	 A CALL_INSN might be the last insn of a basic block, if it is inside 	 an EH region.  There is no easy way to tell, so we just always break 	 when we see a CALL_INSN if flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|src_reg
condition|)
return|return;
name|old_mode
operator|=
name|GET_MODE
argument_list|(
name|src_reg
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|src_reg
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|p
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|PUT_MODE
argument_list|(
name|src_reg
argument_list|,
name|old_mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|src_reg
expr_stmt|;
return|return;
block|}
name|subreg
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|old_mode
argument_list|,
name|src_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|,
name|p
operator|!=
name|insn
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|validate_replace_rtx
argument_list|(
name|src_reg
argument_list|,
name|subreg
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|src_reg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we were not able to update the users of src to use dest directly, try    instead moving the value to dest directly before the operation.  */
end_comment

begin_function
specifier|static
name|void
name|copy_src_to_dest
parameter_list|(
name|insn
parameter_list|,
name|src
parameter_list|,
name|dest
parameter_list|,
name|loop_depth
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|int
name|loop_depth
decl_stmt|;
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|move_insn
decl_stmt|;
name|rtx
modifier|*
name|p_insn_notes
decl_stmt|;
name|rtx
modifier|*
name|p_move_notes
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int
name|insn_uid
decl_stmt|;
name|int
name|move_uid
decl_stmt|;
comment|/* A REG_LIVE_LENGTH of -1 indicates the register is equivalent to a constant      or memory location and is used infrequently; a REG_LIVE_LENGTH of -2 is      parameter when there is no frame pointer that is not allocated a register.      For now, we just reject them, rather than incrementing the live length.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|insn
argument_list|)
condition|)
block|{
comment|/* Generate the src->dest move.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|move_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|p_move_notes
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|move_insn
argument_list|)
expr_stmt|;
name|p_insn_notes
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Move any notes mentioning src to the move instruction */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
name|NULL_RTX
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|src
condition|)
block|{
operator|*
name|p_move_notes
operator|=
name|link
expr_stmt|;
name|p_move_notes
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p_insn_notes
operator|=
name|link
expr_stmt|;
name|p_insn_notes
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|p_move_notes
operator|=
name|NULL_RTX
expr_stmt|;
operator|*
name|p_insn_notes
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Is the insn the head of a basic block?  If so extend it */
name|insn_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|move_uid
operator|=
name|INSN_UID
argument_list|(
name|move_insn
argument_list|)
expr_stmt|;
name|bb
operator|=
name|regmove_bb_head
index|[
name|insn_uid
index|]
expr_stmt|;
if|if
condition|(
name|bb
operator|>=
literal|0
condition|)
block|{
name|basic_block_head
index|[
name|bb
index|]
operator|=
name|move_insn
expr_stmt|;
name|regmove_bb_head
index|[
name|insn_uid
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Update the various register tables.  */
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|dest_regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|dest_regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|dest_regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|dest_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_FIRST_UID
argument_list|(
name|dest_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|move_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|src_regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|src_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_FIRST_UID
argument_list|(
name|src_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|src_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_LAST_UID
argument_list|(
name|src_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
if|if
condition|(
name|REGNO_LAST_NOTE_UID
argument_list|(
name|src_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_LAST_NOTE_UID
argument_list|(
name|src_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return whether REG is set in only one location, and is set to a    constant, but is set in a different basic block from INSN (an    instructions which uses REG).  In this case REG is equivalent to a    constant, and we don't want to break that equivalence, because that    may increase register pressure and make reload harder.  If REG is    set in the same basic block as INSN, we don't worry about it,    because we'll probably need a register anyhow (??? but what if REG    is used in a different basic block as well as this one?).  FIRST is    the first insn in the function.  */
end_comment

begin_function
specifier|static
name|int
name|reg_is_remote_constant_p
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|,
name|first
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|first
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Look for the set.  */
for|for
control|(
name|p
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|s
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|s
operator|=
name|single_set
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
block|{
comment|/* The register is set in the same basic block.  */
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|first
init|;
name|p
operator|&&
name|p
operator|!=
name|insn
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|rtx
name|s
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|s
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
block|{
comment|/* This is the instruction which sets REG.  If there is a              REG_EQUAL note, then REG is equivalent to a constant.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* INSN is adding a CONST_INT to a REG.  We search backwards looking for    another add immediate instruction with the same source and dest registers,    and if we find one, we change INSN to an increment, and return 1.  If    no changes are made, we return 0.     This changes      (set (reg100) (plus reg1 offset1))      ...      (set (reg100) (plus reg1 offset2))    to      (set (reg100) (plus reg1 offset1))      ...      (set (reg100) (plus reg100 offset2-offset1))  */
end_comment

begin_comment
comment|/* ??? What does this comment mean?  */
end_comment

begin_comment
comment|/* cse disrupts preincrement / postdecrement squences when it finds a    hard register as ultimate source, like the frame pointer.  */
end_comment

begin_function
name|int
name|fixup_match_2
parameter_list|(
name|insn
parameter_list|,
name|dst
parameter_list|,
name|src
parameter_list|,
name|offset
parameter_list|,
name|regmove_dump_file
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|offset
decl_stmt|;
name|FILE
modifier|*
name|regmove_dump_file
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|dst_death
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|,
name|num_calls
init|=
literal|0
decl_stmt|;
comment|/* If SRC dies in INSN, we'd have to move the death note.  This is      considered to be very unlikely, so we just skip the optimization      in this case.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Scan backward to find the first instruction that sets DST.  */
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|rtx
name|pset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start). 	 A CALL_INSN might be the last insn of a basic block, if it is inside 	 an EH region.  There is no easy way to tell, so we just always break 	 when we see a CALL_INSN if flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|find_regno_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|dst_death
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|dst_death
condition|)
name|length
operator|++
expr_stmt|;
name|pset
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|&&
name|SET_DEST
argument_list|(
name|pset
argument_list|)
operator|==
name|dst
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|src
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|newconst
init|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|add
init|=
name|gen_add3_insn
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
name|newconst
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|add
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|add
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Remove the death note for DST from DST_DEATH.  */
if|if
condition|(
name|dst_death
condition|)
block|{
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|,
name|dst_death
argument_list|)
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|+=
name|length
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|+=
name|num_calls
expr_stmt|;
block|}
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|-=
name|loop_depth
expr_stmt|;
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Fixed operand of insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|newconst
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
block|}
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|newconst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* If we have passed a call instruction, and the          pseudo-reg SRC is not already live across a call,          then don't perform the optimization.  */
comment|/* reg_set_p is overly conservative for CALL_INSNS, thinks that all 	 hard regs are clobbered.  Thus, we only use it for src for 	 non-call insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|dst_death
condition|)
name|num_calls
operator|++
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|dst
argument_list|)
index|]
operator|||
name|find_reg_fusage
argument_list|(
name|p
argument_list|,
name|CLOBBER
argument_list|,
name|dst
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|regmove_optimize
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|regmove_dump_file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|regmove_dump_file
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|match
name|match
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|int
name|maxregnum
init|=
name|max_reg_num
argument_list|()
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|copy_src
decl_stmt|,
name|copy_dst
decl_stmt|;
name|regno_src_regno
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|*
name|regno_src_regno
operator|*
name|maxregnum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxregnum
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|regno_src_regno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regmove_bb_head
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|get_max_uid
argument_list|()
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|regmove_bb_head
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|regmove_bb_head
index|[
name|INSN_UID
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
comment|/* A forward/backward pass.  Replace output operands with input operands.  */
name|loop_depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|2
condition|;
name|pass
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|flag_regmove
operator|&&
name|pass
operator|>=
name|flag_expensive_optimizations
condition|)
return|return;
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Starting %s pass...\n"
argument_list|,
name|pass
condition|?
literal|"backward"
else|:
literal|"forward"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|pass
condition|?
name|get_last_insn
argument_list|()
else|:
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|pass
condition|?
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
else|:
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|int
name|operand_number
decl_stmt|,
name|match_number
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|!
name|pass
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|optimize_reg_copy_3
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|!
name|pass
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If this is a register-register copy where SRC is not dead, 		 see if we can optimize it.  If this optimization succeeds, 		 it will become a copy where SRC is dead.  */
if|if
condition|(
operator|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
name|optimize_reg_copy_1
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Similarly for a pseudo-pseudo copy when SRC is dead.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|optimize_reg_copy_2
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|!=
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|int
name|srcregno
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno_src_regno
index|[
name|srcregno
index|]
operator|>=
literal|0
condition|)
name|srcregno
operator|=
name|regno_src_regno
index|[
name|srcregno
index|]
expr_stmt|;
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|=
name|srcregno
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
name|insn_code_number
operator|=
name|find_matches
argument_list|(
name|insn
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|<
literal|0
condition|)
continue|continue;
comment|/* Now scan through the operands looking for a source operand 	     which is supposed to match the destination operand. 	     Then scan forward for an instruction which uses the dest 	     operand. 	     If it dies there, then replace the dest in both operands with 	     the source operand.  */
for|for
control|(
name|operand_number
operator|=
literal|0
init|;
name|operand_number
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|operand_number
operator|++
control|)
block|{
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|src_subreg
decl_stmt|;
name|enum
name|reg_class
name|src_class
decl_stmt|,
name|dst_class
decl_stmt|;
name|match_number
operator|=
name|match
operator|.
name|with
index|[
name|operand_number
index|]
expr_stmt|;
comment|/* Nothing to do if the two operands aren't supposed to match.  */
if|if
condition|(
name|match_number
operator|<
literal|0
condition|)
continue|continue;
name|src
operator|=
name|recog_operand
index|[
name|operand_number
index|]
expr_stmt|;
name|dst
operator|=
name|recog_operand
index|[
name|match_number
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|src_subreg
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|src_subreg
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|src
argument_list|,
name|SUBREG_WORD
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|commutative
index|[
name|operand_number
index|]
operator|<
name|operand_number
condition|)
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|dst
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* operand_number/src must be a read-only operand, and 		 match_operand/dst must be a write-only operand.  */
if|if
condition|(
name|match
operator|.
name|use
index|[
name|operand_number
index|]
operator|!=
name|READ
operator|||
name|match
operator|.
name|use
index|[
name|match_number
index|]
operator|!=
name|WRITE
condition|)
continue|continue;
if|if
condition|(
name|match
operator|.
name|early_clobber
index|[
name|match_number
index|]
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|src
argument_list|)
operator|>
literal|1
condition|)
continue|continue;
comment|/* Make sure match_operand is the destination.  */
if|if
condition|(
name|recog_operand
index|[
name|match_number
index|]
operator|!=
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
continue|continue;
comment|/* If the operands already match, then there is nothing to do.  */
comment|/* But in the commutative case, we might find a better match.  */
if|if
condition|(
name|operands_match_p
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|||
operator|(
name|match
operator|.
name|commutative
index|[
name|operand_number
index|]
operator|>=
literal|0
operator|&&
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|match
operator|.
name|commutative
index|[
name|operand_number
index|]
index|]
argument_list|,
name|dst
argument_list|)
operator|&&
operator|(
name|replacement_quality
argument_list|(
name|recog_operand
index|[
name|match
operator|.
name|commutative
index|[
name|operand_number
index|]
index|]
argument_list|)
operator|>=
name|replacement_quality
argument_list|(
name|src
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
name|src_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|dst_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_class
operator|!=
name|dst_class
operator|&&
operator|(
operator|!
name|reg_class_subset_p
argument_list|(
name|src_class
argument_list|,
name|dst_class
argument_list|)
operator|||
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|src_class
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|reg_class_subset_p
argument_list|(
name|dst_class
argument_list|,
name|src_class
argument_list|)
operator|||
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|dst_class
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|fixup_match_1
argument_list|(
name|insn
argument_list|,
name|set
argument_list|,
name|src
argument_list|,
name|src_subreg
argument_list|,
name|dst
argument_list|,
name|pass
argument_list|,
name|operand_number
argument_list|,
name|match_number
argument_list|,
name|regmove_dump_file
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
comment|/* A backward pass.  Replace input operands with output operands.  */
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Starting backward pass...\n"
argument_list|)
expr_stmt|;
name|loop_depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|int
name|insn_code_number
init|=
name|find_matches
argument_list|(
name|insn
argument_list|,
operator|&
name|match
argument_list|)
decl_stmt|;
name|int
name|operand_number
decl_stmt|,
name|match_number
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insn_code_number
operator|<
literal|0
condition|)
continue|continue;
comment|/* Now scan through the operands looking for a destination operand 	     which is supposed to match a source operand. 	     Then scan backward for an instruction which sets the source 	     operand.  If safe, then replace the source operand with the 	     dest operand in both instructions.  */
name|copy_src
operator|=
name|NULL_RTX
expr_stmt|;
name|copy_dst
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|operand_number
operator|=
literal|0
init|;
name|operand_number
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|operand_number
operator|++
control|)
block|{
name|rtx
name|set
decl_stmt|,
name|p
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|rtx
name|src_note
decl_stmt|,
name|dst_note
decl_stmt|;
name|int
name|num_calls
init|=
literal|0
decl_stmt|;
name|enum
name|reg_class
name|src_class
decl_stmt|,
name|dst_class
decl_stmt|;
name|int
name|length
decl_stmt|;
name|match_number
operator|=
name|match
operator|.
name|with
index|[
name|operand_number
index|]
expr_stmt|;
comment|/* Nothing to do if the two operands aren't supposed to match.  */
if|if
condition|(
name|match_number
operator|<
literal|0
condition|)
continue|continue;
name|dst
operator|=
name|recog_operand
index|[
name|match_number
index|]
expr_stmt|;
name|src
operator|=
name|recog_operand
index|[
name|operand_number
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* If the operands already match, then there is nothing to do.  */
if|if
condition|(
name|operands_match_p
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|||
operator|(
name|match
operator|.
name|commutative
index|[
name|operand_number
index|]
operator|>=
literal|0
operator|&&
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|match
operator|.
name|commutative
index|[
name|operand_number
index|]
index|]
argument_list|,
name|dst
argument_list|)
operator|)
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
comment|/* match_number/dst must be a write-only operand, and 		 operand_operand/src must be a read-only operand.  */
if|if
condition|(
name|match
operator|.
name|use
index|[
name|operand_number
index|]
operator|!=
name|READ
operator|||
name|match
operator|.
name|use
index|[
name|match_number
index|]
operator|!=
name|WRITE
condition|)
continue|continue;
if|if
condition|(
name|match
operator|.
name|early_clobber
index|[
name|match_number
index|]
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|src
argument_list|)
operator|>
literal|1
condition|)
continue|continue;
comment|/* Make sure match_number is the destination.  */
if|if
condition|(
name|recog_operand
index|[
name|match_number
index|]
operator|!=
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|src
operator|&&
name|fixup_match_2
argument_list|(
name|insn
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|regmove_dump_file
argument_list|)
condition|)
break|break;
continue|continue;
block|}
name|src_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|dst_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_class
operator|!=
name|dst_class
operator|&&
operator|(
operator|!
name|reg_class_subset_p
argument_list|(
name|src_class
argument_list|,
name|dst_class
argument_list|)
operator|||
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|src_class
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|reg_class_subset_p
argument_list|(
name|dst_class
argument_list|,
name|src_class
argument_list|)
operator|||
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|dst_class
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Can not modify an earlier insn to set dst if this insn 		 uses an old value in the source.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|src_note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* If src is set once in a different basic block, 		 and is set equal to a constant, then do not use 		 it for this optimization, as this would make it 		 no longer equivalent to a constant.  */
if|if
condition|(
name|reg_is_remote_constant_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Could fix operand %d of insn %d matching operand %d.\n"
argument_list|,
name|operand_number
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_number
argument_list|)
expr_stmt|;
comment|/* Scan backward to find the first instruction that uses 		 the input operand.  If the operand is set here, then 		 replace it in both instructions with match_number.  */
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|rtx
name|pset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
comment|/* ??? We can't scan past the end of a basic block without 		     updating the register lifetime info 		     (REG_DEAD/basic_block_live_at_start). 		     A CALL_INSN might be the last insn of a basic block, if 		     it is inside an EH region.  There is no easy way to tell, 		     so we just always break when we see a CALL_INSN if 		     flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|length
operator|++
expr_stmt|;
comment|/* ??? See if all of SRC is set in P.  This test is much 		     more conservative than it needs to be.  */
name|pset
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|&&
name|SET_DEST
argument_list|(
name|pset
argument_list|)
operator|==
name|src
condition|)
block|{
comment|/* We use validate_replace_rtx, in case there 			 are multiple identical source operands.  All of 			 them have to be changed at the same time.  */
if|if
condition|(
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|validate_change
argument_list|(
name|p
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|pset
argument_list|)
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
name|success
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Change all source operands back. 				 This modifies the dst as a side-effect.  */
name|validate_replace_rtx
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Now make sure the dst is right.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_operand_loc
index|[
name|match_number
index|]
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* If we have passed a call instruction, and the 		     pseudo-reg DST is not already live across a call, 		     then don't perform the optimization.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|num_calls
operator|++
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int
name|dstno
decl_stmt|,
name|srcno
decl_stmt|;
comment|/* Remove the death note for SRC from INSN.  */
name|remove_note
argument_list|(
name|insn
argument_list|,
name|src_note
argument_list|)
expr_stmt|;
comment|/* Move the death note for SRC to P if it is used 		     there.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|src_note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|src_note
expr_stmt|;
block|}
comment|/* If there is a REG_DEAD note for DST on P, then remove 		     it, because DST is now set there.  */
if|if
condition|(
operator|(
name|dst_note
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dst
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|p
argument_list|,
name|dst_note
argument_list|)
expr_stmt|;
name|dstno
operator|=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|srcno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|dstno
argument_list|)
operator|++
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|srcno
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|dstno
argument_list|)
operator|+=
name|num_calls
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|srcno
argument_list|)
operator|-=
name|num_calls
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|dstno
argument_list|)
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|-=
name|length
expr_stmt|;
comment|/* REG_LIVE_LENGTH is only an approximation after 			 combine if sched is not run, so make sure that we 			 still have a reasonable value.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|<
literal|2
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
comment|/* We assume that a register is used exactly once per 		     insn in the updates above.  If this is not correct, 		     no great harm is done.  */
name|REG_N_REFS
argument_list|(
name|dstno
argument_list|)
operator|+=
literal|2
operator|*
name|loop_depth
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|srcno
argument_list|)
operator|-=
literal|2
operator|*
name|loop_depth
expr_stmt|;
comment|/* If that was the only time src was set,                      and src was not live at the start of the                      function, we know that we have no more                      references to src; clear REG_N_REFS so it                      won't make reload do any work.  */
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|regno_uninitialized
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Fixed operand %d of insn %d matching operand %d.\n"
argument_list|,
name|operand_number
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_number
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we weren't able to replace any of the alternatives, try an 	     alternative appoach of copying the source to the destination.  */
if|if
condition|(
operator|!
name|success
operator|&&
name|copy_src
operator|!=
name|NULL_RTX
condition|)
name|copy_src_to_dest
argument_list|(
name|insn
argument_list|,
name|copy_src
argument_list|,
name|copy_dst
argument_list|,
name|loop_depth
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REGISTER_CONSTRAINTS */
block|}
end_function

begin_comment
comment|/* Returns the INSN_CODE for INSN if its pattern has matching constraints for    any operand.  Returns -1 if INSN can't be recognized, or if the alternative    can't be determined.     Initialize the info in MATCHP based on the constraints.  */
end_comment

begin_function
specifier|static
name|int
name|find_matches
parameter_list|(
name|insn
parameter_list|,
name|matchp
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|match
modifier|*
name|matchp
decl_stmt|;
block|{
name|int
name|likely_spilled
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|operand_number
decl_stmt|;
name|int
name|insn_code_number
init|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|any_matches
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insn_code_number
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Must initialize this before main loop, because the code for      the commutative case may set matches for operands other than      the current one.  */
for|for
control|(
name|operand_number
operator|=
name|insn_n_operands
index|[
name|insn_code_number
index|]
init|;
operator|--
name|operand_number
operator|>=
literal|0
condition|;
control|)
name|matchp
operator|->
name|with
index|[
name|operand_number
index|]
operator|=
name|matchp
operator|->
name|commutative
index|[
name|operand_number
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|operand_number
operator|=
literal|0
init|;
name|operand_number
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|operand_number
operator|++
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|operand_number
index|]
expr_stmt|;
name|likely_spilled
index|[
name|operand_number
index|]
operator|=
literal|0
expr_stmt|;
name|matchp
operator|->
name|use
index|[
name|operand_number
index|]
operator|=
name|READ
expr_stmt|;
name|matchp
operator|->
name|early_clobber
index|[
name|operand_number
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
name|matchp
operator|->
name|use
index|[
name|operand_number
index|]
operator|=
name|WRITE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|matchp
operator|->
name|use
index|[
name|operand_number
index|]
operator|=
name|READWRITE
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|i
operator|<
name|which_alternative
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
break|break;
case|case
literal|'+'
case|:
break|break;
case|case
literal|'&'
case|:
name|matchp
operator|->
name|early_clobber
index|[
name|operand_number
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|matchp
operator|->
name|commutative
index|[
name|operand_number
index|]
operator|=
name|operand_number
operator|+
literal|1
expr_stmt|;
name|matchp
operator|->
name|commutative
index|[
name|operand_number
operator|+
literal|1
index|]
operator|=
name|operand_number
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|operand_number
operator|&&
name|likely_spilled
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
break|break;
name|matchp
operator|->
name|with
index|[
name|operand_number
index|]
operator|=
name|c
expr_stmt|;
name|any_matches
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|matchp
operator|->
name|commutative
index|[
name|operand_number
index|]
operator|>=
literal|0
condition|)
name|matchp
operator|->
name|with
index|[
name|matchp
operator|->
name|commutative
index|[
name|operand_number
index|]
index|]
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'h'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'W'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
if|if
condition|(
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
name|likely_spilled
index|[
name|operand_number
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|any_matches
condition|?
name|insn_code_number
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Try to replace output operand DST in SET, with input operand SRC.  SET is    the only set in INSN.  INSN has just been recgnized and constrained.    SRC is operand number OPERAND_NUMBER in INSN.    DST is operand number MATCH_NUMBER in INSN.    If BACKWARD is nonzero, we have been called in a backward pass.    Return nonzero for success.  */
end_comment

begin_function
specifier|static
name|int
name|fixup_match_1
parameter_list|(
name|insn
parameter_list|,
name|set
parameter_list|,
name|src
parameter_list|,
name|src_subreg
parameter_list|,
name|dst
parameter_list|,
name|backward
parameter_list|,
name|operand_number
parameter_list|,
name|match_number
parameter_list|,
name|regmove_dump_file
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|,
name|src
decl_stmt|,
name|src_subreg
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|backward
decl_stmt|,
name|operand_number
decl_stmt|,
name|match_number
decl_stmt|;
name|FILE
modifier|*
name|regmove_dump_file
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|post_inc
init|=
literal|0
decl_stmt|,
name|post_inc_set
init|=
literal|0
decl_stmt|,
name|search_end
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|num_calls
init|=
literal|0
decl_stmt|,
name|s_num_calls
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|NOTE
decl_stmt|;
name|HOST_WIDE_INT
name|insn_const
decl_stmt|,
name|newconst
decl_stmt|;
name|rtx
name|overlap
init|=
literal|0
decl_stmt|;
comment|/* need to move insn ? */
name|rtx
name|src_note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
decl_stmt|,
name|dst_note
decl_stmt|;
name|int
name|length
decl_stmt|,
name|s_length
decl_stmt|,
name|true_loop_depth
decl_stmt|;
if|if
condition|(
operator|!
name|src_note
condition|)
block|{
comment|/* Look for (set (regX) (op regA constX)) 		  (set (regY) (op regA constY)) 	 and change that to 		  (set (regA) (op regA constX)). 		  (set (regY) (op regA constY-constX)). 	 This works for add and shift operations, if 	 regA is dead after or set by the second insn.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|src
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|insn_const
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|stable_but_for_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
comment|/* We might find a src_note while scanning.  */
name|code
operator|=
name|NOTE
expr_stmt|;
block|}
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Could fix operand %d of insn %d matching operand %d.\n"
argument_list|,
name|operand_number
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_number
argument_list|)
expr_stmt|;
comment|/* If SRC is equivalent to a constant set in a different basic block,      then do not use it for this optimization.  We want the equivalence      so that if we have to reload this register, we can reload the      constant, rather than extending the lifespan of the register.  */
if|if
condition|(
name|reg_is_remote_constant_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|get_insns
argument_list|()
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Scan forward to find the next instruction that      uses the output operand.  If the operand dies here,      then replace it in both instructions with      operand_number.  */
for|for
control|(
name|length
operator|=
name|s_length
operator|=
literal|0
operator|,
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start). 	 A CALL_INSN might be the last insn of a basic block, if it is 	 inside an EH region.  There is no easy way to tell, so we just 	 always break when we see a CALL_INSN if flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|src_note
condition|)
name|s_length
operator|++
expr_stmt|;
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|p
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* See if all of DST dies in P.  This test is 	 slightly more conservative than it needs to be.  */
if|if
condition|(
operator|(
name|dst_note
operator|=
name|find_regno_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|src_note
condition|)
block|{
name|rtx
name|q
decl_stmt|;
name|rtx
name|set2
decl_stmt|;
comment|/* If an optimization is done, the value of SRC while P 		 is executed will be changed.  Check that this is OK.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ??? We can't scan past the end of a basic block without 		     updating the register lifetime info 		     (REG_DEAD/basic_block_live_at_start). 		     A CALL_INSN might be the last insn of a basic block, if 		     it is inside an EH region.  There is no easy way to tell, 		     so we just always break when we see a CALL_INSN if 		     flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|q
condition|)
name|set2
operator|=
name|single_set
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|||
operator|!
name|set2
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|!=
name|code
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|src
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
operator|!=
name|src
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|q
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is a PLUS, we can still save a register by doing 		     src += insn_const; 		     P; 		     src -= insn_const; . 		     This also gives opportunities for subsequent 		     optimizations in the backward pass, so do it there.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|backward
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We may not emit an insn directly 			 after P if the latter sets CC0.  */
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|search_end
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|insn
expr_stmt|;
name|set2
operator|=
name|set
expr_stmt|;
name|newconst
operator|=
operator|-
name|insn_const
expr_stmt|;
name|code
operator|=
name|MINUS
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
block|{
name|newconst
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|insn_const
expr_stmt|;
comment|/* Reject out of range shifts.  */
if|if
condition|(
name|code
operator|!=
name|PLUS
operator|&&
operator|(
name|newconst
operator|<
literal|0
operator|||
operator|(
name|newconst
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
block|{
name|post_inc
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
operator|!=
name|src
condition|)
name|post_inc_set
operator|=
name|set2
expr_stmt|;
block|}
block|}
comment|/* We use 1 as last argument to validate_change so that all 		 changes are accepted or rejected together by apply_change_group 		 when it is called by validate_replace_rtx .  */
name|validate_change
argument_list|(
name|q
argument_list|,
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|newconst
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_operand_loc
index|[
name|match_number
index|]
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_replace_rtx
argument_list|(
name|dst
argument_list|,
name|src_subreg
argument_list|,
name|p
argument_list|)
condition|)
name|success
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|src_note
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
comment|/* INSN was already checked to be movable when 	     we found no REG_DEAD note for src on it.  */
name|overlap
operator|=
name|p
expr_stmt|;
name|src_note
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* If we have passed a call instruction, and the pseudo-reg SRC is not 	 already live across a call, then don't perform the optimization.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|num_calls
operator|++
expr_stmt|;
if|if
condition|(
name|src_note
condition|)
name|s_num_calls
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
return|return
literal|0
return|;
name|true_loop_depth
operator|=
name|backward
condition|?
literal|2
operator|-
name|loop_depth
else|:
name|loop_depth
expr_stmt|;
comment|/* Remove the death note for DST from P.  */
name|remove_note
argument_list|(
name|p
argument_list|,
name|dst_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
block|{
name|post_inc
operator|=
name|emit_insn_after
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRE_INCREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PRE_DECREMENT
argument_list|)
if|if
condition|(
name|search_end
operator|&&
name|try_auto_increment
argument_list|(
name|search_end
argument_list|,
name|post_inc
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|newconst
argument_list|,
literal|1
argument_list|)
condition|)
name|post_inc
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|insn_const
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|+=
name|true_loop_depth
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|overlap
condition|)
block|{
comment|/* The lifetime of src and dest overlap, 	 but we can change this by moving insn.  */
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_note
condition|)
name|remove_note
argument_list|(
name|overlap
argument_list|,
name|src_note
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POST_INCREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_POST_DECREMENT
argument_list|)
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|try_auto_increment
argument_list|(
name|overlap
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|insn_const
argument_list|,
literal|0
argument_list|)
condition|)
name|insn
operator|=
name|overlap
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|rtx
name|notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|emit_insn_after_with_line_notes
argument_list|(
name|pat
argument_list|,
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* emit_insn_after_with_line_notes has no 	     return value, so search for the new insn.  */
for|for
control|(
name|insn
operator|=
name|p
init|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|!=
name|pat
condition|;
control|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|notes
expr_stmt|;
block|}
block|}
comment|/* Sometimes we'd generate src = const; src += n;      if so, replace the instruction that set src      in the first place.  */
if|if
condition|(
operator|!
name|overlap
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|q
decl_stmt|,
name|set2
decl_stmt|;
name|int
name|num_calls2
init|=
literal|0
decl_stmt|,
name|s_length2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|q
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|q
condition|;
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ??? We can't scan past the end of a basic block without 		 updating the register lifetime info 		 (REG_DEAD/basic_block_live_at_start). 		 A CALL_INSN might be the last insn of a basic block, if 		 it is inside an EH region.  There is no easy way to tell, 		 so we just always break when we see a CALL_INSN if 		 flag_exceptions is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|s_length2
operator|++
expr_stmt|;
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|set2
operator|=
name|single_set
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|num_calls2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|&&
name|set2
operator|&&
name|SET_DEST
argument_list|(
name|set2
argument_list|)
operator|==
name|src
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|q
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|q
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|-=
name|num_calls2
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|-=
name|true_loop_depth
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|-=
name|s_length2
expr_stmt|;
name|insn_const
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Don't remove this seemingly useless if, it is needed to pair with the      else in the next two conditionally included code blocks.  */
if|if
condition|(
literal|0
condition|)
block|{
empty_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRE_INCREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PRE_DECREMENT
argument_list|)
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|insn_const
operator|&&
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|insn_const
argument_list|,
literal|1
argument_list|)
condition|)
name|insn
operator|=
name|p
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POST_INCREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_POST_DECREMENT
argument_list|)
elseif|else
if|if
condition|(
name|post_inc
operator|&&
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|post_inc
argument_list|,
name|post_inc_set
argument_list|,
name|src
argument_list|,
name|newconst
argument_list|,
literal|0
argument_list|)
condition|)
name|post_inc
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRE_INCREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PRE_DECREMENT
argument_list|)
comment|/* If post_inc still prevails, try to find an      insn where it can be used as a pre-in/decrement.      If code is MINUS, this was already tried.  */
if|if
condition|(
name|post_inc
operator|&&
name|code
operator|==
name|PLUS
comment|/* Check that newconst is likely to be usable      in a pre-in/decrement before starting the search.  */
operator|&&
operator|(
literal|0
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRE_INCREMENT
argument_list|)
operator|||
operator|(
name|newconst
operator|>
literal|0
operator|&&
name|newconst
operator|<=
name|MOVE_MAX
operator|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRE_DECREMENT
argument_list|)
operator|||
operator|(
name|newconst
operator|<
literal|0
operator|&&
name|newconst
operator|>=
operator|-
name|MOVE_MAX
operator|)
endif|#
directive|endif
operator|)
operator|&&
name|exact_log2
argument_list|(
name|newconst
argument_list|)
condition|)
block|{
name|rtx
name|q
decl_stmt|,
name|inc_dest
decl_stmt|;
name|inc_dest
operator|=
name|post_inc_set
condition|?
name|SET_DEST
argument_list|(
name|post_inc_set
argument_list|)
else|:
name|src
expr_stmt|;
for|for
control|(
name|q
operator|=
name|post_inc
init|;
operator|(
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
comment|/* ??? We can't scan past the end of a basic block without updating 	     the register lifetime info (REG_DEAD/basic_block_live_at_start). 	     A CALL_INSN might be the last insn of a basic block, if it 	     is inside an EH region.  There is no easy way to tell so we 	     just always break when we see a CALL_INSN if flag_exceptions 	     is nonzero.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|src
operator|!=
name|inc_dest
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|q
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|reg_set_p
argument_list|(
name|inc_dest
argument_list|,
name|q
argument_list|)
condition|)
break|break;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|inc_dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
name|try_auto_increment
argument_list|(
name|q
argument_list|,
name|post_inc
argument_list|,
name|post_inc_set
argument_list|,
name|inc_dest
argument_list|,
name|newconst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) */
comment|/* Move the death note for DST to INSN if it is used      there.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|dst_note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|dst_note
expr_stmt|;
block|}
if|if
condition|(
name|src_note
condition|)
block|{
comment|/* Move the death note for SRC from INSN to P.  */
if|if
condition|(
operator|!
name|overlap
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|src_note
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src_note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|src_note
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|+=
name|s_num_calls
expr_stmt|;
block|}
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|-=
name|num_calls
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|+=
name|s_length
expr_stmt|;
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|-=
name|length
expr_stmt|;
comment|/* REG_LIVE_LENGTH is only an approximation after 	 combine if sched is not run, so make sure that we 	 still have a reasonable value.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|<
literal|2
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
comment|/* We assume that a register is used exactly once per       insn in the updates above.  If this is not correct,       no great harm is done.  */
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|+=
literal|2
operator|*
name|true_loop_depth
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|-=
literal|2
operator|*
name|true_loop_depth
expr_stmt|;
comment|/* If that was the only time dst was set,      and dst was not live at the start of the      function, we know that we have no more      references to dst; clear REG_N_REFS so it      won't make reload do any work.  */
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|regno_uninitialized
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Fixed operand %d of insn %d matching operand %d.\n"
argument_list|,
name|operand_number
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_number
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* return nonzero if X is stable but for mentioning SRC or mentioning /    changing DST .  If in doubt, presume it is unstable.  */
end_comment

begin_function
specifier|static
name|int
name|stable_but_for_p
parameter_list|(
name|x
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'<'
case|:
case|case
literal|'1'
case|:
case|case
literal|'c'
case|:
case|case
literal|'2'
case|:
case|case
literal|'b'
case|:
case|case
literal|'3'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
operator|!
name|stable_but_for_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
case|case
literal|'o'
case|:
if|if
condition|(
name|x
operator|==
name|src
operator|||
name|x
operator|==
name|dst
condition|)
return|return
literal|1
return|;
comment|/* fall through */
default|default:
return|return
operator|!
name|rtx_unstable_p
argument_list|(
name|x
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Test if regmove seems profitable for this target.  Regmove is useful only    if some common patterns are two address, i.e. require matching constraints,    so we check that condition here.  */
end_comment

begin_function
name|int
name|regmove_profitable_p
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
name|struct
name|match
name|match
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|tstoptab
init|=
name|add_optab
decl_stmt|;
do|do
comment|/* check add_optab and ashl_optab */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|tstoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|rtx
name|reg0
decl_stmt|,
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
literal|32
operator|||
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|GENERAL_REGS
index|]
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|+
literal|2
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
break|break;
name|reg0
operator|=
name|gen_rtx_REG
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|gen_rtx_REG
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|gen_rtx_REG
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|2
index|]
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|reg0
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|reg1
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|reg2
argument_list|,
name|VOIDmode
argument_list|)
condition|)
break|break;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|reg0
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|make_insn_raw
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|single_set
argument_list|(
name|pat
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|single_set
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|tstoptab
operator|->
name|code
condition|)
comment|/* Unexpected complexity;  don't need to handle this unless 	       we find a machine where this occurs and regmove should 	       be enabled.  */
break|break;
if|if
condition|(
name|find_matches
argument_list|(
name|pat
argument_list|,
operator|&
name|match
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
break|break;
block|}
do|while
condition|(
name|tstoptab
operator|!=
name|ashl_optab
operator|&&
operator|(
name|tstoptab
operator|=
name|ashl_optab
operator|,
literal|1
operator|)
condition|)
do|;
endif|#
directive|endif
comment|/* REGISTER_CONSTRAINTS */
return|return
literal|0
return|;
block|}
end_function

end_unit

