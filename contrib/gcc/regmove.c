begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Move registers around to reduce number of move instructions needed.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module looks for cases where matching constraints would force    an instruction to need a reload, and this reload would be a register    to register move.  It then attempts to change the registers used by the    instruction to avoid the move instruction.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_comment
comment|/* stdio.h must precede rtl.h for FFS.  */
end_comment

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_comment
comment|/* Turn STACK_GROWS_DOWNWARD into a boolean.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_undef
undef|#
directive|undef
name|STACK_GROWS_DOWNWARD
end_undef

begin_define
define|#
directive|define
name|STACK_GROWS_DOWNWARD
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_GROWS_DOWNWARD
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|perhaps_ends_bb_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|optimize_reg_copy_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_reg_copy_2
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_reg_copy_3
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_src_to_dest
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regmove_bb_head
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|match
block|{
name|int
name|with
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
enum|enum
block|{
name|READ
block|,
name|WRITE
block|,
name|READWRITE
block|}
name|use
index|[
name|MAX_RECOG_OPERANDS
index|]
enum|;
name|int
name|commutative
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|early_clobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|rtx
name|discover_flags_reg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_flags_life_zones
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flags_set_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_auto_increment
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_matches
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|match
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_in_call_usage
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|unsigned
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fixup_match_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_is_remote_constant_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stable_and_no_regs_but_for_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regclass_compatible_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|replacement_quality
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fixup_match_2
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return non-zero if registers with CLASS1 and CLASS2 can be merged without    causing too much register allocation problems.  */
end_comment

begin_function
specifier|static
name|int
name|regclass_compatible_p
parameter_list|(
name|class0
parameter_list|,
name|class1
parameter_list|)
name|int
name|class0
decl_stmt|,
name|class1
decl_stmt|;
block|{
return|return
operator|(
name|class0
operator|==
name|class1
operator|||
operator|(
name|reg_class_subset_p
argument_list|(
name|class0
argument_list|,
name|class1
argument_list|)
operator|&&
operator|!
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|class0
argument_list|)
operator|)
operator|||
operator|(
name|reg_class_subset_p
argument_list|(
name|class1
argument_list|,
name|class0
argument_list|)
operator|&&
operator|!
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|class1
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* INC_INSN is an instruction that adds INCREMENT to REG.    Try to fold INC_INSN as a post/pre in/decrement into INSN.    Iff INC_INSN_SET is nonzero, inc_insn has a destination different from src.    Return nonzero for success.  */
end_comment

begin_function
specifier|static
name|int
name|try_auto_increment
parameter_list|(
name|insn
parameter_list|,
name|inc_insn
parameter_list|,
name|inc_insn_set
parameter_list|,
name|reg
parameter_list|,
name|increment
parameter_list|,
name|pre
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|,
name|inc_insn
decl_stmt|,
name|inc_insn_set
decl_stmt|;
name|HOST_WIDE_INT
name|increment
decl_stmt|;
name|int
name|pre
decl_stmt|;
block|{
name|enum
name|rtx_code
name|inc_code
decl_stmt|;
name|rtx
name|pset
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pset
condition|)
block|{
comment|/* Can't use the size of SET_SRC, we might have something like 	 (sign_extend:SI (mem:QI ...  */
name|rtx
name|use
init|=
name|find_use_as_address
argument_list|(
name|pset
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|use
operator|!=
literal|0
operator|&&
name|use
operator|!=
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
literal|1
condition|)
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|||
operator|(
name|HAVE_POST_INCREMENT
operator|&&
name|pre
operator|==
literal|0
operator|&&
operator|(
name|inc_code
operator|=
name|POST_INC
operator|,
name|increment
operator|==
name|size
operator|)
operator|)
operator|||
operator|(
name|HAVE_PRE_INCREMENT
operator|&&
name|pre
operator|==
literal|1
operator|&&
operator|(
name|inc_code
operator|=
name|PRE_INC
operator|,
name|increment
operator|==
name|size
operator|)
operator|)
operator|||
operator|(
name|HAVE_POST_DECREMENT
operator|&&
name|pre
operator|==
literal|0
operator|&&
operator|(
name|inc_code
operator|=
name|POST_DEC
operator|,
name|increment
operator|==
operator|-
name|size
operator|)
operator|)
operator|||
operator|(
name|HAVE_PRE_DECREMENT
operator|&&
name|pre
operator|==
literal|1
operator|&&
operator|(
name|inc_code
operator|=
name|PRE_DEC
operator|,
name|increment
operator|==
operator|-
name|size
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|inc_insn_set
condition|)
name|validate_change
argument_list|(
name|inc_insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|inc_insn_set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|inc_insn_set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
comment|/* If there is a REG_DEAD note on this insn, we must 		     change this not to REG_UNUSED meaning that the register 		     is set, but the value is dead.  Failure to do so will 		     result in a sched1 abort -- when it recomputes lifetime 		     information, the number of REG_DEAD notes will have 		     changed.  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|PUT_MODE
argument_list|(
name|note
argument_list|,
name|REG_UNUSED
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inc_insn_set
condition|)
name|delete_insn
argument_list|(
name|inc_insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine if the pattern generated by add_optab has a clobber,    such as might be issued for a flags hard register.  To make the    code elsewhere simpler, we handle cc0 in this same framework.     Return the register if one was discovered.  Return NULL_RTX if    if no flags were found.  Return pc_rtx if we got confused.  */
end_comment

begin_function
specifier|static
name|rtx
name|discover_flags_reg
parameter_list|()
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_add3_insn
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we get something that isn't a simple set, or a      [(set ..) (clobber ..)], this whole function will go wrong.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SET
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|found
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|pc_rtx
return|;
name|tmp
operator|=
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
name|pc_rtx
return|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't do anything foolish if the md wanted to clobber a 	 scratch or something.  We only care about hard regs. 	 Moreover we don't like the notion of subregs of hard regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|pc_rtx
return|;
name|found
operator|=
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
expr_stmt|;
return|return
operator|(
name|found
condition|?
name|tmp
else|:
name|NULL_RTX
operator|)
return|;
block|}
return|return
name|pc_rtx
return|;
block|}
end_function

begin_comment
comment|/* It is a tedious task identifying when the flags register is live and    when it is safe to optimize.  Since we process the instruction stream    multiple times, locate and record these live zones by marking the    mode of the instructions --     QImode is used on the instruction at which the flags becomes live.     HImode is used within the range (exclusive) that the flags are    live.  Thus the user of the flags is not marked.     All other instructions are cleared to VOIDmode.  */
end_comment

begin_comment
comment|/* Used to communicate with flags_set_1.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|flags_set_1_rtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flags_set_1_set
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mark_flags_life_zones
parameter_list|(
name|flags
parameter_list|)
name|rtx
name|flags
decl_stmt|;
block|{
name|int
name|flags_regno
decl_stmt|;
name|int
name|flags_nregs
decl_stmt|;
name|int
name|block
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If we found a flags register on a cc0 host, bail.  */
if|if
condition|(
name|flags
operator|==
name|NULL_RTX
condition|)
name|flags
operator|=
name|cc0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|!=
name|cc0_rtx
condition|)
name|flags
operator|=
name|pc_rtx
expr_stmt|;
endif|#
directive|endif
comment|/* Simple cases first: if no flags, clear all modes.  If confusing,      mark the entire function as being in a flags shadow.  */
if|if
condition|(
name|flags
operator|==
name|NULL_RTX
operator|||
name|flags
operator|==
name|pc_rtx
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
operator|(
name|flags
condition|?
name|HImode
else|:
name|VOIDmode
operator|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
name|flags_regno
operator|=
operator|-
literal|1
expr_stmt|;
name|flags_nregs
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|flags_regno
operator|=
name|REGNO
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|flags_nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|flags_regno
argument_list|,
name|GET_MODE
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flags_set_1_rtx
operator|=
name|flags
expr_stmt|;
comment|/* Process each basic block.  */
for|for
control|(
name|block
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|block
operator|>=
literal|0
condition|;
name|block
operator|--
control|)
block|{
name|rtx
name|insn
decl_stmt|,
name|end
decl_stmt|;
name|int
name|live
decl_stmt|;
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|end
operator|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/* Look out for the (unlikely) case of flags being live across 	 basic block boundaries.  */
name|live
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_cc0
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|flags_nregs
condition|;
operator|++
name|i
control|)
name|live
operator||=
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|block
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|flags_regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Process liveness in reverse order of importance -- 	     alive, death, birth.  This lets more important info 	     overwrite the mode of lesser info.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* In the cc0 case, death is not marked in reg notes, 		 but is instead the mere use of cc0 when it is alive.  */
if|if
condition|(
name|live
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|live
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* In the hard reg case, we watch death notes.  */
if|if
condition|(
name|live
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|flags_regno
argument_list|)
condition|)
name|live
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
operator|(
name|live
condition|?
name|HImode
else|:
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
comment|/* In either case, birth is denoted simply by it's presence 		 as the destination of a set.  */
name|flags_set_1_set
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|flags_set_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags_set_1_set
condition|)
block|{
name|live
operator|=
literal|1
expr_stmt|;
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
operator|(
name|live
condition|?
name|HImode
else|:
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of mark_flags_life_zones, called through note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|flags_set_1
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|pat
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|flags_set_1_rtx
argument_list|)
condition|)
name|flags_set_1_set
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regno_src_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate how good a choice REG (which appears as a source) is to replace    a destination register with.  The higher the returned value, the better    the choice.  The main objective is to avoid using a register that is    a candidate for tying to a hard register, since the output might in    turn be a candidate to be tied to a different hard register.  */
end_comment

begin_function
specifier|static
name|int
name|replacement_quality
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|src_regno
decl_stmt|;
comment|/* Bad if this isn't a register at all.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* If this register is not meant to get a hard register,      it is a poor choice.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
comment|/* If it was not copied from another register, it is fine.  */
if|if
condition|(
name|src_regno
operator|<
literal|0
condition|)
return|return
literal|3
return|;
comment|/* Copied from a hard register?  */
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|1
return|;
comment|/* Copied from a pseudo register - not as bad as from a hard register,      yet still cumbersome, since the register live length will be lengthened      when the registers get tied.  */
return|return
literal|2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if INSN might end a basic block.  */
end_comment

begin_function
specifier|static
name|int
name|perhaps_ends_bb_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
case|case
name|JUMP_INSN
case|:
comment|/* These always end a basic block.  */
return|return
literal|1
return|;
case|case
name|CALL_INSN
case|:
comment|/* A CALL_INSN might be the last insn of a basic block, if it is inside 	 an EH region or if there are nonlocal gotos.  Note that this test is 	 very conservative.  */
if|if
condition|(
name|nonlocal_goto_handler_labels
condition|)
return|return
literal|1
return|;
comment|/* FALLTHRU */
default|default:
return|return
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN is a copy from SRC to DEST, both registers, and SRC does not die    in INSN.     Search forward to see if SRC dies before either it or DEST is modified,    but don't scan past the end of a basic block.  If so, we can replace SRC    with DEST and let SRC die in INSN.     This will reduce the number of registers live in that range and may enable    DEST to be tied to SRC, thus often saving one register in addition to a    register-register copy.  */
end_comment

begin_function
specifier|static
name|int
name|optimize_reg_copy_1
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|dest_death
init|=
literal|0
decl_stmt|;
name|int
name|sregno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|dregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* We don't want to mess with hard regs if register classes are small.  */
if|if
condition|(
name|sregno
operator|==
name|dregno
operator|||
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|dregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
comment|/* We don't see all updates to SP if they are in an auto-inc memory 	 reference, so we must disallow this optimization on them.  */
operator|||
name|sregno
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|dregno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|p
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|dest
argument_list|,
name|p
argument_list|)
comment|/* Don't change a USE of a register.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* See if all of SRC dies in P.  This test is slightly more 	 conservative than it needs to be.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_regno_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|sregno
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|int
name|d_length
init|=
literal|0
decl_stmt|;
name|int
name|s_length
init|=
literal|0
decl_stmt|;
name|int
name|d_n_calls
init|=
literal|0
decl_stmt|;
name|int
name|s_n_calls
init|=
literal|0
decl_stmt|;
comment|/* We can do the optimization.  Scan forward from INSN again, 	     replacing regs as we go.  Set FAILED if a replacement can't 	     be done.  In that case, we can't move the death note for SRC. 	     This should be rare.  */
comment|/* Set to stop at next insn.  */
for|for
control|(
name|q
operator|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
init|;
name|q
operator|!=
name|next_real_insn
argument_list|(
name|p
argument_list|)
condition|;
name|q
operator|=
name|next_real_insn
argument_list|(
name|q
argument_list|)
control|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If SRC is a hard register, we might miss some 		     overlapping registers with validate_replace_rtx, 		     so we would have to undo it.  We can't if DEST is 		     present in the insn, so fail in that combination 		     of cases.  */
if|if
condition|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
comment|/* Replace all uses and make sure that the register 		     isn't still present.  */
elseif|else
if|if
condition|(
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|q
argument_list|)
operator|&&
operator|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
block|{
name|validate_replace_rtx
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* For SREGNO, count the total number of insns scanned. 		 For DREGNO, count the total number of insns scanned after 		 passing the death note for DREGNO.  */
name|s_length
operator|++
expr_stmt|;
if|if
condition|(
name|dest_death
condition|)
name|d_length
operator|++
expr_stmt|;
comment|/* If the insn in which SRC dies is a CALL_INSN, don't count it 		 as a call that has been crossed.  Otherwise, count it.  */
if|if
condition|(
name|q
operator|!=
name|p
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Similarly, total calls for SREGNO, total calls beyond 		     the death note for DREGNO.  */
name|s_n_calls
operator|++
expr_stmt|;
if|if
condition|(
name|dest_death
condition|)
name|d_n_calls
operator|++
expr_stmt|;
block|}
comment|/* If DEST dies here, remove the death note and save it for 		 later.  Make sure ALL of DEST dies here; again, this is 		 overly conservative.  */
if|if
condition|(
name|dest_death
operator|==
literal|0
operator|&&
operator|(
name|dest_death
operator|=
name|find_regno_note
argument_list|(
name|q
argument_list|,
name|REG_DEAD
argument_list|,
name|dregno
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dest_death
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
name|failed
operator|=
literal|1
operator|,
name|dest_death
operator|=
literal|0
expr_stmt|;
else|else
name|remove_note
argument_list|(
name|q
argument_list|,
name|dest_death
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
comment|/* These counters need to be updated if and only if we are 		 going to move the REG_DEAD note.  */
if|if
condition|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|-=
name|s_length
expr_stmt|;
comment|/* REG_LIVE_LENGTH is only an approximation after 			 combine if sched is not run, so make sure that we 			 still have a reasonable value.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|<
literal|2
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|sregno
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
name|REG_N_CALLS_CROSSED
argument_list|(
name|sregno
argument_list|)
operator|-=
name|s_n_calls
expr_stmt|;
block|}
comment|/* Move death note of SRC from P to INSN.  */
name|remove_note
argument_list|(
name|p
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* DEST is also dead if INSN has a REG_UNUSED note for DEST.  */
if|if
condition|(
operator|!
name|dest_death
operator|&&
operator|(
name|dest_death
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|dregno
argument_list|)
operator|)
condition|)
block|{
name|PUT_REG_NOTE_KIND
argument_list|(
name|dest_death
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|dest_death
argument_list|)
expr_stmt|;
block|}
comment|/* Put death note of DEST on P if we saw it die.  */
if|if
condition|(
name|dest_death
condition|)
block|{
name|XEXP
argument_list|(
name|dest_death
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|dest_death
expr_stmt|;
if|if
condition|(
name|dregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If and only if we are moving the death note for DREGNO, 		     then we need to update its counters.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|dregno
argument_list|)
operator|>=
literal|0
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|dregno
argument_list|)
operator|+=
name|d_length
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|dregno
argument_list|)
operator|+=
name|d_n_calls
expr_stmt|;
block|}
block|}
return|return
operator|!
name|failed
return|;
block|}
comment|/* If SRC is a hard register which is set or killed in some other 	 way, we can't do this optimization.  */
elseif|else
if|if
condition|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dead_or_set_p
argument_list|(
name|p
argument_list|,
name|src
argument_list|)
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have    a sequence of insns that modify DEST followed by an insn that sets    SRC to DEST in which DEST dies, with no prior modification of DEST.    (There is no need to check if the insns in between actually modify    DEST.  We should not have cases where DEST is not modified, but    the optimization is safe if no such modification is detected.)    In that case, we can replace all uses of DEST, starting with INSN and    ending with the set of SRC to DEST, with SRC.  We do not do this    optimization if a CALL_INSN is crossed unless SRC already crosses a    call or if DEST dies before the copy back to SRC.     It is assumed that DEST and SRC are pseudos; it is too complicated to do    this for hard registers since the substitutions we may make might fail.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_reg_copy_2
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|sregno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|dregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|p
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|dest
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|src
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
condition|)
block|{
comment|/* We can do the optimization.  Scan forward from INSN again, 	     replacing regs as we go.  */
comment|/* Set to stop at next insn.  */
for|for
control|(
name|q
operator|=
name|insn
init|;
name|q
operator|!=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|PATTERN
argument_list|(
name|q
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|REG_N_CALLS_CROSSED
argument_list|(
name|dregno
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|sregno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
name|remove_note
argument_list|(
name|p
argument_list|,
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|dregno
argument_list|)
operator|--
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|sregno
argument_list|)
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|REG_N_CALLS_CROSSED
argument_list|(
name|sregno
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* INSN is a ZERO_EXTEND or SIGN_EXTEND of SRC to DEST.    Look if SRC dies there, and if it is only set once, by loading    it from memory.  If so, try to encorporate the zero/sign extension    into the memory read, change SRC to the mode of DEST, and alter    the remaining accesses to use the appropriate SUBREG.  This allows    SRC and DEST to be tied later.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_reg_copy_3
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|src_reg
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|src_no
init|=
name|REGNO
argument_list|(
name|src_reg
argument_list|)
decl_stmt|;
name|int
name|dst_no
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|,
name|set
decl_stmt|,
name|subreg
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
decl_stmt|;
if|if
condition|(
name|src_no
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|dst_no
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src_reg
argument_list|)
operator|||
name|REG_N_SETS
argument_list|(
name|src_no
argument_list|)
operator|!=
literal|1
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|src_reg
argument_list|,
name|p
argument_list|)
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
comment|/* ??? We can't scan past the end of a basic block without updating        the register lifetime info (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|MEM
comment|/* If there's a REG_EQUIV note, this must be an insn that loads an 	 argument.  Prefer keeping the note over doing this optimization.  */
operator|||
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|src_reg
condition|)
return|return;
comment|/* Be conserative: although this optimization is also valid for      volatile memory references, that could cause trouble in later passes.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Do not use a SUBREG to truncate from one mode to another if truncation      is not a nop.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src_reg
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|&&
operator|!
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src_reg
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return;
name|old_mode
operator|=
name|GET_MODE
argument_list|(
name|src_reg
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|src_reg
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Include this change in the group so that it's easily undone if      one of the changes in the group is invalid.  */
name|validate_change
argument_list|(
name|p
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now walk forward making additional replacements.  We want to be able      to undo all the changes if a later substitution fails.  */
name|subreg
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|old_mode
argument_list|,
name|src_reg
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|,
name|p
operator|!=
name|insn
condition|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
comment|/* Make a tenative change.  */
name|validate_replace_rtx_group
argument_list|(
name|src_reg
argument_list|,
name|subreg
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|validate_replace_rtx_group
argument_list|(
name|src
argument_list|,
name|src_reg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Now see if all the changes are valid.  */
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
block|{
comment|/* One or more changes were no good.  Back out everything.  */
name|PUT_MODE
argument_list|(
name|src_reg
argument_list|,
name|old_mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|src_reg
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|p
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we were not able to update the users of src to use dest directly, try    instead moving the value to dest directly before the operation.  */
end_comment

begin_function
specifier|static
name|void
name|copy_src_to_dest
parameter_list|(
name|insn
parameter_list|,
name|src
parameter_list|,
name|dest
parameter_list|,
name|old_max_uid
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|int
name|old_max_uid
decl_stmt|;
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|move_insn
decl_stmt|;
name|rtx
modifier|*
name|p_insn_notes
decl_stmt|;
name|rtx
modifier|*
name|p_move_notes
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int
name|insn_uid
decl_stmt|;
name|int
name|move_uid
decl_stmt|;
comment|/* A REG_LIVE_LENGTH of -1 indicates the register is equivalent to a constant      or memory location and is used infrequently; a REG_LIVE_LENGTH of -2 is      parameter when there is no frame pointer that is not allocated a register.      For now, we just reject them, rather than incrementing the live length.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|dest
argument_list|)
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|int
name|old_num_regs
init|=
name|reg_rtx_no
decl_stmt|;
comment|/* Generate the src->dest move.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* If this sequence uses new registers, we may not use it.  */
if|if
condition|(
name|old_num_regs
operator|!=
name|reg_rtx_no
operator|||
operator|!
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|insn
argument_list|)
condition|)
block|{
comment|/* We have to restore reg_rtx_no to its old value, lest 	     recompute_reg_usage will try to compute the usage of the 	     new regs, yet reg_n_info is not valid for them.  */
name|reg_rtx_no
operator|=
name|old_num_regs
expr_stmt|;
return|return;
block|}
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|move_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|p_move_notes
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|move_insn
argument_list|)
expr_stmt|;
name|p_insn_notes
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Move any notes mentioning src to the move instruction */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
name|NULL_RTX
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|src
condition|)
block|{
operator|*
name|p_move_notes
operator|=
name|link
expr_stmt|;
name|p_move_notes
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p_insn_notes
operator|=
name|link
expr_stmt|;
name|p_insn_notes
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|p_move_notes
operator|=
name|NULL_RTX
expr_stmt|;
operator|*
name|p_insn_notes
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Is the insn the head of a basic block?  If so extend it */
name|insn_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|move_uid
operator|=
name|INSN_UID
argument_list|(
name|move_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_uid
operator|<
name|old_max_uid
condition|)
block|{
name|bb
operator|=
name|regmove_bb_head
index|[
name|insn_uid
index|]
expr_stmt|;
if|if
condition|(
name|bb
operator|>=
literal|0
condition|)
block|{
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|move_insn
expr_stmt|;
name|regmove_bb_head
index|[
name|insn_uid
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Update the various register tables.  */
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|dest_regno
argument_list|)
operator|++
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|dest_regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|dest_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_FIRST_UID
argument_list|(
name|dest_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|move_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|src_regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|src_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_FIRST_UID
argument_list|(
name|src_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|src_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_LAST_UID
argument_list|(
name|src_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
if|if
condition|(
name|REGNO_LAST_NOTE_UID
argument_list|(
name|src_regno
argument_list|)
operator|==
name|insn_uid
condition|)
name|REGNO_LAST_NOTE_UID
argument_list|(
name|src_regno
argument_list|)
operator|=
name|move_uid
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return whether REG is set in only one location, and is set to a    constant, but is set in a different basic block from INSN (an    instructions which uses REG).  In this case REG is equivalent to a    constant, and we don't want to break that equivalence, because that    may increase register pressure and make reload harder.  If REG is    set in the same basic block as INSN, we don't worry about it,    because we'll probably need a register anyhow (??? but what if REG    is used in a different basic block as well as this one?).  FIRST is    the first insn in the function.  */
end_comment

begin_function
specifier|static
name|int
name|reg_is_remote_constant_p
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|,
name|first
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Look for the set.  */
for|for
control|(
name|p
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|s
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|s
operator|=
name|single_set
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
block|{
comment|/* The register is set in the same basic block.  */
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|first
init|;
name|p
operator|&&
name|p
operator|!=
name|insn
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|rtx
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|s
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
block|{
comment|/* This is the instruction which sets REG.  If there is a              REG_EQUAL note, then REG is equivalent to a constant.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* INSN is adding a CONST_INT to a REG.  We search backwards looking for    another add immediate instruction with the same source and dest registers,    and if we find one, we change INSN to an increment, and return 1.  If    no changes are made, we return 0.     This changes      (set (reg100) (plus reg1 offset1))      ...      (set (reg100) (plus reg1 offset2))    to      (set (reg100) (plus reg1 offset1))      ...      (set (reg100) (plus reg100 offset2-offset1))  */
end_comment

begin_comment
comment|/* ??? What does this comment mean?  */
end_comment

begin_comment
comment|/* cse disrupts preincrement / postdecrement squences when it finds a    hard register as ultimate source, like the frame pointer.  */
end_comment

begin_function
specifier|static
name|int
name|fixup_match_2
parameter_list|(
name|insn
parameter_list|,
name|dst
parameter_list|,
name|src
parameter_list|,
name|offset
parameter_list|,
name|regmove_dump_file
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|offset
decl_stmt|;
name|FILE
modifier|*
name|regmove_dump_file
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|dst_death
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|,
name|num_calls
init|=
literal|0
decl_stmt|;
comment|/* If SRC dies in INSN, we'd have to move the death note.  This is      considered to be very unlikely, so we just skip the optimization      in this case.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Scan backward to find the first instruction that sets DST.  */
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|rtx
name|pset
decl_stmt|;
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|p
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|find_regno_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|dst_death
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|dst_death
condition|)
name|length
operator|++
expr_stmt|;
name|pset
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|&&
name|SET_DEST
argument_list|(
name|pset
argument_list|)
operator|==
name|dst
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|src
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|newconst
init|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pset
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|add
init|=
name|gen_add3_insn
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
name|newconst
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|add
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|add
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Remove the death note for DST from DST_DEATH.  */
if|if
condition|(
name|dst_death
condition|)
block|{
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|,
name|dst_death
argument_list|)
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|+=
name|length
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|+=
name|num_calls
expr_stmt|;
block|}
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Fixed operand of insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|newconst
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
block|}
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|newconst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* If we have passed a call instruction, and the          pseudo-reg SRC is not already live across a call,          then don't perform the optimization.  */
comment|/* reg_set_p is overly conservative for CALL_INSNS, thinks that all 	 hard regs are clobbered.  Thus, we only use it for src for 	 non-call insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|dst_death
condition|)
name|num_calls
operator|++
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|dst
argument_list|)
index|]
operator|||
name|find_reg_fusage
argument_list|(
name|p
argument_list|,
name|CLOBBER
argument_list|,
name|dst
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Main entry for the register move optimization.    F is the first instruction.    NREGS is one plus the highest pseudo-reg number used in the instruction.    REGMOVE_DUMP_FILE is a stream for output of a trace of actions taken    (or 0 if none should be output).  */
end_comment

begin_function
name|void
name|regmove_optimize
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|regmove_dump_file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|regmove_dump_file
decl_stmt|;
block|{
name|int
name|old_max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|match
name|match
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|copy_src
decl_stmt|,
name|copy_dst
decl_stmt|;
comment|/* ??? Hack.  Regmove doesn't examine the CFG, and gets mightily      confused by non-call exceptions ending blocks.  */
if|if
condition|(
name|flag_non_call_exceptions
condition|)
return|return;
comment|/* Find out where a potential flags register is live, and so that we      can supress some optimizations in those zones.  */
name|mark_flags_life_zones
argument_list|(
name|discover_flags_reg
argument_list|()
argument_list|)
expr_stmt|;
name|regno_src_regno
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|regno_src_regno
operator|*
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nregs
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|regno_src_regno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regmove_bb_head
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|old_max_uid
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|old_max_uid
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|regmove_bb_head
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|regmove_bb_head
index|[
name|INSN_UID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|i
argument_list|)
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
comment|/* A forward/backward pass.  Replace output operands with input operands.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|2
condition|;
name|pass
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|flag_regmove
operator|&&
name|pass
operator|>=
name|flag_expensive_optimizations
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Starting %s pass...\n"
argument_list|,
name|pass
condition|?
literal|"backward"
else|:
literal|"forward"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|pass
condition|?
name|get_last_insn
argument_list|()
else|:
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|pass
condition|?
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
else|:
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
name|int
name|op_no
decl_stmt|,
name|match_no
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|!
name|pass
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|optimize_reg_copy_3
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|!
name|pass
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If this is a register-register copy where SRC is not dead, 		 see if we can optimize it.  If this optimization succeeds, 		 it will become a copy where SRC is dead.  */
if|if
condition|(
operator|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
name|optimize_reg_copy_1
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Similarly for a pseudo-pseudo copy when SRC is dead.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|optimize_reg_copy_2
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|!=
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|int
name|srcregno
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno_src_regno
index|[
name|srcregno
index|]
operator|>=
literal|0
condition|)
name|srcregno
operator|=
name|regno_src_regno
index|[
name|srcregno
index|]
expr_stmt|;
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|=
name|srcregno
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|flag_regmove
condition|)
continue|continue;
if|if
condition|(
operator|!
name|find_matches
argument_list|(
name|insn
argument_list|,
operator|&
name|match
argument_list|)
condition|)
continue|continue;
comment|/* Now scan through the operands looking for a source operand 	     which is supposed to match the destination operand. 	     Then scan forward for an instruction which uses the dest 	     operand. 	     If it dies there, then replace the dest in both operands with 	     the source operand.  */
for|for
control|(
name|op_no
operator|=
literal|0
init|;
name|op_no
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|op_no
operator|++
control|)
block|{
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|src_subreg
decl_stmt|;
name|enum
name|reg_class
name|src_class
decl_stmt|,
name|dst_class
decl_stmt|;
name|match_no
operator|=
name|match
operator|.
name|with
index|[
name|op_no
index|]
expr_stmt|;
comment|/* Nothing to do if the two operands aren't supposed to match.  */
if|if
condition|(
name|match_no
operator|<
literal|0
condition|)
continue|continue;
name|src
operator|=
name|recog_data
operator|.
name|operand
index|[
name|op_no
index|]
expr_stmt|;
name|dst
operator|=
name|recog_data
operator|.
name|operand
index|[
name|match_no
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|src_subreg
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|src_subreg
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|src
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|commutative
index|[
name|op_no
index|]
operator|<
name|op_no
condition|)
name|regno_src_regno
index|[
name|REGNO
argument_list|(
name|dst
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* op_no/src must be a read-only operand, and 		 match_operand/dst must be a write-only operand.  */
if|if
condition|(
name|match
operator|.
name|use
index|[
name|op_no
index|]
operator|!=
name|READ
operator|||
name|match
operator|.
name|use
index|[
name|match_no
index|]
operator|!=
name|WRITE
condition|)
continue|continue;
if|if
condition|(
name|match
operator|.
name|early_clobber
index|[
name|match_no
index|]
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
operator|>
literal|1
condition|)
continue|continue;
comment|/* Make sure match_operand is the destination.  */
if|if
condition|(
name|recog_data
operator|.
name|operand
index|[
name|match_no
index|]
operator|!=
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
continue|continue;
comment|/* If the operands already match, then there is nothing to do.  */
if|if
condition|(
name|operands_match_p
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
condition|)
continue|continue;
comment|/* But in the commutative case, we might find a better match.  */
if|if
condition|(
name|match
operator|.
name|commutative
index|[
name|op_no
index|]
operator|>=
literal|0
condition|)
block|{
name|rtx
name|comm
init|=
name|recog_data
operator|.
name|operand
index|[
name|match
operator|.
name|commutative
index|[
name|op_no
index|]
index|]
decl_stmt|;
if|if
condition|(
name|operands_match_p
argument_list|(
name|comm
argument_list|,
name|dst
argument_list|)
operator|&&
operator|(
name|replacement_quality
argument_list|(
name|comm
argument_list|)
operator|>=
name|replacement_quality
argument_list|(
name|src
argument_list|)
operator|)
condition|)
continue|continue;
block|}
name|src_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|dst_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regclass_compatible_p
argument_list|(
name|src_class
argument_list|,
name|dst_class
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fixup_match_1
argument_list|(
name|insn
argument_list|,
name|set
argument_list|,
name|src
argument_list|,
name|src_subreg
argument_list|,
name|dst
argument_list|,
name|pass
argument_list|,
name|op_no
argument_list|,
name|match_no
argument_list|,
name|regmove_dump_file
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
comment|/* A backward pass.  Replace input operands with output operands.  */
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Starting backward pass...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|op_no
decl_stmt|,
name|match_no
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|find_matches
argument_list|(
name|insn
argument_list|,
operator|&
name|match
argument_list|)
condition|)
continue|continue;
comment|/* Now scan through the operands looking for a destination operand 	     which is supposed to match a source operand. 	     Then scan backward for an instruction which sets the source 	     operand.  If safe, then replace the source operand with the 	     dest operand in both instructions.  */
name|copy_src
operator|=
name|NULL_RTX
expr_stmt|;
name|copy_dst
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|op_no
operator|=
literal|0
init|;
name|op_no
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|op_no
operator|++
control|)
block|{
name|rtx
name|set
decl_stmt|,
name|p
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|rtx
name|src_note
decl_stmt|,
name|dst_note
decl_stmt|;
name|int
name|num_calls
init|=
literal|0
decl_stmt|;
name|enum
name|reg_class
name|src_class
decl_stmt|,
name|dst_class
decl_stmt|;
name|int
name|length
decl_stmt|;
name|match_no
operator|=
name|match
operator|.
name|with
index|[
name|op_no
index|]
expr_stmt|;
comment|/* Nothing to do if the two operands aren't supposed to match.  */
if|if
condition|(
name|match_no
operator|<
literal|0
condition|)
continue|continue;
name|dst
operator|=
name|recog_data
operator|.
name|operand
index|[
name|match_no
index|]
expr_stmt|;
name|src
operator|=
name|recog_data
operator|.
name|operand
index|[
name|op_no
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|RTX_UNCHANGING_P
argument_list|(
name|dst
argument_list|)
condition|)
continue|continue;
comment|/* If the operands already match, then there is nothing to do.  */
if|if
condition|(
name|operands_match_p
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|match
operator|.
name|commutative
index|[
name|op_no
index|]
operator|>=
literal|0
condition|)
block|{
name|rtx
name|comm
init|=
name|recog_data
operator|.
name|operand
index|[
name|match
operator|.
name|commutative
index|[
name|op_no
index|]
index|]
decl_stmt|;
if|if
condition|(
name|operands_match_p
argument_list|(
name|comm
argument_list|,
name|dst
argument_list|)
condition|)
continue|continue;
block|}
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
comment|/* Note that single_set ignores parts of a parallel set for 		 which one of the destinations is REG_UNUSED.  We can't 		 handle that here, since we can wind up rewriting things 		 such that a single register is set twice within a single 		 parallel.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* match_no/dst must be a write-only operand, and 		 operand_operand/src must be a read-only operand.  */
if|if
condition|(
name|match
operator|.
name|use
index|[
name|op_no
index|]
operator|!=
name|READ
operator|||
name|match
operator|.
name|use
index|[
name|match_no
index|]
operator|!=
name|WRITE
condition|)
continue|continue;
if|if
condition|(
name|match
operator|.
name|early_clobber
index|[
name|match_no
index|]
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
operator|>
literal|1
condition|)
continue|continue;
comment|/* Make sure match_no is the destination.  */
if|if
condition|(
name|recog_data
operator|.
name|operand
index|[
name|match_no
index|]
operator|!=
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|src
operator|&&
name|fixup_match_2
argument_list|(
name|insn
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|regmove_dump_file
argument_list|)
condition|)
break|break;
continue|continue;
block|}
name|src_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|dst_class
operator|=
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regclass_compatible_p
argument_list|(
name|src_class
argument_list|,
name|dst_class
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Can not modify an earlier insn to set dst if this insn 		 uses an old value in the source.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|src_note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* If src is set once in a different basic block, 		 and is set equal to a constant, then do not use 		 it for this optimization, as this would make it 		 no longer equivalent to a constant.  */
if|if
condition|(
name|reg_is_remote_constant_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|src
expr_stmt|;
name|copy_dst
operator|=
name|dst
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Could fix operand %d of insn %d matching operand %d.\n"
argument_list|,
name|op_no
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_no
argument_list|)
expr_stmt|;
comment|/* Scan backward to find the first instruction that uses 		 the input operand.  If the operand is set here, then 		 replace it in both instructions with match_no.  */
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|rtx
name|pset
decl_stmt|;
comment|/* ??? We can't scan past the end of a basic block without 		     updating the register lifetime info 		     (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|p
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|length
operator|++
expr_stmt|;
comment|/* ??? See if all of SRC is set in P.  This test is much 		     more conservative than it needs to be.  */
name|pset
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|&&
name|SET_DEST
argument_list|(
name|pset
argument_list|)
operator|==
name|src
condition|)
block|{
comment|/* We use validate_replace_rtx, in case there 			 are multiple identical source operands.  All of 			 them have to be changed at the same time.  */
if|if
condition|(
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|validate_change
argument_list|(
name|p
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|pset
argument_list|)
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
name|success
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Change all source operands back. 				 This modifies the dst as a side-effect.  */
name|validate_replace_rtx
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Now make sure the dst is right.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|match_no
index|]
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* If we have passed a call instruction, and the 		     pseudo-reg DST is not already live across a call, 		     then don't perform the optimization.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|num_calls
operator|++
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
block|{
name|int
name|dstno
decl_stmt|,
name|srcno
decl_stmt|;
comment|/* Remove the death note for SRC from INSN.  */
name|remove_note
argument_list|(
name|insn
argument_list|,
name|src_note
argument_list|)
expr_stmt|;
comment|/* Move the death note for SRC to P if it is used 		     there.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|src_note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|src_note
expr_stmt|;
block|}
comment|/* If there is a REG_DEAD note for DST on P, then remove 		     it, because DST is now set there.  */
if|if
condition|(
operator|(
name|dst_note
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dst
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|p
argument_list|,
name|dst_note
argument_list|)
expr_stmt|;
name|dstno
operator|=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|srcno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|dstno
argument_list|)
operator|++
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|srcno
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|dstno
argument_list|)
operator|+=
name|num_calls
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|srcno
argument_list|)
operator|-=
name|num_calls
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|dstno
argument_list|)
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|-=
name|length
expr_stmt|;
comment|/* REG_LIVE_LENGTH is only an approximation after 			 combine if sched is not run, so make sure that we 			 still have a reasonable value.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|<
literal|2
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|srcno
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Fixed operand %d of insn %d matching operand %d.\n"
argument_list|,
name|op_no
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_no
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we weren't able to replace any of the alternatives, try an 	     alternative appoach of copying the source to the destination.  */
if|if
condition|(
operator|!
name|success
operator|&&
name|copy_src
operator|!=
name|NULL_RTX
condition|)
name|copy_src_to_dest
argument_list|(
name|insn
argument_list|,
name|copy_src
argument_list|,
name|copy_dst
argument_list|,
name|old_max_uid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In fixup_match_1, some insns may have been inserted after basic block      ends.  Fix that here.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|end
init|=
name|BLOCK_END
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|end
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|new
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|!=
literal|0
operator|&&
name|INSN_UID
argument_list|(
name|next
argument_list|)
operator|>=
name|old_max_uid
operator|&&
operator|(
name|i
operator|==
name|n_basic_blocks
operator|-
literal|1
operator|||
name|BLOCK_HEAD
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|!=
name|next
operator|)
condition|)
name|new
operator|=
name|next
operator|,
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
name|done
label|:
comment|/* Clean up.  */
name|free
argument_list|(
name|regno_src_regno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regmove_bb_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if INSN's pattern has matching constraints for any operand.    Returns 0 if INSN can't be recognized, or if the alternative can't be    determined.     Initialize the info in MATCHP based on the constraints.  */
end_comment

begin_function
specifier|static
name|int
name|find_matches
parameter_list|(
name|insn
parameter_list|,
name|matchp
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|match
modifier|*
name|matchp
decl_stmt|;
block|{
name|int
name|likely_spilled
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|op_no
decl_stmt|;
name|int
name|any_matches
init|=
literal|0
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Must initialize this before main loop, because the code for      the commutative case may set matches for operands other than      the current one.  */
for|for
control|(
name|op_no
operator|=
name|recog_data
operator|.
name|n_operands
init|;
operator|--
name|op_no
operator|>=
literal|0
condition|;
control|)
name|matchp
operator|->
name|with
index|[
name|op_no
index|]
operator|=
name|matchp
operator|->
name|commutative
index|[
name|op_no
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|op_no
operator|=
literal|0
init|;
name|op_no
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|op_no
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|recog_data
operator|.
name|constraints
index|[
name|op_no
index|]
expr_stmt|;
name|likely_spilled
index|[
name|op_no
index|]
operator|=
literal|0
expr_stmt|;
name|matchp
operator|->
name|use
index|[
name|op_no
index|]
operator|=
name|READ
expr_stmt|;
name|matchp
operator|->
name|early_clobber
index|[
name|op_no
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
name|matchp
operator|->
name|use
index|[
name|op_no
index|]
operator|=
name|WRITE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|matchp
operator|->
name|use
index|[
name|op_no
index|]
operator|=
name|READWRITE
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|i
operator|<
name|which_alternative
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
break|break;
case|case
literal|'+'
case|:
break|break;
case|case
literal|'&'
case|:
name|matchp
operator|->
name|early_clobber
index|[
name|op_no
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|matchp
operator|->
name|commutative
index|[
name|op_no
index|]
operator|=
name|op_no
operator|+
literal|1
expr_stmt|;
name|matchp
operator|->
name|commutative
index|[
name|op_no
operator|+
literal|1
index|]
operator|=
name|op_no
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|match_ul
init|=
name|strtoul
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|match
init|=
name|match_ul
decl_stmt|;
name|p
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|match
operator|<
name|op_no
operator|&&
name|likely_spilled
index|[
name|match
index|]
condition|)
break|break;
name|matchp
operator|->
name|with
index|[
name|op_no
index|]
operator|=
name|match
expr_stmt|;
name|any_matches
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|matchp
operator|->
name|commutative
index|[
name|op_no
index|]
operator|>=
literal|0
condition|)
name|matchp
operator|->
name|with
index|[
name|matchp
operator|->
name|commutative
index|[
name|op_no
index|]
index|]
operator|=
name|match
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'h'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'W'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
if|if
condition|(
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
argument_list|)
condition|)
name|likely_spilled
index|[
name|op_no
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|any_matches
return|;
block|}
end_function

begin_comment
comment|/* Try to replace all occurrences of DST_REG with SRC in LOC, that is    assumed to be in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|replace_in_call_usage
parameter_list|(
name|loc
parameter_list|,
name|dst_reg
parameter_list|,
name|src
parameter_list|,
name|insn
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|int
name|dst_reg
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|dst_reg
condition|)
return|return;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process each of our operands recursively.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
name|replace_in_call_usage
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|dst_reg
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_in_call_usage
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|dst_reg
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to replace output operand DST in SET, with input operand SRC.  SET is    the only set in INSN.  INSN has just been recognized and constrained.    SRC is operand number OPERAND_NUMBER in INSN.    DST is operand number MATCH_NUMBER in INSN.    If BACKWARD is nonzero, we have been called in a backward pass.    Return nonzero for success.  */
end_comment

begin_function
specifier|static
name|int
name|fixup_match_1
parameter_list|(
name|insn
parameter_list|,
name|set
parameter_list|,
name|src
parameter_list|,
name|src_subreg
parameter_list|,
name|dst
parameter_list|,
name|backward
parameter_list|,
name|operand_number
parameter_list|,
name|match_number
parameter_list|,
name|regmove_dump_file
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|,
name|src
decl_stmt|,
name|src_subreg
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|backward
decl_stmt|,
name|operand_number
decl_stmt|,
name|match_number
decl_stmt|;
name|FILE
modifier|*
name|regmove_dump_file
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|post_inc
init|=
literal|0
decl_stmt|,
name|post_inc_set
init|=
literal|0
decl_stmt|,
name|search_end
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|num_calls
init|=
literal|0
decl_stmt|,
name|s_num_calls
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|NOTE
decl_stmt|;
name|HOST_WIDE_INT
name|insn_const
init|=
literal|0
decl_stmt|,
name|newconst
decl_stmt|;
name|rtx
name|overlap
init|=
literal|0
decl_stmt|;
comment|/* need to move insn ? */
name|rtx
name|src_note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
decl_stmt|,
name|dst_note
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|length
decl_stmt|,
name|s_length
decl_stmt|;
comment|/* If SRC is marked as unchanging, we may not change it.      ??? Maybe we could get better code by removing the unchanging bit      instead, and changing it back if we don't succeed?  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|src_note
condition|)
block|{
comment|/* Look for (set (regX) (op regA constX)) 		  (set (regY) (op regA constY)) 	 and change that to 		  (set (regA) (op regA constX)). 		  (set (regY) (op regA constY-constX)). 	 This works for add and shift operations, if 	 regA is dead after or set by the second insn.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|src
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|insn_const
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|stable_and_no_regs_but_for_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
comment|/* We might find a src_note while scanning.  */
name|code
operator|=
name|NOTE
expr_stmt|;
block|}
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Could fix operand %d of insn %d matching operand %d.\n"
argument_list|,
name|operand_number
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_number
argument_list|)
expr_stmt|;
comment|/* If SRC is equivalent to a constant set in a different basic block,      then do not use it for this optimization.  We want the equivalence      so that if we have to reload this register, we can reload the      constant, rather than extending the lifespan of the register.  */
if|if
condition|(
name|reg_is_remote_constant_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|get_insns
argument_list|()
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Scan forward to find the next instruction that      uses the output operand.  If the operand dies here,      then replace it in both instructions with      operand_number.  */
for|for
control|(
name|length
operator|=
name|s_length
operator|=
literal|0
operator|,
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|replace_in_call_usage
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|,
name|src
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* ??? We can't scan past the end of a basic block without updating 	 the register lifetime info (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|p
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|src_note
condition|)
name|s_length
operator|++
expr_stmt|;
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|p
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* See if all of DST dies in P.  This test is 	 slightly more conservative than it needs to be.  */
if|if
condition|(
operator|(
name|dst_note
operator|=
name|find_regno_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
block|{
comment|/* If we would be moving INSN, check that we won't move it 	     into the shadow of a live a live flags register.  */
comment|/* ??? We only try to move it in front of P, although 		 we could move it anywhere between OVERLAP and P.  */
if|if
condition|(
name|overlap
operator|&&
name|GET_MODE
argument_list|(
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
break|break;
if|if
condition|(
operator|!
name|src_note
condition|)
block|{
name|rtx
name|q
decl_stmt|;
name|rtx
name|set2
init|=
name|NULL_RTX
decl_stmt|;
comment|/* If an optimization is done, the value of SRC while P 		 is executed will be changed.  Check that this is OK.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
block|{
comment|/* ??? We can't scan past the end of a basic block without 		     updating the register lifetime info 		     (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|q
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|q
condition|)
name|set2
operator|=
name|single_set
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|||
operator|!
name|set2
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|!=
name|code
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|src
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
operator|!=
name|src
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|q
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is a PLUS, we can still save a register by doing 		     src += insn_const; 		     P; 		     src -= insn_const; . 		     This also gives opportunities for subsequent 		     optimizations in the backward pass, so do it there.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|backward
comment|/* Don't do this if we can likely tie DST to SET_DEST 			 of P later; we can't do this tying here if we got a 			 hard register.  */
operator|&&
operator|!
operator|(
name|dst_note
operator|&&
operator|!
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|&&
name|single_set
argument_list|(
name|p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|single_set
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|single_set
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
comment|/* We may only emit an insn directly after P if we 			 are not in the shadow of a live flags register.  */
operator|&&
name|GET_MODE
argument_list|(
name|p
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|search_end
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|insn
expr_stmt|;
name|set2
operator|=
name|set
expr_stmt|;
name|newconst
operator|=
operator|-
name|insn_const
expr_stmt|;
name|code
operator|=
name|MINUS
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
block|{
name|newconst
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|insn_const
expr_stmt|;
comment|/* Reject out of range shifts.  */
if|if
condition|(
name|code
operator|!=
name|PLUS
operator|&&
operator|(
name|newconst
operator|<
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|newconst
operator|>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
block|{
name|post_inc
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
operator|!=
name|src
condition|)
name|post_inc_set
operator|=
name|set2
expr_stmt|;
block|}
block|}
comment|/* We use 1 as last argument to validate_change so that all 		 changes are accepted or rejected together by apply_change_group 		 when it is called by validate_replace_rtx .  */
name|validate_change
argument_list|(
name|q
argument_list|,
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|newconst
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|match_number
index|]
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_replace_rtx
argument_list|(
name|dst
argument_list|,
name|src_subreg
argument_list|,
name|p
argument_list|)
condition|)
name|success
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|src_note
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
comment|/* INSN was already checked to be movable wrt. the registers that it 	     sets / uses when we found no REG_DEAD note for src on it, but it 	     still might clobber the flags register.  We'll have to check that 	     we won't insert it into the shadow of a live flags register when 	     we finally know where we are to move it.  */
name|overlap
operator|=
name|p
expr_stmt|;
name|src_note
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* If we have passed a call instruction, and the pseudo-reg SRC is not 	 already live across a call, then don't perform the optimization.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|num_calls
operator|++
expr_stmt|;
if|if
condition|(
name|src_note
condition|)
name|s_num_calls
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
return|return
literal|0
return|;
comment|/* Remove the death note for DST from P.  */
name|remove_note
argument_list|(
name|p
argument_list|,
name|dst_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
block|{
name|post_inc
operator|=
name|emit_insn_after
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|HAVE_PRE_INCREMENT
operator|||
name|HAVE_PRE_DECREMENT
operator|)
operator|&&
name|search_end
operator|&&
name|try_auto_increment
argument_list|(
name|search_end
argument_list|,
name|post_inc
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|newconst
argument_list|,
literal|1
argument_list|)
condition|)
name|post_inc
operator|=
literal|0
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|insn_const
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|overlap
condition|)
block|{
comment|/* The lifetime of src and dest overlap, 	 but we can change this by moving insn.  */
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_note
condition|)
name|remove_note
argument_list|(
name|overlap
argument_list|,
name|src_note
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|HAVE_POST_INCREMENT
operator|||
name|HAVE_POST_DECREMENT
operator|)
operator|&&
name|code
operator|==
name|PLUS
operator|&&
name|try_auto_increment
argument_list|(
name|overlap
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|insn_const
argument_list|,
literal|0
argument_list|)
condition|)
name|insn
operator|=
name|overlap
expr_stmt|;
else|else
block|{
name|rtx
name|notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|emit_insn_after_with_line_notes
argument_list|(
name|pat
argument_list|,
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* emit_insn_after_with_line_notes has no 	     return value, so search for the new insn.  */
name|insn
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|!=
name|pat
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|notes
expr_stmt|;
block|}
block|}
comment|/* Sometimes we'd generate src = const; src += n;      if so, replace the instruction that set src      in the first place.  */
if|if
condition|(
operator|!
name|overlap
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|q
decl_stmt|,
name|set2
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|num_calls2
init|=
literal|0
decl_stmt|,
name|s_length2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|q
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|q
condition|;
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
control|)
block|{
comment|/* ??? We can't scan past the end of a basic block without 		 updating the register lifetime info 		 (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|q
argument_list|)
condition|)
continue|continue;
name|s_length2
operator|++
expr_stmt|;
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|set2
operator|=
name|single_set
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|num_calls2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|&&
name|set2
operator|&&
name|SET_DEST
argument_list|(
name|set2
argument_list|)
operator|==
name|src
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|delete_insn
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|-=
name|num_calls2
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|-=
name|s_length2
expr_stmt|;
name|insn_const
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|HAVE_PRE_INCREMENT
operator|||
name|HAVE_PRE_DECREMENT
operator|)
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|insn_const
operator|&&
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|insn_const
argument_list|,
literal|1
argument_list|)
condition|)
name|insn
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|HAVE_POST_INCREMENT
operator|||
name|HAVE_POST_DECREMENT
operator|)
operator|&&
name|post_inc
operator|&&
name|try_auto_increment
argument_list|(
name|p
argument_list|,
name|post_inc
argument_list|,
name|post_inc_set
argument_list|,
name|src
argument_list|,
name|newconst
argument_list|,
literal|0
argument_list|)
condition|)
name|post_inc
operator|=
literal|0
expr_stmt|;
comment|/* If post_inc still prevails, try to find an      insn where it can be used as a pre-in/decrement.      If code is MINUS, this was already tried.  */
if|if
condition|(
name|post_inc
operator|&&
name|code
operator|==
name|PLUS
comment|/* Check that newconst is likely to be usable      in a pre-in/decrement before starting the search.  */
operator|&&
operator|(
operator|(
name|HAVE_PRE_INCREMENT
operator|&&
name|newconst
operator|>
literal|0
operator|&&
name|newconst
operator|<=
name|MOVE_MAX
operator|)
operator|||
operator|(
name|HAVE_PRE_DECREMENT
operator|&&
name|newconst
operator|<
literal|0
operator|&&
name|newconst
operator|>=
operator|-
name|MOVE_MAX
operator|)
operator|)
operator|&&
name|exact_log2
argument_list|(
name|newconst
argument_list|)
condition|)
block|{
name|rtx
name|q
decl_stmt|,
name|inc_dest
decl_stmt|;
name|inc_dest
operator|=
name|post_inc_set
condition|?
name|SET_DEST
argument_list|(
name|post_inc_set
argument_list|)
else|:
name|src
expr_stmt|;
for|for
control|(
name|q
operator|=
name|post_inc
init|;
operator|(
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
operator|)
condition|;
control|)
block|{
comment|/* ??? We can't scan past the end of a basic block without updating 	     the register lifetime info 	     (REG_DEAD/basic_block_live_at_start).  */
if|if
condition|(
name|perhaps_ends_bb_p
argument_list|(
name|q
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|q
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|src
operator|!=
name|inc_dest
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|q
argument_list|)
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|inc_dest
argument_list|,
name|q
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|inc_dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
name|try_auto_increment
argument_list|(
name|q
argument_list|,
name|post_inc
argument_list|,
name|post_inc_set
argument_list|,
name|inc_dest
argument_list|,
name|newconst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Move the death note for DST to INSN if it is used      there.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|dst_note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|dst_note
expr_stmt|;
block|}
if|if
condition|(
name|src_note
condition|)
block|{
comment|/* Move the death note for SRC from INSN to P.  */
if|if
condition|(
operator|!
name|overlap
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|src_note
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src_note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|src_note
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|+=
name|s_num_calls
expr_stmt|;
block|}
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|-=
name|num_calls
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|+=
name|s_length
expr_stmt|;
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|-=
name|length
expr_stmt|;
comment|/* REG_LIVE_LENGTH is only an approximation after 	 combine if sched is not run, so make sure that we 	 still have a reasonable value.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|<
literal|2
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|regmove_dump_file
condition|)
name|fprintf
argument_list|(
name|regmove_dump_file
argument_list|,
literal|"Fixed operand %d of insn %d matching operand %d.\n"
argument_list|,
name|operand_number
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|match_number
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* return nonzero if X is stable and mentions no regsiters but for    mentioning SRC or mentioning / changing DST .  If in doubt, presume    it is unstable.    The rationale is that we want to check if we can move an insn easily    while just paying attention to SRC and DST.  A register is considered    stable if it has the RTX_UNCHANGING_P bit set, but that would still    leave the burden to update REG_DEAD / REG_UNUSED notes, so we don't    want any registers but SRC and DST.  */
end_comment

begin_function
specifier|static
name|int
name|stable_and_no_regs_but_for_p
parameter_list|(
name|x
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'<'
case|:
case|case
literal|'1'
case|:
case|case
literal|'c'
case|:
case|case
literal|'2'
case|:
case|case
literal|'b'
case|:
case|case
literal|'3'
case|:
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
operator|!
name|stable_and_no_regs_but_for_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
case|case
literal|'o'
case|:
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
name|x
operator|==
name|src
operator|||
name|x
operator|==
name|dst
return|;
comment|/* If this is a MEM, look inside - there might be a register hidden in 	 the address of an unchanging MEM.  */
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
operator|!
name|stable_and_no_regs_but_for_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* fall through */
default|default:
return|return
operator|!
name|rtx_unstable_p
argument_list|(
name|x
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Track stack adjustments and stack memory references.  Attempt to    reduce the number of stack adjustments by back-propagating across    the memory references.     This is intended primarily for use with targets that do not define    ACCUMULATE_OUTGOING_ARGS.  It is of significantly more value to    targets that define PREFERRED_STACK_BOUNDARY more aligned than    STACK_BOUNDARY (e.g. x86), or if not all registers can be pushed    (e.g. x86 fp regs) which would ordinarily have to be implemented    as a sub/mov pair due to restrictions in calls.c.     Propagation stops when any of the insns that need adjusting are    (a) no longer valid because we've exceeded their range, (b) a    non-trivial push instruction, or (c) a call instruction.     Restriction B is based on the assumption that push instructions    are smaller or faster.  If a port really wants to remove all    pushes, it should have defined ACCUMULATE_OUTGOING_ARGS.  The    one exception that is made is for an add immediately followed    by a push.  */
end_comment

begin_comment
comment|/* This structure records stack memory references between stack adjusting    instructions.  */
end_comment

begin_struct
struct|struct
name|csa_memlist
block|{
name|HOST_WIDE_INT
name|sp_offset
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
modifier|*
name|mem
decl_stmt|;
name|struct
name|csa_memlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|stack_memref_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|single_set_for_csa
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_csa_memlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|csa_memlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|csa_memlist
modifier|*
name|record_one_stack_memref
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
expr|struct
name|csa_memlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_apply_stack_adjustment
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|csa_memlist
operator|*
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine_stack_adjustments_for_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|record_stack_memrefs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main entry point for stack adjustment combination.  */
end_comment

begin_function
name|void
name|combine_stack_adjustments
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
name|combine_stack_adjustments_for_block
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recognize a MEM of the form (sp) or (plus sp const).  */
end_comment

begin_function
specifier|static
name|int
name|stack_memref_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|stack_pointer_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Recognize either normal single_set or the hack in i386.md for    tying fp and sp adjustments.  */
end_comment

begin_function
specifier|static
name|rtx
name|single_set_for_csa
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|tmp
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|PARALLEL
condition|)
return|return
name|NULL_RTX
return|;
name|tmp
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|NULL_RTX
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|this
init|=
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* The special case is allowing a no-op set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|this
argument_list|)
operator|==
name|SET
operator|&&
name|SET_SRC
argument_list|(
name|this
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|this
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|this
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|this
argument_list|)
operator|!=
name|USE
condition|)
return|return
name|NULL_RTX
return|;
block|}
return|return
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free the list of csa_memlist nodes.  */
end_comment

begin_function
specifier|static
name|void
name|free_csa_memlist
parameter_list|(
name|memlist
parameter_list|)
name|struct
name|csa_memlist
modifier|*
name|memlist
decl_stmt|;
block|{
name|struct
name|csa_memlist
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|memlist
condition|;
name|memlist
operator|=
name|next
control|)
block|{
name|next
operator|=
name|memlist
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|memlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new csa_memlist node from the given memory reference.    It is already known that the memory is stack_memref_p.  */
end_comment

begin_function
specifier|static
name|struct
name|csa_memlist
modifier|*
name|record_one_stack_memref
parameter_list|(
name|insn
parameter_list|,
name|mem
parameter_list|,
name|next_memlist
parameter_list|)
name|rtx
name|insn
decl_stmt|,
decl|*
name|mem
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|csa_memlist
modifier|*
name|next_memlist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|csa_memlist
modifier|*
name|ml
decl_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|csa_memlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ml
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|mem
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|ml
operator|->
name|sp_offset
operator|=
literal|0
expr_stmt|;
else|else
name|ml
operator|->
name|sp_offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|ml
operator|->
name|mem
operator|=
name|mem
expr_stmt|;
name|ml
operator|->
name|next
operator|=
name|next_memlist
expr_stmt|;
return|return
name|ml
return|;
block|}
end_block

begin_comment
comment|/* Attempt to apply ADJUST to the stack adjusting insn INSN, as well    as each of the memories in MEMLIST.  Return true on success.  */
end_comment

begin_function
specifier|static
name|int
name|try_apply_stack_adjustment
parameter_list|(
name|insn
parameter_list|,
name|memlist
parameter_list|,
name|new_adjust
parameter_list|,
name|delta
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|csa_memlist
modifier|*
name|memlist
decl_stmt|;
name|HOST_WIDE_INT
name|new_adjust
decl_stmt|,
name|delta
decl_stmt|;
block|{
name|struct
name|csa_memlist
modifier|*
name|ml
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|set
operator|=
name|single_set_for_csa
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|new_adjust
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|memlist
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
name|validate_change
argument_list|(
name|ml
operator|->
name|insn
argument_list|,
name|ml
operator|->
name|mem
argument_list|,
name|replace_equiv_address_nv
argument_list|(
operator|*
name|ml
operator|->
name|mem
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|ml
operator|->
name|sp_offset
operator|-
name|delta
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
comment|/* Succeeded.  Update our knowledge of the memory references.  */
for|for
control|(
name|ml
operator|=
name|memlist
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
name|ml
operator|->
name|sp_offset
operator|-=
name|delta
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called via for_each_rtx and used to record all stack memory references in    the insn and discard all other stack pointer references.  */
end_comment

begin_struct
struct|struct
name|record_stack_memrefs_data
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|csa_memlist
modifier|*
name|memlist
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|record_stack_memrefs
parameter_list|(
name|xp
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|xp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
name|struct
name|record_stack_memrefs_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|record_stack_memrefs_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|x
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We are not able to handle correctly all possible memrefs containing          stack pointer, so this check is necessary.  */
if|if
condition|(
name|stack_memref_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|d
operator|->
name|memlist
operator|=
name|record_one_stack_memref
argument_list|(
name|d
operator|->
name|insn
argument_list|,
name|xp
argument_list|,
name|d
operator|->
name|memlist
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
case|case
name|REG
case|:
comment|/* ??? We want be able to handle non-memory stack pointer 	 references later.  For now just discard all insns refering to 	 stack pointer outside mem expressions.  We would probably 	 want to teach validate_replace to simplify expressions first.  	 We can't just compare with STACK_POINTER_RTX because the 	 reference to the stack pointer might be in some other mode. 	 In particular, an explict clobber in an asm statement will 	 result in a QImode clober.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of combine_stack_adjustments, called for each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|combine_stack_adjustments_for_block
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|last_sp_adjust
init|=
literal|0
decl_stmt|;
name|rtx
name|last_sp_set
init|=
name|NULL_RTX
decl_stmt|;
name|struct
name|csa_memlist
modifier|*
name|memlist
init|=
name|NULL
decl_stmt|;
name|rtx
name|pending_delete
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|struct
name|record_stack_memrefs_data
name|data
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
decl_stmt|;
name|pending_delete
operator|=
name|NULL_RTX
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|processed
goto|;
name|set
operator|=
name|single_set_for_csa
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
comment|/* Find constant additions to the stack pointer.  */
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|this_adjust
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we've not seen an adjustment previously, record 		 it now and continue.  */
if|if
condition|(
operator|!
name|last_sp_set
condition|)
block|{
name|last_sp_set
operator|=
name|insn
expr_stmt|;
name|last_sp_adjust
operator|=
name|this_adjust
expr_stmt|;
goto|goto
name|processed
goto|;
block|}
comment|/* If not all recorded memrefs can be adjusted, or the 		 adjustment is now too large for a constant addition, 		 we cannot merge the two stack adjustments.  		 Also we need to be carefull to not move stack pointer 		 such that we create stack accesses outside the allocated 		 area.  We can combine an allocation into the first insn, 		 or a deallocation into the second insn.  We can not 		 combine an allocation followed by a deallocation.  		 The only somewhat frequent occurrence of the later is when 		 a function allocates a stack frame but does not use it. 		 For this case, we would need to analyze rtl stream to be 		 sure that allocated area is really unused.  This means not 		 only checking the memory references, but also all registers 		 or global memory references possibly containing a stack 		 frame address.  		 Perhaps the best way to address this problem is to teach 		 gcc not to allocate stack for objects never used.  */
comment|/* Combine an allocation into the first instruction.  */
if|if
condition|(
name|STACK_GROWS_DOWNWARD
condition|?
name|this_adjust
operator|<=
literal|0
else|:
name|this_adjust
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|try_apply_stack_adjustment
argument_list|(
name|last_sp_set
argument_list|,
name|memlist
argument_list|,
name|last_sp_adjust
operator|+
name|this_adjust
argument_list|,
name|this_adjust
argument_list|)
condition|)
block|{
comment|/* It worked!  */
name|pending_delete
operator|=
name|insn
expr_stmt|;
name|last_sp_adjust
operator|+=
name|this_adjust
expr_stmt|;
goto|goto
name|processed
goto|;
block|}
block|}
comment|/* Otherwise we have a deallocation.  Do not combine with 		 a previous allocation.  Combine into the second insn.  */
elseif|else
if|if
condition|(
name|STACK_GROWS_DOWNWARD
condition|?
name|last_sp_adjust
operator|>=
literal|0
else|:
name|last_sp_adjust
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|try_apply_stack_adjustment
argument_list|(
name|insn
argument_list|,
name|memlist
argument_list|,
name|last_sp_adjust
operator|+
name|this_adjust
argument_list|,
operator|-
name|last_sp_adjust
argument_list|)
condition|)
block|{
comment|/* It worked!  */
name|delete_insn
argument_list|(
name|last_sp_set
argument_list|)
expr_stmt|;
name|last_sp_set
operator|=
name|insn
expr_stmt|;
name|last_sp_adjust
operator|+=
name|this_adjust
expr_stmt|;
name|free_csa_memlist
argument_list|(
name|memlist
argument_list|)
expr_stmt|;
name|memlist
operator|=
name|NULL
expr_stmt|;
goto|goto
name|processed
goto|;
block|}
block|}
comment|/* Combination failed.  Restart processing from here.  */
name|free_csa_memlist
argument_list|(
name|memlist
argument_list|)
expr_stmt|;
name|memlist
operator|=
name|NULL
expr_stmt|;
name|last_sp_set
operator|=
name|insn
expr_stmt|;
name|last_sp_adjust
operator|=
name|this_adjust
expr_stmt|;
goto|goto
name|processed
goto|;
block|}
comment|/* Find a predecrement of exactly the previous adjustment and 	     turn it into a direct store.  Obviously we can't do this if 	     there were any intervening uses of the stack pointer.  */
if|if
condition|(
name|memlist
operator|==
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|&&
operator|(
name|last_sp_adjust
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_MODIFY
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|last_sp_adjust
operator|)
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|src
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|replace_equiv_address
argument_list|(
name|dest
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_sp_set
operator|==
name|bb
operator|->
name|head
condition|)
name|bb
operator|->
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|last_sp_set
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|last_sp_set
argument_list|)
expr_stmt|;
name|free_csa_memlist
argument_list|(
name|memlist
argument_list|)
expr_stmt|;
name|memlist
operator|=
name|NULL
expr_stmt|;
name|last_sp_set
operator|=
name|NULL_RTX
expr_stmt|;
name|last_sp_adjust
operator|=
literal|0
expr_stmt|;
goto|goto
name|processed
goto|;
block|}
block|}
name|data
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|data
operator|.
name|memlist
operator|=
name|memlist
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|last_sp_set
operator|&&
operator|!
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_stack_memrefs
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
name|memlist
operator|=
name|data
operator|.
name|memlist
expr_stmt|;
goto|goto
name|processed
goto|;
block|}
name|memlist
operator|=
name|data
operator|.
name|memlist
expr_stmt|;
comment|/* Otherwise, we were not able to process the instruction. 	 Do not continue collecting data across such a one.  */
if|if
condition|(
name|last_sp_set
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free_csa_memlist
argument_list|(
name|memlist
argument_list|)
expr_stmt|;
name|memlist
operator|=
name|NULL
expr_stmt|;
name|last_sp_set
operator|=
name|NULL_RTX
expr_stmt|;
name|last_sp_adjust
operator|=
literal|0
expr_stmt|;
block|}
name|processed
label|:
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
if|if
condition|(
name|pending_delete
condition|)
name|delete_insn
argument_list|(
name|pending_delete
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending_delete
condition|)
name|delete_insn
argument_list|(
name|pending_delete
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

