begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph manipulation code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains low level functions to manipulate the CFG and analyze it    that are aware of the RTL intermediate language.     Available functionality:      - CFG-aware instruction chain manipulation 	 delete_insn, delete_insn_chain      - Basic block manipulation 	 create_basic_block, flow_delete_block, split_block, 	 merge_blocks_nomove      - Infrastructure to determine quickly basic block for insn 	 compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,      - Edge redirection with updating and optimizing of insn chain 	 block_label, redirect_edge_and_branch, 	 redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru      - Edge splitting and commiting to edges 	 split_edge, insert_insn_on_edge, commit_edge_insertions      - Dumping and debugging 	 print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n      - Consistency checking 	 verify_flow_info      - CFG updating after constant propagation 	 purge_dead_edges, purge_all_dead_edges   */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Stubs in case we don't have a return insn.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_return
end_ifndef

begin_define
define|#
directive|define
name|HAVE_return
value|0
end_define

begin_define
define|#
directive|define
name|gen_return
parameter_list|()
value|NULL_RTX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The basic block structure for every insn, indexed by uid.  */
end_comment

begin_decl_stmt
name|varray_type
name|basic_block_for_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */
end_comment

begin_comment
comment|/* ??? Should probably be using LABEL_NUSES instead.  It would take a    bit of surgery to be able to use or co-opt the routines in jump.  */
end_comment

begin_decl_stmt
name|rtx
name|label_value_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|tail_recursion_label_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_delete_note_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_delete_label_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|commit_one_edge_insertion
name|PARAMS
argument_list|(
operator|(
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|try_redirect_by_replacing_jump
name|PARAMS
argument_list|(
operator|(
name|edge
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|last_loop_beg_note
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|back_edge_of_syntactic_loop_p
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|force_nonfallthru_and_redirect
name|PARAMS
argument_list|(
operator|(
name|edge
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return true if NOTE is not one of the ones that must be kept paired,    so that we may simply delete it.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_note_p
parameter_list|(
name|note
parameter_list|)
name|rtx
name|note
decl_stmt|;
block|{
return|return
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True if a given label can be deleted.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_label_p
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|LABEL_PRESERVE_P
argument_list|(
name|label
argument_list|)
comment|/* User declared labels must be preserved.  */
operator|&&
name|LABEL_NAME
argument_list|(
name|label
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|in_expr_list_p
argument_list|(
name|forced_labels
argument_list|,
name|label
argument_list|)
operator|&&
operator|!
name|in_expr_list_p
argument_list|(
name|label_value_list
argument_list|,
name|label
argument_list|)
operator|&&
operator|!
name|in_expr_list_p
argument_list|(
name|exception_handler_labels
argument_list|,
name|label
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete INSN by patching it out.  Return the next insn.  */
end_comment

begin_function
name|rtx
name|delete_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|bool
name|really_delete
init|=
name|true
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* Some labels can't be directly removed from the INSN chain, as they          might be references via variables, constant pool etc.           Convert them to the special NOTE_INSN_DELETED_LABEL note.  */
if|if
condition|(
operator|!
name|can_delete_label_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|really_delete
operator|=
name|false
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED_LABEL
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
name|remove_node_from_expr_list
argument_list|(
name|insn
argument_list|,
operator|&
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|really_delete
condition|)
block|{
comment|/* If this insn has already been deleted, something is very wrong.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If deleting a jump, decrement the use count of the label.  Deleting      the label itself should happen in the normal course of block merging.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|--
expr_stmt|;
comment|/* Also if deleting an insn that references a label.  */
elseif|else
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|--
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* When deleting code in bulk (e.g. removing many unreachable 	     blocks) we can delete a label that's a target of the vector 	     before deleting the vector itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|NOTE
condition|)
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|--
expr_stmt|;
block|}
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Unlink a chain of insns between START and FINISH, leaving notes    that must be paired.  */
end_comment

begin_function
name|void
name|delete_insn_chain
parameter_list|(
name|start
parameter_list|,
name|finish
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|finish
decl_stmt|;
block|{
name|rtx
name|next
decl_stmt|;
comment|/* Unchain the insns one by one.  It would be quicker to delete all of these      with a single unchaining, rather than one at a time, but we need to keep      the NOTE's.  */
while|while
condition|(
literal|1
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|NOTE
operator|&&
operator|!
name|can_delete_note_p
argument_list|(
name|start
argument_list|)
condition|)
empty_stmt|;
else|else
name|next
operator|=
name|delete_insn
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|finish
condition|)
break|break;
name|start
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new basic block consisting of the instructions between HEAD and END    inclusive.  This function is designed to allow fast BB construction - reuses    the note and basic block struct in BB_NOTE, if any and do not grow    BASIC_BLOCK chain and should be used directly only by CFG construction code.    END can be NULL in to create new empty basic block before HEAD.  Both END    and HEAD can be NULL to create basic block at the end of INSN chain.  */
end_comment

begin_function
name|basic_block
name|create_basic_block_structure
parameter_list|(
name|index
parameter_list|,
name|head
parameter_list|,
name|end
parameter_list|,
name|bb_note
parameter_list|)
name|int
name|index
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|end
decl_stmt|,
name|bb_note
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|bb_note
operator|&&
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|bb_note
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bb
operator|->
name|aux
operator|==
name|NULL
condition|)
block|{
comment|/* If we found an existing note, thread it back onto the chain.  */
name|rtx
name|after
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|after
operator|=
name|head
expr_stmt|;
else|else
block|{
name|after
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
block|}
if|if
condition|(
name|after
operator|!=
name|bb_note
operator|&&
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|!=
name|bb_note
condition|)
name|reorder_insns
argument_list|(
name|bb_note
argument_list|,
name|bb_note
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise we must create a note and a basic block structure.  */
name|bb
operator|=
name|alloc_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|head
operator|&&
operator|!
name|end
condition|)
name|head
operator|=
name|end
operator|=
name|bb_note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|end
condition|)
block|{
name|bb_note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|end
condition|)
name|end
operator|=
name|bb_note
expr_stmt|;
block|}
else|else
block|{
name|bb_note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|end
operator|=
name|head
expr_stmt|;
block|}
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
comment|/* Always include the bb note in the block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
operator|==
name|bb_note
condition|)
name|end
operator|=
name|bb_note
expr_stmt|;
name|bb
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|bb
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|index
argument_list|)
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|basic_block_for_insn
condition|)
name|update_bb_for_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Tag the block so that we know it has been used when considering      other basic block notes.  */
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Create new basic block consisting of instructions in between HEAD and END    and place it to the BB chain at position INDEX.  END can be NULL in to    create new empty basic block before HEAD.  Both END and HEAD can be NULL to    create basic block at the end of INSN chain.  */
end_comment

begin_function
name|basic_block
name|create_basic_block
parameter_list|(
name|index
parameter_list|,
name|head
parameter_list|,
name|end
parameter_list|)
name|int
name|index
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|end
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Place the new block just after the block being split.  */
name|VARRAY_GROW
argument_list|(
name|basic_block_info
argument_list|,
operator|++
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Some parts of the compiler expect blocks to be number in      sequential order so insert the new block immediately after the      block being split..  */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>
name|index
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|tmp
init|=
name|BASIC_BLOCK
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
name|bb
operator|=
name|create_basic_block_structure
argument_list|(
name|index
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete the insns in a (non-live) block.  We physically delete every    non-deleted-note insn, and update the flow graph appropriately.     Return nonzero if we deleted an exception handler.  */
end_comment

begin_comment
comment|/* ??? Preserving all such notes strikes me as wrong.  It would be nice    to post-process the stream to remove empty blocks, loops, ranges, etc.  */
end_comment

begin_function
name|int
name|flow_delete_block
parameter_list|(
name|b
parameter_list|)
name|basic_block
name|b
decl_stmt|;
block|{
name|int
name|deleted_handler
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|end
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* If the head of this block is a CODE_LABEL, then it might be the      label for an exception handler which can't be reached.       We need to remove the label from the exception_handler_label list      and remove the associated NOTE_INSN_EH_REGION_BEG and      NOTE_INSN_EH_REGION_END notes.  */
name|insn
operator|=
name|b
operator|->
name|head
expr_stmt|;
name|never_reached_warning
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|maybe_remove_eh_handler
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Include any jump table following the basic block.  */
name|end
operator|=
name|b
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|end
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
comment|/* Include any barrier that may follow the basic block.  */
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|BARRIER
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
comment|/* Selectively delete the entire chain.  */
name|b
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|insn
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* Remove the edges into and out of this block.  Note that there may      indeed be edges in, if we are removing an unreachable loop.  */
while|while
condition|(
name|b
operator|->
name|pred
operator|!=
name|NULL
condition|)
name|remove_edge
argument_list|(
name|b
operator|->
name|pred
argument_list|)
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|succ
operator|!=
name|NULL
condition|)
name|remove_edge
argument_list|(
name|b
operator|->
name|succ
argument_list|)
expr_stmt|;
name|b
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
comment|/* Remove the basic block from the array, and compact behind it.  */
name|expunge_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|deleted_handler
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Records the basic block struct in BB_FOR_INSN, for every instruction    indexed by INSN_UID.  MAX is the size of the array.  */
end_comment

begin_function
name|void
name|compute_bb_for_insn
parameter_list|(
name|max
parameter_list|)
name|int
name|max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|basic_block_for_insn
condition|)
name|VARRAY_FREE
argument_list|(
name|basic_block_for_insn
argument_list|)
expr_stmt|;
name|VARRAY_BB_INIT
argument_list|(
name|basic_block_for_insn
argument_list|,
name|max
argument_list|,
literal|"basic_block_for_insn"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|end
init|=
name|bb
operator|->
name|end
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max
condition|)
name|VARRAY_BB
argument_list|(
name|basic_block_for_insn
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Release the basic_block_for_insn array.  */
end_comment

begin_function
name|void
name|free_bb_for_insn
parameter_list|()
block|{
if|if
condition|(
name|basic_block_for_insn
condition|)
name|VARRAY_FREE
argument_list|(
name|basic_block_for_insn
argument_list|)
expr_stmt|;
name|basic_block_for_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update insns block within BB.  */
end_comment

begin_function
name|void
name|update_bb_for_insn
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|basic_block_for_insn
condition|)
return|return;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Record INSN's block as BB.  */
end_comment

begin_function
name|void
name|set_block_for_insn
parameter_list|(
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|size_t
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|>=
name|basic_block_for_insn
operator|->
name|num_elements
condition|)
block|{
comment|/* Add one-eighth the size so we don't keep calling xrealloc.  */
name|size_t
name|new_size
init|=
name|uid
operator|+
operator|(
name|uid
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|VARRAY_GROW
argument_list|(
name|basic_block_for_insn
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
block|}
name|VARRAY_BB
argument_list|(
name|basic_block_for_insn
argument_list|,
name|uid
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a block BB after insn INSN creating a new fallthru edge.    Return the new edge.  Note that to keep other parts of the compiler happy,    this function renumbers all the basic blocks so that the new    one has a number one greater than the block split.  */
end_comment

begin_function
name|edge
name|split_block
parameter_list|(
name|bb
parameter_list|,
name|insn
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|basic_block
name|new_bb
decl_stmt|;
name|edge
name|new_edge
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* There is no point splitting the block after its end.  */
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|insn
condition|)
return|return
literal|0
return|;
comment|/* Create the new basic block.  */
name|new_bb
operator|=
name|create_basic_block
argument_list|(
name|bb
operator|->
name|index
operator|+
literal|1
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb
operator|->
name|end
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|bb
operator|->
name|frequency
expr_stmt|;
name|new_bb
operator|->
name|loop_depth
operator|=
name|bb
operator|->
name|loop_depth
expr_stmt|;
name|bb
operator|->
name|end
operator|=
name|insn
expr_stmt|;
comment|/* Redirect the outgoing edges.  */
name|new_bb
operator|->
name|succ
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
name|bb
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|e
operator|=
name|new_bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|src
operator|=
name|new_bb
expr_stmt|;
name|new_edge
operator|=
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|new_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|global_live_at_start
condition|)
block|{
name|new_bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_end
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
comment|/* We now have to calculate which registers are live at the end 	 of the split basic block and at the start of the new basic 	 block.  Start with those registers that are known to be live 	 at the end of the original basic block and get 	 propagate_block to determine which registers are live.  */
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_start
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|new_bb
argument_list|,
name|new_bb
operator|->
name|global_live_at_start
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|new_bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
return|return
name|new_edge
return|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block A.  The insns    are already contiguous, hence `nomove'.  */
end_comment

begin_function
name|void
name|merge_blocks_nomove
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|basic_block
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|rtx
name|b_head
init|=
name|b
operator|->
name|head
decl_stmt|,
name|b_end
init|=
name|b
operator|->
name|end
decl_stmt|,
name|a_end
init|=
name|a
operator|->
name|end
decl_stmt|;
name|rtx
name|del_first
init|=
name|NULL_RTX
decl_stmt|,
name|del_last
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|b_empty
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* If there was a CODE_LABEL beginning B, delete it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|b_head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* Detect basic blocks with nothing but a label.  This can happen 	 in particular at the end of a function.  */
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
name|del_first
operator|=
name|del_last
operator|=
name|b_head
expr_stmt|;
name|b_head
operator|=
name|NEXT_INSN
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the basic block note and handle blocks containing just that      note.  */
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|b_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|del_last
condition|)
name|del_first
operator|=
name|b_head
expr_stmt|;
name|del_last
operator|=
name|b_head
expr_stmt|;
name|b_head
operator|=
name|NEXT_INSN
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* If there was a jump out of A, delete it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a_end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|a_end
argument_list|)
init|;
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|||
name|prev
operator|==
name|a
operator|->
name|head
condition|)
break|break;
name|del_first
operator|=
name|a_end
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
name|only_sets_cc0_p
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|prev
decl_stmt|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|prev
operator|=
name|a
operator|->
name|head
expr_stmt|;
name|del_first
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
name|a_end
operator|=
name|PREV_INSN
argument_list|(
name|del_first
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|a_end
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
name|del_first
operator|=
name|NEXT_INSN
argument_list|(
name|a_end
argument_list|)
expr_stmt|;
comment|/* Normally there should only be one successor of A and that is B, but      partway though the merge of blocks for conditional_execution we'll      be merging a TEST block with THEN and ELSE successors.  Free the      whole lot of them and hope the caller knows what they're doing.  */
while|while
condition|(
name|a
operator|->
name|succ
condition|)
name|remove_edge
argument_list|(
name|a
operator|->
name|succ
argument_list|)
expr_stmt|;
comment|/* Adjust the edges out of B for the new owner.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|src
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|succ
operator|=
name|b
operator|->
name|succ
expr_stmt|;
comment|/* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */
name|b
operator|->
name|pred
operator|=
name|b
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|global_live_at_end
operator|=
name|b
operator|->
name|global_live_at_end
expr_stmt|;
name|expunge_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Delete everything marked above as well as crap that might be      hanging out between the two blocks.  */
name|delete_insn_chain
argument_list|(
name|del_first
argument_list|,
name|del_last
argument_list|)
expr_stmt|;
comment|/* Reassociate the insns of B with A.  */
if|if
condition|(
operator|!
name|b_empty
condition|)
block|{
if|if
condition|(
name|basic_block_for_insn
condition|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|a_end
init|;
name|x
operator|!=
name|b_end
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
operator|=
name|a
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|b_end
argument_list|)
operator|=
name|a
expr_stmt|;
block|}
name|a_end
operator|=
name|b_end
expr_stmt|;
block|}
name|a
operator|->
name|end
operator|=
name|a_end
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the label in the head of basic block BLOCK.  Create one if it doesn't    exist.  */
end_comment

begin_function
name|rtx
name|block_label
parameter_list|(
name|block
parameter_list|)
name|basic_block
name|block
decl_stmt|;
block|{
if|if
condition|(
name|block
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|block
operator|->
name|head
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|block
operator|->
name|head
operator|=
name|emit_label_before
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|block
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_block_for_insn
condition|)
name|set_block_for_insn
argument_list|(
name|block
operator|->
name|head
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
return|return
name|block
operator|->
name|head
return|;
block|}
end_function

begin_comment
comment|/* Attempt to perform edge redirection by replacing possibly complex jump    instruction by unconditional jump or removing jump completely.  This can    apply only if all edges now point to the same block.  The parameters and    return values are equivalent to redirect_edge_and_branch.  */
end_comment

begin_function
specifier|static
name|bool
name|try_redirect_by_replacing_jump
parameter_list|(
name|e
parameter_list|,
name|target
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|target
decl_stmt|;
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|src
operator|->
name|end
decl_stmt|,
name|kill_from
decl_stmt|;
name|edge
name|tmp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|fallthru
init|=
literal|0
decl_stmt|;
comment|/* Verify that all targets will be TARGET.  */
for|for
control|(
name|tmp
operator|=
name|src
operator|->
name|succ
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|succ_next
control|)
if|if
condition|(
name|tmp
operator|->
name|dest
operator|!=
name|target
operator|&&
name|tmp
operator|!=
name|e
condition|)
break|break;
if|if
condition|(
name|tmp
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Avoid removing branch with side effects.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|side_effects_p
argument_list|(
name|set
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* In case we zap a conditional jump, we'll need to kill      the cc0 setter too.  */
name|kill_from
operator|=
name|insn
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|kill_from
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if we can create the fallthru edge.  */
if|if
condition|(
name|can_fallthru
argument_list|(
name|src
argument_list|,
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Removing jump %i.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fallthru
operator|=
literal|1
expr_stmt|;
comment|/* Selectively unlink whole insn chain.  */
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|PREV_INSN
argument_list|(
name|target
operator|->
name|head
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this already is simplejump, redirect it.  */
elseif|else
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Redirecting jump %i from %i to %i.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Cannot do anything for target exit block.  */
elseif|else
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
comment|/* Or replace possibly complicated jump insn by simple jump insn.  */
else|else
block|{
name|rtx
name|target_label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|target_label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|src
operator|->
name|end
argument_list|)
operator|=
name|target_label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|target_label
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Replacing insn %i by jump %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|src
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|next_nonnote_insn
argument_list|(
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|barrier
operator|||
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* Keep only one edge out and set proper flags.  */
while|while
condition|(
name|src
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|remove_edge
argument_list|(
name|src
operator|->
name|succ
argument_list|)
expr_stmt|;
name|e
operator|=
name|src
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|fallthru
condition|)
name|e
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
else|else
name|e
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|src
operator|->
name|count
expr_stmt|;
comment|/* We don't want a block to end on a line-number note since that has      the potential of changing the code between -g and not -g.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
operator|>=
literal|0
condition|)
name|delete_insn
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target
condition|)
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return last loop_beg note appearing after INSN, before start of next    basic block.  Return INSN if there are no such notes.     When emitting jump to redirect an fallthru edge, it should always appear    after the LOOP_BEG notes, as loop optimizer expect loop to either start by    fallthru edge or jump following the LOOP_BEG note jumping to the loop exit    test.  */
end_comment

begin_function
specifier|static
name|rtx
name|last_loop_beg_note
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|last
init|=
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|last
operator|=
name|insn
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Attempt to change code to redirect edge E to TARGET.  Don't do that on    expense of adding new instructions or reordering basic blocks.     Function can be also called with edge destination equivalent to the TARGET.    Then it should try the simplifications and do nothing if none is possible.     Return true if transformation succeeded.  We still return false in case E    already destinated TARGET and we didn't managed to simplify instruction    stream.  */
end_comment

begin_function
name|bool
name|redirect_edge_and_branch
parameter_list|(
name|e
parameter_list|,
name|target
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|target
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|old_label
init|=
name|e
operator|->
name|dest
operator|->
name|head
decl_stmt|;
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|src
operator|->
name|end
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|try_redirect_by_replacing_jump
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Do this fast path late, as we want above code to simplify for cases      where called on single edge leaving basic block containing nontrivial      jump insn.  */
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|false
return|;
comment|/* We can only redirect non-fallthru edges of jump insn.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return
name|false
return|;
comment|/* Recognize a tablejump and adjust all matching cases.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|j
decl_stmt|;
name|rtx
name|new_label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
block|}
comment|/* Handle casesi dispatch insns */
if|if
condition|(
operator|(
name|tmp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|SET_DEST
argument_list|(
name|tmp
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ?? We may play the games with moving the named labels from 	 one basic block to the other in case only one computed_jump is 	 available.  */
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
comment|/* A return instruction can't be redirected.  */
operator|||
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the insn doesn't go where we think, we're confused.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|old_label
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the substitution doesn't succeed, die.  This can happen 	 if the back end emitted unrecognizable instructions or if 	 target is exit block on some arches.  */
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Edge %i->%i redirected to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target
condition|)
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Like force_nonfallthru below, but additionally performs redirection    Used by redirect_edge_and_branch_force.  */
end_comment

begin_function
specifier|static
name|basic_block
name|force_nonfallthru_and_redirect
parameter_list|(
name|e
parameter_list|,
name|target
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|target
decl_stmt|;
block|{
name|basic_block
name|jump_block
decl_stmt|,
name|new_bb
init|=
name|NULL
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|edge
name|new_edge
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
comment|/* Create the new structures.  */
name|note
operator|=
name|last_loop_beg_note
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
name|jump_block
operator|=
name|create_basic_block
argument_list|(
name|e
operator|->
name|src
operator|->
name|index
operator|+
literal|1
argument_list|,
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|jump_block
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|loop_depth
operator|=
name|target
operator|->
name|loop_depth
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|global_live_at_start
condition|)
block|{
name|jump_block
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|jump_block
operator|->
name|global_live_at_start
argument_list|,
name|target
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|jump_block
operator|->
name|global_live_at_end
argument_list|,
name|target
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
comment|/* Wire edge in.  */
name|new_edge
operator|=
name|make_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|jump_block
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|new_edge
operator|->
name|probability
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|new_edge
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Redirect old edge.  */
name|redirect_edge_pred
argument_list|(
name|e
argument_list|,
name|jump_block
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|new_bb
operator|=
name|jump_block
expr_stmt|;
block|}
else|else
name|jump_block
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
if|if
condition|(
name|HAVE_return
condition|)
name|emit_jump_insn_after
argument_list|(
name|gen_return
argument_list|()
argument_list|,
name|jump_block
operator|->
name|end
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|jump_block
operator|->
name|end
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump_block
operator|->
name|end
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|jump_block
operator|->
name|end
argument_list|)
expr_stmt|;
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Edge E is assumed to be fallthru edge.  Emit needed jump instruction    (and possibly create new basic block) to make edge non-fallthru.    Return newly created BB or NULL if none.  */
end_comment

begin_function
name|basic_block
name|force_nonfallthru
parameter_list|(
name|e
parameter_list|)
name|edge
name|e
decl_stmt|;
block|{
return|return
name|force_nonfallthru_and_redirect
argument_list|(
name|e
argument_list|,
name|e
operator|->
name|dest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Redirect edge even at the expense of creating new jump insn or    basic block.  Return new basic block if created, NULL otherwise.    Abort if conversion is impossible.  */
end_comment

begin_function
name|basic_block
name|redirect_edge_and_branch_force
parameter_list|(
name|e
parameter_list|,
name|target
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|target
decl_stmt|;
block|{
if|if
condition|(
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
operator|||
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|NULL
return|;
comment|/* In case the edge redirection failed, try to force it to be non-fallthru      and redirect newly created simplejump.  */
return|return
name|force_nonfallthru_and_redirect
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The given edge should potentially be a fallthru edge.  If that is in    fact true, delete the jump and barriers that are in the way.  */
end_comment

begin_function
name|void
name|tidy_fallthru_edge
parameter_list|(
name|e
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
name|rtx
name|q
decl_stmt|;
comment|/* ??? In a late-running flow pass, other folks may have deleted basic      blocks by nopping out blocks, leaving multiple BARRIERs between here      and the target label. They ought to be chastized and fixed.       We can also wind up with a sequence of undeletable labels between      one block and the next.       So search through a sequence of barriers, labels, and notes for      the head of block C and assert that we really do fall through.  */
if|if
condition|(
name|next_real_insn
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|!=
name|next_real_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|c
operator|->
name|head
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Remove what will soon cease being the jump insn from the source block.      If block B consisted only of this single jump, turn it into a deleted      note.  */
name|q
operator|=
name|b
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|onlyjump_p
argument_list|(
name|q
argument_list|)
operator|&&
operator|(
name|any_uncondjump_p
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|b
operator|->
name|succ
operator|==
name|e
operator|&&
name|e
operator|->
name|succ_next
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|q
argument_list|)
operator|&&
name|only_sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* We don't want a block to end on a line-number note since that has 	 the potential of changing the code between -g and not -g.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|>=
literal|0
condition|)
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Selectively unlink the sequence.  */
if|if
condition|(
name|q
operator|!=
name|PREV_INSN
argument_list|(
name|c
operator|->
name|head
argument_list|)
condition|)
name|delete_insn_chain
argument_list|(
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|c
operator|->
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up edges that now fall through, or rather should now fall through    but previously required a jump around now deleted blocks.  Simplify    the search by only examining blocks numerically adjacent, since this    is how find_basic_blocks created them.  */
end_comment

begin_function
name|void
name|tidy_fallthru_edges
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|basic_block
name|c
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|s
decl_stmt|;
comment|/* We care about simple conditional or unconditional jumps with 	 a single successor.  	 If we had a conditional branch to the next instruction when 	 find_basic_blocks was called, then there will only be one 	 out edge for the block which ended with the conditional 	 branch (since we do not create duplicate edges).  	 Furthermore, the edge will be marked as a fallthru because we 	 merge the flags for the duplicate edges.  So we do not want to 	 check that the edge is not a FALLTHRU edge.  */
if|if
condition|(
operator|(
name|s
operator|=
name|b
operator|->
name|succ
operator|)
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|s
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
name|s
operator|->
name|dest
operator|==
name|c
comment|/* If the jump insn has side effects, we can't tidy the edge.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|onlyjump_p
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|)
condition|)
name|tidy_fallthru_edge
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for split_edge.  Return true in case edge BB2 to BB1    is back edge of syntactic loop.  */
end_comment

begin_function
specifier|static
name|bool
name|back_edge_of_syntactic_loop_p
parameter_list|(
name|bb1
parameter_list|,
name|bb2
parameter_list|)
name|basic_block
name|bb1
decl_stmt|,
name|bb2
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bb1
operator|->
name|index
operator|>
name|bb2
operator|->
name|index
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|bb1
operator|->
name|index
operator|==
name|bb2
operator|->
name|index
condition|)
return|return
name|true
return|;
for|for
control|(
name|insn
operator|=
name|bb1
operator|->
name|end
init|;
name|insn
operator|!=
name|bb2
operator|->
name|head
operator|&&
name|count
operator|>=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|count
operator|--
expr_stmt|;
block|}
return|return
name|count
operator|>=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Split a (typically critical) edge.  Return the new block.    Abort on abnormal edges.     ??? The code generally expects to be called on critical edges.    The case of a block ending in an unconditional jump to a    block with multiple predecessors is not handled optimally.  */
end_comment

begin_function
name|basic_block
name|split_edge
parameter_list|(
name|edge_in
parameter_list|)
name|edge
name|edge_in
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|edge_out
decl_stmt|;
name|rtx
name|before
decl_stmt|;
comment|/* Abnormal edges cannot be split.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We are going to place the new block in front of edge destination.      Avoid existence of fallthru predecessors.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|edge_in
operator|->
name|dest
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
condition|)
name|force_nonfallthru
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* Create the basic block note.       Where we place the note can have a noticeable impact on the generated      code.  Consider this cfg:  		        E 			| 			0 		       / \ 		   +->1-->2--->E                    |  | 		   +--+        If we need to insert an insn on the edge from block 0 to block 1,       we want to ensure the instructions we insert are outside of any       loop notes that physically sit between block 0 and block 1.  Otherwise       we confuse the loop optimizer into thinking the loop is a phony.  */
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|PREV_INSN
argument_list|(
name|edge_in
operator|->
name|dest
operator|->
name|head
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|edge_in
operator|->
name|dest
operator|->
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|edge_in
operator|->
name|dest
operator|->
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|)
operator|&&
operator|!
name|back_edge_of_syntactic_loop_p
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|,
name|edge_in
operator|->
name|src
argument_list|)
condition|)
name|before
operator|=
name|PREV_INSN
argument_list|(
name|edge_in
operator|->
name|dest
operator|->
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|before
operator|=
name|edge_in
operator|->
name|dest
operator|->
name|head
expr_stmt|;
else|else
name|before
operator|=
name|NULL_RTX
expr_stmt|;
name|bb
operator|=
name|create_basic_block
argument_list|(
name|edge_in
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|?
name|n_basic_blocks
else|:
name|edge_in
operator|->
name|dest
operator|->
name|index
argument_list|,
name|before
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|edge_in
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|edge_in
argument_list|)
expr_stmt|;
comment|/* ??? This info is likely going to be out of date very soon.  */
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|->
name|global_live_at_start
condition|)
block|{
name|bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
name|edge_out
operator|=
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|edge_in
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
comment|/* For non-fallthry edges, we must adjust the predecessor's      jump instruction to target our new block.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|redirect_edge_and_branch
argument_list|(
name|edge_in
argument_list|,
name|bb
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|redirect_edge_succ
argument_list|(
name|edge_in
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Queue instructions for insertion on an edge between two basic blocks.    The new instructions and basic blocks (if any) will not appear in the    CFG until commit_edge_insertions is called.  */
end_comment

begin_function
name|void
name|insert_insn_on_edge
parameter_list|(
name|pattern
parameter_list|,
name|e
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|edge
name|e
decl_stmt|;
block|{
comment|/* We cannot insert instructions on an abnormal critical edge.      It will be easier to find the culprit if we die now.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|&&
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
operator|==
name|NULL_RTX
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|e
operator|->
name|insns
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|e
operator|->
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the CFG for the instructions queued on edge E.  */
end_comment

begin_function
specifier|static
name|void
name|commit_one_edge_insertion
parameter_list|(
name|e
parameter_list|)
name|edge
name|e
decl_stmt|;
block|{
name|rtx
name|before
init|=
name|NULL_RTX
decl_stmt|,
name|after
init|=
name|NULL_RTX
decl_stmt|,
name|insns
decl_stmt|,
name|tmp
decl_stmt|,
name|last
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Pull the insns off the edge now since the edge might go away.  */
name|insns
operator|=
name|e
operator|->
name|insns
expr_stmt|;
name|e
operator|->
name|insns
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Figure out where to put these things.  If the destination has      one predecessor, insert there.  Except for the exit block.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Get the location correct wrt a code label, and "nice" wrt 	 a basic block note, and before everything else.  */
name|tmp
operator|=
name|bb
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|bb
operator|->
name|head
condition|)
name|before
operator|=
name|tmp
expr_stmt|;
else|else
name|after
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* If the source has one successor and the edge is not abnormal,      insert there.  Except for the entry block.  */
elseif|else
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
operator|&&
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
comment|/* It is possible to have a non-simple jump here.  Consider a target 	 where some forms of unconditional jumps clobber a register.  This 	 happens on the fr30 for example.  	 We know this block has a single successor, so we can just emit 	 the queued insns before the jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
for|for
control|(
name|before
operator|=
name|bb
operator|->
name|end
init|;
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|before
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|before
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|;
name|before
operator|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
control|)
empty_stmt|;
else|else
block|{
comment|/* We'd better be fallthru, or we've lost track of what's what.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|after
operator|=
name|bb
operator|->
name|end
expr_stmt|;
block|}
block|}
comment|/* Otherwise we must split the edge.  */
else|else
block|{
name|bb
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|after
operator|=
name|bb
operator|->
name|end
expr_stmt|;
block|}
comment|/* Now that we've found the spot, do the insertion.  */
if|if
condition|(
name|before
condition|)
block|{
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|prev_nonnote_insn
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
else|else
name|last
operator|=
name|emit_insns_after
argument_list|(
name|insns
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnjump_p
argument_list|(
name|last
argument_list|)
condition|)
block|{
comment|/* ??? Remove all outgoing edges from BB and add one for EXIT.          This is not currently a problem because this only happens 	 for the (single) epilogue, which already has a fallthru edge 	 to EXIT.  */
name|e
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|succ_next
operator|!=
name|NULL
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
condition|)
name|delete_insn
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
name|find_sub_basic_blocks
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the CFG for all queued instructions.  */
end_comment

begin_function
name|void
name|commit_edge_insertions
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
condition|)
name|commit_one_edge_insertion
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|n_basic_blocks
condition|)
break|break;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out one basic block with live information at start and end.  */
end_comment

begin_function
name|void
name|dump_bb
parameter_list|(
name|bb
parameter_list|,
name|outf
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Basic block %d, loop depth %d, count "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";; Predecessors: "
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|dump_edge_info
argument_list|(
name|outf
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";; Registers live at start:"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
operator|,
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";; Registers live at end:"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";; Successors: "
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|dump_edge_info
argument_list|(
name|outf
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_bb
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_bb_n
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|dump_bb
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|n
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like print_rtl, but also print out live information for the start of each    basic block.  */
end_comment

begin_function
name|void
name|print_rtl_with_bb
parameter_list|(
name|outf
parameter_list|,
name|rtx_first
parameter_list|)
name|FILE
modifier|*
name|outf
decl_stmt|;
name|rtx
name|rtx_first
decl_stmt|;
block|{
name|rtx
name|tmp_rtx
decl_stmt|;
if|if
condition|(
name|rtx_first
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(nil)\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
enum|enum
name|bb_state
block|{
name|NOT_IN_BB
block|,
name|IN_ONE_BB
block|,
name|IN_MULTIPLE_BB
block|}
enum|;
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|start
init|=
operator|(
name|basic_block
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|end
init|=
operator|(
name|basic_block
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|bb_state
modifier|*
name|in_bb_p
init|=
operator|(
expr|enum
name|bb_state
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
expr|enum
name|bb_state
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|start
index|[
name|INSN_UID
argument_list|(
name|bb
operator|->
name|head
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
name|end
index|[
name|INSN_UID
argument_list|(
name|bb
operator|->
name|end
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|x
operator|=
name|bb
operator|->
name|head
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|enum
name|bb_state
name|state
init|=
name|IN_MULTIPLE_BB
decl_stmt|;
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|NOT_IN_BB
condition|)
name|state
operator|=
name|IN_ONE_BB
expr_stmt|;
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
block|}
for|for
control|(
name|tmp_rtx
operator|=
name|rtx_first
init|;
name|NULL
operator|!=
name|tmp_rtx
condition|;
name|tmp_rtx
operator|=
name|NEXT_INSN
argument_list|(
name|tmp_rtx
argument_list|)
control|)
block|{
name|int
name|did_output
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|start
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Start of basic block %d, registers live:"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|NOT_IN_BB
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|BARRIER
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is not within a basic block\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|IN_MULTIPLE_BB
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is in multiple basic blocks\n"
argument_list|)
expr_stmt|;
name|did_output
operator|=
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|tmp_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|end
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; End of basic block %d, registers live:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|did_output
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_bb_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_epilogue_delay_list
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\n;; Insns in epilogue delay list:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp_rtx
operator|=
name|current_function_epilogue_delay_list
init|;
name|tmp_rtx
operator|!=
literal|0
condition|;
name|tmp_rtx
operator|=
name|XEXP
argument_list|(
name|tmp_rtx
argument_list|,
literal|1
argument_list|)
control|)
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|XEXP
argument_list|(
name|tmp_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|update_br_prob_note
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return;
name|note
operator|=
name|find_reg_note
argument_list|(
name|bb
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
condition|)
return|return;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify the CFG consistency.  This function check some CFG invariants and    aborts when something is wrong.  Hope that this function will help to    convert many optimization passes to preserve CFG consistent.     Currently it does following checks:     - test head/end pointers    - overlapping of basic blocks    - edge list correctness    - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)    - tails of basic blocks (ensure that boundary is necessary)    - scans body of the basic block for JUMP_INSN, CODE_LABEL      and NOTE_INSN_BASIC_BLOCK    - check that all insns are in the basic blocks      (except the switch handling code, barriers and notes)    - check that all returns are followed by barriers     In future it can be extended check a lot of other stuff as well    (reachability of basic blocks, life information, etc. etc.).  */
end_comment

begin_function
name|void
name|verify_flow_info
parameter_list|()
block|{
specifier|const
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
specifier|const
name|rtx
name|rtx_first
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|rtx
name|last_head
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|bb_info
decl_stmt|,
modifier|*
name|last_visited
decl_stmt|;
name|size_t
modifier|*
name|edge_checksum
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|,
name|last_bb_num_seen
decl_stmt|,
name|num_bb_notes
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|bb_info
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|last_visited
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|edge_checksum
operator|=
operator|(
name|size_t
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|head
init|=
name|bb
operator|->
name|head
decl_stmt|;
name|rtx
name|end
init|=
name|bb
operator|->
name|end
decl_stmt|;
comment|/* Verify the end of the basic block is in the INSN chain.  */
for|for
control|(
name|x
operator|=
name|last_head
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|x
operator|==
name|end
condition|)
break|break;
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"end insn %d for block %d not found in the insn stream"
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Work backwards from the end to the head of the basic block 	 to verify the head is in the RTL chain.  */
for|for
control|(
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
comment|/* While walking over the insn chain, verify insns appear 	     in only one basic block and initialize the BB_INFO array 	     used by other passes.  */
if|if
condition|(
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"insn %d is in multiple basic blocks (%d and %d)"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|head
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"head insn %d for block %d not found in the insn stream"
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_head
operator|=
name|x
expr_stmt|;
block|}
comment|/* Now check the basic blocks (boundaries etc.) */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|has_fallthru
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|last_visited
index|[
name|e
operator|->
name|dest
operator|->
name|index
operator|+
literal|2
index|]
operator|==
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Duplicate edge %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_visited
index|[
name|e
operator|->
name|dest
operator|->
name|index
operator|+
literal|2
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|has_fallthru
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|+
literal|1
operator|!=
name|e
operator|->
name|dest
operator|->
name|index
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Incorrect blocks for fallthru %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
init|;
name|insn
operator|!=
name|e
operator|->
name|dest
operator|->
name|head
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
ifndef|#
directive|ifndef
name|CASE_DROPS_THROUGH
operator|||
name|INSN_P
argument_list|(
name|insn
argument_list|)
else|#
directive|else
operator|||
operator|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_TABLE_DATA_P
argument_list|(
name|insn
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Incorrect fallthru %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"wrong insn in the fallthru edge"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Basic block %d succ edge is corrupted"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Predecessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSuccessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
operator|+
literal|2
index|]
operator|+=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_fallthru
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Ensure existence of barrier in BB with no fallthru edges.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
operator|!
name|insn
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|!
name|insn
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"missing barrier after block %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"basic block %d pred edge is corrupted"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Predecessor: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\nSuccessor: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
operator|+
literal|2
index|]
operator|-=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|bb
operator|->
name|head
init|;
name|x
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|basic_block_for_insn
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
condition|)
name|error
argument_list|(
literal|"insn %d inside basic block %d but block_for_insn is NULL"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"insn %d inside basic block %d but block_for_insn is %i"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* OK pointers are correct.  Now check the header of basic          block.  It ought to contain optional CODE_LABEL followed 	 by NOTE_BASIC_BLOCK.  */
name|x
operator|=
name|bb
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|x
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK is missing for block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
operator|||
name|NOTE_BASIC_BLOCK
argument_list|(
name|x
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK is missing for block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|x
condition|)
comment|/* Do checks for empty blocks her. e */
empty_stmt|;
else|else
for|for
control|(
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK %d in middle of basic block %d"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|error
argument_list|(
literal|"in basic block %d:"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"flow control insn inside a basic block"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Complete edge checksumming for ENTRY and EXIT.  */
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
operator|+
literal|2
index|]
operator|+=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
operator|+
literal|2
index|]
operator|-=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|-
literal|2
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|edge_checksum
index|[
name|i
operator|+
literal|2
index|]
condition|)
block|{
name|error
argument_list|(
literal|"basic block %i edge lists are corrupted"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_bb_num_seen
operator|=
operator|-
literal|1
expr_stmt|;
name|num_bb_notes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rtx_first
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|num_bb_notes
operator|++
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|index
operator|!=
name|last_bb_num_seen
operator|+
literal|1
condition|)
name|internal_error
argument_list|(
literal|"basic blocks not numbered consecutively"
argument_list|)
expr_stmt|;
name|last_bb_num_seen
operator|=
name|bb
operator|->
name|index
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
break|break;
case|case
name|CODE_LABEL
case|:
comment|/* An addr_vec is placed outside any block block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* But in any case, non-deletable labels can appear anywhere.  */
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"insn outside basic block"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|returnjump_p
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|condjump_p
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|BARRIER
operator|)
condition|)
name|fatal_insn
argument_list|(
literal|"return not followed by barrier"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_bb_notes
operator|!=
name|n_basic_blocks
condition|)
name|internal_error
argument_list|(
literal|"number of bb notes in insn chain (%d) != n_basic_blocks (%d)"
argument_list|,
name|num_bb_notes
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|internal_error
argument_list|(
literal|"verify_flow_info failed"
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|free
argument_list|(
name|bb_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|last_visited
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edge_checksum
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assume that the preceding pass has possibly eliminated jump instructions    or converted the unconditional jumps.  Eliminate the edges from CFG.    Return true if any edges are eliminated.  */
end_comment

begin_function
name|bool
name|purge_dead_edges
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|;
name|rtx
name|insn
init|=
name|bb
operator|->
name|end
decl_stmt|,
name|note
decl_stmt|;
name|bool
name|purged
init|=
name|false
decl_stmt|;
comment|/* ??? This makes no sense since the later test includes more cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|edge
name|b
decl_stmt|,
name|f
decl_stmt|;
comment|/* We do care only about conditional jumps and simplejumps.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|returnjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
comment|/* Avoid abnormal flags to leak from computed jumps turned 	     into simplejumps.  */
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_ABNORMAL
expr_stmt|;
comment|/* Check purposes we can have edge.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|->
name|head
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|purged
operator|=
name|true
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|||
operator|!
name|purged
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Purged edges from bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
name|purged
return|;
comment|/* Redistribute probabilities.  */
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|bb
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|bb
operator|->
name|succ
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
return|return
name|purged
return|;
name|b
operator|=
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|f
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|b
operator|->
name|probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|b
operator|->
name|probability
expr_stmt|;
name|b
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|b
operator|->
name|probability
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|f
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|f
operator|->
name|probability
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
return|return
name|purged
return|;
block|}
comment|/* If this instruction cannot trap, remove REG_EH_REGION notes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|eqnote
decl_stmt|;
if|if
condition|(
operator|!
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|eqnote
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|eqnote
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup abnormal edges caused by throwing insns that have been      eliminated.  */
if|if
condition|(
operator|!
name|can_throw_internal
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|)
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|purged
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If we don't see a jump insn, we don't know exactly why the block would      have been broken at this point.  Look for a simple, non-fallthru edge,      as these are only created by conditional branches.  If we find such an      edge we know that there used to be a jump here and can then safely      remove all non-fallthru edges.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FALLTHRU
operator|)
operator|)
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|purged
return|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|remove_edge
argument_list|(
name|e
argument_list|)
operator|,
name|purged
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|||
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|bb
operator|->
name|succ
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Purged non-fallthru edges from bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|purged
return|;
block|}
end_function

begin_comment
comment|/* Search all basic blocks for potentially dead edges and purge them.  Return    true if some edge has been eliminated.  */
end_comment

begin_function
name|bool
name|purge_all_dead_edges
parameter_list|(
name|update_life_p
parameter_list|)
name|int
name|update_life_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|purged
init|=
name|false
decl_stmt|;
name|sbitmap
name|blocks
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|update_life_p
condition|)
block|{
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|purged_here
init|=
name|purge_dead_edges
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|purged
operator||=
name|purged_here
expr_stmt|;
if|if
condition|(
name|purged_here
operator|&&
name|update_life_p
condition|)
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_life_p
operator|&&
name|purged
condition|)
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_life_p
condition|)
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
return|return
name|purged
return|;
block|}
end_function

end_unit

