begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph manipulation code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains low level functions to manipulate the CFG and analyze it    that are aware of the RTL intermediate language.     Available functionality:      - Basic CFG/RTL manipulation API documented in cfghooks.h      - CFG-aware instruction chain manipulation 	 delete_insn, delete_insn_chain      - Edge splitting and committing to edges 	 insert_insn_on_edge, commit_edge_insertions      - CFG updating after insn simplification 	 purge_dead_edges, purge_all_dead_edges     Functions not supposed for generic use:      - Infrastructure to determine quickly basic block for insn 	 compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,      - Edge redirection with updating and optimizing of insn chain 	 block_label, tidy_fallthru_edge, force_nonfallthru  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_function_decl
specifier|static
name|int
name|can_delete_note_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_delete_label_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|commit_one_edge_insertion
parameter_list|(
name|edge
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|rtl_split_edge
parameter_list|(
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rtl_move_block_after
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtl_verify_flow_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|cfg_layout_split_block
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|cfg_layout_redirect_edge_and_branch
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|cfg_layout_redirect_edge_and_branch_force
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfg_layout_delete_block
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtl_delete_block
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|rtl_redirect_edge_and_branch_force
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|rtl_redirect_edge_and_branch
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|rtl_split_block
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtl_dump_bb
parameter_list|(
name|basic_block
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtl_verify_flow_info_1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtl_make_forwarder_block
parameter_list|(
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return true if NOTE is not one of the ones that must be kept paired,    so that we may simply delete it.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_note_p
parameter_list|(
name|rtx
name|note
parameter_list|)
block|{
return|return
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True if a given label can be deleted.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_label_p
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
return|return
operator|(
operator|!
name|LABEL_PRESERVE_P
argument_list|(
name|label
argument_list|)
comment|/* User declared labels must be preserved.  */
operator|&&
name|LABEL_NAME
argument_list|(
name|label
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|in_expr_list_p
argument_list|(
name|forced_labels
argument_list|,
name|label
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete INSN by patching it out.  Return the next insn.  */
end_comment

begin_function
name|rtx
name|delete_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|bool
name|really_delete
init|=
name|true
decl_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Some labels can't be directly removed from the INSN chain, as they 	 might be references via variables, constant pool etc. 	 Convert them to the special NOTE_INSN_DELETED_LABEL note.  */
if|if
condition|(
operator|!
name|can_delete_label_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|really_delete
operator|=
name|false
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED_LABEL
expr_stmt|;
name|NOTE_DELETED_LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
name|remove_node_from_expr_list
argument_list|(
name|insn
argument_list|,
operator|&
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|really_delete
condition|)
block|{
comment|/* If this insn has already been deleted, something is very wrong.  */
name|gcc_assert
argument_list|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If deleting a jump, decrement the use count of the label.  Deleting      the label itself should happen in the normal course of block merging.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|&&
name|LABEL_P
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|--
expr_stmt|;
comment|/* Also if deleting an insn that references a label.  */
else|else
block|{
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* When deleting code in bulk (e.g. removing many unreachable 	     blocks) we can delete a label that's a target of the vector 	     before deleting the vector itself.  */
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|label
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|--
expr_stmt|;
block|}
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Like delete_insn but also purge dead edges from BB.  */
end_comment

begin_function
name|rtx
name|delete_insn_and_edges
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|bool
name|purge
init|=
name|false
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|BB_END
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|insn
condition|)
name|purge
operator|=
name|true
expr_stmt|;
name|x
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|purge
condition|)
name|purge_dead_edges
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Unlink a chain of insns between START and FINISH, leaving notes    that must be paired.  */
end_comment

begin_function
name|void
name|delete_insn_chain
parameter_list|(
name|rtx
name|start
parameter_list|,
name|rtx
name|finish
parameter_list|)
block|{
name|rtx
name|next
decl_stmt|;
comment|/* Unchain the insns one by one.  It would be quicker to delete all of these      with a single unchaining, rather than one at a time, but we need to keep      the NOTE's.  */
while|while
condition|(
literal|1
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|start
argument_list|)
operator|&&
operator|!
name|can_delete_note_p
argument_list|(
name|start
argument_list|)
condition|)
empty_stmt|;
else|else
name|next
operator|=
name|delete_insn
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|finish
condition|)
break|break;
name|start
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like delete_insn but also purge dead edges from BB.  */
end_comment

begin_function
name|void
name|delete_insn_chain_and_edges
parameter_list|(
name|rtx
name|first
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|bool
name|purge
init|=
name|false
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|last
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|last
argument_list|)
operator|&&
name|BB_END
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|last
condition|)
name|purge
operator|=
name|true
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|purge
condition|)
name|purge_dead_edges
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new basic block consisting of the instructions between HEAD and END    inclusive.  This function is designed to allow fast BB construction - reuses    the note and basic block struct in BB_NOTE, if any and do not grow    BASIC_BLOCK chain and should be used directly only by CFG construction code.    END can be NULL in to create new empty basic block before HEAD.  Both END    and HEAD can be NULL to create basic block at the end of INSN chain.    AFTER is the basic block we should be put after.  */
end_comment

begin_function
name|basic_block
name|create_basic_block_structure
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|end
parameter_list|,
name|rtx
name|bb_note
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|bb_note
operator|&&
operator|(
name|bb
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bb
operator|->
name|aux
operator|==
name|NULL
condition|)
block|{
comment|/* If we found an existing note, thread it back onto the chain.  */
name|rtx
name|after
decl_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|head
argument_list|)
condition|)
name|after
operator|=
name|head
expr_stmt|;
else|else
block|{
name|after
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
block|}
if|if
condition|(
name|after
operator|!=
name|bb_note
operator|&&
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|!=
name|bb_note
condition|)
name|reorder_insns_nobb
argument_list|(
name|bb_note
argument_list|,
name|bb_note
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise we must create a note and a basic block structure.  */
name|bb
operator|=
name|alloc_block
argument_list|()
expr_stmt|;
name|init_rtl_bb_info
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
operator|&&
operator|!
name|end
condition|)
name|head
operator|=
name|end
operator|=
name|bb_note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LABEL_P
argument_list|(
name|head
argument_list|)
operator|&&
name|end
condition|)
block|{
name|bb_note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|end
condition|)
name|end
operator|=
name|bb_note
expr_stmt|;
block|}
else|else
block|{
name|bb_note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|end
operator|=
name|head
expr_stmt|;
block|}
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
comment|/* Always include the bb note in the block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
operator|==
name|bb_note
condition|)
name|end
operator|=
name|bb_note
expr_stmt|;
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|head
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|end
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|last_basic_block
operator|++
expr_stmt|;
name|bb
operator|->
name|flags
operator|=
name|BB_NEW
operator||
name|BB_RTL
expr_stmt|;
name|link_block
argument_list|(
name|bb
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|SET_BASIC_BLOCK
argument_list|(
name|bb
operator|->
name|index
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|BB_SET_PARTITION
argument_list|(
name|bb
argument_list|,
name|BB_UNPARTITIONED
argument_list|)
expr_stmt|;
comment|/* Tag the block so that we know it has been used when considering      other basic block notes.  */
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Create new basic block consisting of instructions in between HEAD and END    and place it to the BB chain after block AFTER.  END can be NULL in to    create new empty basic block before HEAD.  Both END and HEAD can be NULL to    create basic block at the end of INSN chain.  */
end_comment

begin_function
specifier|static
name|basic_block
name|rtl_create_basic_block
parameter_list|(
name|void
modifier|*
name|headp
parameter_list|,
name|void
modifier|*
name|endp
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|rtx
name|head
init|=
name|headp
decl_stmt|,
name|end
init|=
name|endp
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Grow the basic block array if needed.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|last_basic_block
operator|>=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
condition|)
block|{
name|size_t
name|old_size
init|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
decl_stmt|;
name|size_t
name|new_size
init|=
name|last_basic_block
operator|+
operator|(
name|last_basic_block
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|basic_block
modifier|*
name|p
decl_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|basic_block_info
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p
index|[
name|old_size
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|)
expr_stmt|;
block|}
name|n_basic_blocks
operator|++
expr_stmt|;
name|bb
operator|=
name|create_basic_block_structure
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|NULL
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_function
specifier|static
name|basic_block
name|cfg_layout_create_basic_block
parameter_list|(
name|void
modifier|*
name|head
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|basic_block
name|newbb
init|=
name|rtl_create_basic_block
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|after
argument_list|)
decl_stmt|;
return|return
name|newbb
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete the insns in a (non-live) block.  We physically delete every    non-deleted-note insn, and update the flow graph appropriately.     Return nonzero if we deleted an exception handler.  */
end_comment

begin_comment
comment|/* ??? Preserving all such notes strikes me as wrong.  It would be nice    to post-process the stream to remove empty blocks, loops, ranges, etc.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_delete_block
parameter_list|(
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|end
decl_stmt|;
comment|/* If the head of this block is a CODE_LABEL, then it might be the      label for an exception handler which can't be reached.  We need      to remove the label from the exception_handler_label list.  */
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|maybe_remove_eh_handler
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|end
operator|=
name|get_last_bb_insn
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Selectively delete the entire chain.  */
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|insn
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
condition|)
block|{
name|FREE_REG_SET
argument_list|(
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Records the basic block struct in BLOCK_FOR_INSN for every insn.  */
end_comment

begin_function
name|void
name|compute_bb_for_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|end
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Release the basic_block_for_insn array.  */
end_comment

begin_function
name|unsigned
name|int
name|free_bb_for_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_free_cfg
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|free_bb_for_insn
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_cfg
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return RTX to emit after when we want to emit code on the entry of function.  */
end_comment

begin_function
name|rtx
name|entry_of_function
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|n_basic_blocks
operator|>
name|NUM_FIXED_BLOCKS
condition|?
name|BB_HEAD
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
argument_list|)
else|:
name|get_insns
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Emit INSN at the entry point of the function, ensuring that it is only    executed once per function.  */
end_comment

begin_function
name|void
name|emit_insn_at_entry
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|edge_iterator
name|ei
init|=
name|ei_start
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|)
decl_stmt|;
name|edge
name|e
init|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|insn
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|commit_edge_insertions
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update insns block within BB.  */
end_comment

begin_function
name|void
name|update_bb_for_insn
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creates a new basic block just after basic block B by splitting    everything after specified instruction I.  */
end_comment

begin_function
specifier|static
name|basic_block
name|rtl_split_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|insnp
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
name|rtx
name|insn
init|=
name|insnp
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
block|{
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* We probably should check type of the insn so that we do not create      inconsistent cfg.  It is checked in verify_flow_info anyway, so do not      bother.  */
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Create the new basic block.  */
name|new_bb
operator|=
name|create_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|BB_COPY_PARTITION
argument_list|(
name|new_bb
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Redirect the outgoing edges.  */
name|new_bb
operator|->
name|succs
operator|=
name|bb
operator|->
name|succs
expr_stmt|;
name|bb
operator|->
name|succs
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|new_bb->succs
argument_list|)
name|e
operator|->
name|src
operator|=
name|new_bb
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
condition|)
block|{
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
comment|/* We now have to calculate which registers are live at the end 	 of the split basic block and at the start of the new basic 	 block.  Start with those registers that are known to be live 	 at the end of the original basic block and get 	 propagate_block to determine which registers are live.  */
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|new_bb
argument_list|,
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* In the presence of conditional execution we are not able to update 	 liveness precisely.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|new_bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block A.  The insns    are already contiguous.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|b_head
init|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
decl_stmt|,
name|b_end
init|=
name|BB_END
argument_list|(
name|b
argument_list|)
decl_stmt|,
name|a_end
init|=
name|BB_END
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|rtx
name|del_first
init|=
name|NULL_RTX
decl_stmt|,
name|del_last
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|b_empty
init|=
literal|0
decl_stmt|;
comment|/* If there was a CODE_LABEL beginning B, delete it.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|b_head
argument_list|)
condition|)
block|{
comment|/* This might have been an EH label that no longer has incoming 	 EH edges.  Update data structures to match.  */
name|maybe_remove_eh_handler
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
comment|/* Detect basic blocks with nothing but a label.  This can happen 	 in particular at the end of a function.  */
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
name|del_first
operator|=
name|del_last
operator|=
name|b_head
expr_stmt|;
name|b_head
operator|=
name|NEXT_INSN
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the basic block note and handle blocks containing just that      note.  */
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|b_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|del_last
condition|)
name|del_first
operator|=
name|b_head
expr_stmt|;
name|del_last
operator|=
name|b_head
expr_stmt|;
name|b_head
operator|=
name|NEXT_INSN
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* If there was a jump out of A, delete it.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|a_end
argument_list|)
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|a_end
argument_list|)
init|;
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|prev
argument_list|)
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|||
name|prev
operator|==
name|BB_HEAD
argument_list|(
name|a
argument_list|)
condition|)
break|break;
name|del_first
operator|=
name|a_end
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
name|only_sets_cc0_p
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|prev
decl_stmt|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|prev
operator|=
name|BB_HEAD
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|del_first
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
name|a_end
operator|=
name|PREV_INSN
argument_list|(
name|del_first
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BARRIER_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|a_end
argument_list|)
argument_list|)
condition|)
name|del_first
operator|=
name|NEXT_INSN
argument_list|(
name|a_end
argument_list|)
expr_stmt|;
comment|/* Delete everything marked above as well as crap that might be      hanging out between the two blocks.  */
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|del_first
argument_list|,
name|del_last
argument_list|)
expr_stmt|;
comment|/* Reassociate the insns of B with A.  */
if|if
condition|(
operator|!
name|b_empty
condition|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|a_end
init|;
name|x
operator|!=
name|b_end
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|set_block_for_insn
argument_list|(
name|b_end
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|a_end
operator|=
name|b_end
expr_stmt|;
block|}
name|BB_END
argument_list|(
name|a
argument_list|)
operator|=
name|a_end
expr_stmt|;
name|a
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when block A and B can be merged.  */
end_comment

begin_function
specifier|static
name|bool
name|rtl_can_merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
comment|/* If we are partitioning hot/cold basic blocks, we don't want to      mess up unconditional or indirect jumps that cross between hot      and cold sections.       Basic block partitioning may result in some jumps that appear to      be optimizable (or blocks that appear to be mergeable), but which really      must be left untouched (they are required to make it safely across      partition boundaries).  See  the comments at the top of      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|a
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* There must be exactly one edge in between the blocks.  */
return|return
operator|(
name|single_succ_p
argument_list|(
name|a
argument_list|)
operator|&&
name|single_succ
argument_list|(
name|a
argument_list|)
operator|==
name|b
operator|&&
name|single_pred_p
argument_list|(
name|b
argument_list|)
operator|&&
name|a
operator|!=
name|b
comment|/* Must be simple edge.  */
operator|&&
operator|!
operator|(
name|single_succ_edge
argument_list|(
name|a
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|a
operator|->
name|next_bb
operator|==
name|b
operator|&&
name|a
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|b
operator|!=
name|EXIT_BLOCK_PTR
comment|/* If the jump insn has side effects, 	     we can't kill the edge.  */
operator|&&
operator|(
operator|!
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|||
operator|(
name|reload_completed
condition|?
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
else|:
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the label in the head of basic block BLOCK.  Create one if it doesn't    exist.  */
end_comment

begin_function
name|rtx
name|block_label
parameter_list|(
name|basic_block
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
name|LABEL_P
argument_list|(
name|BB_HEAD
argument_list|(
name|block
argument_list|)
argument_list|)
condition|)
block|{
name|BB_HEAD
argument_list|(
name|block
argument_list|)
operator|=
name|emit_label_before
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|BB_HEAD
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|BB_HEAD
argument_list|(
name|block
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Attempt to perform edge redirection by replacing possibly complex jump    instruction by unconditional jump or removing jump completely.  This can    apply only if all edges now point to the same block.  The parameters and    return values are equivalent to redirect_edge_and_branch.  */
end_comment

begin_function
name|edge
name|try_redirect_by_replacing_jump
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|,
name|bool
name|in_cfglayout
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|src
argument_list|)
decl_stmt|,
name|kill_from
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|fallthru
init|=
literal|0
decl_stmt|;
comment|/* If we are partitioning hot/cold basic blocks, we don't want to      mess up unconditional or indirect jumps that cross between hot      and cold sections.       Basic block partitioning may result in some jumps that appear to      be optimizable (or blocks that appear to be mergeable), but which really      must be left untouched (they are required to make it safely across      partition boundaries).  See  the comments at the top of      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
name|BB_PARTITION
argument_list|(
name|src
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* We can replace or remove a complex jump only when we have exactly      two edges.  Also, if we have exactly one outgoing edge, we can      redirect that.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|src
operator|->
name|succs
argument_list|)
operator|>=
literal|3
comment|/* Verify that all targets will be TARGET.  Specifically, the 	 edge that is not E must also go to TARGET.  */
operator|||
operator|(
name|EDGE_COUNT
argument_list|(
name|src
operator|->
name|succs
argument_list|)
operator|==
literal|2
operator|&&
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|e
argument_list|)
operator|->
name|dest
operator|!=
name|target
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|reload_completed
operator|)
operator|&&
name|tablejump_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Avoid removing branch with side effects.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|side_effects_p
argument_list|(
name|set
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* In case we zap a conditional jump, we'll need to kill      the cc0 setter too.  */
name|kill_from
operator|=
name|insn
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|kill_from
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if we can create the fallthru edge.  */
if|if
condition|(
name|in_cfglayout
operator|||
name|can_fallthru
argument_list|(
name|src
argument_list|,
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Removing jump %i.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fallthru
operator|=
literal|1
expr_stmt|;
comment|/* Selectively unlink whole insn chain.  */
if|if
condition|(
name|in_cfglayout
condition|)
block|{
name|rtx
name|insn
init|=
name|src
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
decl_stmt|;
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove barriers but keep jumptables.  */
while|while
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|src
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this already is simplejump, redirect it.  */
elseif|else
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Redirecting jump %i from %i to %i.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|target
operator|==
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Cannot do anything for target exit block.  */
elseif|else
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|NULL
return|;
comment|/* Or replace possibly complicated jump insn by simple jump insn.  */
else|else
block|{
name|rtx
name|target_label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|rtx
name|barrier
decl_stmt|,
name|label
decl_stmt|,
name|table
decl_stmt|;
name|emit_jump_insn_after_noloc
argument_list|(
name|gen_jump
argument_list|(
name|target_label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
operator|=
name|target_label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|target_label
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Replacing insn %i by jump %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Recognize a tablejump that we are converting to a 	 simple jump and remove its associated CODE_LABEL 	 and ADDR_VEC or ADDR_DIFF_VEC.  */
if|if
condition|(
name|tablejump_p
argument_list|(
name|insn
argument_list|,
operator|&
name|label
argument_list|,
operator|&
name|table
argument_list|)
condition|)
name|delete_insn_chain
argument_list|(
name|label
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|next_nonnote_insn
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|barrier
operator|||
operator|!
name|BARRIER_P
argument_list|(
name|barrier
argument_list|)
condition|)
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|barrier
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Move the jump before barrier so that the notes 		 which originally were or were created before jump table are 		 inside the basic block.  */
name|rtx
name|new_insn
init|=
name|BB_END
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
init|;
name|tmp
operator|!=
name|barrier
condition|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|tmp
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|new_insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|new_insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|new_insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|new_insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|new_insn
argument_list|)
operator|=
name|barrier
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
argument_list|)
operator|=
name|new_insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|new_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
operator|=
name|new_insn
expr_stmt|;
block|}
block|}
block|}
comment|/* Keep only one edge out and set proper flags.  */
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|src
argument_list|)
condition|)
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|single_succ_p
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|single_succ_edge
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallthru
condition|)
name|e
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
else|else
name|e
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|src
operator|->
name|count
expr_stmt|;
comment|/* We don't want a block to end on a line-number note since that has      the potential of changing the code between -g and not -g.  */
while|while
condition|(
name|NOTE_P
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|delete_insn
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target
condition|)
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Redirect edge representing branch of (un)conditional jump or tablejump,    NULL on failure  */
end_comment

begin_function
specifier|static
name|edge
name|redirect_branch_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|old_label
init|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
decl_stmt|;
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* We can only redirect non-fallthru edges of jump insn.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Recognize a tablejump and adjust all matching cases.  */
if|if
condition|(
name|tablejump_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|j
decl_stmt|;
name|rtx
name|new_label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
block|}
comment|/* Handle casesi dispatch insns.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|SET_DEST
argument_list|(
name|tmp
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ?? We may play the games with moving the named labels from 	 one basic block to the other in case only one computed_jump is 	 available.  */
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
comment|/* A return instruction can't be redirected.  */
operator|||
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If the insn doesn't go where we think, we're confused.  */
name|gcc_assert
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|old_label
argument_list|)
expr_stmt|;
comment|/* If the substitution doesn't succeed, die.  This can happen 	 if the back end emitted unrecognizable instructions or if 	 target is exit block on some arches.  */
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|target
operator|==
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Edge %i->%i redirected to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target
condition|)
name|e
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Attempt to change code to redirect edge E to TARGET.  Don't do that on    expense of adding new instructions or reordering basic blocks.     Function can be also called with edge destination equivalent to the TARGET.    Then it should try the simplifications and do nothing if none is possible.     Return edge representing the branch if transformation succeeded.  Return NULL    on failure.    We still return NULL in case E already destinated TARGET and we didn't    managed to simplify instruction stream.  */
end_comment

begin_function
specifier|static
name|edge
name|rtl_redirect_edge_and_branch
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|edge
name|ret
decl_stmt|;
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|e
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|try_redirect_by_replacing_jump
argument_list|(
name|e
argument_list|,
name|target
argument_list|,
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|src
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|redirect_branch_edge
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|src
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Like force_nonfallthru below, but additionally performs redirection    Used by redirect_edge_and_branch_force.  */
end_comment

begin_function
specifier|static
name|basic_block
name|force_nonfallthru_and_redirect
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|basic_block
name|jump_block
decl_stmt|,
name|new_bb
init|=
name|NULL
decl_stmt|,
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|edge
name|new_edge
decl_stmt|;
name|int
name|abnormal_edge_flags
init|=
literal|0
decl_stmt|;
comment|/* In the case the last instruction is conditional jump to the next      instruction, first redirect the jump itself and then continue      by creating a basic block afterwards to redirect fallthru edge.  */
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|==
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|edge
name|b
init|=
name|unchecked_make_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bool
name|redirected
decl_stmt|;
name|redirected
operator|=
name|redirect_jump
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|redirected
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|->
name|probability
operator|=
name|prob
expr_stmt|;
name|b
operator|->
name|count
operator|=
name|e
operator|->
name|count
operator|*
name|prob
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|probability
operator|-=
name|e
operator|->
name|probability
expr_stmt|;
name|e
operator|->
name|count
operator|-=
name|b
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|probability
operator|<
literal|0
condition|)
name|e
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
condition|)
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
comment|/* Irritating special case - fallthru edge to the same block as abnormal 	 edge. 	 We can't redirect abnormal edge, but we still can split the fallthru 	 one and create separate abnormal edge to original destination. 	 This allows bb-reorder to make such edge non-fallthru.  */
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest
operator|==
name|target
argument_list|)
expr_stmt|;
name|abnormal_edge_flags
operator|=
name|e
operator|->
name|flags
operator|&
operator|~
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_CAN_FALLTHRU
operator|)
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
name|EDGE_FALLTHRU
operator||
name|EDGE_CAN_FALLTHRU
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
block|{
comment|/* We can't redirect the entry block.  Create an empty block 	     at the start of the function which we use to add the new 	     jump.  */
name|edge
name|tmp
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|basic_block
name|bb
init|=
name|create_basic_block
argument_list|(
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
decl_stmt|;
comment|/* Change the existing edge's source to be the new block, and add 	     a new edge from the entry block to the new block.  */
name|e
operator|->
name|src
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|)
init|;
operator|(
name|tmp
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|tmp
operator|==
name|e
condition|)
block|{
name|VEC_unordered_remove
argument_list|(
name|edge
argument_list|,
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|,
name|ei
operator|.
name|index
argument_list|)
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|,
name|bb
operator|->
name|succs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|e
operator|->
name|src
operator|->
name|succs
argument_list|)
operator|>=
literal|2
operator|||
name|abnormal_edge_flags
condition|)
block|{
comment|/* Create the new structures.  */
comment|/* If the old block ended with a tablejump, skip its table 	 by searching forward from there.  Otherwise start searching 	 forward from the last instruction of the old block.  */
if|if
condition|(
operator|!
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|note
argument_list|)
condition|)
name|note
operator|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|jump_block
operator|=
name|create_basic_block
argument_list|(
name|note
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|jump_block
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|loop_depth
operator|=
name|target
operator|->
name|loop_depth
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
condition|)
block|{
name|jump_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|jump_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|target
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|jump_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|target
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure new block ends up in correct hot/cold section.  */
name|BB_COPY_PARTITION
argument_list|(
name|jump_block
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
operator|&&
name|targetm
operator|.
name|have_named_sections
operator|&&
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
operator|&&
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
operator|&&
operator|(
name|EDGE_SUCC
argument_list|(
name|jump_block
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wire edge in.  */
name|new_edge
operator|=
name|make_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|jump_block
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|new_edge
operator|->
name|probability
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|new_edge
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Redirect old edge.  */
name|redirect_edge_pred
argument_list|(
name|e
argument_list|,
name|jump_block
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|new_bb
operator|=
name|jump_block
expr_stmt|;
block|}
else|else
name|jump_block
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_return
name|emit_jump_insn_after_noloc
argument_list|(
name|gen_return
argument_list|()
argument_list|,
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|rtx
name|label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|emit_jump_insn_after_noloc
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
expr_stmt|;
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|abnormal_edge_flags
condition|)
name|make_edge
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|abnormal_edge_flags
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Edge E is assumed to be fallthru edge.  Emit needed jump instruction    (and possibly create new basic block) to make edge non-fallthru.    Return newly created BB or NULL if none.  */
end_comment

begin_function
name|basic_block
name|force_nonfallthru
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
return|return
name|force_nonfallthru_and_redirect
argument_list|(
name|e
argument_list|,
name|e
operator|->
name|dest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Redirect edge even at the expense of creating new jump insn or    basic block.  Return new basic block if created, NULL otherwise.    Conversion must be possible.  */
end_comment

begin_function
specifier|static
name|basic_block
name|rtl_redirect_edge_and_branch_force
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
if|if
condition|(
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
operator|||
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|NULL
return|;
comment|/* In case the edge redirection failed, try to force it to be non-fallthru      and redirect newly created simplejump.  */
name|e
operator|->
name|src
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
return|return
name|force_nonfallthru_and_redirect
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The given edge should potentially be a fallthru edge.  If that is in    fact true, delete the jump and barriers that are in the way.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_tidy_fallthru_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|rtx
name|q
decl_stmt|;
name|basic_block
name|b
init|=
name|e
operator|->
name|src
decl_stmt|,
name|c
init|=
name|b
operator|->
name|next_bb
decl_stmt|;
comment|/* ??? In a late-running flow pass, other folks may have deleted basic      blocks by nopping out blocks, leaving multiple BARRIERs between here      and the target label. They ought to be chastised and fixed.       We can also wind up with a sequence of undeletable labels between      one block and the next.       So search through a sequence of barriers, labels, and notes for      the head of block C and assert that we really do fall through.  */
for|for
control|(
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
init|;
name|q
operator|!=
name|BB_HEAD
argument_list|(
name|c
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|q
argument_list|)
condition|)
return|return;
comment|/* Remove what will soon cease being the jump insn from the source block.      If block B consisted only of this single jump, turn it into a deleted      note.  */
name|q
operator|=
name|BB_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|q
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|q
argument_list|)
operator|&&
operator|(
name|any_uncondjump_p
argument_list|(
name|q
argument_list|)
operator|||
name|single_succ_p
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|q
argument_list|)
operator|&&
name|only_sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* We don't want a block to end on a line-number note since that has 	 the potential of changing the code between -g and not -g.  */
while|while
condition|(
name|NOTE_P
argument_list|(
name|q
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|>=
literal|0
condition|)
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Selectively unlink the sequence.  */
if|if
condition|(
name|q
operator|!=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
name|delete_insn_chain
argument_list|(
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Should move basic block BB after basic block AFTER.  NIY.  */
end_comment

begin_function
specifier|static
name|bool
name|rtl_move_block_after
parameter_list|(
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|after
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Split a (typically critical) edge.  Return the new block.    The edge must not be abnormal.     ??? The code generally expects to be called on critical edges.    The case of a block ending in an unconditional jump to a    block with multiple predecessors is not handled optimally.  */
end_comment

begin_function
specifier|static
name|basic_block
name|rtl_split_edge
parameter_list|(
name|edge
name|edge_in
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|before
decl_stmt|;
comment|/* Abnormal edges cannot be split.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
argument_list|)
expr_stmt|;
comment|/* We are going to place the new block in front of edge destination.      Avoid existence of fallthru predecessors.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|edge_in->dest->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
condition|)
name|force_nonfallthru
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* Create the basic block note.  */
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|before
operator|=
name|BB_HEAD
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|)
expr_stmt|;
else|else
name|before
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If this is a fall through edge to the exit block, the blocks might be      not adjacent, and the right place is the after the source.  */
if|if
condition|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|&&
name|edge_in
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
name|before
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|edge_in
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|=
name|create_basic_block
argument_list|(
name|before
argument_list|,
name|NULL
argument_list|,
name|edge_in
operator|->
name|src
argument_list|)
expr_stmt|;
name|BB_COPY_PARTITION
argument_list|(
name|bb
argument_list|,
name|edge_in
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb
operator|=
name|create_basic_block
argument_list|(
name|before
argument_list|,
name|NULL
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
comment|/* ??? Why not edge_in->dest->prev_bb here?  */
name|BB_COPY_PARTITION
argument_list|(
name|bb
argument_list|,
name|edge_in
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/* ??? This info is likely going to be out of date very soon.  */
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
condition|)
block|{
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|edge_in
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
comment|/* For non-fallthru edges, we must adjust the predecessor's      jump instruction to target our new block.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
name|edge
name|redirected
init|=
name|redirect_edge_and_branch
argument_list|(
name|edge_in
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|redirected
argument_list|)
expr_stmt|;
block|}
else|else
name|redirect_edge_succ
argument_list|(
name|edge_in
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Queue instructions for insertion on an edge between two basic blocks.    The new instructions and basic blocks (if any) will not appear in the    CFG until commit_edge_insertions is called.  */
end_comment

begin_function
name|void
name|insert_insn_on_edge
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
comment|/* We cannot insert instructions on an abnormal critical edge.      It will be easier to find the culprit if we die now.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|&&
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
operator|.
name|r
operator|==
name|NULL_RTX
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|e
operator|->
name|insns
operator|.
name|r
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|e
operator|->
name|insns
operator|.
name|r
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the CFG for the instructions queued on edge E.  */
end_comment

begin_function
specifier|static
name|void
name|commit_one_edge_insertion
parameter_list|(
name|edge
name|e
parameter_list|,
name|int
name|watch_calls
parameter_list|)
block|{
name|rtx
name|before
init|=
name|NULL_RTX
decl_stmt|,
name|after
init|=
name|NULL_RTX
decl_stmt|,
name|insns
decl_stmt|,
name|tmp
decl_stmt|,
name|last
decl_stmt|;
name|basic_block
name|bb
init|=
name|NULL
decl_stmt|;
comment|/* Pull the insns off the edge now since the edge might go away.  */
name|insns
operator|=
name|e
operator|->
name|insns
operator|.
name|r
expr_stmt|;
name|e
operator|->
name|insns
operator|.
name|r
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Special case -- avoid inserting code between call and storing      its return value.  */
if|if
condition|(
name|watch_calls
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|single_pred_p
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|CALL_P
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|after
operator|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* The first insn after the call may be a stack pop, skip it.  */
while|while
condition|(
name|next
operator|&&
name|keep_with_call_p
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|after
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|before
operator|&&
operator|!
name|after
condition|)
block|{
comment|/* Figure out where to put these things.  If the destination has 	 one predecessor, insert there.  Except for the exit block.  */
if|if
condition|(
name|single_pred_p
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Get the location correct wrt a code label, and "nice" wrt 	     a basic block note, and before everything else.  */
name|tmp
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
name|before
operator|=
name|tmp
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
condition|)
name|after
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|after
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* If the source has one successor and the edge is not abnormal, 	 insert there.  Except for the entry block.  */
elseif|else
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
operator|&&
name|single_succ_p
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
comment|/* It is possible to have a non-simple jump here.  Consider a target 	     where some forms of unconditional jumps clobber a register.  This 	     happens on the fr30 for example.  	     We know this block has a single successor, so we can just emit 	     the queued insns before the jump.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
name|before
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We'd better be fallthru, or we've lost track of 		 what's what.  */
name|gcc_assert
argument_list|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|after
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise we must split the edge.  */
else|else
block|{
name|bb
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|after
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
operator|&&
name|targetm
operator|.
name|have_named_sections
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|==
name|BB_COLD_PARTITION
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
block|{
name|rtx
name|bb_note
decl_stmt|,
name|cur_insn
decl_stmt|;
name|bb_note
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|cur_insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|cur_insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|cur_insn
operator|=
name|NEXT_INSN
argument_list|(
name|cur_insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|cur_insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|cur_insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
name|bb_note
operator|=
name|cur_insn
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
operator|(
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that we've found the spot, do the insertion.  */
if|if
condition|(
name|before
condition|)
block|{
name|emit_insn_before_noloc
argument_list|(
name|insns
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|prev_nonnote_insn
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
else|else
name|last
operator|=
name|emit_insn_after_noloc
argument_list|(
name|insns
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnjump_p
argument_list|(
name|last
argument_list|)
condition|)
block|{
comment|/* ??? Remove all outgoing edges from BB and add one for EXIT. 	 This is not currently a problem because this only happens 	 for the (single) epilogue, which already has a fallthru edge 	 to EXIT.  */
name|e
operator|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
condition|)
name|delete_insn
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
operator|!
name|JUMP_P
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the basic block for find_many_sub_basic_blocks.  */
name|bb
operator|->
name|aux
operator|=
operator|&
name|bb
operator|->
name|aux
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the CFG for all queued instructions.  */
end_comment

begin_function
name|void
name|commit_edge_insertions
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|sbitmap
name|blocks
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|insns
operator|.
name|r
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|commit_one_edge_insertion
argument_list|(
name|e
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
return|return;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|bb
operator|->
name|aux
condition|)
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Check for forgotten bb->aux values before commit_edge_insertions 	   call.  */
name|gcc_assert
argument_list|(
name|bb
operator|->
name|aux
operator|==
operator|&
name|bb
operator|->
name|aux
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
name|find_many_sub_basic_blocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the CFG for all queued instructions, taking special care of inserting    code on edges between call and storing its return value.  */
end_comment

begin_function
name|void
name|commit_edge_insertions_watch_calls
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|sbitmap
name|blocks
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|insns
operator|.
name|r
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|commit_one_edge_insertion
argument_list|(
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
return|return;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|bb
operator|->
name|aux
condition|)
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Check for forgotten bb->aux values before commit_edge_insertions 	   call.  */
name|gcc_assert
argument_list|(
name|bb
operator|->
name|aux
operator|==
operator|&
name|bb
operator|->
name|aux
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
name|find_many_sub_basic_blocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out RTL-specific basic block information (live information    at start and end).  */
end_comment

begin_function
specifier|static
name|void
name|rtl_dump_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|FILE
modifier|*
name|outf
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|char
modifier|*
name|s_indent
decl_stmt|;
name|s_indent
operator|=
name|alloca
argument_list|(
operator|(
name|size_t
operator|)
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s_indent
argument_list|,
literal|' '
argument_list|,
operator|(
name|size_t
operator|)
name|indent
argument_list|)
expr_stmt|;
name|s_indent
index|[
name|indent
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";;%s Registers live at start: "
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|,
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";;%s Registers live at end: "
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like print_rtl, but also print out live information for the start of each    basic block.  */
end_comment

begin_function
name|void
name|print_rtl_with_bb
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|rtx
name|rtx_first
parameter_list|)
block|{
name|rtx
name|tmp_rtx
decl_stmt|;
if|if
condition|(
name|rtx_first
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(nil)\n"
argument_list|)
expr_stmt|;
else|else
block|{
enum|enum
name|bb_state
block|{
name|NOT_IN_BB
block|,
name|IN_ONE_BB
block|,
name|IN_MULTIPLE_BB
block|}
enum|;
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|start
init|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|max_uid
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|end
init|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|max_uid
argument_list|)
decl_stmt|;
name|enum
name|bb_state
modifier|*
name|in_bb_p
init|=
name|XCNEWVEC
argument_list|(
expr|enum
name|bb_state
argument_list|,
name|max_uid
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|start
index|[
name|INSN_UID
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
name|end
index|[
name|INSN_UID
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|x
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|enum
name|bb_state
name|state
init|=
name|IN_MULTIPLE_BB
decl_stmt|;
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|NOT_IN_BB
condition|)
name|state
operator|=
name|IN_ONE_BB
expr_stmt|;
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
for|for
control|(
name|tmp_rtx
operator|=
name|rtx_first
init|;
name|NULL
operator|!=
name|tmp_rtx
condition|;
name|tmp_rtx
operator|=
name|NEXT_INSN
argument_list|(
name|tmp_rtx
argument_list|)
control|)
block|{
name|int
name|did_output
decl_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|start
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Start of basic block %d, registers live:"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|NOT_IN_BB
operator|&&
operator|!
name|NOTE_P
argument_list|(
name|tmp_rtx
argument_list|)
operator|&&
operator|!
name|BARRIER_P
argument_list|(
name|tmp_rtx
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is not within a basic block\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|IN_MULTIPLE_BB
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is in multiple basic blocks\n"
argument_list|)
expr_stmt|;
name|did_output
operator|=
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|tmp_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|end
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; End of basic block %d, registers live:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|did_output
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_bb_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_epilogue_delay_list
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\n;; Insns in epilogue delay list:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp_rtx
operator|=
name|current_function_epilogue_delay_list
init|;
name|tmp_rtx
operator|!=
literal|0
condition|;
name|tmp_rtx
operator|=
name|XEXP
argument_list|(
name|tmp_rtx
argument_list|,
literal|1
argument_list|)
control|)
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|XEXP
argument_list|(
name|tmp_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|update_br_prob_note
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
return|return;
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
condition|)
return|return;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the last insn associated with block BB (that includes barriers and    tablejumps after BB).  */
end_comment

begin_function
name|rtx
name|get_last_bb_insn
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|end
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* Include any jump table following the basic block.  */
if|if
condition|(
name|tablejump_p
argument_list|(
name|end
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
comment|/* Include any barriers that may follow the basic block.  */
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|end
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
operator|&&
name|BARRIER_P
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|end
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
return|return
name|end
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify the CFG and RTL consistency common for both underlying RTL and    cfglayout RTL.     Currently it does following checks:     - test head/end pointers    - overlapping of basic blocks    - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)    - tails of basic blocks (ensure that boundary is necessary)    - scans body of the basic block for JUMP_INSN, CODE_LABEL      and NOTE_INSN_BASIC_BLOCK    - verify that no fall_thru edge crosses hot/cold partition boundaries     In future it can be extended check a lot of other stuff as well    (reachability of basic blocks, life information, etc. etc.).  */
end_comment

begin_function
specifier|static
name|int
name|rtl_verify_flow_info_1
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|rtx
name|last_head
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|bb_info
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|bb_info
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|end
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* Verify the end of the basic block is in the INSN chain.  */
for|for
control|(
name|x
operator|=
name|last_head
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|x
operator|==
name|end
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_RTL
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"BB_RTL flag not set for block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"end insn %d for block %d not found in the insn stream"
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Work backwards from the end to the head of the basic block 	 to verify the head is in the RTL chain.  */
for|for
control|(
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
comment|/* While walking over the insn chain, verify insns appear 	     in only one basic block and initialize the BB_INFO array 	     used by other passes.  */
if|if
condition|(
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"insn %d is in multiple basic blocks (%d and %d)"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|head
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"head insn %d for block %d not found in the insn stream"
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_head
operator|=
name|x
expr_stmt|;
block|}
comment|/* Now check the basic blocks (boundaries etc.) */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|n_fallthru
init|=
literal|0
decl_stmt|,
name|n_eh
init|=
literal|0
decl_stmt|,
name|n_call
init|=
literal|0
decl_stmt|,
name|n_abnormal
init|=
literal|0
decl_stmt|,
name|n_branch
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|fallthru
init|=
name|NULL
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>=
literal|2
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|&&
name|profile_status
operator|!=
name|PROFILE_ABSENT
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: REG_BR_PROB does not match cfg %wi %i"
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|n_fallthru
operator|++
operator|,
name|fallthru
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
operator|||
operator|(
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"fallthru edge crosses section boundary (bb %i)"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|~
operator|(
name|EDGE_DFS_BACK
operator||
name|EDGE_CAN_FALLTHRU
operator||
name|EDGE_IRREDUCIBLE_LOOP
operator||
name|EDGE_LOOP_EXIT
operator||
name|EDGE_CROSSING
operator|)
operator|)
operator|==
literal|0
condition|)
name|n_branch
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL_CALL
condition|)
name|n_call
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
name|n_eh
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|n_abnormal
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n_eh
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|RESX
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"missing REG_EH_REGION note in the end of bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_branch
operator|&&
operator|(
operator|!
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|||
operator|(
name|n_branch
operator|>
literal|1
operator|&&
operator|(
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|||
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"too many outgoing branch edges from bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_fallthru
operator|&&
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fallthru edge after unconditional jump %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_branch
operator|!=
literal|1
operator|&&
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong amount of branch edges after unconditional jump %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_branch
operator|!=
literal|1
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|BB_HEAD
argument_list|(
name|fallthru
operator|->
name|dest
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong amount of branch edges after conditional jump %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_call
operator|&&
operator|!
name|CALL_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"call edges for non-call insn in bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_abnormal
operator|&&
operator|(
operator|!
name|CALL_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
name|n_call
operator|!=
name|n_abnormal
operator|)
operator|&&
operator|(
operator|!
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|||
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|||
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"abnormal edges for no purpose in bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|x
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
comment|/* We may have a barrier inside a basic block before dead code 	   elimination.  There is no BLOCK_FOR_INSN field in a barrier.  */
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|x
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
condition|)
name|error
argument_list|(
literal|"insn %d inside basic block %d but block_for_insn is NULL"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"insn %d inside basic block %d but block_for_insn is %i"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* OK pointers are correct.  Now check the header of basic 	 block.  It ought to contain optional CODE_LABEL followed 	 by NOTE_BASIC_BLOCK.  */
name|x
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|x
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK is missing for block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
operator|||
name|NOTE_BASIC_BLOCK
argument_list|(
name|x
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK is missing for block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|x
condition|)
comment|/* Do checks for empty blocks here.  */
empty_stmt|;
else|else
for|for
control|(
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK %d in middle of basic block %d"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"in basic block %d:"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"flow control insn inside a basic block"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Verify the CFG and RTL consistency common for both underlying RTL and    cfglayout RTL.     Currently it does following checks:    - all checks of rtl_verify_flow_info_1    - check that all insns are in the basic blocks      (except the switch handling code, barriers and notes)    - check that all returns are followed by barriers    - check that all fallthru edge points to the adjacent blocks.  */
end_comment

begin_function
specifier|static
name|int
name|rtl_verify_flow_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|err
init|=
name|rtl_verify_flow_info_1
argument_list|()
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|num_bb_notes
decl_stmt|;
specifier|const
name|rtx
name|rtx_first
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|basic_block
name|last_bb_seen
init|=
name|ENTRY_BLOCK_PTR
decl_stmt|,
name|curr_bb
init|=
name|NULL
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|predictions
condition|)
block|{
name|error
argument_list|(
literal|"bb prediction set for block %i, but it is not used in RTL land"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Ensure existence of barrier in BB with no fallthru edges.  */
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|insn
operator|||
operator|!
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|!
name|insn
operator|||
operator|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"missing barrier after block %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|next_bb
operator|!=
name|e
operator|->
name|dest
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Incorrect blocks for fallthru %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|||
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Incorrect fallthru %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"wrong insn in the fallthru edge"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|num_bb_notes
operator|=
literal|0
expr_stmt|;
name|last_bb_seen
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rtx_first
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|bb
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|num_bb_notes
operator|++
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
name|last_bb_seen
operator|->
name|next_bb
condition|)
name|internal_error
argument_list|(
literal|"basic blocks not laid down consecutively"
argument_list|)
expr_stmt|;
name|curr_bb
operator|=
name|last_bb_seen
operator|=
name|bb
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curr_bb
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
break|break;
case|case
name|CODE_LABEL
case|:
comment|/* An addr_vec is placed outside any basic block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|&&
name|JUMP_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* But in any case, non-deletable labels can appear anywhere.  */
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"insn outside basic block"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|x
argument_list|)
operator|&&
name|returnjump_p
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|condjump_p
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|&&
name|BARRIER_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
name|fatal_insn
argument_list|(
literal|"return not followed by barrier"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_bb
operator|&&
name|x
operator|==
name|BB_END
argument_list|(
name|curr_bb
argument_list|)
condition|)
name|curr_bb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|num_bb_notes
operator|!=
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
condition|)
name|internal_error
argument_list|(
literal|"number of bb notes in insn chain (%d) != n_basic_blocks (%d)"
argument_list|,
name|num_bb_notes
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assume that the preceding pass has possibly eliminated jump instructions    or converted the unconditional jumps.  Eliminate the edges from CFG.    Return true if any edges are eliminated.  */
end_comment

begin_function
name|bool
name|purge_dead_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|,
name|note
decl_stmt|;
name|bool
name|purged
init|=
name|false
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* If this instruction cannot trap, remove REG_EH_REGION notes.  */
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|eqnote
decl_stmt|;
if|if
condition|(
operator|!
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|eqnote
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|eqnote
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup abnormal edges caused by exceptions or non-local gotos.  */
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
comment|/* There are three types of edges we need to handle correctly here: EH 	 edges, abnormal call EH edges, and abnormal call non-EH edges.  The 	 latter can appear when nonlocal gotos are used.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
if|if
condition|(
name|can_throw_internal
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
comment|/* If this is a call edge, verify that this is a call insn.  */
operator|&&
operator|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL_CALL
operator|)
operator|||
name|CALL_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL_CALL
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|purged
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|edge
name|b
decl_stmt|,
name|f
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* We do care only about conditional jumps and simplejumps.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|returnjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|purged
return|;
comment|/* Branch probability/prediction notes are defined only for 	 condjumps.  We've possibly turned condjump into simplejump.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PRED
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
comment|/* Avoid abnormal flags to leak from computed jumps turned 	     into simplejumps.  */
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_ABNORMAL
expr_stmt|;
comment|/* See if this edge is one we should keep.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* A conditional jump can fall through into the next 	       block, so we should keep the edge.  */
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* If the destination block is the target of the jump, 	       keep the edge.  */
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* If the destination block is the exit block, and this 	       instruction is a return, then keep the edge.  */
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
operator|&&
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* Keep the edges that correspond to exceptions thrown by 	       this instruction and rematerialize the EDGE_ABNORMAL 	       flag we just cleared above.  */
block|{
name|e
operator|->
name|flags
operator||=
name|EDGE_ABNORMAL
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We do not need this edge.  */
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|purged
operator|=
name|true
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|purged
condition|)
return|return
name|purged
return|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Purged edges from bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
name|purged
return|;
comment|/* Redistribute probabilities.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
return|return
name|purged
return|;
name|b
operator|=
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|f
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|b
operator|->
name|probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|b
operator|->
name|probability
expr_stmt|;
name|b
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|b
operator|->
name|probability
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|f
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|f
operator|->
name|probability
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
return|return
name|purged
return|;
block|}
elseif|else
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* First, there should not be any EH or ABCALL edges resulting 	 from non-local gotos and the like.  If there were, we shouldn't 	 have created the sibcall in the first place.  Second, there 	 should of course never have been a fallthru edge.  */
name|gcc_assert
argument_list|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator|==
operator|(
name|EDGE_SIBCALL
operator||
name|EDGE_ABNORMAL
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we don't see a jump insn, we don't know exactly why the block would      have been broken at this point.  Look for a simple, non-fallthru edge,      as these are only created by conditional branches.  If we find such an      edge we know that there used to be a jump here and can then safely      remove all non-fallthru edges.  */
name|found
operator|=
name|false
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FALLTHRU
operator|)
operator|)
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
name|purged
return|;
comment|/* Remove all but the fake and fallthru edges.  The fake edge may be      the only successor for this block in the case of noreturn      calls.  */
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
block|{
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|purged
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Purged non-fallthru edges from bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|purged
return|;
block|}
end_function

begin_comment
comment|/* Search all basic blocks for potentially dead edges and purge them.  Return    true if some edge has been eliminated.  */
end_comment

begin_function
name|bool
name|purge_all_dead_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|purged
init|=
name|false
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bool
name|purged_here
init|=
name|purge_dead_edges
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|purged
operator||=
name|purged_here
expr_stmt|;
block|}
return|return
name|purged
return|;
block|}
end_function

begin_comment
comment|/* Same as split_block but update cfg_layout structures.  */
end_comment

begin_function
specifier|static
name|basic_block
name|cfg_layout_split_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|insnp
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|insnp
decl_stmt|;
name|basic_block
name|new_bb
init|=
name|rtl_split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|NULL
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Redirect Edge to DEST.  */
end_comment

begin_function
specifier|static
name|edge
name|cfg_layout_redirect_edge_and_branch
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|edge
name|ret
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|dest
condition|)
return|return
name|e
return|;
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|(
name|ret
operator|=
name|try_redirect_by_replacing_jump
argument_list|(
name|e
argument_list|,
name|dest
argument_list|,
name|true
argument_list|)
operator|)
condition|)
block|{
name|src
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Redirecting entry edge from bb %i to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|e
operator|->
name|src
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
comment|/* Redirect_edge_and_branch may decide to turn branch into fallthru edge      in the case the basic block appears to be in sequence.  Avoid this      transformation.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
comment|/* Redirect any branch edges unified with the fallthru one.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
operator|&&
name|label_is_jump_target_p
argument_list|(
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
name|edge
name|redirected
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Fallthru edge unified with branch "
literal|"%i->%i redirected to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|redirected
operator|=
name|redirect_branch_edge
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|redirected
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|e
operator|->
name|src
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
return|return
name|e
return|;
block|}
comment|/* In case we are redirecting fallthru edge to the branch edge 	 of conditional jump, remove it.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|src
operator|->
name|succs
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Find the edge that is different from E.  */
name|edge
name|s
init|=
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|dest
operator|==
name|dest
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Fallthru edge %i->%i redirected to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|redirect_branch_edge
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* We don't want simplejumps in the insn stream during cfglayout.  */
name|gcc_assert
argument_list|(
operator|!
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Simple wrapper as we always can redirect fallthru edges.  */
end_comment

begin_function
specifier|static
name|basic_block
name|cfg_layout_redirect_edge_and_branch_force
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|edge
name|redirected
init|=
name|cfg_layout_redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|redirected
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Same as delete_basic_block but update cfg_layout structures.  */
end_comment

begin_function
specifier|static
name|void
name|cfg_layout_delete_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|prev
init|=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
decl_stmt|,
modifier|*
name|to
decl_stmt|,
name|remaints
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
condition|)
block|{
name|next
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
expr_stmt|;
else|else
name|set_first_insn
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
argument_list|)
operator|=
name|prev
expr_stmt|;
name|insn
operator|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
condition|)
block|{
name|insn
operator|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
condition|)
block|{
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
expr_stmt|;
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
argument_list|)
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
else|else
name|set_last_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|to
operator|=
operator|&
name|bb
operator|->
name|next_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
expr_stmt|;
else|else
name|to
operator|=
operator|&
name|cfg_layout_function_footer
expr_stmt|;
name|rtl_delete_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
else|else
name|prev
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
operator|!=
name|prev
condition|)
block|{
name|remaints
operator|=
name|unlink_insn_chain
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|insn
operator|=
name|remaints
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
operator|*
name|to
expr_stmt|;
if|if
condition|(
operator|*
name|to
condition|)
name|PREV_INSN
argument_list|(
operator|*
name|to
argument_list|)
operator|=
name|insn
expr_stmt|;
operator|*
name|to
operator|=
name|remaints
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true when blocks A and B can be safely merged.  */
end_comment

begin_function
specifier|static
name|bool
name|cfg_layout_can_merge_blocks_p
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
comment|/* If we are partitioning hot/cold basic blocks, we don't want to      mess up unconditional or indirect jumps that cross between hot      and cold sections.       Basic block partitioning may result in some jumps that appear to      be optimizable (or blocks that appear to be mergeable), but which really      must be left untouched (they are required to make it safely across      partition boundaries).  See  the comments at the top of      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|a
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* There must be exactly one edge in between the blocks.  */
return|return
operator|(
name|single_succ_p
argument_list|(
name|a
argument_list|)
operator|&&
name|single_succ
argument_list|(
name|a
argument_list|)
operator|==
name|b
operator|&&
name|single_pred_p
argument_list|(
name|b
argument_list|)
operator|==
literal|1
operator|&&
name|a
operator|!=
name|b
comment|/* Must be simple edge.  */
operator|&&
operator|!
operator|(
name|single_succ_edge
argument_list|(
name|a
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|a
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|b
operator|!=
name|EXIT_BLOCK_PTR
comment|/* If the jump insn has side effects, 	     we can't kill the edge.  */
operator|&&
operator|(
operator|!
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|||
operator|(
name|reload_completed
condition|?
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
else|:
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Merge block A and B.  The blocks must be mergeable.  */
end_comment

begin_function
specifier|static
name|void
name|cfg_layout_merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|cfg_layout_can_merge_blocks_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If there was a CODE_LABEL beginning B, delete it.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This might have been an EH label that no longer has incoming 	 EH edges.  Update data structures to match.  */
name|maybe_remove_eh_handler
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We should have fallthru edge in a, or we can do dummy redirection to get      it cleaned up.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
name|try_redirect_by_replacing_jump
argument_list|(
name|EDGE_SUCC
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Possible line number notes should appear in between.  */
if|if
condition|(
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
condition|)
block|{
name|rtx
name|first
init|=
name|BB_END
argument_list|(
name|a
argument_list|)
decl_stmt|,
name|last
decl_stmt|;
name|last
operator|=
name|emit_insn_after_noloc
argument_list|(
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
argument_list|,
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|header
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* In the case basic blocks are not adjacent, move them around.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|!=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|rtx
name|first
init|=
name|unlink_insn_chain
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_after_noloc
argument_list|(
name|first
argument_list|,
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip possible DELETED_LABEL insn.  */
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|first
argument_list|)
condition|)
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|delete_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise just re-associate the instructions.  */
else|else
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Skip possible DELETED_LABEL insn.  */
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BB_END
argument_list|(
name|a
argument_list|)
operator|=
name|BB_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Possible tablejumps and barriers should appear after the block.  */
if|if
condition|(
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
condition|)
block|{
if|if
condition|(
operator|!
name|a
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
condition|)
name|a
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
expr_stmt|;
else|else
block|{
name|rtx
name|last
init|=
name|a
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
decl_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
expr_stmt|;
name|PREV_INSN
argument_list|(
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
argument_list|)
operator|=
name|last
expr_stmt|;
block|}
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|NULL
expr_stmt|;
block|}
name|a
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Merged blocks %d and %d.\n"
argument_list|,
name|a
operator|->
name|index
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split edge E.  */
end_comment

begin_function
specifier|static
name|basic_block
name|cfg_layout_split_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|new_bb
init|=
name|create_basic_block
argument_list|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|?
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
else|:
name|get_insns
argument_list|()
argument_list|,
name|NULL_RTX
argument_list|,
name|e
operator|->
name|src
argument_list|)
decl_stmt|;
comment|/* ??? This info is likely going to be out of date very soon, but we must      create it to avoid getting an ICE later.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
condition|)
block|{
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
name|make_edge
argument_list|(
name|new_bb
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Do postprocessing after making a forwarder block joined by edge FALLTHRU.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_make_forwarder_block
parameter_list|(
name|edge
name|fallthru
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Return 1 if BB ends with a call, possibly followed by some    instructions that must stay with the call, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|rtl_block_ends_with_call_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|&&
name|keep_with_call_p
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if BB ends with a conditional branch, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|rtl_block_ends_with_condjump_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
return|return
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if we need to add fake edge to exit.    Helper function for rtl_flow_call_edges_add.  */
end_comment

begin_function
specifier|static
name|bool
name|need_fake_edge_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|asm_noperands
argument_list|(
name|insn
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add fake edges to the function exit for any non constant and non noreturn    calls, volatile inline assembly in the bitmap of blocks specified by    BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks    that were split.     The goal is to expose cases in which entering a basic block does not imply    that all subsequent instructions must be executed.  */
end_comment

begin_function
specifier|static
name|int
name|rtl_flow_call_edges_add
parameter_list|(
name|sbitmap
name|blocks
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|blocks_split
init|=
literal|0
decl_stmt|;
name|int
name|last_bb
init|=
name|last_basic_block
decl_stmt|;
name|bool
name|check_last_block
init|=
name|false
decl_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|==
name|NUM_FIXED_BLOCKS
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|blocks
condition|)
name|check_last_block
operator|=
name|true
expr_stmt|;
else|else
name|check_last_block
operator|=
name|TEST_BIT
argument_list|(
name|blocks
argument_list|,
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* In the last basic block, before epilogue generation, there will be      a fallthru edge to EXIT.  Special care is required if the last insn      of the last basic block is a call because make_edge folds duplicate      edges, which would result in the fallthru edge also being marked      fake, which would result in the fallthru edge being removed by      remove_fake_edges, which would result in an invalid CFG.       Moreover, we can't elide the outgoing fake edge, since the block      profiler needs to take this into account in order to solve the minimal      spanning tree in the case that the call doesn't return.       Handle this by adding a dummy instruction in a new last basic block.  */
if|if
condition|(
name|check_last_block
condition|)
block|{
name|basic_block
name|bb
init|=
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* Back up past insns that must be kept in the same block as a call.  */
while|while
condition|(
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|&&
name|keep_with_call_p
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fake_edge_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|insert_insn_on_edge
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|commit_edge_insertions
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Now add fake edges to the function exit for any non constant      calls since there is no way that we can determine if they will      return or not...  */
for|for
control|(
name|i
operator|=
name|NUM_FIXED_BLOCKS
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
continue|continue;
if|if
condition|(
name|blocks
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|blocks
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|prev_insn
control|)
block|{
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fake_edge_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|rtx
name|split_at_insn
init|=
name|insn
decl_stmt|;
comment|/* Don't split the block between a call and an insn that should 		 remain in the same block as the call.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
while|while
condition|(
name|split_at_insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|&&
name|keep_with_call_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|split_at_insn
argument_list|)
argument_list|)
condition|)
name|split_at_insn
operator|=
name|NEXT_INSN
argument_list|(
name|split_at_insn
argument_list|)
expr_stmt|;
comment|/* The handling above of the final block before the epilogue 		 should be enough to verify that there is no edge to the exit 		 block in CFG already.  Calling make_edge in such case would 		 cause us to mark that edge as fake and remove it later.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|split_at_insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Note that the following may create a new basic block 		 and renumber the existing basic blocks.  */
if|if
condition|(
name|split_at_insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|e
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|split_at_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|blocks_split
operator|++
expr_stmt|;
block|}
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|blocks_split
condition|)
name|verify_flow_info
argument_list|()
expr_stmt|;
return|return
name|blocks_split
return|;
block|}
end_function

begin_comment
comment|/* Add COMP_RTX as a condition at end of COND_BB.  FIRST_HEAD is    the conditional branch target, SECOND_HEAD should be the fall-thru    there is no need to handle this here the loop versioning code handles    this.  the reason for SECON_HEAD is that it is needed for condition    in trees, and this should be of the same type since it is a hook.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_lv_add_condition_to_bb
parameter_list|(
name|basic_block
name|first_head
parameter_list|,
name|basic_block
name|second_head
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|cond_bb
parameter_list|,
name|void
modifier|*
name|comp_rtx
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|,
name|seq
decl_stmt|,
name|jump
decl_stmt|;
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
operator|(
name|rtx
operator|)
name|comp_rtx
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
operator|(
name|rtx
operator|)
name|comp_rtx
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|comp
init|=
name|GET_CODE
argument_list|(
operator|(
name|rtx
operator|)
name|comp_rtx
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|first_head
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|comp
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|jump
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Add the new cond , in the new head.  */
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|BB_END
argument_list|(
name|cond_bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a block B with unconditional branch at its end, get the    store the return the branch edge and the fall-thru edge in    BRANCH_EDGE and FALLTHRU_EDGE respectively.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_extract_cond_bb_edges
parameter_list|(
name|basic_block
name|b
parameter_list|,
name|edge
modifier|*
name|branch_edge
parameter_list|,
name|edge
modifier|*
name|fallthru_edge
parameter_list|)
block|{
name|edge
name|e
init|=
name|EDGE_SUCC
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
operator|*
name|fallthru_edge
operator|=
name|e
expr_stmt|;
operator|*
name|branch_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|branch_edge
operator|=
name|e
expr_stmt|;
operator|*
name|fallthru_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_rtl_bb_info
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|bb
operator|->
name|il
operator|.
name|rtl
argument_list|)
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtl_bb_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add EXPR to the end of basic block BB.  */
end_comment

begin_function
name|rtx
name|insert_insn_end_bb_new
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|new_insn
decl_stmt|;
name|rtx
name|pat_end
init|=
name|pat
decl_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|pat_end
argument_list|)
operator|!=
name|NULL_RTX
condition|)
name|pat_end
operator|=
name|NEXT_INSN
argument_list|(
name|pat_end
argument_list|)
expr_stmt|;
comment|/* If the last insn is a jump, insert EXPR in front [taking care to      handle cc0, etc. properly].  Similarly we need to care trapping      instructions in presence of non-call exceptions.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|||
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|note
decl_stmt|;
endif|#
directive|endif
comment|/* If this is a jump table, then we can't insert stuff here.  Since          we know the previous real insn must be the tablejump, we insert          the new instruction just before the tablejump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts          if cc0 isn't set.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|maybe_cc0_setter
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|maybe_cc0_setter
operator|&&
name|INSN_P
argument_list|(
name|maybe_cc0_setter
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|maybe_cc0_setter
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|maybe_cc0_setter
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FIXME: What if something in cc0/jump uses value set in new          insn?  */
name|new_insn
operator|=
name|emit_insn_before_noloc
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise if the last insn is a call, as will happen in the presence      of exception handling.  */
elseif|else
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|||
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
block|{
comment|/* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,          we search backward and place the instructions before the first          parameter is loaded.  Do this for everyone for consistency and a          presumption that we'll get better code elsewhere as well.  */
comment|/* Since different machines initialize their parameter registers          in different orders, assume nothing.  Collect the set of all          parameter registers.  */
name|insn
operator|=
name|find_first_parameter_load
argument_list|(
name|insn
argument_list|,
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we found all the parameter loads, then we want to insert          before the first parameter load.           If we did not find all the parameter loads, then we might have          stopped on the head of the block, which could be a CODE_LABEL.          If we inserted before the CODE_LABEL, then we would be putting          the insn in the wrong basic block.  In that case, put the insn          after the CODE_LABEL.  Also, respect NOTE_INSN_BASIC_BLOCK.  */
while|while
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before_noloc
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|new_insn
operator|=
name|emit_insn_after_noloc
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|new_insn
return|;
block|}
end_function

begin_comment
comment|/* Implementation of CFG manipulation for linearized RTL.  */
end_comment

begin_decl_stmt
name|struct
name|cfg_hooks
name|rtl_cfg_hooks
init|=
block|{
literal|"rtl"
block|,
name|rtl_verify_flow_info
block|,
name|rtl_dump_bb
block|,
name|rtl_create_basic_block
block|,
name|rtl_redirect_edge_and_branch
block|,
name|rtl_redirect_edge_and_branch_force
block|,
name|rtl_delete_block
block|,
name|rtl_split_block
block|,
name|rtl_move_block_after
block|,
name|rtl_can_merge_blocks
block|,
comment|/* can_merge_blocks_p */
name|rtl_merge_blocks
block|,
name|rtl_predict_edge
block|,
name|rtl_predicted_by_p
block|,
name|NULL
block|,
comment|/* can_duplicate_block_p */
name|NULL
block|,
comment|/* duplicate_block */
name|rtl_split_edge
block|,
name|rtl_make_forwarder_block
block|,
name|rtl_tidy_fallthru_edge
block|,
name|rtl_block_ends_with_call_p
block|,
name|rtl_block_ends_with_condjump_p
block|,
name|rtl_flow_call_edges_add
block|,
name|NULL
block|,
comment|/* execute_on_growing_pred */
name|NULL
block|,
comment|/* execute_on_shrinking_pred */
name|NULL
block|,
comment|/* duplicate loop for trees */
name|NULL
block|,
comment|/* lv_add_condition_to_bb */
name|NULL
block|,
comment|/* lv_adjust_loop_header_phi*/
name|NULL
block|,
comment|/* extract_cond_bb_edges */
name|NULL
comment|/* flush_pending_stmts */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implementation of CFG manipulation for cfg layout RTL, where    basic block connected via fallthru edges does not have to be adjacent.    This representation will hopefully become the default one in future    version of the compiler.  */
end_comment

begin_comment
comment|/* We do not want to declare these functions in a header file, since they    should only be used through the cfghooks interface, and we do not want to    move them here since it would require also moving quite a lot of related    code.  */
end_comment

begin_function_decl
specifier|extern
name|bool
name|cfg_layout_can_duplicate_bb_p
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|basic_block
name|cfg_layout_duplicate_bb
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfg_hooks
name|cfg_layout_rtl_cfg_hooks
init|=
block|{
literal|"cfglayout mode"
block|,
name|rtl_verify_flow_info_1
block|,
name|rtl_dump_bb
block|,
name|cfg_layout_create_basic_block
block|,
name|cfg_layout_redirect_edge_and_branch
block|,
name|cfg_layout_redirect_edge_and_branch_force
block|,
name|cfg_layout_delete_block
block|,
name|cfg_layout_split_block
block|,
name|rtl_move_block_after
block|,
name|cfg_layout_can_merge_blocks_p
block|,
name|cfg_layout_merge_blocks
block|,
name|rtl_predict_edge
block|,
name|rtl_predicted_by_p
block|,
name|cfg_layout_can_duplicate_bb_p
block|,
name|cfg_layout_duplicate_bb
block|,
name|cfg_layout_split_edge
block|,
name|rtl_make_forwarder_block
block|,
name|NULL
block|,
name|rtl_block_ends_with_call_p
block|,
name|rtl_block_ends_with_condjump_p
block|,
name|rtl_flow_call_edges_add
block|,
name|NULL
block|,
comment|/* execute_on_growing_pred */
name|NULL
block|,
comment|/* execute_on_shrinking_pred */
name|duplicate_loop_to_header_edge
block|,
comment|/* duplicate loop for trees */
name|rtl_lv_add_condition_to_bb
block|,
comment|/* lv_add_condition_to_bb */
name|NULL
block|,
comment|/* lv_adjust_loop_header_phi*/
name|rtl_extract_cond_bb_edges
block|,
comment|/* extract_cond_bb_edges */
name|NULL
comment|/* flush_pending_stmts */
block|}
decl_stmt|;
end_decl_stmt

end_unit

