begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph manipulation code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains low level functions to manipulate the CFG and analyze it    that are aware of the RTL intermediate language.     Available functionality:      - Basic CFG/RTL manipulation API documented in cfghooks.h      - CFG-aware instruction chain manipulation 	 delete_insn, delete_insn_chain      - Edge splitting and committing to edges 	 insert_insn_on_edge, commit_edge_insertions      - CFG updating after insn simplification 	 purge_dead_edges, purge_all_dead_edges     Functions not supposed for generic use:      - Infrastructure to determine quickly basic block for insn 	 compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,      - Edge redirection with updating and optimizing of insn chain 	 block_label, tidy_fallthru_edge, force_nonfallthru  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_comment
comment|/* Stubs in case we don't have a return insn.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_return
end_ifndef

begin_define
define|#
directive|define
name|HAVE_return
value|0
end_define

begin_define
define|#
directive|define
name|gen_return
parameter_list|()
value|NULL_RTX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */
end_comment

begin_comment
comment|/* ??? Should probably be using LABEL_NUSES instead.  It would take a    bit of surgery to be able to use or co-opt the routines in jump.  */
end_comment

begin_decl_stmt
name|rtx
name|label_value_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|tail_recursion_label_list
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|can_delete_note_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_delete_label_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|commit_one_edge_insertion
parameter_list|(
name|edge
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|last_loop_beg_note
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|back_edge_of_syntactic_loop_p
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|basic_block
name|force_nonfallthru_and_redirect
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|rtl_split_edge
parameter_list|(
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtl_verify_flow_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|cfg_layout_split_block
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cfg_layout_redirect_edge_and_branch
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|cfg_layout_redirect_edge_and_branch_force
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfg_layout_delete_block
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtl_delete_block
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|rtl_redirect_edge_and_branch_force
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rtl_redirect_edge_and_branch
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|rtl_split_block
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtl_dump_bb
parameter_list|(
name|basic_block
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtl_verify_flow_info_1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_killed_regs
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return true if NOTE is not one of the ones that must be kept paired,    so that we may simply delete it.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_note_p
parameter_list|(
name|rtx
name|note
parameter_list|)
block|{
return|return
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_PREDICTION
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True if a given label can be deleted.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_label_p
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
return|return
operator|(
operator|!
name|LABEL_PRESERVE_P
argument_list|(
name|label
argument_list|)
comment|/* User declared labels must be preserved.  */
operator|&&
name|LABEL_NAME
argument_list|(
name|label
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|in_expr_list_p
argument_list|(
name|forced_labels
argument_list|,
name|label
argument_list|)
operator|&&
operator|!
name|in_expr_list_p
argument_list|(
name|label_value_list
argument_list|,
name|label
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete INSN by patching it out.  Return the next insn.  */
end_comment

begin_function
name|rtx
name|delete_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|bool
name|really_delete
init|=
name|true
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* Some labels can't be directly removed from the INSN chain, as they          might be references via variables, constant pool etc.          Convert them to the special NOTE_INSN_DELETED_LABEL note.  */
if|if
condition|(
operator|!
name|can_delete_label_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|really_delete
operator|=
name|false
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED_LABEL
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
name|remove_node_from_expr_list
argument_list|(
name|insn
argument_list|,
operator|&
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|really_delete
condition|)
block|{
comment|/* If this insn has already been deleted, something is very wrong.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If deleting a jump, decrement the use count of the label.  Deleting      the label itself should happen in the normal course of block merging.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|--
expr_stmt|;
comment|/* Also if deleting an insn that references a label.  */
else|else
block|{
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* When deleting code in bulk (e.g. removing many unreachable 	     blocks) we can delete a label that's a target of the vector 	     before deleting the vector itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|NOTE
condition|)
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|--
expr_stmt|;
block|}
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Like delete_insn but also purge dead edges from BB.  */
end_comment

begin_function
name|rtx
name|delete_insn_and_edges
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|bool
name|purge
init|=
name|false
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|BB_END
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|insn
condition|)
name|purge
operator|=
name|true
expr_stmt|;
name|x
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|purge
condition|)
name|purge_dead_edges
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Unlink a chain of insns between START and FINISH, leaving notes    that must be paired.  */
end_comment

begin_function
name|void
name|delete_insn_chain
parameter_list|(
name|rtx
name|start
parameter_list|,
name|rtx
name|finish
parameter_list|)
block|{
name|rtx
name|next
decl_stmt|;
comment|/* Unchain the insns one by one.  It would be quicker to delete all of these      with a single unchaining, rather than one at a time, but we need to keep      the NOTE's.  */
while|while
condition|(
literal|1
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|NOTE
operator|&&
operator|!
name|can_delete_note_p
argument_list|(
name|start
argument_list|)
condition|)
empty_stmt|;
else|else
name|next
operator|=
name|delete_insn
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|finish
condition|)
break|break;
name|start
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like delete_insn but also purge dead edges from BB.  */
end_comment

begin_function
name|void
name|delete_insn_chain_and_edges
parameter_list|(
name|rtx
name|first
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|bool
name|purge
init|=
name|false
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|last
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|last
argument_list|)
operator|&&
name|BB_END
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|last
condition|)
name|purge
operator|=
name|true
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|purge
condition|)
name|purge_dead_edges
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new basic block consisting of the instructions between HEAD and END    inclusive.  This function is designed to allow fast BB construction - reuses    the note and basic block struct in BB_NOTE, if any and do not grow    BASIC_BLOCK chain and should be used directly only by CFG construction code.    END can be NULL in to create new empty basic block before HEAD.  Both END    and HEAD can be NULL to create basic block at the end of INSN chain.    AFTER is the basic block we should be put after.  */
end_comment

begin_function
name|basic_block
name|create_basic_block_structure
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|end
parameter_list|,
name|rtx
name|bb_note
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|bb_note
operator|&&
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|bb_note
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bb
operator|->
name|aux
operator|==
name|NULL
condition|)
block|{
comment|/* If we found an existing note, thread it back onto the chain.  */
name|rtx
name|after
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|after
operator|=
name|head
expr_stmt|;
else|else
block|{
name|after
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
block|}
if|if
condition|(
name|after
operator|!=
name|bb_note
operator|&&
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|!=
name|bb_note
condition|)
name|reorder_insns_nobb
argument_list|(
name|bb_note
argument_list|,
name|bb_note
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise we must create a note and a basic block structure.  */
name|bb
operator|=
name|alloc_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|head
operator|&&
operator|!
name|end
condition|)
name|head
operator|=
name|end
operator|=
name|bb_note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|end
condition|)
block|{
name|bb_note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|end
condition|)
name|end
operator|=
name|bb_note
expr_stmt|;
block|}
else|else
block|{
name|bb_note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|end
operator|=
name|head
expr_stmt|;
block|}
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
comment|/* Always include the bb note in the block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
operator|==
name|bb_note
condition|)
name|end
operator|=
name|bb_note
expr_stmt|;
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|head
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|end
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|last_basic_block
operator|++
expr_stmt|;
name|bb
operator|->
name|flags
operator|=
name|BB_NEW
expr_stmt|;
name|link_block
argument_list|(
name|bb
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|bb
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Tag the block so that we know it has been used when considering      other basic block notes.  */
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Create new basic block consisting of instructions in between HEAD and END    and place it to the BB chain after block AFTER.  END can be NULL in to    create new empty basic block before HEAD.  Both END and HEAD can be NULL to    create basic block at the end of INSN chain.  */
end_comment

begin_function
specifier|static
name|basic_block
name|rtl_create_basic_block
parameter_list|(
name|void
modifier|*
name|headp
parameter_list|,
name|void
modifier|*
name|endp
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|rtx
name|head
init|=
name|headp
decl_stmt|,
name|end
init|=
name|endp
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Place the new block just after the end.  */
name|VARRAY_GROW
argument_list|(
name|basic_block_info
argument_list|,
name|last_basic_block
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n_basic_blocks
operator|++
expr_stmt|;
name|bb
operator|=
name|create_basic_block_structure
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|NULL
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_function
specifier|static
name|basic_block
name|cfg_layout_create_basic_block
parameter_list|(
name|void
modifier|*
name|head
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|basic_block
name|newbb
init|=
name|rtl_create_basic_block
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|after
argument_list|)
decl_stmt|;
name|cfg_layout_initialize_rbi
argument_list|(
name|newbb
argument_list|)
expr_stmt|;
return|return
name|newbb
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete the insns in a (non-live) block.  We physically delete every    non-deleted-note insn, and update the flow graph appropriately.     Return nonzero if we deleted an exception handler.  */
end_comment

begin_comment
comment|/* ??? Preserving all such notes strikes me as wrong.  It would be nice    to post-process the stream to remove empty blocks, loops, ranges, etc.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_delete_block
parameter_list|(
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|end
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* If the head of this block is a CODE_LABEL, then it might be the      label for an exception handler which can't be reached.       We need to remove the label from the exception_handler_label list      and remove the associated NOTE_INSN_EH_REGION_BEG and      NOTE_INSN_EH_REGION_END notes.  */
comment|/* Get rid of all NOTE_INSN_PREDICTIONs and NOTE_INSN_LOOP_CONTs      hanging before the block.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PREDICTION
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
condition|)
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|never_reached_warning
argument_list|(
name|insn
argument_list|,
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|maybe_remove_eh_handler
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Include any jump table following the basic block.  */
name|end
operator|=
name|BB_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|tablejump_p
argument_list|(
name|end
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
comment|/* Include any barrier that may follow the basic block.  */
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|BARRIER
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
comment|/* Selectively delete the entire chain.  */
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|insn
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* Remove the edges into and out of this block.  Note that there may      indeed be edges in, if we are removing an unreachable loop.  */
while|while
condition|(
name|b
operator|->
name|pred
operator|!=
name|NULL
condition|)
name|remove_edge
argument_list|(
name|b
operator|->
name|pred
argument_list|)
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|succ
operator|!=
name|NULL
condition|)
name|remove_edge
argument_list|(
name|b
operator|->
name|succ
argument_list|)
expr_stmt|;
name|b
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
comment|/* Remove the basic block from the array.  */
name|expunge_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Records the basic block struct in BLOCK_FOR_INSN for every insn.  */
end_comment

begin_function
name|void
name|compute_bb_for_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|end
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Release the basic_block_for_insn array.  */
end_comment

begin_function
name|void
name|free_bb_for_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update insns block within BB.  */
end_comment

begin_function
name|void
name|update_bb_for_insn
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a block BB after insn INSN creating a new fallthru edge.    Return the new edge.  Note that to keep other parts of the compiler happy,    this function renumbers all the basic blocks so that the new    one has a number one greater than the block split.  */
end_comment

begin_function
specifier|static
name|edge
name|rtl_split_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|insnp
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
name|edge
name|new_edge
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|rtx
name|insn
init|=
name|insnp
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
block|{
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* We probably should check type of the insn so that we do not create      inconsistent cfg.  It is checked in verify_flow_info anyway, so do not      bother.  */
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Create the new basic block.  */
name|new_bb
operator|=
name|create_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|bb
operator|->
name|frequency
expr_stmt|;
name|new_bb
operator|->
name|loop_depth
operator|=
name|bb
operator|->
name|loop_depth
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Redirect the outgoing edges.  */
name|new_bb
operator|->
name|succ
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
name|bb
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|e
operator|=
name|new_bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|src
operator|=
name|new_bb
expr_stmt|;
name|new_edge
operator|=
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|new_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|global_live_at_start
condition|)
block|{
name|new_bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_end
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
comment|/* We now have to calculate which registers are live at the end 	 of the split basic block and at the start of the new basic 	 block.  Start with those registers that are known to be live 	 at the end of the original basic block and get 	 propagate_block to determine which registers are live.  */
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_start
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|new_bb
argument_list|,
name|new_bb
operator|->
name|global_live_at_start
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|new_bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* In the presence of conditional execution we are not able to update 	 liveness precisely.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|new_bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|new_edge
return|;
block|}
end_function

begin_comment
comment|/* Assume that the code of basic block B has been merged into A.    Do corresponding CFG updates:  redirect edges accordingly etc.  */
end_comment

begin_function
specifier|static
name|void
name|update_cfg_after_block_merging
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* Normally there should only be one successor of A and that is B, but      partway though the merge of blocks for conditional_execution we'll      be merging a TEST block with THEN and ELSE successors.  Free the      whole lot of them and hope the caller knows what they're doing.  */
while|while
condition|(
name|a
operator|->
name|succ
condition|)
name|remove_edge
argument_list|(
name|a
operator|->
name|succ
argument_list|)
expr_stmt|;
comment|/* Adjust the edges out of B for the new owner.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|src
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|succ
operator|=
name|b
operator|->
name|succ
expr_stmt|;
name|a
operator|->
name|flags
operator||=
name|b
operator|->
name|flags
expr_stmt|;
comment|/* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */
name|b
operator|->
name|pred
operator|=
name|b
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|global_live_at_end
operator|=
name|b
operator|->
name|global_live_at_end
expr_stmt|;
name|expunge_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block A.  The insns    are already contiguous.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|b_head
init|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
decl_stmt|,
name|b_end
init|=
name|BB_END
argument_list|(
name|b
argument_list|)
decl_stmt|,
name|a_end
init|=
name|BB_END
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|rtx
name|del_first
init|=
name|NULL_RTX
decl_stmt|,
name|del_last
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|b_empty
init|=
literal|0
decl_stmt|;
comment|/* If there was a CODE_LABEL beginning B, delete it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|b_head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* Detect basic blocks with nothing but a label.  This can happen 	 in particular at the end of a function.  */
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
name|del_first
operator|=
name|del_last
operator|=
name|b_head
expr_stmt|;
name|b_head
operator|=
name|NEXT_INSN
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the basic block note and handle blocks containing just that      note.  */
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|b_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|del_last
condition|)
name|del_first
operator|=
name|b_head
expr_stmt|;
name|del_last
operator|=
name|b_head
expr_stmt|;
name|b_head
operator|=
name|NEXT_INSN
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* If there was a jump out of A, delete it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a_end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|a_end
argument_list|)
init|;
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|||
name|prev
operator|==
name|BB_HEAD
argument_list|(
name|a
argument_list|)
condition|)
break|break;
name|del_first
operator|=
name|a_end
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
name|only_sets_cc0_p
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|prev
decl_stmt|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|prev
operator|=
name|BB_HEAD
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|del_first
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
name|a_end
operator|=
name|PREV_INSN
argument_list|(
name|del_first
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|a_end
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
name|del_first
operator|=
name|NEXT_INSN
argument_list|(
name|a_end
argument_list|)
expr_stmt|;
name|update_cfg_after_block_merging
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Delete everything marked above as well as crap that might be      hanging out between the two blocks.  */
name|delete_insn_chain
argument_list|(
name|del_first
argument_list|,
name|del_last
argument_list|)
expr_stmt|;
comment|/* Reassociate the insns of B with A.  */
if|if
condition|(
operator|!
name|b_empty
condition|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|a_end
init|;
name|x
operator|!=
name|b_end
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|set_block_for_insn
argument_list|(
name|b_end
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|a_end
operator|=
name|b_end
expr_stmt|;
block|}
name|BB_END
argument_list|(
name|a
argument_list|)
operator|=
name|a_end
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when block A and B can be merged.  */
end_comment

begin_function
specifier|static
name|bool
name|rtl_can_merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
comment|/* There must be exactly one edge in between the blocks.  */
return|return
operator|(
name|a
operator|->
name|succ
operator|&&
operator|!
name|a
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|a
operator|->
name|succ
operator|->
name|dest
operator|==
name|b
operator|&&
operator|!
name|b
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|a
operator|!=
name|b
comment|/* Must be simple edge.  */
operator|&&
operator|!
operator|(
name|a
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|a
operator|->
name|next_bb
operator|==
name|b
operator|&&
name|a
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|b
operator|!=
name|EXIT_BLOCK_PTR
comment|/* If the jump insn has side effects, 	     we can't kill the edge.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|reload_completed
condition|?
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
else|:
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the label in the head of basic block BLOCK.  Create one if it doesn't    exist.  */
end_comment

begin_function
name|rtx
name|block_label
parameter_list|(
name|basic_block
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_HEAD
argument_list|(
name|block
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|BB_HEAD
argument_list|(
name|block
argument_list|)
operator|=
name|emit_label_before
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|BB_HEAD
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|BB_HEAD
argument_list|(
name|block
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Attempt to perform edge redirection by replacing possibly complex jump    instruction by unconditional jump or removing jump completely.  This can    apply only if all edges now point to the same block.  The parameters and    return values are equivalent to redirect_edge_and_branch.  */
end_comment

begin_function
name|bool
name|try_redirect_by_replacing_jump
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|,
name|bool
name|in_cfglayout
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|src
argument_list|)
decl_stmt|,
name|kill_from
decl_stmt|;
name|edge
name|tmp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|fallthru
init|=
literal|0
decl_stmt|;
comment|/* Verify that all targets will be TARGET.  */
for|for
control|(
name|tmp
operator|=
name|src
operator|->
name|succ
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|succ_next
control|)
if|if
condition|(
name|tmp
operator|->
name|dest
operator|!=
name|target
operator|&&
name|tmp
operator|!=
name|e
condition|)
break|break;
if|if
condition|(
name|tmp
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|reload_completed
operator|)
operator|&&
name|tablejump_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Avoid removing branch with side effects.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|side_effects_p
argument_list|(
name|set
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* In case we zap a conditional jump, we'll need to kill      the cc0 setter too.  */
name|kill_from
operator|=
name|insn
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|kill_from
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if we can create the fallthru edge.  */
if|if
condition|(
name|in_cfglayout
operator|||
name|can_fallthru
argument_list|(
name|src
argument_list|,
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Removing jump %i.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fallthru
operator|=
literal|1
expr_stmt|;
comment|/* Selectively unlink whole insn chain.  */
if|if
condition|(
name|in_cfglayout
condition|)
block|{
name|rtx
name|insn
init|=
name|src
operator|->
name|rbi
operator|->
name|footer
decl_stmt|;
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove barriers but keep jumptables.  */
while|while
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|src
operator|->
name|rbi
operator|->
name|footer
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this already is simplejump, redirect it.  */
elseif|else
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Redirecting jump %i from %i to %i.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Cannot do anything for target exit block.  */
elseif|else
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
comment|/* Or replace possibly complicated jump insn by simple jump insn.  */
else|else
block|{
name|rtx
name|target_label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|rtx
name|barrier
decl_stmt|,
name|label
decl_stmt|,
name|table
decl_stmt|;
name|emit_jump_insn_after_noloc
argument_list|(
name|gen_jump
argument_list|(
name|target_label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
operator|=
name|target_label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|target_label
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Replacing insn %i by jump %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|kill_from
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Recognize a tablejump that we are converting to a 	 simple jump and remove its associated CODE_LABEL 	 and ADDR_VEC or ADDR_DIFF_VEC.  */
if|if
condition|(
name|tablejump_p
argument_list|(
name|insn
argument_list|,
operator|&
name|label
argument_list|,
operator|&
name|table
argument_list|)
condition|)
name|delete_insn_chain
argument_list|(
name|label
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|next_nonnote_insn
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|barrier
operator|||
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|barrier
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Move the jump before barrier so that the notes 		 which originally were or were created before jump table are 		 inside the basic block.  */
name|rtx
name|new_insn
init|=
name|BB_END
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
init|;
name|tmp
operator|!=
name|barrier
condition|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|tmp
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|new_insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|new_insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|new_insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|new_insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|new_insn
argument_list|)
operator|=
name|barrier
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
argument_list|)
operator|=
name|new_insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|new_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
operator|=
name|new_insn
expr_stmt|;
block|}
block|}
block|}
comment|/* Keep only one edge out and set proper flags.  */
while|while
condition|(
name|src
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|remove_edge
argument_list|(
name|src
operator|->
name|succ
argument_list|)
expr_stmt|;
name|e
operator|=
name|src
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|fallthru
condition|)
name|e
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
else|else
name|e
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|src
operator|->
name|count
expr_stmt|;
comment|/* We don't want a block to end on a line-number note since that has      the potential of changing the code between -g and not -g.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|delete_insn
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target
condition|)
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return last loop_beg note appearing after INSN, before start of next    basic block.  Return INSN if there are no such notes.     When emitting jump to redirect a fallthru edge, it should always appear    after the LOOP_BEG notes, as loop optimizer expect loop to either start by    fallthru edge or jump following the LOOP_BEG note jumping to the loop exit    test.  */
end_comment

begin_function
specifier|static
name|rtx
name|last_loop_beg_note
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|last
init|=
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|last
operator|=
name|insn
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Redirect edge representing branch of (un)conditional jump or tablejump.  */
end_comment

begin_function
specifier|static
name|bool
name|redirect_branch_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|old_label
init|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
decl_stmt|;
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* We can only redirect non-fallthru edges of jump insn.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return
name|false
return|;
comment|/* Recognize a tablejump and adjust all matching cases.  */
if|if
condition|(
name|tablejump_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|j
decl_stmt|;
name|rtx
name|new_label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
block|}
comment|/* Handle casesi dispatch insns.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|SET_DEST
argument_list|(
name|tmp
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ?? We may play the games with moving the named labels from 	 one basic block to the other in case only one computed_jump is 	 available.  */
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
comment|/* A return instruction can't be redirected.  */
operator|||
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the insn doesn't go where we think, we're confused.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|old_label
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the substitution doesn't succeed, die.  This can happen 	 if the back end emitted unrecognizable instructions or if 	 target is exit block on some arches.  */
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Edge %i->%i redirected to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target
condition|)
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Attempt to change code to redirect edge E to TARGET.  Don't do that on    expense of adding new instructions or reordering basic blocks.     Function can be also called with edge destination equivalent to the TARGET.    Then it should try the simplifications and do nothing if none is possible.     Return true if transformation succeeded.  We still return false in case E    already destinated TARGET and we didn't managed to simplify instruction    stream.  */
end_comment

begin_function
specifier|static
name|bool
name|rtl_redirect_edge_and_branch
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|true
return|;
if|if
condition|(
name|try_redirect_by_replacing_jump
argument_list|(
name|e
argument_list|,
name|target
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|redirect_branch_edge
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Like force_nonfallthru below, but additionally performs redirection    Used by redirect_edge_and_branch_force.  */
end_comment

begin_function
name|basic_block
name|force_nonfallthru_and_redirect
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|basic_block
name|jump_block
decl_stmt|,
name|new_bb
init|=
name|NULL
decl_stmt|,
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|edge
name|new_edge
decl_stmt|;
name|int
name|abnormal_edge_flags
init|=
literal|0
decl_stmt|;
comment|/* In the case the last instruction is conditional jump to the next      instruction, first redirect the jump itself and then continue      by creating a basic block afterwards to redirect fallthru edge.  */
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
comment|/* When called from cfglayout, fallthru edges do not          necessarily go to the next block.  */
operator|&&
name|e
operator|->
name|src
operator|->
name|next_bb
operator|==
name|e
operator|->
name|dest
operator|&&
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|==
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|edge
name|b
init|=
name|unchecked_make_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|block_label
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|->
name|probability
operator|=
name|prob
expr_stmt|;
name|b
operator|->
name|count
operator|=
name|e
operator|->
name|count
operator|*
name|prob
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|probability
operator|-=
name|e
operator|->
name|probability
expr_stmt|;
name|e
operator|->
name|count
operator|-=
name|b
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|probability
operator|<
literal|0
condition|)
name|e
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
condition|)
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
comment|/* Irritating special case - fallthru edge to the same block as abnormal 	 edge. 	 We can't redirect abnormal edge, but we still can split the fallthru 	 one and create separate abnormal edge to original destination. 	 This allows bb-reorder to make such edge non-fallthru.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target
condition|)
name|abort
argument_list|()
expr_stmt|;
name|abnormal_edge_flags
operator|=
name|e
operator|->
name|flags
operator|&
operator|~
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_CAN_FALLTHRU
operator|)
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
name|EDGE_FALLTHRU
operator||
name|EDGE_CAN_FALLTHRU
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
block|{
comment|/* We can't redirect the entry block.  Create an empty block at the          start of the function which we use to add the new jump.  */
name|edge
modifier|*
name|pe1
decl_stmt|;
name|basic_block
name|bb
init|=
name|create_basic_block
argument_list|(
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
decl_stmt|;
comment|/* Change the existing edge's source to be the new block, and add 	 a new edge from the entry block to the new block.  */
name|e
operator|->
name|src
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|pe1
operator|=
operator|&
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
operator|*
name|pe1
condition|;
name|pe1
operator|=
operator|&
operator|(
operator|*
name|pe1
operator|)
operator|->
name|succ_next
control|)
if|if
condition|(
operator|*
name|pe1
operator|==
name|e
condition|)
block|{
operator|*
name|pe1
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
break|break;
block|}
name|e
operator|->
name|succ_next
operator|=
literal|0
expr_stmt|;
name|bb
operator|->
name|succ
operator|=
name|e
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|abnormal_edge_flags
condition|)
block|{
comment|/* Create the new structures.  */
comment|/* If the old block ended with a tablejump, skip its table 	 by searching forward from there.  Otherwise start searching 	 forward from the last instruction of the old block.  */
if|if
condition|(
operator|!
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|note
argument_list|)
condition|)
name|note
operator|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* Position the new block correctly relative to loop notes.  */
name|note
operator|=
name|last_loop_beg_note
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|jump_block
operator|=
name|create_basic_block
argument_list|(
name|note
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|jump_block
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|loop_depth
operator|=
name|target
operator|->
name|loop_depth
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|global_live_at_start
condition|)
block|{
name|jump_block
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|jump_block
operator|->
name|global_live_at_start
argument_list|,
name|target
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|jump_block
operator|->
name|global_live_at_end
argument_list|,
name|target
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
comment|/* Wire edge in.  */
name|new_edge
operator|=
name|make_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|jump_block
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|new_edge
operator|->
name|probability
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|new_edge
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Redirect old edge.  */
name|redirect_edge_pred
argument_list|(
name|e
argument_list|,
name|jump_block
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|new_bb
operator|=
name|jump_block
expr_stmt|;
block|}
else|else
name|jump_block
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
if|if
condition|(
name|HAVE_return
condition|)
name|emit_jump_insn_after_noloc
argument_list|(
name|gen_return
argument_list|()
argument_list|,
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|label
init|=
name|block_label
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|emit_jump_insn_after_noloc
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
expr_stmt|;
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|abnormal_edge_flags
condition|)
name|make_edge
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|abnormal_edge_flags
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Edge E is assumed to be fallthru edge.  Emit needed jump instruction    (and possibly create new basic block) to make edge non-fallthru.    Return newly created BB or NULL if none.  */
end_comment

begin_function
name|basic_block
name|force_nonfallthru
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
return|return
name|force_nonfallthru_and_redirect
argument_list|(
name|e
argument_list|,
name|e
operator|->
name|dest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Redirect edge even at the expense of creating new jump insn or    basic block.  Return new basic block if created, NULL otherwise.    Abort if conversion is impossible.  */
end_comment

begin_function
specifier|static
name|basic_block
name|rtl_redirect_edge_and_branch_force
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
if|if
condition|(
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
operator|||
name|e
operator|->
name|dest
operator|==
name|target
condition|)
return|return
name|NULL
return|;
comment|/* In case the edge redirection failed, try to force it to be non-fallthru      and redirect newly created simplejump.  */
return|return
name|force_nonfallthru_and_redirect
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The given edge should potentially be a fallthru edge.  If that is in    fact true, delete the jump and barriers that are in the way.  */
end_comment

begin_function
name|void
name|tidy_fallthru_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|b
parameter_list|,
name|basic_block
name|c
parameter_list|)
block|{
name|rtx
name|q
decl_stmt|;
comment|/* ??? In a late-running flow pass, other folks may have deleted basic      blocks by nopping out blocks, leaving multiple BARRIERs between here      and the target label. They ought to be chastized and fixed.       We can also wind up with a sequence of undeletable labels between      one block and the next.       So search through a sequence of barriers, labels, and notes for      the head of block C and assert that we really do fall through.  */
for|for
control|(
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
init|;
name|q
operator|!=
name|BB_HEAD
argument_list|(
name|c
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|q
argument_list|)
condition|)
return|return;
comment|/* Remove what will soon cease being the jump insn from the source block.      If block B consisted only of this single jump, turn it into a deleted      note.  */
name|q
operator|=
name|BB_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|onlyjump_p
argument_list|(
name|q
argument_list|)
operator|&&
operator|(
name|any_uncondjump_p
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|b
operator|->
name|succ
operator|==
name|e
operator|&&
name|e
operator|->
name|succ_next
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|q
argument_list|)
operator|&&
name|only_sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* We don't want a block to end on a line-number note since that has 	 the potential of changing the code between -g and not -g.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|>=
literal|0
condition|)
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Selectively unlink the sequence.  */
if|if
condition|(
name|q
operator|!=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
name|delete_insn_chain
argument_list|(
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up edges that now fall through, or rather should now fall through    but previously required a jump around now deleted blocks.  Simplify    the search by only examining blocks numerically adjacent, since this    is how find_basic_blocks created them.  */
end_comment

begin_function
name|void
name|tidy_fallthru_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|b
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return;
name|FOR_BB_BETWEEN
argument_list|(
argument|b
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb
argument_list|,
argument|EXIT_BLOCK_PTR->prev_bb
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|s
decl_stmt|;
name|c
operator|=
name|b
operator|->
name|next_bb
expr_stmt|;
comment|/* We care about simple conditional or unconditional jumps with 	 a single successor.  	 If we had a conditional branch to the next instruction when 	 find_basic_blocks was called, then there will only be one 	 out edge for the block which ended with the conditional 	 branch (since we do not create duplicate edges).  	 Furthermore, the edge will be marked as a fallthru because we 	 merge the flags for the duplicate edges.  So we do not want to 	 check that the edge is not a FALLTHRU edge.  */
if|if
condition|(
operator|(
name|s
operator|=
name|b
operator|->
name|succ
operator|)
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|s
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
name|s
operator|->
name|dest
operator|==
name|c
comment|/* If the jump insn has side effects, we can't tidy the edge.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
condition|)
name|tidy_fallthru_edge
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for split_edge.  Return true in case edge BB2 to BB1    is back edge of syntactic loop.  */
end_comment

begin_function
specifier|static
name|bool
name|back_edge_of_syntactic_loop_p
parameter_list|(
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|bb1
operator|==
name|bb2
condition|)
return|return
name|true
return|;
comment|/* ??? Could we guarantee that bb indices are monotone, so that we could      just compare them?  */
for|for
control|(
name|bb
operator|=
name|bb1
init|;
name|bb
operator|&&
name|bb
operator|!=
name|bb2
condition|;
name|bb
operator|=
name|bb
operator|->
name|next_bb
control|)
continue|continue;
if|if
condition|(
operator|!
name|bb
condition|)
return|return
name|false
return|;
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb1
argument_list|)
init|;
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb2
argument_list|)
operator|&&
name|count
operator|>=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|count
operator|--
expr_stmt|;
block|}
return|return
name|count
operator|>=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Split a (typically critical) edge.  Return the new block.    Abort on abnormal edges.     ??? The code generally expects to be called on critical edges.    The case of a block ending in an unconditional jump to a    block with multiple predecessors is not handled optimally.  */
end_comment

begin_function
specifier|static
name|basic_block
name|rtl_split_edge
parameter_list|(
name|edge
name|edge_in
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|before
decl_stmt|;
comment|/* Abnormal edges cannot be split.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We are going to place the new block in front of edge destination.      Avoid existence of fallthru predecessors.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|edge_in
operator|->
name|dest
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
condition|)
name|force_nonfallthru
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* Create the basic block note.       Where we place the note can have a noticeable impact on the generated      code.  Consider this cfg:  		        E 			| 			0 		       / \ 		   +->1-->2--->E                    |  | 		   +--+        If we need to insert an insn on the edge from block 0 to block 1,       we want to ensure the instructions we insert are outside of any       loop notes that physically sit between block 0 and block 1.  Otherwise       we confuse the loop optimizer into thinking the loop is a phony.  */
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|)
operator|&&
operator|!
name|back_edge_of_syntactic_loop_p
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|,
name|edge_in
operator|->
name|src
argument_list|)
condition|)
name|before
operator|=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|before
operator|=
name|BB_HEAD
argument_list|(
name|edge_in
operator|->
name|dest
argument_list|)
expr_stmt|;
else|else
name|before
operator|=
name|NULL_RTX
expr_stmt|;
name|bb
operator|=
name|create_basic_block
argument_list|(
name|before
argument_list|,
name|NULL
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|edge_in
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|edge_in
argument_list|)
expr_stmt|;
comment|/* ??? This info is likely going to be out of date very soon.  */
if|if
condition|(
name|edge_in
operator|->
name|dest
operator|->
name|global_live_at_start
condition|)
block|{
name|bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|edge_in
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|edge_in
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
comment|/* For non-fallthru edges, we must adjust the predecessor's      jump instruction to target our new block.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|redirect_edge_and_branch
argument_list|(
name|edge_in
argument_list|,
name|bb
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|redirect_edge_succ
argument_list|(
name|edge_in
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Queue instructions for insertion on an edge between two basic blocks.    The new instructions and basic blocks (if any) will not appear in the    CFG until commit_edge_insertions is called.  */
end_comment

begin_function
name|void
name|insert_insn_on_edge
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
comment|/* We cannot insert instructions on an abnormal critical edge.      It will be easier to find the culprit if we die now.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|&&
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
operator|==
name|NULL_RTX
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|e
operator|->
name|insns
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|e
operator|->
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from safe_insert_insn_on_edge through note_stores, marks live    registers that are killed by the store.  */
end_comment

begin_function
specifier|static
name|void
name|mark_killed_regs
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|set
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|regset
name|killed
init|=
name|data
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|killed
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_REGNO_REG_SET
argument_list|(
name|killed
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar to insert_insn_on_edge, tries to put INSN to edge E.  Additionally    it checks whether this will not clobber the registers that are live on the    edge (i.e. it requires liveness information to be up-to-date) and if there    are some, then it tries to save and restore them.  Returns true if    successful.  */
end_comment

begin_function
name|bool
name|safe_insert_insn_on_edge
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|regset_head
name|killed_head
decl_stmt|;
name|regset
name|killed
init|=
name|INITIALIZE_REG_SET
argument_list|(
name|killed_head
argument_list|)
decl_stmt|;
name|rtx
name|save_regs
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|noccmode
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|AVOID_CCMODE_COPIES
name|noccmode
operator|=
name|true
expr_stmt|;
else|#
directive|else
name|noccmode
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|x
operator|=
name|insn
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|mark_killed_regs
argument_list|,
name|killed
argument_list|)
expr_stmt|;
name|bitmap_operation
argument_list|(
name|killed
argument_list|,
name|killed
argument_list|,
name|e
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|,
name|BITMAP_AND
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|killed
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|{       mode = regno< FIRST_PSEUDO_REGISTER 	      ? reg_raw_mode[regno] 	      : GET_MODE (regno_reg_rtx[regno]);       if (mode == VOIDmode) 	return false;        if (noccmode&& mode == CCmode) 	return false; 	       save_regs = alloc_EXPR_LIST (
literal|0
argument|, 				   alloc_EXPR_LIST (
literal|0
argument|, 						    gen_reg_rtx (mode), 						    gen_raw_REG (mode, regno)), 				   save_regs);     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|save_regs
condition|)
block|{
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|x
operator|=
name|save_regs
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|from
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|to
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|save_regs
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|from
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|to
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|save_regs
argument_list|)
expr_stmt|;
block|}
name|insert_insn_on_edge
argument_list|(
name|insn
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|killed
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Update the CFG for the instructions queued on edge E.  */
end_comment

begin_function
specifier|static
name|void
name|commit_one_edge_insertion
parameter_list|(
name|edge
name|e
parameter_list|,
name|int
name|watch_calls
parameter_list|)
block|{
name|rtx
name|before
init|=
name|NULL_RTX
decl_stmt|,
name|after
init|=
name|NULL_RTX
decl_stmt|,
name|insns
decl_stmt|,
name|tmp
decl_stmt|,
name|last
decl_stmt|;
name|basic_block
name|bb
init|=
name|NULL
decl_stmt|;
comment|/* Pull the insns off the edge now since the edge might go away.  */
name|insns
operator|=
name|e
operator|->
name|insns
expr_stmt|;
name|e
operator|->
name|insns
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Special case -- avoid inserting code between call and storing      its return value.  */
if|if
condition|(
name|watch_calls
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|after
operator|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* The first insn after the call may be a stack pop, skip it.  */
while|while
condition|(
name|next
operator|&&
name|keep_with_call_p
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|after
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|before
operator|&&
operator|!
name|after
condition|)
block|{
comment|/* Figure out where to put these things.  If the destination has          one predecessor, insert there.  Except for the exit block.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Get the location correct wrt a code label, and "nice" wrt 	     a basic block note, and before everything else.  */
name|tmp
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
name|before
operator|=
name|tmp
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
condition|)
name|after
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|after
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* If the source has one successor and the edge is not abnormal,          insert there.  Except for the entry block.  */
elseif|else
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
operator|&&
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
comment|/* It is possible to have a non-simple jump here.  Consider a target 	     where some forms of unconditional jumps clobber a register.  This 	     happens on the fr30 for example.  	     We know this block has a single successor, so we can just emit 	     the queued insns before the jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
for|for
control|(
name|before
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|before
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|before
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|;
name|before
operator|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
control|)
empty_stmt|;
else|else
block|{
comment|/* We'd better be fallthru, or we've lost track of what's what.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|after
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise we must split the edge.  */
else|else
block|{
name|bb
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|after
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now that we've found the spot, do the insertion.  */
if|if
condition|(
name|before
condition|)
block|{
name|emit_insn_before_noloc
argument_list|(
name|insns
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|last
operator|=
name|prev_nonnote_insn
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
else|else
name|last
operator|=
name|emit_insn_after_noloc
argument_list|(
name|insns
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnjump_p
argument_list|(
name|last
argument_list|)
condition|)
block|{
comment|/* ??? Remove all outgoing edges from BB and add one for EXIT.          This is not currently a problem because this only happens          for the (single) epilogue, which already has a fallthru edge          to EXIT.  */
name|e
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|succ_next
operator|!=
name|NULL
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
condition|)
name|delete_insn
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Mark the basic block for find_sub_basic_blocks.  */
name|bb
operator|->
name|aux
operator|=
operator|&
name|bb
operator|->
name|aux
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the CFG for all queued instructions.  */
end_comment

begin_function
name|void
name|commit_edge_insertions
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|sbitmap
name|blocks
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|commit_one_edge_insertion
argument_list|(
name|e
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
return|return;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|bb
operator|->
name|aux
condition|)
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Check for forgotten bb->aux values before commit_edge_insertions 	   call.  */
if|if
condition|(
name|bb
operator|->
name|aux
operator|!=
operator|&
name|bb
operator|->
name|aux
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
name|find_many_sub_basic_blocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the CFG for all queued instructions, taking special care of inserting    code on edges between call and storing its return value.  */
end_comment

begin_function
name|void
name|commit_edge_insertions_watch_calls
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|sbitmap
name|blocks
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|commit_one_edge_insertion
argument_list|(
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
return|return;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|bb
operator|->
name|aux
condition|)
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Check for forgotten bb->aux values before commit_edge_insertions 	   call.  */
if|if
condition|(
name|bb
operator|->
name|aux
operator|!=
operator|&
name|bb
operator|->
name|aux
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
name|find_many_sub_basic_blocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out one basic block with live information at start and end.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_dump_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|FILE
modifier|*
name|outf
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|fputs
argument_list|(
literal|";; Registers live at start:"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|,
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";; Registers live at end:"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like print_rtl, but also print out live information for the start of each    basic block.  */
end_comment

begin_function
name|void
name|print_rtl_with_bb
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|rtx
name|rtx_first
parameter_list|)
block|{
name|rtx
name|tmp_rtx
decl_stmt|;
if|if
condition|(
name|rtx_first
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(nil)\n"
argument_list|)
expr_stmt|;
else|else
block|{
enum|enum
name|bb_state
block|{
name|NOT_IN_BB
block|,
name|IN_ONE_BB
block|,
name|IN_MULTIPLE_BB
block|}
enum|;
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|start
init|=
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|end
init|=
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|bb_state
modifier|*
name|in_bb_p
init|=
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
expr|enum
name|bb_state
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|start
index|[
name|INSN_UID
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
name|end
index|[
name|INSN_UID
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|x
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|enum
name|bb_state
name|state
init|=
name|IN_MULTIPLE_BB
decl_stmt|;
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|NOT_IN_BB
condition|)
name|state
operator|=
name|IN_ONE_BB
expr_stmt|;
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
for|for
control|(
name|tmp_rtx
operator|=
name|rtx_first
init|;
name|NULL
operator|!=
name|tmp_rtx
condition|;
name|tmp_rtx
operator|=
name|NEXT_INSN
argument_list|(
name|tmp_rtx
argument_list|)
control|)
block|{
name|int
name|did_output
decl_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|start
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Start of basic block %d, registers live:"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|NOT_IN_BB
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|BARRIER
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is not within a basic block\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|IN_MULTIPLE_BB
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is in multiple basic blocks\n"
argument_list|)
expr_stmt|;
name|did_output
operator|=
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|tmp_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|end
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; End of basic block %d, registers live:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|did_output
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_bb_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_epilogue_delay_list
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\n;; Insns in epilogue delay list:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp_rtx
operator|=
name|current_function_epilogue_delay_list
init|;
name|tmp_rtx
operator|!=
literal|0
condition|;
name|tmp_rtx
operator|=
name|XEXP
argument_list|(
name|tmp_rtx
argument_list|,
literal|1
argument_list|)
control|)
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|XEXP
argument_list|(
name|tmp_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|update_br_prob_note
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return;
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
condition|)
return|return;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify the CFG and RTL consistency common for both underlying RTL and    cfglayout RTL.     Currently it does following checks:     - test head/end pointers    - overlapping of basic blocks    - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)    - tails of basic blocks (ensure that boundary is necessary)    - scans body of the basic block for JUMP_INSN, CODE_LABEL      and NOTE_INSN_BASIC_BLOCK     In future it can be extended check a lot of other stuff as well    (reachability of basic blocks, life information, etc. etc.).  */
end_comment

begin_function
specifier|static
name|int
name|rtl_verify_flow_info_1
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|rtx
name|last_head
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|bb_info
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|last_bb_seen
decl_stmt|;
name|bb_info
operator|=
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check bb chain& numbers.  */
name|last_bb_seen
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|end
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* Verify the end of the basic block is in the INSN chain.  */
for|for
control|(
name|x
operator|=
name|last_head
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|x
operator|==
name|end
condition|)
break|break;
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"end insn %d for block %d not found in the insn stream"
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Work backwards from the end to the head of the basic block 	 to verify the head is in the RTL chain.  */
for|for
control|(
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
comment|/* While walking over the insn chain, verify insns appear 	     in only one basic block and initialize the BB_INFO array 	     used by other passes.  */
if|if
condition|(
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"insn %d is in multiple basic blocks (%d and %d)"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|head
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"head insn %d for block %d not found in the insn stream"
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_head
operator|=
name|x
expr_stmt|;
block|}
comment|/* Now check the basic blocks (boundaries etc.) */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|n_fallthru
init|=
literal|0
decl_stmt|,
name|n_eh
init|=
literal|0
decl_stmt|,
name|n_call
init|=
literal|0
decl_stmt|,
name|n_abnormal
init|=
literal|0
decl_stmt|,
name|n_branch
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|fallthru
init|=
name|NULL
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|bb
operator|->
name|succ
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: REG_BR_PROB does not match cfg %wi %i"
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|n_fallthru
operator|++
operator|,
name|fallthru
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|~
operator|(
name|EDGE_DFS_BACK
operator||
name|EDGE_CAN_FALLTHRU
operator||
name|EDGE_IRREDUCIBLE_LOOP
operator||
name|EDGE_LOOP_EXIT
operator|)
operator|)
operator|==
literal|0
condition|)
name|n_branch
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL_CALL
condition|)
name|n_call
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
name|n_eh
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|n_abnormal
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n_eh
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|RESX
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Missing REG_EH_REGION note in the end of bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_branch
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|n_branch
operator|>
literal|1
operator|&&
operator|(
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|||
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Too many outgoing branch edges from bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_fallthru
operator|&&
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Fallthru edge after unconditional jump %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_branch
operator|!=
literal|1
operator|&&
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Wrong amount of branch edges after unconditional jump %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_branch
operator|!=
literal|1
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|BB_HEAD
argument_list|(
name|fallthru
operator|->
name|dest
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Wrong amount of branch edges after conditional jump %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_call
operator|&&
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|CALL_INSN
condition|)
block|{
name|error
argument_list|(
literal|"Call edges for non-call insn in bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_abnormal
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|n_call
operator|!=
name|n_abnormal
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|||
name|any_uncondjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Abnormal edges for no purpose in bb %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|x
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
condition|)
name|error
argument_list|(
literal|"insn %d inside basic block %d but block_for_insn is NULL"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"insn %d inside basic block %d but block_for_insn is %i"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|x
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* OK pointers are correct.  Now check the header of basic          block.  It ought to contain optional CODE_LABEL followed 	 by NOTE_BASIC_BLOCK.  */
name|x
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|x
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK is missing for block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
operator|||
name|NOTE_BASIC_BLOCK
argument_list|(
name|x
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK is missing for block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|x
condition|)
comment|/* Do checks for empty blocks her. e */
empty_stmt|;
else|else
for|for
control|(
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"NOTE_INSN_BASIC_BLOCK %d in middle of basic block %d"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"in basic block %d:"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"flow control insn inside a basic block"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Verify the CFG and RTL consistency common for both underlying RTL and    cfglayout RTL.     Currently it does following checks:    - all checks of rtl_verify_flow_info_1    - check that all insns are in the basic blocks      (except the switch handling code, barriers and notes)    - check that all returns are followed by barriers    - check that all fallthru edge points to the adjacent blocks.  */
end_comment

begin_function
specifier|static
name|int
name|rtl_verify_flow_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|err
init|=
name|rtl_verify_flow_info_1
argument_list|()
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|num_bb_notes
decl_stmt|;
specifier|const
name|rtx
name|rtx_first
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|basic_block
name|last_bb_seen
init|=
name|ENTRY_BLOCK_PTR
decl_stmt|,
name|curr_bb
init|=
name|NULL
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Ensure existence of barrier in BB with no fallthru edges.  */
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|insn
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|!
name|insn
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"missing barrier after block %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|next_bb
operator|!=
name|e
operator|->
name|dest
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Incorrect blocks for fallthru %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
ifndef|#
directive|ifndef
name|CASE_DROPS_THROUGH
operator|||
name|INSN_P
argument_list|(
name|insn
argument_list|)
else|#
directive|else
operator|||
operator|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_TABLE_DATA_P
argument_list|(
name|insn
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Incorrect fallthru %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"wrong insn in the fallthru edge"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|num_bb_notes
operator|=
literal|0
expr_stmt|;
name|last_bb_seen
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rtx_first
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|bb
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|num_bb_notes
operator|++
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
name|last_bb_seen
operator|->
name|next_bb
condition|)
name|internal_error
argument_list|(
literal|"basic blocks not laid down consecutively"
argument_list|)
expr_stmt|;
name|curr_bb
operator|=
name|last_bb_seen
operator|=
name|bb
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curr_bb
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
break|break;
case|case
name|CODE_LABEL
case|:
comment|/* An addr_vec is placed outside any block block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* But in any case, non-deletable labels can appear anywhere.  */
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"insn outside basic block"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|returnjump_p
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|condjump_p
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|BARRIER
operator|)
condition|)
name|fatal_insn
argument_list|(
literal|"return not followed by barrier"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_bb
operator|&&
name|x
operator|==
name|BB_END
argument_list|(
name|curr_bb
argument_list|)
condition|)
name|curr_bb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|num_bb_notes
operator|!=
name|n_basic_blocks
condition|)
name|internal_error
argument_list|(
literal|"number of bb notes in insn chain (%d) != n_basic_blocks (%d)"
argument_list|,
name|num_bb_notes
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assume that the preceding pass has possibly eliminated jump instructions    or converted the unconditional jumps.  Eliminate the edges from CFG.    Return true if any edges are eliminated.  */
end_comment

begin_function
name|bool
name|purge_dead_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|,
name|note
decl_stmt|;
name|bool
name|purged
init|=
name|false
decl_stmt|;
comment|/* If this instruction cannot trap, remove REG_EH_REGION notes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|eqnote
decl_stmt|;
if|if
condition|(
operator|!
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|eqnote
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|eqnote
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup abnormal edges caused by exceptions or non-local gotos.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
if|if
condition|(
name|can_throw_internal
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL_CALL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
operator|!
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
condition|)
continue|continue;
block|}
else|else
continue|continue;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|purged
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|edge
name|b
decl_stmt|,
name|f
decl_stmt|;
comment|/* We do care only about conditional jumps and simplejumps.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|returnjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|purged
return|;
comment|/* Branch probability/prediction notes are defined only for 	 condjumps.  We've possibly turned condjump into simplejump.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PRED
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
comment|/* Avoid abnormal flags to leak from computed jumps turned 	     into simplejumps.  */
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_ABNORMAL
expr_stmt|;
comment|/* See if this edge is one we should keep.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* A conditional jump can fall through into the next 	       block, so we should keep the edge.  */
continue|continue;
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* If the destination block is the target of the jump, 	       keep the edge.  */
continue|continue;
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* If the destination block is the exit block, and this 	       instruction is a return, then keep the edge.  */
continue|continue;
elseif|else
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
operator|&&
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* Keep the edges that correspond to exceptions thrown by 	       this instruction and rematerialize the EDGE_ABNORMAL 	       flag we just cleared above.  */
block|{
name|e
operator|->
name|flags
operator||=
name|EDGE_ABNORMAL
expr_stmt|;
continue|continue;
block|}
comment|/* We do not need this edge.  */
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|purged
operator|=
name|true
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|||
operator|!
name|purged
condition|)
return|return
name|purged
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Purged edges from bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
name|purged
return|;
comment|/* Redistribute probabilities.  */
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|bb
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|bb
operator|->
name|succ
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
return|return
name|purged
return|;
name|b
operator|=
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|f
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|b
operator|->
name|probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|b
operator|->
name|probability
expr_stmt|;
name|b
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|b
operator|->
name|probability
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|f
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|f
operator|->
name|probability
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
return|return
name|purged
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* First, there should not be any EH or ABCALL edges resulting 	 from non-local gotos and the like.  If there were, we shouldn't 	 have created the sibcall in the first place.  Second, there 	 should of course never have been a fallthru edge.  */
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|||
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
operator|->
name|flags
operator|!=
operator|(
name|EDGE_SIBCALL
operator||
name|EDGE_ABNORMAL
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we don't see a jump insn, we don't know exactly why the block would      have been broken at this point.  Look for a simple, non-fallthru edge,      as these are only created by conditional branches.  If we find such an      edge we know that there used to be a jump here and can then safely      remove all non-fallthru edges.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FALLTHRU
operator|)
operator|)
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|purged
return|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
block|{
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|purged
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|||
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|bb
operator|->
name|succ
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Purged non-fallthru edges from bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|purged
return|;
block|}
end_function

begin_comment
comment|/* Search all basic blocks for potentially dead edges and purge them.  Return    true if some edge has been eliminated.  */
end_comment

begin_function
name|bool
name|purge_all_dead_edges
parameter_list|(
name|int
name|update_life_p
parameter_list|)
block|{
name|int
name|purged
init|=
name|false
decl_stmt|;
name|sbitmap
name|blocks
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|update_life_p
condition|)
block|{
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bool
name|purged_here
init|=
name|purge_dead_edges
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|purged
operator||=
name|purged_here
expr_stmt|;
if|if
condition|(
name|purged_here
operator|&&
name|update_life_p
condition|)
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_life_p
operator|&&
name|purged
condition|)
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_life_p
condition|)
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
return|return
name|purged
return|;
block|}
end_function

begin_comment
comment|/* Same as split_block but update cfg_layout structures.  */
end_comment

begin_function
specifier|static
name|edge
name|cfg_layout_split_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|insnp
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|insnp
decl_stmt|;
name|edge
name|fallthru
init|=
name|rtl_split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|fallthru
operator|->
name|dest
operator|->
name|rbi
operator|->
name|footer
operator|=
name|fallthru
operator|->
name|src
operator|->
name|rbi
operator|->
name|footer
expr_stmt|;
name|fallthru
operator|->
name|src
operator|->
name|rbi
operator|->
name|footer
operator|=
name|NULL
expr_stmt|;
return|return
name|fallthru
return|;
block|}
end_function

begin_comment
comment|/* Redirect Edge to DEST.  */
end_comment

begin_function
specifier|static
name|bool
name|cfg_layout_redirect_edge_and_branch
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|dest
condition|)
return|return
name|true
return|;
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|try_redirect_by_replacing_jump
argument_list|(
name|e
argument_list|,
name|dest
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Redirecting entry edge from bb %i to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Redirect_edge_and_branch may decide to turn branch into fallthru edge      in the case the basic block appears to be in sequence.  Avoid this      transformation.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
comment|/* Redirect any branch edges unified with the fallthru one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|label_is_jump_target_p
argument_list|(
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Fallthru edge unified with branch "
literal|"%i->%i redirected to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_branch_edge
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* In case we are redirecting fallthru edge to the branch edge          of conditional jump, remove it.  */
if|if
condition|(
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|!
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
block|{
name|edge
name|s
init|=
name|e
operator|->
name|succ_next
condition|?
name|e
operator|->
name|succ_next
else|:
name|src
operator|->
name|succ
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|dest
operator|==
name|dest
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Fallthru edge %i->%i redirected to %i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|ret
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|redirect_branch_edge
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* We don't want simplejumps in the insn stream during cfglayout.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Simple wrapper as we always can redirect fallthru edges.  */
end_comment

begin_function
specifier|static
name|basic_block
name|cfg_layout_redirect_edge_and_branch_force
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg_layout_redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Same as flow_delete_block but update cfg_layout structures.  */
end_comment

begin_function
specifier|static
name|void
name|cfg_layout_delete_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|prev
init|=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
decl_stmt|,
modifier|*
name|to
decl_stmt|,
name|remaints
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|rbi
operator|->
name|header
condition|)
block|{
name|next
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|bb
operator|->
name|rbi
operator|->
name|header
expr_stmt|;
else|else
name|set_first_insn
argument_list|(
name|bb
operator|->
name|rbi
operator|->
name|header
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|rbi
operator|->
name|header
argument_list|)
operator|=
name|prev
expr_stmt|;
name|insn
operator|=
name|bb
operator|->
name|rbi
operator|->
name|header
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|rbi
operator|->
name|footer
condition|)
block|{
name|insn
operator|=
name|bb
operator|->
name|rbi
operator|->
name|footer
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|bb
operator|->
name|rbi
operator|->
name|footer
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|rbi
operator|->
name|footer
condition|)
block|{
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|bb
operator|->
name|rbi
operator|->
name|footer
expr_stmt|;
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|rbi
operator|->
name|footer
argument_list|)
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
else|else
name|set_last_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|to
operator|=
operator|&
name|bb
operator|->
name|next_bb
operator|->
name|rbi
operator|->
name|header
expr_stmt|;
else|else
name|to
operator|=
operator|&
name|cfg_layout_function_footer
expr_stmt|;
name|rtl_delete_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
else|else
name|prev
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
operator|!=
name|prev
condition|)
block|{
name|remaints
operator|=
name|unlink_insn_chain
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|insn
operator|=
name|remaints
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
operator|*
name|to
expr_stmt|;
if|if
condition|(
operator|*
name|to
condition|)
name|PREV_INSN
argument_list|(
operator|*
name|to
argument_list|)
operator|=
name|insn
expr_stmt|;
operator|*
name|to
operator|=
name|remaints
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true when blocks A and B can be safely merged.  */
end_comment

begin_function
specifier|static
name|bool
name|cfg_layout_can_merge_blocks_p
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
comment|/* There must be exactly one edge in between the blocks.  */
return|return
operator|(
name|a
operator|->
name|succ
operator|&&
operator|!
name|a
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|a
operator|->
name|succ
operator|->
name|dest
operator|==
name|b
operator|&&
operator|!
name|b
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|a
operator|!=
name|b
comment|/* Must be simple edge.  */
operator|&&
operator|!
operator|(
name|a
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|a
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|b
operator|!=
name|EXIT_BLOCK_PTR
comment|/* If the jump insn has side effects, 	     we can't kill the edge.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|reload_completed
condition|?
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
else|:
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Merge block A and B, abort when it is not possible.  */
end_comment

begin_function
specifier|static
name|void
name|cfg_layout_merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|cfg_layout_can_merge_blocks_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If there was a CODE_LABEL beginning B, delete it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|delete_insn
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We should have fallthru edge in a, or we can do dummy redirection to get      it cleaned up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|try_redirect_by_replacing_jump
argument_list|(
name|a
operator|->
name|succ
argument_list|,
name|b
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Possible line number notes should appear in between.  */
if|if
condition|(
name|b
operator|->
name|rbi
operator|->
name|header
condition|)
block|{
name|rtx
name|first
init|=
name|BB_END
argument_list|(
name|a
argument_list|)
decl_stmt|,
name|last
decl_stmt|;
name|last
operator|=
name|emit_insn_after_noloc
argument_list|(
name|b
operator|->
name|rbi
operator|->
name|header
argument_list|,
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|b
operator|->
name|rbi
operator|->
name|header
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* In the case basic blocks are not adjacent, move them around.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
operator|!=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|rtx
name|first
init|=
name|unlink_insn_chain
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_after_noloc
argument_list|(
name|first
argument_list|,
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip possible DELETED_LABEL insn.  */
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|first
argument_list|)
condition|)
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|first
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|delete_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise just re-associate the instructions.  */
else|else
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Skip possible DELETED_LABEL insn.  */
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BB_END
argument_list|(
name|a
argument_list|)
operator|=
name|BB_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Possible tablejumps and barriers should appear after the block.  */
if|if
condition|(
name|b
operator|->
name|rbi
operator|->
name|footer
condition|)
block|{
if|if
condition|(
operator|!
name|a
operator|->
name|rbi
operator|->
name|footer
condition|)
name|a
operator|->
name|rbi
operator|->
name|footer
operator|=
name|b
operator|->
name|rbi
operator|->
name|footer
expr_stmt|;
else|else
block|{
name|rtx
name|last
init|=
name|a
operator|->
name|rbi
operator|->
name|footer
decl_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|b
operator|->
name|rbi
operator|->
name|footer
expr_stmt|;
name|PREV_INSN
argument_list|(
name|b
operator|->
name|rbi
operator|->
name|footer
argument_list|)
operator|=
name|last
expr_stmt|;
block|}
name|b
operator|->
name|rbi
operator|->
name|footer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Merged blocks %d and %d.\n"
argument_list|,
name|a
operator|->
name|index
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|update_cfg_after_block_merging
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split edge E.  */
end_comment

begin_function
specifier|static
name|basic_block
name|cfg_layout_split_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|edge
name|new_e
decl_stmt|;
name|basic_block
name|new_bb
init|=
name|create_basic_block
argument_list|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|?
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
else|:
name|get_insns
argument_list|()
argument_list|,
name|NULL_RTX
argument_list|,
name|e
operator|->
name|src
argument_list|)
decl_stmt|;
name|new_bb
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* ??? This info is likely going to be out of date very soon, but we must      create it to avoid getting an ICE later.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|global_live_at_start
condition|)
block|{
name|new_bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_start
argument_list|,
name|e
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_end
argument_list|,
name|e
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
name|new_e
operator|=
name|make_edge
argument_list|(
name|new_bb
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|new_e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|new_e
operator|->
name|count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Implementation of CFG manipulation for linearized RTL.  */
end_comment

begin_decl_stmt
name|struct
name|cfg_hooks
name|rtl_cfg_hooks
init|=
block|{
name|rtl_verify_flow_info
block|,
name|rtl_dump_bb
block|,
name|rtl_create_basic_block
block|,
name|rtl_redirect_edge_and_branch
block|,
name|rtl_redirect_edge_and_branch_force
block|,
name|rtl_delete_block
block|,
name|rtl_split_block
block|,
name|rtl_can_merge_blocks
block|,
comment|/* can_merge_blocks_p */
name|rtl_merge_blocks
block|,
name|rtl_split_edge
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implementation of CFG manipulation for cfg layout RTL, where    basic block connected via fallthru edges does not have to be adjacent.    This representation will hopefully become the default one in future    version of the compiler.  */
end_comment

begin_decl_stmt
name|struct
name|cfg_hooks
name|cfg_layout_rtl_cfg_hooks
init|=
block|{
name|rtl_verify_flow_info_1
block|,
name|rtl_dump_bb
block|,
name|cfg_layout_create_basic_block
block|,
name|cfg_layout_redirect_edge_and_branch
block|,
name|cfg_layout_redirect_edge_and_branch_force
block|,
name|cfg_layout_delete_block
block|,
name|cfg_layout_split_block
block|,
name|cfg_layout_can_merge_blocks_p
block|,
name|cfg_layout_merge_blocks
block|,
name|cfg_layout_split_edge
block|}
decl_stmt|;
end_decl_stmt

end_unit

