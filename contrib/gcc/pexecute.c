begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.    Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file exports two functions: pexecute and pwait.  */
end_comment

begin_comment
comment|/* This file lives in at least two places: libiberty and gcc.    Don't change one without the other.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IN_GCC
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IN_GCC
end_ifdef

begin_include
include|#
directive|include
file|"gansidecl.h"
end_include

begin_comment
comment|/* ??? Need to find a suitable header file.  */
end_comment

begin_define
define|#
directive|define
name|PEXECUTE_FIRST
value|1
end_define

begin_define
define|#
directive|define
name|PEXECUTE_LAST
value|2
end_define

begin_define
define|#
directive|define
name|PEXECUTE_ONE
value|(PEXECUTE_FIRST + PEXECUTE_LAST)
end_define

begin_define
define|#
directive|define
name|PEXECUTE_SEARCH
value|4
end_define

begin_define
define|#
directive|define
name|PEXECUTE_VERBOSE
value|8
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* stdin file number.  */
end_comment

begin_define
define|#
directive|define
name|STDIN_FILE_NO
value|0
end_define

begin_comment
comment|/* stdout file number.  */
end_comment

begin_define
define|#
directive|define
name|STDOUT_FILE_NO
value|1
end_define

begin_comment
comment|/* value of `pipe': port index for reading.  */
end_comment

begin_define
define|#
directive|define
name|READ_PORT
value|0
end_define

begin_comment
comment|/* value of `pipe': port index for writing.  */
end_comment

begin_define
define|#
directive|define
name|WRITE_PORT
value|1
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|install_error_msg
init|=
literal|"installation problem, cannot exec `%s'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pexecute: execute a program.     PROGRAM and ARGV are the arguments to execv/execvp.     THIS_PNAME is name of the calling program (i.e. argv[0]).     TEMP_BASE is the path name, sans suffix, of a temporary file to use    if needed.  This is currently only needed for MSDOS ports that don't use    GO32 (do any still exist?).  Ports that don't need it can pass NULL.     (FLAGS& PEXECUTE_SEARCH) is non-zero if $PATH should be searched    (??? It's not clear that GCC passes this flag correctly).    (FLAGS& PEXECUTE_FIRST) is nonzero for the first process in chain.    (FLAGS& PEXECUTE_FIRST) is nonzero for the last process in chain.    FIRST_LAST could be simplified to only mark the last of a chain of processes    but that requires the caller to always mark the last one (and not give up    early if some error occurs).  It's more robust to require the caller to    mark both ends of the chain.     The result is the pid on systems like Unix where we fork/exec and on systems    like WIN32 and OS2 where we use spawn.  It is up to the caller to wait for    the child.     The result is the WEXITSTATUS on systems like MSDOS where we spawn and wait    for the child here.     Upon failure, ERRMSG_FMT and ERRMSG_ARG are set to the text of the error    message with an optional argument (if not needed, ERRMSG_ARG is set to    NULL), and -1 is returned.  `errno' is available to the caller to use.     pwait: cover function for wait.     PID is the process id of the task to wait for.    STATUS is the `status' argument to wait.    FLAGS is currently unused (allows future enhancement without breaking    upward compatibility).  Pass 0 for now.     The result is the pid of the child reaped,    or -1 for failure (errno says why).     On systems that don't support waiting for a particular child, PID is    ignored.  On systems like MSDOS that don't really multitask pwait    is just a mechanism to provide a consistent interface for the caller.     pfinish: finish generation of script     pfinish is necessary for systems like MPW where a script is generated that    runs the requested programs. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_comment
comment|/* MSDOS doesn't multitask, but for the sake of a consistent interface    the code behaves like it does.  pexecute runs the program, tucks the    exit code away, and returns a "pid".  pwait must be called to fetch the    exit code.  */
end_comment

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_comment
comment|/* For communicating information from pexecute to pwait.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_pid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_reaped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rc
decl_stmt|;
name|last_pid
operator|++
expr_stmt|;
if|if
condition|(
name|last_pid
operator|<
literal|0
condition|)
name|last_pid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PEXECUTE_ONE
operator|)
operator|!=
name|PEXECUTE_ONE
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__GO32__
comment|/* ??? What are the possible return values from spawnv?  */
name|rc
operator|=
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
name|spawnvp
else|:
name|spawnv
operator|)
operator|(
literal|1
operator|,
name|program
operator|,
name|argv
operator|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|scmd
decl_stmt|,
modifier|*
name|rf
decl_stmt|;
name|FILE
modifier|*
name|argfile
decl_stmt|;
name|int
name|i
decl_stmt|,
name|el
init|=
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
literal|4
else|:
literal|0
decl_stmt|;
name|scmd
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|program
argument_list|)
operator|+
name|strlen
argument_list|(
name|temp_base
argument_list|)
operator|+
literal|6
operator|+
name|el
argument_list|)
expr_stmt|;
name|rf
operator|=
name|scmd
operator|+
name|strlen
argument_list|(
name|program
argument_list|)
operator|+
literal|2
operator|+
name|el
expr_stmt|;
name|sprintf
argument_list|(
name|scmd
argument_list|,
literal|"%s%s @%s.gp"
argument_list|,
name|program
argument_list|,
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
literal|".exe"
else|:
literal|""
operator|)
argument_list|,
name|temp_base
argument_list|)
expr_stmt|;
name|argfile
operator|=
name|fopen
argument_list|(
name|rf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argfile
operator|==
literal|0
condition|)
block|{
name|int
name|errno_save
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|errno_save
expr_stmt|;
operator|*
name|errmsg_fmt
operator|=
literal|"cannot open `%s.gp'"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|temp_base
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|'\''
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|argfile
argument_list|)
expr_stmt|;
name|rc
operator|=
name|system
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
block|{
name|int
name|errno_save
init|=
name|errno
decl_stmt|;
name|remove
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|errno_save
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
name|install_error_msg
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|program
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Tuck the status away for pwait, and return a "pid".  */
name|last_status
operator|=
name|rc
operator|<<
literal|8
expr_stmt|;
return|return
name|last_pid
return|;
block|}
end_block

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* On MSDOS each pexecute must be followed by it's associated pwait.  */
if|if
condition|(
name|pid
operator|!=
name|last_pid
comment|/* Called twice for the same child?  */
operator|||
name|pid
operator|==
name|last_reaped
condition|)
block|{
comment|/* ??? ECHILD would be a better choice.  Can we use it here?  */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ??? Here's an opportunity to canonicalize the values in STATUS.      Needed?  */
operator|*
name|status
operator|=
name|last_status
expr_stmt|;
name|last_reaped
operator|=
name|last_pid
expr_stmt|;
return|return
name|last_pid
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN32__
end_ifdef

begin_define
define|#
directive|define
name|fix_argv
parameter_list|(
name|argvec
parameter_list|)
value|(argvec)
end_define

begin_function_decl
specifier|extern
name|int
name|_spawnv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_spawnvp
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PEXECUTE_ONE
operator|)
operator|!=
name|PEXECUTE_ONE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pid
operator|=
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
name|_spawnvp
else|:
name|_spawnv
operator|)
operator|(
name|_P_NOWAIT
operator|,
name|program
operator|,
name|fix_argv
argument_list|(
name|argv
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
name|install_error_msg
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|program
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|pid
return|;
block|}
end_block

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* ??? Here's an opportunity to canonicalize the values in STATUS.      Needed?  */
return|return
name|cwait
argument_list|(
name|status
argument_list|,
name|pid
argument_list|,
name|WAIT_CHILD
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! __CYGWIN32__ */
end_comment

begin_comment
comment|/* This is a kludge to get around the Microsoft C spawn functions' propensity    to remove the outermost set of double quotes from all arguments.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|fix_argv
parameter_list|(
name|argvec
parameter_list|)
name|char
modifier|*
modifier|*
name|argvec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argvec
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|newtemp
decl_stmt|;
name|temp
operator|=
name|argvec
index|[
name|i
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|temp
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
block|{
name|newtemp
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newtemp
argument_list|,
name|temp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|newtemp
index|[
name|j
index|]
operator|=
literal|'\\'
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|newtemp
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
operator|&
name|temp
index|[
name|j
index|]
argument_list|,
name|len
operator|-
name|j
argument_list|)
expr_stmt|;
name|newtemp
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|newtemp
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|argvec
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|argvec
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* mingw32 headers may not define the following.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_P_WAIT
end_ifndef

begin_define
define|#
directive|define
name|_P_WAIT
value|0
end_define

begin_define
define|#
directive|define
name|_P_NOWAIT
value|1
end_define

begin_define
define|#
directive|define
name|_P_OVERLAY
value|2
end_define

begin_define
define|#
directive|define
name|_P_NOWAITO
value|3
end_define

begin_define
define|#
directive|define
name|_P_DETACH
value|4
end_define

begin_define
define|#
directive|define
name|WAIT_CHILD
value|0
end_define

begin_define
define|#
directive|define
name|WAIT_GRANDCHILD
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Win32 supports pipes */
end_comment

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|,
name|org_stdin
decl_stmt|,
name|org_stdout
decl_stmt|;
name|int
name|input_desc
decl_stmt|,
name|output_desc
decl_stmt|;
name|int
name|retries
decl_stmt|,
name|sleep_interval
decl_stmt|;
comment|/* Pipe waiting from last process, to be used as input for the next one.      Value is STDIN_FILE_NO if no pipe is waiting      (i.e. the next command is the first of a group).  */
specifier|static
name|int
name|last_pipe_input
decl_stmt|;
comment|/* If this is the first process, initialize.  */
if|if
condition|(
name|flags
operator|&
name|PEXECUTE_FIRST
condition|)
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
name|input_desc
operator|=
name|last_pipe_input
expr_stmt|;
comment|/* If this isn't the last process, make a pipe for its output,      and record it as waiting to be the input to the next process.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PEXECUTE_LAST
operator|)
condition|)
block|{
if|if
condition|(
name|_pipe
argument_list|(
name|pdes
argument_list|,
literal|256
argument_list|,
name|O_BINARY
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
literal|"pipe"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|output_desc
operator|=
name|pdes
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|last_pipe_input
operator|=
name|pdes
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Last process.  */
name|output_desc
operator|=
name|STDOUT_FILE_NO
expr_stmt|;
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
block|}
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|org_stdin
operator|=
name|dup
argument_list|(
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|input_desc
argument_list|,
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|org_stdout
operator|=
name|dup
argument_list|(
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|output_desc
argument_list|,
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
name|_spawnvp
else|:
name|_spawnv
operator|)
operator|(
name|_P_NOWAIT
operator|,
name|program
operator|,
name|fix_argv
argument_list|(
name|argv
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|dup2
argument_list|(
name|org_stdin
argument_list|,
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|org_stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|dup2
argument_list|(
name|org_stdout
argument_list|,
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|org_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
name|install_error_msg
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|program
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|pid
return|;
block|}
end_block

begin_comment
comment|/* MS CRTDLL doesn't return enough information in status to decide if the    child exited due to a signal or not, rather it simply returns an    integer with the exit code of the child; eg., if the child exited with     an abort() call and didn't have a handler for SIGABRT, it simply returns    with status = 3. We fix the status code to conform to the usual WIF*    macros. Note that WIFSIGNALED will never be true under CRTDLL. */
end_comment

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|termstat
decl_stmt|;
name|pid
operator|=
name|_cwait
argument_list|(
operator|&
name|termstat
argument_list|,
name|pid
argument_list|,
name|WAIT_CHILD
argument_list|)
expr_stmt|;
comment|/* ??? Here's an opportunity to canonicalize the values in STATUS.      Needed?  */
comment|/* cwait returns the child process exit code in termstat.      A value of 3 indicates that the child caught a signal, but not      which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we      report SIGABRT.  */
if|if
condition|(
name|termstat
operator|==
literal|3
condition|)
operator|*
name|status
operator|=
name|SIGABRT
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|(
operator|(
operator|(
name|termstat
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (__CYGWIN32__) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_comment
comment|/* ??? Does OS2 have process.h?  */
end_comment

begin_function_decl
specifier|extern
name|int
name|spawnv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|spawnvp
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PEXECUTE_ONE
operator|)
operator|!=
name|PEXECUTE_ONE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* ??? Presumably 1 == _P_NOWAIT.  */
name|pid
operator|=
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
name|spawnvp
else|:
name|spawnv
operator|)
operator|(
literal|1
operator|,
name|program
operator|,
name|argv
operator|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
name|install_error_msg
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|program
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|pid
return|;
block|}
end_block

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* ??? Here's an opportunity to canonicalize the values in STATUS.      Needed?  */
name|int
name|pid
init|=
name|wait
argument_list|(
name|status
argument_list|)
decl_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MPW
end_ifdef

begin_comment
comment|/* MPW pexecute doesn't actually run anything; instead, it writes out    script commands that, when run, will do the actual executing.     For example, in GCC's case, GCC will write out several script commands:     cpp ...    cc1 ...    as ...    ld ...     and then exit.  None of the above programs will have run yet.  The task    that called GCC will then execute the script and cause cpp,etc. to run.    The caller must invoke pfinish before calling exit.  This adds    the finishing touches to the generated script.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tmpprogram
index|[
literal|255
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tmpname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mpwify_filename
argument_list|(
name|program
argument_list|,
name|tmpprogram
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|printf
argument_list|(
literal|"Set Failed 0\n"
argument_list|)
expr_stmt|;
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"If {Failed} == 0\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* If being verbose, output a copy of the command.  It should be      accurate enough and escaped enough to be "clickable".  */
if|if
condition|(
name|flags
operator|&
name|PEXECUTE_VERBOSE
condition|)
block|{
name|fputs
argument_list|(
literal|"\tEcho "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tmpprogram
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* See if we have an argument that needs fixing.  */
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|tmpname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|mpwify_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|tmpname
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
comment|/* Write an Option-d escape char in front of special chars.  */
if|if
condition|(
name|strchr
argument_list|(
literal|"'+"
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\266'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\t"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tmpprogram
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* See if we have an argument that needs fixing.  */
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|tmpname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|mpwify_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|tmpname
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
comment|/* Write an Option-d escape char in front of special chars.  */
if|if
condition|(
name|strchr
argument_list|(
literal|"'+"
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\266'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* Output commands that arrange to clean up and exit if a failure occurs.      We have to be careful to collect the status from the program that was      run, rather than some other script command.  Also, we don't exit      immediately, since necessary cleanups are at the end of the script.  */
name|fputs
argument_list|(
literal|"\tSet TmpStatus {Status}\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tIf {TmpStatus} != 0\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t\tSet Failed {TmpStatus}\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tEnd\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"End\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* We're just composing a script, can't fail here.  */
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out commands that will exit with the correct error code    if something in the script failed.  */
end_comment

begin_function
name|void
name|pfinish
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tExit \"{Failed}\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPW */
end_comment

begin_comment
comment|/* include for Unix-like environments but not for Dos-like environments */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MPW
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|vfork
parameter_list|()
value|(decc$$alloc_vfork_blocks()>= 0 ? \                lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|execv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|execvp
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IN_GCC
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|my_strerror
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
init|=
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
name|execvp
operator|:
name|execv
init|)
function_decl|;
name|int
name|pid
decl_stmt|;
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|input_desc
decl_stmt|,
name|output_desc
decl_stmt|;
name|int
name|retries
decl_stmt|,
name|sleep_interval
decl_stmt|;
comment|/* Pipe waiting from last process, to be used as input for the next one.      Value is STDIN_FILE_NO if no pipe is waiting      (i.e. the next command is the first of a group).  */
specifier|static
name|int
name|last_pipe_input
decl_stmt|;
comment|/* If this is the first process, initialize.  */
if|if
condition|(
name|flags
operator|&
name|PEXECUTE_FIRST
condition|)
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
name|input_desc
operator|=
name|last_pipe_input
expr_stmt|;
comment|/* If this isn't the last process, make a pipe for its output,      and record it as waiting to be the input to the next process.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PEXECUTE_LAST
operator|)
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pdes
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
literal|"pipe"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|output_desc
operator|=
name|pdes
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|last_pipe_input
operator|=
name|pdes
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Last process.  */
name|output_desc
operator|=
name|STDOUT_FILE_NO
expr_stmt|;
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
block|}
comment|/* Fork a subprocess; wait and retry if it fails.  */
name|sleep_interval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|retries
operator|=
literal|0
init|;
name|retries
operator|<
literal|4
condition|;
name|retries
operator|++
control|)
block|{
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|>=
literal|0
condition|)
break|break;
name|sleep
argument_list|(
name|sleep_interval
argument_list|)
expr_stmt|;
name|sleep_interval
operator|*=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
block|{
ifdef|#
directive|ifdef
name|vfork
operator|*
name|errmsg_fmt
operator|=
literal|"fork"
expr_stmt|;
else|#
directive|else
operator|*
name|errmsg_fmt
operator|=
literal|"vfork"
expr_stmt|;
endif|#
directive|endif
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
case|case
literal|0
case|:
comment|/* child */
comment|/* Move the input and output pipes into place, if necessary.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
block|}
comment|/* Close the parent's descs that aren't wanted here.  */
if|if
condition|(
name|last_pipe_input
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|last_pipe_input
argument_list|)
expr_stmt|;
comment|/* Exec the program.  */
call|(
modifier|*
name|func
call|)
argument_list|(
name|program
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Note: Calling fprintf and exit here doesn't seem right for vfork.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|this_pname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|install_error_msg
argument_list|,
name|program
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IN_GCC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
default|default:
comment|/* In the parent, after forking. 	 Close the descriptors that we made for this child.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
comment|/* Return child's process number.  */
return|return
name|pid
return|;
block|}
block|}
end_block

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* ??? Here's an opportunity to canonicalize the values in STATUS.      Needed?  */
ifdef|#
directive|ifdef
name|VMS
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait
argument_list|(
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|pid
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! __MSDOS__&& ! OS2&& ! MPW&& ! _WIN32 */
end_comment

end_unit

