begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Exception handling and frame unwind runtime interface routines.    Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you include this header file into source    files compiled by GCC, this header file does not by itself cause    the resulting executable to be covered by the GNU General Public    License.  This exception does not however invalidate any other    reasons why the executable file might be covered by the GNU General    Public License.  */
end_comment

begin_comment
comment|/* This is derived from the C++ ABI for IA-64.  Where we diverge    for cross-architecture compatibility are noted with "@@@".  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_UNWIND_H
end_ifndef

begin_define
define|#
directive|define
name|_UNWIND_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* Level 1: Base ABI  */
comment|/* @@@ The IA-64 ABI uses uint64 throughout.  Most places this is    inefficient for 32-bit and smaller machines.  */
typedef|typedef
name|unsigned
name|_Unwind_Word
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__word__
typedef|)));
typedef|typedef
name|signed
name|_Unwind_Sword
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__word__
typedef|)));
if|#
directive|if
name|defined
argument_list|(
name|__ia64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__hpux__
argument_list|)
typedef|typedef
name|unsigned
name|_Unwind_Ptr
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__word__
typedef|)));
else|#
directive|else
typedef|typedef
name|unsigned
name|_Unwind_Ptr
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__pointer__
typedef|)));
endif|#
directive|endif
typedef|typedef
name|unsigned
name|_Unwind_Internal_Ptr
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__pointer__
typedef|)));
comment|/* @@@ The IA-64 ABI uses a 64-bit word to identify the producer and    consumer of an exception.  We'll go along with this for now even on    32-bit machines.  We'll need to provide some other option for    16-bit machines and for machines with> 8 bits per byte.  */
typedef|typedef
name|unsigned
name|_Unwind_Exception_Class
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__DI__
typedef|)));
comment|/* The unwind interface uses reason codes in several contexts to    identify the reasons for failures or other actions.  */
typedef|typedef
enum|enum
block|{
name|_URC_NO_REASON
init|=
literal|0
block|,
name|_URC_FOREIGN_EXCEPTION_CAUGHT
init|=
literal|1
block|,
name|_URC_FATAL_PHASE2_ERROR
init|=
literal|2
block|,
name|_URC_FATAL_PHASE1_ERROR
init|=
literal|3
block|,
name|_URC_NORMAL_STOP
init|=
literal|4
block|,
name|_URC_END_OF_STACK
init|=
literal|5
block|,
name|_URC_HANDLER_FOUND
init|=
literal|6
block|,
name|_URC_INSTALL_CONTEXT
init|=
literal|7
block|,
name|_URC_CONTINUE_UNWIND
init|=
literal|8
block|}
name|_Unwind_Reason_Code
typedef|;
comment|/* The unwind interface uses a pointer to an exception header object    as its representation of an exception being thrown. In general, the    full representation of an exception object is language- and    implementation-specific, but it will be prefixed by a header    understood by the unwind interface.  */
struct_decl|struct
name|_Unwind_Exception
struct_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|_Unwind_Exception_Cleanup_Fn
function_decl|)
parameter_list|(
name|_Unwind_Reason_Code
parameter_list|,
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
struct|struct
name|_Unwind_Exception
block|{
name|_Unwind_Exception_Class
name|exception_class
decl_stmt|;
name|_Unwind_Exception_Cleanup_Fn
name|exception_cleanup
decl_stmt|;
name|_Unwind_Word
name|private_1
decl_stmt|;
name|_Unwind_Word
name|private_2
decl_stmt|;
comment|/* @@@ The IA-64 ABI says that this structure must be double-word aligned.      Taking that literally does not make much sense generically.  Instead we      provide the maximum alignment required by any type for the machine.  */
block|}
name|__attribute__
argument_list|(
operator|(
name|__aligned__
operator|)
argument_list|)
struct|;
comment|/* The ACTIONS argument to the personality routine is a bitwise OR of one    or more of the following constants.  */
typedef|typedef
name|int
name|_Unwind_Action
typedef|;
define|#
directive|define
name|_UA_SEARCH_PHASE
value|1
define|#
directive|define
name|_UA_CLEANUP_PHASE
value|2
define|#
directive|define
name|_UA_HANDLER_FRAME
value|4
define|#
directive|define
name|_UA_FORCE_UNWIND
value|8
define|#
directive|define
name|_UA_END_OF_STACK
value|16
comment|/* This is an opaque type used to refer to a system-specific data    structure used by the system unwinder. This context is created and    destroyed by the system, and passed to the personality routine    during unwinding.  */
struct_decl|struct
name|_Unwind_Context
struct_decl|;
comment|/* Raise an exception, passing along the given exception object.  */
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_RaiseException
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
comment|/* Raise an exception for forced unwinding.  */
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Stop_Fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|_Unwind_Action
parameter_list|,
name|_Unwind_Exception_Class
parameter_list|,
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_ForcedUnwind
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|,
name|_Unwind_Stop_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* Helper to invoke the exception_cleanup routine.  */
specifier|extern
name|void
name|_Unwind_DeleteException
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
comment|/* Resume propagation of an existing exception.  This is used after    e.g. executing cleanup code, and not to implement rethrowing.  */
specifier|extern
name|void
name|_Unwind_Resume
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
comment|/* @@@ Resume propagation of an FORCE_UNWIND exception, or to rethrow    a normal exception that was handled.  */
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_Resume_or_Rethrow
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
comment|/* @@@ Use unwind data to perform a stack backtrace.  The trace callback    is called for every stack frame in the call chain, but no cleanup    actions are performed.  */
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Trace_Fn
function_decl|)
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_Backtrace
parameter_list|(
name|_Unwind_Trace_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* These functions are used for communicating information about the unwind    context (i.e. the unwind descriptors and the user register state) between    the unwind library and the personality routine and landing pad.  Only    selected registers maybe manipulated.  */
specifier|extern
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|int
parameter_list|,
name|_Unwind_Word
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Ptr
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|_Unwind_Ptr
parameter_list|)
function_decl|;
comment|/* @@@ Retrieve the CFA of the given context.  */
specifier|extern
name|_Unwind_Word
name|_Unwind_GetCFA
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
comment|/* The personality routine is the function in the C++ (or other language)    runtime library which serves as an interface between the system unwind    library and language-specific exception handling semantics.  It is    specific to the code fragment described by an unwind info block, and    it is always referenced via the pointer in the unwind info block, and    hence it has no ABI-specified name.     Note that this implies that two different C++ implementations can    use different names, and have different contents in the language    specific data area.  Moreover, that the language specific data    area contains no version info because name of the function invoked    provides more effective versioning by detecting at link time the    lack of code to handle the different data format.  */
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Personality_Fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|_Unwind_Action
parameter_list|,
name|_Unwind_Exception_Class
parameter_list|,
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
comment|/* @@@ The following alternate entry points are for setjmp/longjmp    based unwinding.  */
struct_decl|struct
name|SjLj_Function_Context
struct_decl|;
specifier|extern
name|void
name|_Unwind_SjLj_Register
parameter_list|(
name|struct
name|SjLj_Function_Context
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SjLj_Unregister
parameter_list|(
name|struct
name|SjLj_Function_Context
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_SjLj_RaiseException
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_SjLj_ForcedUnwind
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|,
name|_Unwind_Stop_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SjLj_Resume
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_SjLj_Resume_or_Rethrow
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
comment|/* @@@ The following provide access to the base addresses for text    and data-relative addressing in the LDSA.  In order to stay link    compatible with the standard ABI for IA-64, we inline these.  */
ifdef|#
directive|ifdef
name|__ia64__
include|#
directive|include
file|<stdlib.h>
specifier|static
specifier|inline
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|_C
parameter_list|)
block|{
comment|/* The GP is stored in R1.  */
return|return
name|_Unwind_GetGR
argument_list|(
name|_C
argument_list|,
literal|1
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|_C
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* @@@ Retrieve the Backing Store Pointer of the given context.  */
specifier|extern
name|_Unwind_Word
name|_Unwind_GetBSP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* @@@ Given an address, return the entry point of the function that    contains it.  */
specifier|extern
name|void
modifier|*
name|_Unwind_FindEnclosingFunction
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unwind.h */
end_comment

end_unit

