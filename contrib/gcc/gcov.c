begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Gcov.c: prepend line execution counts and branch probabilities to a    source file.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by James E. Wilson of Cygnus Support.    Mangled by Bob Manson of Cygnus Support.    Mangled further by Nathan Sidwell<nathan@codesourcery.com>  Gcov is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Gcov is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Gcov; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ??? Print a list of the ten blocks with the highest execution counts,    and list the line numbers corresponding to those blocks.  Also, perhaps    list the line numbers with the highest execution counts, only printing    the first if there are several which are all listed in the same block.  */
end_comment

begin_comment
comment|/* ??? Should have an option to print the number of basic blocks, and the    percent of them that are covered.  */
end_comment

begin_comment
comment|/* ??? Does not correctly handle the case where two .bb files refer to    the same included source file.  For example, if one has a short    file containing only inline functions, which is then included in    two other files, then there will be two .bb files which refer to    the include file, but there is no way to get the total execution    counts for the included file, can only get execution counts for one    or the other of the including files. this can be fixed by --ratios    --long-file-names --preserve-paths and perl.  */
end_comment

begin_comment
comment|/* Need an option to show individual block counts, and show    probabilities of fall through arcs.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_define
define|#
directive|define
name|IN_GCOV
value|1
end_define

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_include
include|#
directive|include
file|"gcov-io.c"
end_include

begin_comment
comment|/* The bbg file is generated by -ftest-coverage option. The da file is    generated by a program compiled with -fprofile-arcs. Their formats    are documented in gcov-io.h.  */
end_comment

begin_comment
comment|/* The functions in this file for creating and solution program flow graphs    are very similar to functions in the gcc source file profile.c.  In    some places we make use of the knowledge of how profile.c works to    select particular algorithms here.  */
end_comment

begin_comment
comment|/* This is the size of the buffer used to read in source file lines.  */
end_comment

begin_define
define|#
directive|define
name|STRING_SIZE
value|200
end_define

begin_struct_decl
struct_decl|struct
name|function_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|block_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|source_info
struct_decl|;
end_struct_decl

begin_comment
comment|/* Describes an arc between two basic blocks.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|arc_info
block|{
comment|/* source and destination blocks.  */
name|struct
name|block_info
modifier|*
name|src
decl_stmt|;
name|struct
name|block_info
modifier|*
name|dst
decl_stmt|;
comment|/* transition counts.  */
name|gcov_type
name|count
decl_stmt|;
comment|/* used in cycle search, so that we do not clobber original counts.  */
name|gcov_type
name|cs_count
decl_stmt|;
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fake
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fall_through
range|:
literal|1
decl_stmt|;
comment|/* Arc is for a function that abnormally returns.  */
name|unsigned
name|int
name|is_call_non_return
range|:
literal|1
decl_stmt|;
comment|/* Arc is for catch/setjump.  */
name|unsigned
name|int
name|is_nonlocal_return
range|:
literal|1
decl_stmt|;
comment|/* Is an unconditional branch.  */
name|unsigned
name|int
name|is_unconditional
range|:
literal|1
decl_stmt|;
comment|/* Loop making arc.  */
name|unsigned
name|int
name|cycle
range|:
literal|1
decl_stmt|;
comment|/* Next branch on line.  */
name|struct
name|arc_info
modifier|*
name|line_next
decl_stmt|;
comment|/* Links to next arc on src and dst lists.  */
name|struct
name|arc_info
modifier|*
name|succ_next
decl_stmt|;
name|struct
name|arc_info
modifier|*
name|pred_next
decl_stmt|;
block|}
name|arc_t
typedef|;
end_typedef

begin_comment
comment|/* Describes a basic block. Contains lists of arcs to successor and    predecessor blocks.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|block_info
block|{
comment|/* Chain of exit and entry arcs.  */
name|arc_t
modifier|*
name|succ
decl_stmt|;
name|arc_t
modifier|*
name|pred
decl_stmt|;
comment|/* Number of unprocessed exit and entry arcs.  */
name|gcov_type
name|num_succ
decl_stmt|;
name|gcov_type
name|num_pred
decl_stmt|;
comment|/* Block execution count.  */
name|gcov_type
name|count
decl_stmt|;
name|unsigned
name|flags
range|:
literal|13
decl_stmt|;
name|unsigned
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|valid_chain
range|:
literal|1
decl_stmt|;
name|unsigned
name|invalid_chain
range|:
literal|1
decl_stmt|;
comment|/* Block is a call instrumenting site.  */
name|unsigned
name|is_call_site
range|:
literal|1
decl_stmt|;
comment|/* Does the call.  */
name|unsigned
name|is_call_return
range|:
literal|1
decl_stmt|;
comment|/* Is the return.  */
comment|/* Block is a landing pad for longjmp or throw.  */
name|unsigned
name|is_nonlocal_return
range|:
literal|1
decl_stmt|;
union|union
block|{
struct|struct
block|{
comment|/* Array of line numbers and source files. source files are         introduced by a linenumber of zero, the next 'line number' is         the number of the source file.  Always starts with a source         file.  */
name|unsigned
modifier|*
name|encoding
decl_stmt|;
name|unsigned
name|num
decl_stmt|;
block|}
name|line
struct|;
comment|/* Valid until blocks are linked onto lines */
struct|struct
block|{
comment|/* Single line graph cycle workspace.  Used for all-blocks 	 mode.  */
name|arc_t
modifier|*
name|arc
decl_stmt|;
name|unsigned
name|ident
decl_stmt|;
block|}
name|cycle
struct|;
comment|/* Used in all-blocks mode, after blocks are linked onto 	       lines.  */
block|}
name|u
union|;
comment|/* Temporary chain for solving graph, and for chaining blocks on one      line.  */
name|struct
name|block_info
modifier|*
name|chain
decl_stmt|;
block|}
name|block_t
typedef|;
end_typedef

begin_comment
comment|/* Describes a single function. Contains an array of basic blocks.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|function_info
block|{
comment|/* Name of function.  */
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|ident
decl_stmt|;
name|unsigned
name|checksum
decl_stmt|;
comment|/* Array of basic blocks.  */
name|block_t
modifier|*
name|blocks
decl_stmt|;
name|unsigned
name|num_blocks
decl_stmt|;
name|unsigned
name|blocks_executed
decl_stmt|;
comment|/* Raw arc coverage counts.  */
name|gcov_type
modifier|*
name|counts
decl_stmt|;
name|unsigned
name|num_counts
decl_stmt|;
comment|/* First line number.  */
name|unsigned
name|line
decl_stmt|;
name|struct
name|source_info
modifier|*
name|src
decl_stmt|;
comment|/* Next function in same source file.  */
name|struct
name|function_info
modifier|*
name|line_next
decl_stmt|;
comment|/* Next function.  */
name|struct
name|function_info
modifier|*
name|next
decl_stmt|;
block|}
name|function_t
typedef|;
end_typedef

begin_comment
comment|/* Describes coverage of a file or function.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|coverage_info
block|{
name|int
name|lines
decl_stmt|;
name|int
name|lines_executed
decl_stmt|;
name|int
name|branches
decl_stmt|;
name|int
name|branches_executed
decl_stmt|;
name|int
name|branches_taken
decl_stmt|;
name|int
name|calls
decl_stmt|;
name|int
name|calls_executed
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|coverage_t
typedef|;
end_typedef

begin_comment
comment|/* Describes a single line of source. Contains a chain of basic blocks    with code on it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|line_info
block|{
name|gcov_type
name|count
decl_stmt|;
comment|/* execution count */
union|union
block|{
name|arc_t
modifier|*
name|branches
decl_stmt|;
comment|/* branches from blocks that end on this 			      line. Used for branch-counts when not 			      all-blocks mode.  */
name|block_t
modifier|*
name|blocks
decl_stmt|;
comment|/* blocks which start on this line.  Used 			      in all-blocks mode.  */
block|}
name|u
union|;
name|unsigned
name|exists
range|:
literal|1
decl_stmt|;
block|}
name|line_t
typedef|;
end_typedef

begin_comment
comment|/* Describes a file mentioned in the block graph.  Contains an array    of line info.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|source_info
block|{
comment|/* Name of source file.  */
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|index
decl_stmt|;
comment|/* Array of line information.  */
name|line_t
modifier|*
name|lines
decl_stmt|;
name|unsigned
name|num_lines
decl_stmt|;
name|coverage_t
name|coverage
decl_stmt|;
comment|/* Functions in this source file.  These are in ascending line      number order.  */
name|function_t
modifier|*
name|functions
decl_stmt|;
comment|/* Next source file.  */
name|struct
name|source_info
modifier|*
name|next
decl_stmt|;
block|}
name|source_t
typedef|;
end_typedef

begin_comment
comment|/* Holds a list of function basic block graphs.  */
end_comment

begin_decl_stmt
specifier|static
name|function_t
modifier|*
name|functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the head of the sourcefile structure list.  */
end_comment

begin_decl_stmt
specifier|static
name|source_t
modifier|*
name|sources
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This holds data summary information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gcov_summary
name|object_summary
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|program_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Modification time of graph file.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|bbg_file_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the basic block graph.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bbg_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stamp of the bbg file */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|bbg_stamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the arc count data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|da_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output branch probabilities.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_branches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Show unconditional branches too.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_unconditional
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output a gcov file if this is true.  This is on by default, and can    be turned off by the -n option.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_gcov_file
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For included files, make the gcov output file name include the name    of the input source file.  For example, if x.h is included in a.c,    then the output file name is a.c##x.h.gcov instead of x.h.gcov.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_long_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output count information for every basic block, not merely those    that contain line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_all_blocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output summary info for each function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_function_summary
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Object directory file prefix.  This is the directory/file where the    graph and data files are looked for, if nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|object_directory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preserve all pathname components. Needed when object files and    source files are in subdirectories. '/' is mangled as '#', '.' is    elided and '..' mangled to '^'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_preserve_paths
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output the number of times a branch was taken as opposed to the percentage    of times it was taken.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_counts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fnotice
argument_list|(
name|FILE
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|process_args
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|print_usage
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_version
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|process_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_file_names
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|source_t
modifier|*
name|find_source
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_graph_file
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_count_file
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|solve_flow_graph
parameter_list|(
name|function_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_branch_counts
parameter_list|(
name|coverage_t
modifier|*
parameter_list|,
specifier|const
name|arc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_line_counts
parameter_list|(
name|coverage_t
modifier|*
parameter_list|,
name|function_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|function_summary
parameter_list|(
specifier|const
name|coverage_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|format_gcov
parameter_list|(
name|gcov_type
parameter_list|,
name|gcov_type
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|accumulate_line_counts
parameter_list|(
name|source_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|output_branch_count
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|arc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_lines
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|source_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|make_gcov_file_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_structures
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|argno
decl_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
name|argno
operator|=
name|process_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|print_usage
argument_list|(
name|true
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|argno
operator|!=
name|argc
condition|;
name|argno
operator|++
control|)
block|{
name|release_structures
argument_list|()
expr_stmt|;
name|process_file
argument_list|(
name|argv
index|[
name|argno
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fnotice
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|fancy_abort
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fancy_abort
parameter_list|(
name|void
parameter_list|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Internal gcov abort.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a usage message and exit.  If ERROR_P is nonzero, this is an error,    otherwise the output of --help.  */
end_comment

begin_function
specifier|static
name|void
name|print_usage
parameter_list|(
name|int
name|error_p
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|error_p
condition|?
name|stderr
else|:
name|stdout
decl_stmt|;
name|int
name|status
init|=
name|error_p
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
decl_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"Usage: gcov [OPTION]... SOURCEFILE\n\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"Print code coverage information.\n\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -h, --help                      Print this help, then exit\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -v, --version                   Print version number, then exit\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -a, --all-blocks                Show information for every basic block\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -b, --branch-probabilities      Include branch probabilities in output\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -c, --branch-counts             Given counts of branches taken\n\                                     rather than percentages\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -n, --no-output                 Do not create an output file\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -l, --long-file-names           Use long output file names for included\n\                                     source files\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -f, --function-summaries        Output summaries for each function\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -p, --preserve-paths            Preserve all pathname components\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -u, --unconditional-branches    Show unconditional branch counts too\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"\nFor bug reporting instructions, please see:\n%s.\n"
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print version information and exit.  */
end_comment

begin_function
specifier|static
name|void
name|print_version
parameter_list|(
name|void
parameter_list|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"gcov (GCC) %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Copyright %s 2004 Free Software Foundation, Inc.\n"
argument_list|,
name|_
argument_list|(
literal|"(C)"
argument_list|)
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"This is free software; see the source for copying conditions.\n"
literal|"There is NO warranty; not even for MERCHANTABILITY or \n"
literal|"FITNESS FOR A PARTICULAR PURPOSE.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"all-blocks"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"branch-probabilities"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"branch-counts"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"no-output"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"long-file-names"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"function-summaries"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"preserve-paths"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"object-directory"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"object-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"unconditional-branches"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process args, return index to first non-arg.  */
end_comment

begin_function
specifier|static
name|int
name|process_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abcfhlno:puv"
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'a'
case|:
name|flag_all_blocks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|flag_branches
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flag_counts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flag_function_summary
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|print_usage
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* print_usage will exit.  */
case|case
literal|'l'
case|:
name|flag_long_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flag_gcov_file
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|object_directory
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flag_preserve_paths
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|flag_unconditional
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|print_version
argument_list|()
expr_stmt|;
comment|/* print_version will exit.  */
default|default:
name|print_usage
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* print_usage will exit.  */
block|}
block|}
return|return
name|optind
return|;
block|}
end_function

begin_comment
comment|/* Process a single source file.  */
end_comment

begin_function
specifier|static
name|void
name|process_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|source_t
modifier|*
name|src
decl_stmt|;
name|function_t
modifier|*
name|fn
decl_stmt|;
name|create_file_names
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_graph_file
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|functions
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:no functions found\n"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|read_count_file
argument_list|()
condition|)
return|return;
for|for
control|(
name|fn
operator|=
name|functions
init|;
name|fn
condition|;
name|fn
operator|=
name|fn
operator|->
name|next
control|)
name|solve_flow_graph
argument_list|(
name|fn
argument_list|)
expr_stmt|;
for|for
control|(
name|src
operator|=
name|sources
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
name|src
operator|->
name|lines
operator|=
name|xcalloc
argument_list|(
name|src
operator|->
name|num_lines
argument_list|,
sizeof|sizeof
argument_list|(
name|line_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|functions
init|;
name|fn
condition|;
name|fn
operator|=
name|fn
operator|->
name|next
control|)
block|{
name|coverage_t
name|coverage
decl_stmt|;
name|memset
argument_list|(
operator|&
name|coverage
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|coverage
argument_list|)
argument_list|)
expr_stmt|;
name|coverage
operator|.
name|name
operator|=
name|fn
operator|->
name|name
expr_stmt|;
name|add_line_counts
argument_list|(
name|flag_function_summary
condition|?
operator|&
name|coverage
else|:
name|NULL
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_function_summary
condition|)
block|{
name|function_summary
argument_list|(
operator|&
name|coverage
argument_list|,
literal|"Function"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|src
operator|=
name|sources
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
name|accumulate_line_counts
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|function_summary
argument_list|(
operator|&
name|src
operator|->
name|coverage
argument_list|,
literal|"File"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gcov_file
condition|)
block|{
name|char
modifier|*
name|gcov_file_name
init|=
name|make_gcov_file_name
argument_list|(
name|file_name
argument_list|,
name|src
operator|->
name|name
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|gcov_file
init|=
name|fopen
argument_list|(
name|gcov_file_name
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gcov_file
condition|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%s:creating `%s'\n"
argument_list|,
name|src
operator|->
name|name
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
name|output_lines
argument_list|(
name|gcov_file
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|gcov_file
argument_list|)
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:error writing output file `%s'\n"
argument_list|,
name|src
operator|->
name|name
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|gcov_file
argument_list|)
expr_stmt|;
block|}
else|else
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:could not open output file `%s'\n"
argument_list|,
name|src
operator|->
name|name
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gcov_file_name
argument_list|)
expr_stmt|;
block|}
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Release all memory used.  */
end_comment

begin_function
specifier|static
name|void
name|release_structures
parameter_list|(
name|void
parameter_list|)
block|{
name|function_t
modifier|*
name|fn
decl_stmt|;
name|source_t
modifier|*
name|src
decl_stmt|;
name|free
argument_list|(
name|bbg_file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|da_file_name
argument_list|)
expr_stmt|;
name|da_file_name
operator|=
name|bbg_file_name
operator|=
name|NULL
expr_stmt|;
name|bbg_file_time
operator|=
literal|0
expr_stmt|;
name|bbg_stamp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|src
operator|=
name|sources
operator|)
condition|)
block|{
name|sources
operator|=
name|src
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|src
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src
operator|->
name|lines
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|fn
operator|=
name|functions
operator|)
condition|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|block_t
modifier|*
name|block
decl_stmt|;
name|functions
operator|=
name|fn
operator|->
name|next
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|fn
operator|->
name|num_blocks
operator|,
name|block
operator|=
name|fn
operator|->
name|blocks
init|;
name|ix
operator|--
condition|;
name|block
operator|++
control|)
block|{
name|arc_t
modifier|*
name|arc
decl_stmt|,
modifier|*
name|arc_n
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|block
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc_n
control|)
block|{
name|arc_n
operator|=
name|arc
operator|->
name|succ_next
expr_stmt|;
name|free
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|fn
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
operator|->
name|counts
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the names of the graph and data files. If OBJECT_DIRECTORY    is not specified, these are looked for in the current directory,    and named from the basename of the FILE_NAME sans extension. If    OBJECT_DIRECTORY is specified and is a directory, the files are in    that directory, but named from the basename of the FILE_NAME, sans    extension. Otherwise OBJECT_DIRECTORY is taken to be the name of    the object *file*, and the data files are named from that.  */
end_comment

begin_function
specifier|static
name|void
name|create_file_names
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|char
modifier|*
name|cptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|file_name
argument_list|)
decl_stmt|;
name|int
name|base
decl_stmt|;
if|if
condition|(
name|object_directory
operator|&&
name|object_directory
index|[
literal|0
index|]
condition|)
block|{
name|struct
name|stat
name|status
decl_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|object_directory
argument_list|)
operator|+
literal|2
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|base
operator|=
operator|!
name|stat
argument_list|(
name|object_directory
argument_list|,
operator|&
name|status
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|status
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|object_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|&&
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|base
condition|)
block|{
comment|/* Append source file name.  */
name|cptr
operator|=
name|strrchr
argument_list|(
name|file_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|cptr
condition|?
name|cptr
operator|+
literal|1
else|:
name|file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the extension.  */
name|cptr
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
operator|*
name|cptr
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bbg_file_name
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
name|strlen
argument_list|(
name|GCOV_NOTE_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
operator|+
name|length
argument_list|,
name|GCOV_NOTE_SUFFIX
argument_list|)
expr_stmt|;
name|da_file_name
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
name|strlen
argument_list|(
name|GCOV_DATA_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|da_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|da_file_name
operator|+
name|length
argument_list|,
name|GCOV_DATA_SUFFIX
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Find or create a source file structure for FILE_NAME. Copies    FILE_NAME on creation */
end_comment

begin_function
specifier|static
name|source_t
modifier|*
name|find_source
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|source_t
modifier|*
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
name|file_name
operator|=
literal|"<unknown>"
expr_stmt|;
for|for
control|(
name|src
operator|=
name|sources
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|src
operator|->
name|name
argument_list|)
condition|)
return|return
name|src
return|;
name|src
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|source_t
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|src
operator|->
name|coverage
operator|.
name|name
operator|=
name|src
operator|->
name|name
expr_stmt|;
name|src
operator|->
name|index
operator|=
name|sources
condition|?
name|sources
operator|->
name|index
operator|+
literal|1
else|:
literal|1
expr_stmt|;
name|src
operator|->
name|next
operator|=
name|sources
expr_stmt|;
name|sources
operator|=
name|src
expr_stmt|;
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/* Read the graph file. Return nonzero on fatal error.  */
end_comment

begin_function
specifier|static
name|int
name|read_graph_file
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|version
decl_stmt|;
name|unsigned
name|current_tag
init|=
literal|0
decl_stmt|;
name|struct
name|function_info
modifier|*
name|fn
init|=
name|NULL
decl_stmt|;
name|source_t
modifier|*
name|src
init|=
name|NULL
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|unsigned
name|tag
decl_stmt|;
if|if
condition|(
operator|!
name|gcov_open
argument_list|(
name|bbg_file_name
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:cannot open graph file\n"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bbg_file_time
operator|=
name|gcov_time
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gcov_magic
argument_list|(
name|gcov_read_unsigned
argument_list|()
argument_list|,
name|GCOV_NOTE_MAGIC
argument_list|)
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:not a gcov graph file\n"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
name|gcov_close
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|version
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|GCOV_VERSION
condition|)
block|{
name|char
name|v
index|[
literal|4
index|]
decl_stmt|,
name|e
index|[
literal|4
index|]
decl_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|v
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|e
argument_list|,
name|GCOV_VERSION
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:version `%.4s', prefer `%.4s'\n"
argument_list|,
name|bbg_file_name
argument_list|,
name|v
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|bbg_stamp
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
operator|)
condition|)
block|{
name|unsigned
name|length
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
name|gcov_position_t
name|base
init|=
name|gcov_position
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|GCOV_TAG_FUNCTION
condition|)
block|{
name|char
modifier|*
name|function_name
decl_stmt|;
name|unsigned
name|ident
decl_stmt|,
name|checksum
decl_stmt|,
name|lineno
decl_stmt|;
name|source_t
modifier|*
name|src
decl_stmt|;
name|function_t
modifier|*
name|probe
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|ident
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|checksum
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|function_name
operator|=
name|xstrdup
argument_list|(
name|gcov_read_string
argument_list|()
argument_list|)
expr_stmt|;
name|src
operator|=
name|find_source
argument_list|(
name|gcov_read_string
argument_list|()
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|fn
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|function_t
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|->
name|name
operator|=
name|function_name
expr_stmt|;
name|fn
operator|->
name|ident
operator|=
name|ident
expr_stmt|;
name|fn
operator|->
name|checksum
operator|=
name|checksum
expr_stmt|;
name|fn
operator|->
name|src
operator|=
name|src
expr_stmt|;
name|fn
operator|->
name|line
operator|=
name|lineno
expr_stmt|;
name|fn
operator|->
name|next
operator|=
name|functions
expr_stmt|;
name|functions
operator|=
name|fn
expr_stmt|;
name|current_tag
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|lineno
operator|>=
name|src
operator|->
name|num_lines
condition|)
name|src
operator|->
name|num_lines
operator|=
name|lineno
operator|+
literal|1
expr_stmt|;
comment|/* Now insert it into the source file's list of 	     functions. Normally functions will be encountered in 	     ascending order, so a simple scan is quick.  */
for|for
control|(
name|probe
operator|=
name|src
operator|->
name|functions
operator|,
name|prev
operator|=
name|NULL
init|;
name|probe
operator|&&
name|probe
operator|->
name|line
operator|>
name|lineno
condition|;
name|prev
operator|=
name|probe
operator|,
name|probe
operator|=
name|probe
operator|->
name|line_next
control|)
continue|continue;
name|fn
operator|->
name|line_next
operator|=
name|probe
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|line_next
operator|=
name|fn
expr_stmt|;
else|else
name|src
operator|->
name|functions
operator|=
name|fn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn
operator|&&
name|tag
operator|==
name|GCOV_TAG_BLOCKS
condition|)
block|{
if|if
condition|(
name|fn
operator|->
name|blocks
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:already seen blocks for `%s'\n"
argument_list|,
name|bbg_file_name
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|ix
decl_stmt|,
name|num_blocks
init|=
name|GCOV_TAG_BLOCKS_NUM
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|fn
operator|->
name|num_blocks
operator|=
name|num_blocks
expr_stmt|;
name|fn
operator|->
name|blocks
operator|=
name|xcalloc
argument_list|(
name|fn
operator|->
name|num_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|block_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|num_blocks
condition|;
name|ix
operator|++
control|)
name|fn
operator|->
name|blocks
index|[
name|ix
index|]
operator|.
name|flags
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fn
operator|&&
name|tag
operator|==
name|GCOV_TAG_ARCS
condition|)
block|{
name|unsigned
name|src
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
name|unsigned
name|num_dests
init|=
name|GCOV_TAG_ARCS_NUM
argument_list|(
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|>=
name|fn
operator|->
name|num_blocks
operator|||
name|fn
operator|->
name|blocks
index|[
name|src
index|]
operator|.
name|succ
condition|)
goto|goto
name|corrupt
goto|;
while|while
condition|(
name|num_dests
operator|--
condition|)
block|{
name|struct
name|arc_info
modifier|*
name|arc
decl_stmt|;
name|unsigned
name|dest
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
name|unsigned
name|flags
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
if|if
condition|(
name|dest
operator|>=
name|fn
operator|->
name|num_blocks
condition|)
goto|goto
name|corrupt
goto|;
name|arc
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_t
argument_list|)
argument_list|)
expr_stmt|;
name|arc
operator|->
name|dst
operator|=
operator|&
name|fn
operator|->
name|blocks
index|[
name|dest
index|]
expr_stmt|;
name|arc
operator|->
name|src
operator|=
operator|&
name|fn
operator|->
name|blocks
index|[
name|src
index|]
expr_stmt|;
name|arc
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|arc
operator|->
name|count_valid
operator|=
literal|0
expr_stmt|;
name|arc
operator|->
name|on_tree
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|GCOV_ARC_ON_TREE
operator|)
expr_stmt|;
name|arc
operator|->
name|fake
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|GCOV_ARC_FAKE
operator|)
expr_stmt|;
name|arc
operator|->
name|fall_through
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|GCOV_ARC_FALLTHROUGH
operator|)
expr_stmt|;
name|arc
operator|->
name|succ_next
operator|=
name|fn
operator|->
name|blocks
index|[
name|src
index|]
operator|.
name|succ
expr_stmt|;
name|fn
operator|->
name|blocks
index|[
name|src
index|]
operator|.
name|succ
operator|=
name|arc
expr_stmt|;
name|fn
operator|->
name|blocks
index|[
name|src
index|]
operator|.
name|num_succ
operator|++
expr_stmt|;
name|arc
operator|->
name|pred_next
operator|=
name|fn
operator|->
name|blocks
index|[
name|dest
index|]
operator|.
name|pred
expr_stmt|;
name|fn
operator|->
name|blocks
index|[
name|dest
index|]
operator|.
name|pred
operator|=
name|arc
expr_stmt|;
name|fn
operator|->
name|blocks
index|[
name|dest
index|]
operator|.
name|num_pred
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|fake
condition|)
block|{
if|if
condition|(
name|src
condition|)
block|{
comment|/* Exceptional exit from this function, the 			 source block must be a call.  */
name|fn
operator|->
name|blocks
index|[
name|src
index|]
operator|.
name|is_call_site
operator|=
literal|1
expr_stmt|;
name|arc
operator|->
name|is_call_non_return
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-local return from a callee of this 		         function. The destination block is a catch or 		         setjmp.  */
name|arc
operator|->
name|is_nonlocal_return
operator|=
literal|1
expr_stmt|;
name|fn
operator|->
name|blocks
index|[
name|dest
index|]
operator|.
name|is_nonlocal_return
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|arc
operator|->
name|on_tree
condition|)
name|fn
operator|->
name|num_counts
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fn
operator|&&
name|tag
operator|==
name|GCOV_TAG_LINES
condition|)
block|{
name|unsigned
name|blockno
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
name|unsigned
modifier|*
name|line_nos
init|=
name|xcalloc
argument_list|(
name|length
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockno
operator|>=
name|fn
operator|->
name|num_blocks
operator|||
name|fn
operator|->
name|blocks
index|[
name|blockno
index|]
operator|.
name|u
operator|.
name|line
operator|.
name|encoding
condition|)
goto|goto
name|corrupt
goto|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|unsigned
name|lineno
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
if|if
condition|(
name|lineno
condition|)
block|{
if|if
condition|(
operator|!
name|ix
condition|)
block|{
name|line_nos
index|[
name|ix
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|line_nos
index|[
name|ix
operator|++
index|]
operator|=
name|src
operator|->
name|index
expr_stmt|;
block|}
name|line_nos
index|[
name|ix
operator|++
index|]
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|lineno
operator|>=
name|src
operator|->
name|num_lines
condition|)
name|src
operator|->
name|num_lines
operator|=
name|lineno
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|file_name
init|=
name|gcov_read_string
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
break|break;
name|src
operator|=
name|find_source
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|line_nos
index|[
name|ix
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|line_nos
index|[
name|ix
operator|++
index|]
operator|=
name|src
operator|->
name|index
expr_stmt|;
block|}
block|}
name|fn
operator|->
name|blocks
index|[
name|blockno
index|]
operator|.
name|u
operator|.
name|line
operator|.
name|encoding
operator|=
name|line_nos
expr_stmt|;
name|fn
operator|->
name|blocks
index|[
name|blockno
index|]
operator|.
name|u
operator|.
name|line
operator|.
name|num
operator|=
name|ix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_tag
operator|&&
operator|!
name|GCOV_TAG_IS_SUBTAG
argument_list|(
name|current_tag
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|fn
operator|=
name|NULL
expr_stmt|;
name|current_tag
operator|=
literal|0
expr_stmt|;
block|}
name|gcov_sync
argument_list|(
name|base
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcov_is_error
argument_list|()
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|gcov_is_eof
argument_list|()
condition|)
block|{
name|corrupt
label|:
empty_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:corrupted\n"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
name|gcov_close
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|gcov_close
argument_list|()
expr_stmt|;
comment|/* We built everything backwards, so nreverse them all.  */
comment|/* Reverse sources. Not strictly necessary, but we'll then process      them in the 'expected' order.  */
block|{
name|source_t
modifier|*
name|src
decl_stmt|,
modifier|*
name|src_p
decl_stmt|,
modifier|*
name|src_n
decl_stmt|;
for|for
control|(
name|src_p
operator|=
name|NULL
operator|,
name|src
operator|=
name|sources
init|;
name|src
condition|;
name|src_p
operator|=
name|src
operator|,
name|src
operator|=
name|src_n
control|)
block|{
name|src_n
operator|=
name|src
operator|->
name|next
expr_stmt|;
name|src
operator|->
name|next
operator|=
name|src_p
expr_stmt|;
block|}
name|sources
operator|=
name|src_p
expr_stmt|;
block|}
comment|/* Reverse functions.  */
block|{
name|function_t
modifier|*
name|fn
decl_stmt|,
modifier|*
name|fn_p
decl_stmt|,
modifier|*
name|fn_n
decl_stmt|;
for|for
control|(
name|fn_p
operator|=
name|NULL
operator|,
name|fn
operator|=
name|functions
init|;
name|fn
condition|;
name|fn_p
operator|=
name|fn
operator|,
name|fn
operator|=
name|fn_n
control|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|fn_n
operator|=
name|fn
operator|->
name|next
expr_stmt|;
name|fn
operator|->
name|next
operator|=
name|fn_p
expr_stmt|;
comment|/* Reverse the arcs.  */
for|for
control|(
name|ix
operator|=
name|fn
operator|->
name|num_blocks
init|;
name|ix
operator|--
condition|;
control|)
block|{
name|arc_t
modifier|*
name|arc
decl_stmt|,
modifier|*
name|arc_p
decl_stmt|,
modifier|*
name|arc_n
decl_stmt|;
for|for
control|(
name|arc_p
operator|=
name|NULL
operator|,
name|arc
operator|=
name|fn
operator|->
name|blocks
index|[
name|ix
index|]
operator|.
name|succ
init|;
name|arc
condition|;
name|arc_p
operator|=
name|arc
operator|,
name|arc
operator|=
name|arc_n
control|)
block|{
name|arc_n
operator|=
name|arc
operator|->
name|succ_next
expr_stmt|;
name|arc
operator|->
name|succ_next
operator|=
name|arc_p
expr_stmt|;
block|}
name|fn
operator|->
name|blocks
index|[
name|ix
index|]
operator|.
name|succ
operator|=
name|arc_p
expr_stmt|;
for|for
control|(
name|arc_p
operator|=
name|NULL
operator|,
name|arc
operator|=
name|fn
operator|->
name|blocks
index|[
name|ix
index|]
operator|.
name|pred
init|;
name|arc
condition|;
name|arc_p
operator|=
name|arc
operator|,
name|arc
operator|=
name|arc_n
control|)
block|{
name|arc_n
operator|=
name|arc
operator|->
name|pred_next
expr_stmt|;
name|arc
operator|->
name|pred_next
operator|=
name|arc_p
expr_stmt|;
block|}
name|fn
operator|->
name|blocks
index|[
name|ix
index|]
operator|.
name|pred
operator|=
name|arc_p
expr_stmt|;
block|}
block|}
name|functions
operator|=
name|fn_p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Reads profiles from the count file and attach to each    function. Return nonzero if fatal error.  */
end_comment

begin_function
specifier|static
name|int
name|read_count_file
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|unsigned
name|version
decl_stmt|;
name|unsigned
name|tag
decl_stmt|;
name|function_t
modifier|*
name|fn
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|gcov_open
argument_list|(
name|da_file_name
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:cannot open data file\n"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|gcov_magic
argument_list|(
name|gcov_read_unsigned
argument_list|()
argument_list|,
name|GCOV_DATA_MAGIC
argument_list|)
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:not a gcov data file\n"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
name|cleanup
label|:
empty_stmt|;
name|gcov_close
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|version
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|GCOV_VERSION
condition|)
block|{
name|char
name|v
index|[
literal|4
index|]
decl_stmt|,
name|e
index|[
literal|4
index|]
decl_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|v
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|e
argument_list|,
name|GCOV_VERSION
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:version `%.4s', prefer version `%.4s'\n"
argument_list|,
name|da_file_name
argument_list|,
name|v
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|bbg_stamp
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:stamp mismatch with graph file\n"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
while|while
condition|(
operator|(
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
operator|)
condition|)
block|{
name|unsigned
name|length
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
name|unsigned
name|long
name|base
init|=
name|gcov_position
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|GCOV_TAG_OBJECT_SUMMARY
condition|)
name|gcov_read_summary
argument_list|(
operator|&
name|object_summary
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tag
operator|==
name|GCOV_TAG_PROGRAM_SUMMARY
condition|)
name|program_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tag
operator|==
name|GCOV_TAG_FUNCTION
condition|)
block|{
name|unsigned
name|ident
init|=
name|gcov_read_unsigned
argument_list|()
decl_stmt|;
name|struct
name|function_info
modifier|*
name|fn_n
init|=
name|functions
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fn
condition|?
name|fn
operator|->
name|next
else|:
name|NULL
init|;
condition|;
name|fn
operator|=
name|fn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fn
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fn
operator|=
name|fn_n
operator|)
condition|)
name|fn_n
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:unknown function `%u'\n"
argument_list|,
name|da_file_name
argument_list|,
name|ident
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fn
operator|->
name|ident
operator|==
name|ident
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|fn
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|gcov_read_unsigned
argument_list|()
operator|!=
name|fn
operator|->
name|checksum
condition|)
block|{
name|mismatch
label|:
empty_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:profile mismatch for `%s'\n"
argument_list|,
name|da_file_name
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|GCOV_TAG_FOR_COUNTER
argument_list|(
name|GCOV_COUNTER_ARCS
argument_list|)
operator|&&
name|fn
condition|)
block|{
if|if
condition|(
name|length
operator|!=
name|GCOV_TAG_COUNTER_LENGTH
argument_list|(
name|fn
operator|->
name|num_counts
argument_list|)
condition|)
goto|goto
name|mismatch
goto|;
if|if
condition|(
operator|!
name|fn
operator|->
name|counts
condition|)
name|fn
operator|->
name|counts
operator|=
name|xcalloc
argument_list|(
name|fn
operator|->
name|num_counts
argument_list|,
sizeof|sizeof
argument_list|(
name|gcov_type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|fn
operator|->
name|num_counts
condition|;
name|ix
operator|++
control|)
name|fn
operator|->
name|counts
index|[
name|ix
index|]
operator|+=
name|gcov_read_counter
argument_list|()
expr_stmt|;
block|}
name|gcov_sync
argument_list|(
name|base
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gcov_is_error
argument_list|()
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|gcov_is_eof
argument_list|()
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
name|error
operator|<
literal|0
condition|?
literal|"%s:overflowed\n"
else|:
literal|"%s:corrupted\n"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|gcov_close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Solve the flow graph. Propagate counts from the instrumented arcs    to the blocks and the uninstrumented arcs.  */
end_comment

begin_function
specifier|static
name|void
name|solve_flow_graph
parameter_list|(
name|function_t
modifier|*
name|fn
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|arc_t
modifier|*
name|arc
decl_stmt|;
name|gcov_type
modifier|*
name|count_ptr
init|=
name|fn
operator|->
name|counts
decl_stmt|;
name|block_t
modifier|*
name|blk
decl_stmt|;
name|block_t
modifier|*
name|valid_blocks
init|=
name|NULL
decl_stmt|;
comment|/* valid, but unpropagated blocks.  */
name|block_t
modifier|*
name|invalid_blocks
init|=
name|NULL
decl_stmt|;
comment|/* invalid, but inferable blocks.  */
if|if
condition|(
name|fn
operator|->
name|num_blocks
operator|<
literal|2
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:`%s' lacks entry and/or exit blocks\n"
argument_list|,
name|bbg_file_name
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fn
operator|->
name|blocks
index|[
literal|0
index|]
operator|.
name|num_pred
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:`%s' has arcs to entry block\n"
argument_list|,
name|bbg_file_name
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* We can't deduce the entry block counts from the lack of 	   predecessors.  */
name|fn
operator|->
name|blocks
index|[
literal|0
index|]
operator|.
name|num_pred
operator|=
operator|~
operator|(
name|unsigned
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|fn
operator|->
name|blocks
index|[
name|fn
operator|->
name|num_blocks
operator|-
literal|1
index|]
operator|.
name|num_succ
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:`%s' has arcs from exit block\n"
argument_list|,
name|bbg_file_name
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* Likewise, we can't deduce exit block counts from the lack 	   of its successors.  */
name|fn
operator|->
name|blocks
index|[
name|fn
operator|->
name|num_blocks
operator|-
literal|1
index|]
operator|.
name|num_succ
operator|=
operator|~
operator|(
name|unsigned
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Propagate the measured counts, this must be done in the same      order as the code in profile.c  */
for|for
control|(
name|ix
operator|=
literal|0
operator|,
name|blk
operator|=
name|fn
operator|->
name|blocks
init|;
name|ix
operator|!=
name|fn
operator|->
name|num_blocks
condition|;
name|ix
operator|++
operator|,
name|blk
operator|++
control|)
block|{
name|block_t
specifier|const
modifier|*
name|prev_dst
init|=
name|NULL
decl_stmt|;
name|int
name|out_of_order
init|=
literal|0
decl_stmt|;
name|int
name|non_fake_succ
init|=
literal|0
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|blk
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
operator|!
name|arc
operator|->
name|fake
condition|)
name|non_fake_succ
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|arc
operator|->
name|on_tree
condition|)
block|{
if|if
condition|(
name|count_ptr
condition|)
name|arc
operator|->
name|count
operator|=
operator|*
name|count_ptr
operator|++
expr_stmt|;
name|arc
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|blk
operator|->
name|num_succ
operator|--
expr_stmt|;
name|arc
operator|->
name|dst
operator|->
name|num_pred
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|prev_dst
operator|&&
name|prev_dst
operator|>
name|arc
operator|->
name|dst
condition|)
name|out_of_order
operator|=
literal|1
expr_stmt|;
name|prev_dst
operator|=
name|arc
operator|->
name|dst
expr_stmt|;
block|}
if|if
condition|(
name|non_fake_succ
operator|==
literal|1
condition|)
block|{
comment|/* If there is only one non-fake exit, it is an 	     unconditional branch.  */
for|for
control|(
name|arc
operator|=
name|blk
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arc
operator|->
name|fake
condition|)
block|{
name|arc
operator|->
name|is_unconditional
operator|=
literal|1
expr_stmt|;
comment|/* If this block is instrumenting a call, it might be 		   an artificial block. It is not artificial if it has 		   a non-fallthrough exit, or the destination of this 		   arc has more than one entry.  Mark the destination 		   block as a return site, if none of those conditions 		   hold.  */
if|if
condition|(
name|blk
operator|->
name|is_call_site
operator|&&
name|arc
operator|->
name|fall_through
operator|&&
name|arc
operator|->
name|dst
operator|->
name|pred
operator|==
name|arc
operator|&&
operator|!
name|arc
operator|->
name|pred_next
condition|)
name|arc
operator|->
name|dst
operator|->
name|is_call_return
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Sort the successor arcs into ascending dst order. profile.c 	 normally produces arcs in the right order, but sometimes with 	 one or two out of order.  We're not using a particularly 	 smart sort.  */
if|if
condition|(
name|out_of_order
condition|)
block|{
name|arc_t
modifier|*
name|start
init|=
name|blk
operator|->
name|succ
decl_stmt|;
name|unsigned
name|changes
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|arc_t
modifier|*
name|arc
decl_stmt|,
modifier|*
name|arc_p
decl_stmt|,
modifier|*
name|arc_n
decl_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc_p
operator|=
name|NULL
operator|,
name|arc
operator|=
name|start
init|;
operator|(
name|arc_n
operator|=
name|arc
operator|->
name|succ_next
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|dst
operator|>
name|arc_n
operator|->
name|dst
condition|)
block|{
name|changes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arc_p
condition|)
name|arc_p
operator|->
name|succ_next
operator|=
name|arc_n
expr_stmt|;
else|else
name|start
operator|=
name|arc_n
expr_stmt|;
name|arc
operator|->
name|succ_next
operator|=
name|arc_n
operator|->
name|succ_next
expr_stmt|;
name|arc_n
operator|->
name|succ_next
operator|=
name|arc
expr_stmt|;
name|arc_p
operator|=
name|arc_n
expr_stmt|;
block|}
else|else
block|{
name|arc_p
operator|=
name|arc
expr_stmt|;
name|arc
operator|=
name|arc_n
expr_stmt|;
block|}
block|}
block|}
name|blk
operator|->
name|succ
operator|=
name|start
expr_stmt|;
block|}
comment|/* Place it on the invalid chain, it will be ignored if that's 	 wrong.  */
name|blk
operator|->
name|invalid_chain
operator|=
literal|1
expr_stmt|;
name|blk
operator|->
name|chain
operator|=
name|invalid_blocks
expr_stmt|;
name|invalid_blocks
operator|=
name|blk
expr_stmt|;
block|}
while|while
condition|(
name|invalid_blocks
operator|||
name|valid_blocks
condition|)
block|{
while|while
condition|(
operator|(
name|blk
operator|=
name|invalid_blocks
operator|)
condition|)
block|{
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
specifier|const
name|arc_t
modifier|*
name|arc
decl_stmt|;
name|invalid_blocks
operator|=
name|blk
operator|->
name|chain
expr_stmt|;
name|blk
operator|->
name|invalid_chain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|blk
operator|->
name|num_succ
condition|)
for|for
control|(
name|arc
operator|=
name|blk
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
control|)
name|total
operator|+=
name|arc
operator|->
name|count
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|blk
operator|->
name|num_pred
condition|)
for|for
control|(
name|arc
operator|=
name|blk
operator|->
name|pred
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|pred_next
control|)
name|total
operator|+=
name|arc
operator|->
name|count
expr_stmt|;
else|else
continue|continue;
name|blk
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|blk
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|blk
operator|->
name|chain
operator|=
name|valid_blocks
expr_stmt|;
name|blk
operator|->
name|valid_chain
operator|=
literal|1
expr_stmt|;
name|valid_blocks
operator|=
name|blk
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|blk
operator|=
name|valid_blocks
operator|)
condition|)
block|{
name|gcov_type
name|total
decl_stmt|;
name|arc_t
modifier|*
name|arc
decl_stmt|,
modifier|*
name|inv_arc
decl_stmt|;
name|valid_blocks
operator|=
name|blk
operator|->
name|chain
expr_stmt|;
name|blk
operator|->
name|valid_chain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blk
operator|->
name|num_succ
operator|==
literal|1
condition|)
block|{
name|block_t
modifier|*
name|dst
decl_stmt|;
name|total
operator|=
name|blk
operator|->
name|count
expr_stmt|;
name|inv_arc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|blk
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
control|)
block|{
name|total
operator|-=
name|arc
operator|->
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|arc
operator|->
name|count_valid
condition|)
name|inv_arc
operator|=
name|arc
expr_stmt|;
block|}
name|dst
operator|=
name|inv_arc
operator|->
name|dst
expr_stmt|;
name|inv_arc
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|inv_arc
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|blk
operator|->
name|num_succ
operator|--
expr_stmt|;
name|dst
operator|->
name|num_pred
operator|--
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|num_pred
operator|==
literal|1
operator|&&
operator|!
name|dst
operator|->
name|valid_chain
condition|)
block|{
name|dst
operator|->
name|chain
operator|=
name|valid_blocks
expr_stmt|;
name|dst
operator|->
name|valid_chain
operator|=
literal|1
expr_stmt|;
name|valid_blocks
operator|=
name|dst
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dst
operator|->
name|num_pred
operator|&&
operator|!
name|dst
operator|->
name|invalid_chain
condition|)
block|{
name|dst
operator|->
name|chain
operator|=
name|invalid_blocks
expr_stmt|;
name|dst
operator|->
name|invalid_chain
operator|=
literal|1
expr_stmt|;
name|invalid_blocks
operator|=
name|dst
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|blk
operator|->
name|num_pred
operator|==
literal|1
condition|)
block|{
name|block_t
modifier|*
name|src
decl_stmt|;
name|total
operator|=
name|blk
operator|->
name|count
expr_stmt|;
name|inv_arc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|blk
operator|->
name|pred
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|pred_next
control|)
block|{
name|total
operator|-=
name|arc
operator|->
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|arc
operator|->
name|count_valid
condition|)
name|inv_arc
operator|=
name|arc
expr_stmt|;
block|}
name|src
operator|=
name|inv_arc
operator|->
name|src
expr_stmt|;
name|inv_arc
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|inv_arc
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|blk
operator|->
name|num_pred
operator|--
expr_stmt|;
name|src
operator|->
name|num_succ
operator|--
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|src
operator|->
name|num_succ
operator|==
literal|1
operator|&&
operator|!
name|src
operator|->
name|valid_chain
condition|)
block|{
name|src
operator|->
name|chain
operator|=
name|valid_blocks
expr_stmt|;
name|src
operator|->
name|valid_chain
operator|=
literal|1
expr_stmt|;
name|valid_blocks
operator|=
name|src
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|src
operator|->
name|num_succ
operator|&&
operator|!
name|src
operator|->
name|invalid_chain
condition|)
block|{
name|src
operator|->
name|chain
operator|=
name|invalid_blocks
expr_stmt|;
name|src
operator|->
name|invalid_chain
operator|=
literal|1
expr_stmt|;
name|invalid_blocks
operator|=
name|src
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* If the graph has been correctly solved, every block will have a      valid count.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|fn
operator|->
name|num_blocks
condition|;
name|ix
operator|++
control|)
if|if
condition|(
operator|!
name|fn
operator|->
name|blocks
index|[
name|ix
index|]
operator|.
name|count_valid
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:graph is unsolvable for `%s'\n"
argument_list|,
name|bbg_file_name
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Increment totals in COVERAGE according to arc ARC.  */
end_comment

begin_function
specifier|static
name|void
name|add_branch_counts
parameter_list|(
name|coverage_t
modifier|*
name|coverage
parameter_list|,
specifier|const
name|arc_t
modifier|*
name|arc
parameter_list|)
block|{
if|if
condition|(
name|arc
operator|->
name|is_call_non_return
condition|)
block|{
name|coverage
operator|->
name|calls
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|src
operator|->
name|count
condition|)
name|coverage
operator|->
name|calls_executed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|arc
operator|->
name|is_unconditional
condition|)
block|{
name|coverage
operator|->
name|branches
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|src
operator|->
name|count
condition|)
name|coverage
operator|->
name|branches_executed
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|count
condition|)
name|coverage
operator|->
name|branches_taken
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Format a HOST_WIDE_INT as either a percent ratio, or absolute    count.  If dp>= 0, format TOP/BOTTOM * 100 to DP decimal places.    If DP is zero, no decimal point is printed. Only print 100% when    TOP==BOTTOM and only print 0% when TOP=0.  If dp< 0, then simply    format TOP.  Return pointer to a static string.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|format_gcov
parameter_list|(
name|gcov_type
name|top
parameter_list|,
name|gcov_type
name|bottom
parameter_list|,
name|int
name|dp
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|dp
operator|>=
literal|0
condition|)
block|{
name|float
name|ratio
init|=
name|bottom
condition|?
operator|(
name|float
operator|)
name|top
operator|/
name|bottom
else|:
literal|0
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|unsigned
name|limit
init|=
literal|100
decl_stmt|;
name|unsigned
name|percent
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|dp
init|;
name|ix
operator|--
condition|;
control|)
name|limit
operator|*=
literal|10
expr_stmt|;
name|percent
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|ratio
operator|*
name|limit
operator|+
operator|(
name|float
operator|)
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|percent
operator|<=
literal|0
operator|&&
name|top
condition|)
name|percent
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|percent
operator|>=
name|limit
operator|&&
name|top
operator|!=
name|bottom
condition|)
name|percent
operator|=
name|limit
operator|-
literal|1
expr_stmt|;
name|ix
operator|=
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%.*u%%"
argument_list|,
name|dp
operator|+
literal|1
argument_list|,
name|percent
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
name|dp
operator|++
expr_stmt|;
do|do
block|{
name|buffer
index|[
name|ix
operator|+
literal|1
index|]
operator|=
name|buffer
index|[
name|ix
index|]
expr_stmt|;
name|ix
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|dp
operator|--
condition|)
do|;
name|buffer
index|[
name|ix
operator|+
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|top
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Output summary info for a function.  */
end_comment

begin_function
specifier|static
name|void
name|function_summary
parameter_list|(
specifier|const
name|coverage_t
modifier|*
name|coverage
parameter_list|,
specifier|const
name|char
modifier|*
name|title
parameter_list|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%s `%s'\n"
argument_list|,
name|title
argument_list|,
name|coverage
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|coverage
operator|->
name|lines
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"Lines executed:%s of %d\n"
argument_list|,
name|format_gcov
argument_list|(
name|coverage
operator|->
name|lines_executed
argument_list|,
name|coverage
operator|->
name|lines
argument_list|,
literal|2
argument_list|)
argument_list|,
name|coverage
operator|->
name|lines
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No executable lines"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_branches
condition|)
block|{
if|if
condition|(
name|coverage
operator|->
name|branches
condition|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"Branches executed:%s of %d\n"
argument_list|,
name|format_gcov
argument_list|(
name|coverage
operator|->
name|branches_executed
argument_list|,
name|coverage
operator|->
name|branches
argument_list|,
literal|2
argument_list|)
argument_list|,
name|coverage
operator|->
name|branches
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"Taken at least once:%s of %d\n"
argument_list|,
name|format_gcov
argument_list|(
name|coverage
operator|->
name|branches_taken
argument_list|,
name|coverage
operator|->
name|branches
argument_list|,
literal|2
argument_list|)
argument_list|,
name|coverage
operator|->
name|branches
argument_list|)
expr_stmt|;
block|}
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No branches\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|coverage
operator|->
name|calls
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"Calls executed:%s of %d\n"
argument_list|,
name|format_gcov
argument_list|(
name|coverage
operator|->
name|calls_executed
argument_list|,
name|coverage
operator|->
name|calls
argument_list|,
literal|2
argument_list|)
argument_list|,
name|coverage
operator|->
name|calls
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No calls\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate an output file name. LONG_OUTPUT_NAMES and PRESERVE_PATHS    affect name generation. With preserve_paths we create a filename    from all path components of the source file, replacing '/' with    '#', without it we simply take the basename component. With    long_output_names we prepend the processed name of the input file    to each output name (except when the current source file is the    input file, so you don't get a double concatenation). The two    components are separated by '##'. Also '.' filename components are    removed and '..'  components are renamed to '^'.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_gcov_file_name
parameter_list|(
specifier|const
name|char
modifier|*
name|input_name
parameter_list|,
specifier|const
name|char
modifier|*
name|src_name
parameter_list|)
block|{
name|char
modifier|*
name|cptr
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|src_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_long_names
operator|&&
name|strcmp
argument_list|(
name|src_name
argument_list|,
name|input_name
argument_list|)
condition|)
block|{
comment|/* Generate the input filename part.  */
name|cptr
operator|=
name|flag_preserve_paths
condition|?
name|NULL
else|:
name|strrchr
argument_list|(
name|input_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|cptr
condition|?
name|cptr
operator|+
literal|1
else|:
name|input_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"##"
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the source filename part.  */
name|cptr
operator|=
name|flag_preserve_paths
condition|?
name|NULL
else|:
name|strrchr
argument_list|(
name|src_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|cptr
condition|?
name|cptr
operator|+
literal|1
else|:
name|src_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_preserve_paths
condition|)
block|{
comment|/* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */
name|char
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|cptr
operator|=
name|name
init|;
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
operator|(
name|prev
operator|=
name|cptr
operator|)
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|;
control|)
block|{
name|unsigned
name|shift
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|prev
operator|+
literal|1
operator|==
name|cptr
operator|&&
name|prev
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* Remove '.' */
name|shift
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev
operator|+
literal|2
operator|==
name|cptr
operator|&&
name|prev
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|prev
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* Convert '..' */
name|shift
operator|=
literal|1
expr_stmt|;
name|prev
index|[
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
block|}
else|else
operator|*
name|cptr
operator|++
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|cptr
operator|=
name|prev
expr_stmt|;
do|do
name|prev
index|[
literal|0
index|]
operator|=
name|prev
index|[
name|shift
index|]
expr_stmt|;
do|while
condition|(
operator|*
name|prev
operator|++
condition|)
do|;
block|}
block|}
block|}
name|strcat
argument_list|(
name|name
argument_list|,
literal|".gcov"
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Scan through the bb_data for each line in the block, increment    the line number execution count indicated by the execution count of    the appropriate basic block.  */
end_comment

begin_function
specifier|static
name|void
name|add_line_counts
parameter_list|(
name|coverage_t
modifier|*
name|coverage
parameter_list|,
name|function_t
modifier|*
name|fn
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|line_t
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
comment|/* This is propagated from one iteration to the 			  next.  */
comment|/* Scan each basic block.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|fn
operator|->
name|num_blocks
condition|;
name|ix
operator|++
control|)
block|{
name|block_t
modifier|*
name|block
init|=
operator|&
name|fn
operator|->
name|blocks
index|[
name|ix
index|]
decl_stmt|;
name|unsigned
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|source_t
modifier|*
name|src
init|=
name|NULL
decl_stmt|;
name|unsigned
name|jx
decl_stmt|;
if|if
condition|(
name|block
operator|->
name|count
operator|&&
name|ix
operator|&&
name|ix
operator|+
literal|1
operator|!=
name|fn
operator|->
name|num_blocks
condition|)
name|fn
operator|->
name|blocks_executed
operator|++
expr_stmt|;
for|for
control|(
name|jx
operator|=
literal|0
operator|,
name|encoding
operator|=
name|block
operator|->
name|u
operator|.
name|line
operator|.
name|encoding
init|;
name|jx
operator|!=
name|block
operator|->
name|u
operator|.
name|line
operator|.
name|num
condition|;
name|jx
operator|++
operator|,
name|encoding
operator|++
control|)
if|if
condition|(
operator|!
operator|*
name|encoding
condition|)
block|{
name|unsigned
name|src_n
init|=
operator|*
operator|++
name|encoding
decl_stmt|;
for|for
control|(
name|src
operator|=
name|sources
init|;
name|src
operator|->
name|index
operator|!=
name|src_n
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
continue|continue;
name|jx
operator|++
expr_stmt|;
block|}
else|else
block|{
name|line
operator|=
operator|&
name|src
operator|->
name|lines
index|[
operator|*
name|encoding
index|]
expr_stmt|;
if|if
condition|(
name|coverage
condition|)
block|{
if|if
condition|(
operator|!
name|line
operator|->
name|exists
condition|)
name|coverage
operator|->
name|lines
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|line
operator|->
name|count
operator|&&
name|block
operator|->
name|count
condition|)
name|coverage
operator|->
name|lines_executed
operator|++
expr_stmt|;
block|}
name|line
operator|->
name|exists
operator|=
literal|1
expr_stmt|;
name|line
operator|->
name|count
operator|+=
name|block
operator|->
name|count
expr_stmt|;
block|}
name|free
argument_list|(
name|block
operator|->
name|u
operator|.
name|line
operator|.
name|encoding
argument_list|)
expr_stmt|;
name|block
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
operator|=
name|NULL
expr_stmt|;
name|block
operator|->
name|u
operator|.
name|cycle
operator|.
name|ident
operator|=
operator|~
literal|0U
expr_stmt|;
if|if
condition|(
operator|!
name|ix
operator|||
name|ix
operator|+
literal|1
operator|==
name|fn
operator|->
name|num_blocks
condition|)
comment|/* Entry or exit block */
empty_stmt|;
elseif|else
if|if
condition|(
name|flag_all_blocks
condition|)
block|{
name|line_t
modifier|*
name|block_line
init|=
name|line
condition|?
name|line
else|:
operator|&
name|fn
operator|->
name|src
operator|->
name|lines
index|[
name|fn
operator|->
name|line
index|]
decl_stmt|;
name|block
operator|->
name|chain
operator|=
name|block_line
operator|->
name|u
operator|.
name|blocks
expr_stmt|;
name|block_line
operator|->
name|u
operator|.
name|blocks
operator|=
name|block
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_branches
condition|)
block|{
name|arc_t
modifier|*
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|block
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
control|)
block|{
name|arc
operator|->
name|line_next
operator|=
name|line
operator|->
name|u
operator|.
name|branches
expr_stmt|;
name|line
operator|->
name|u
operator|.
name|branches
operator|=
name|arc
expr_stmt|;
if|if
condition|(
name|coverage
operator|&&
operator|!
name|arc
operator|->
name|is_unconditional
condition|)
name|add_branch_counts
argument_list|(
name|coverage
argument_list|,
name|arc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|line
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:no lines for `%s'\n"
argument_list|,
name|bbg_file_name
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Accumulate the line counts of a file.  */
end_comment

begin_function
specifier|static
name|void
name|accumulate_line_counts
parameter_list|(
name|source_t
modifier|*
name|src
parameter_list|)
block|{
name|line_t
modifier|*
name|line
decl_stmt|;
name|function_t
modifier|*
name|fn
decl_stmt|,
modifier|*
name|fn_p
decl_stmt|,
modifier|*
name|fn_n
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
comment|/* Reverse the function order.  */
for|for
control|(
name|fn
operator|=
name|src
operator|->
name|functions
operator|,
name|fn_p
operator|=
name|NULL
init|;
name|fn
condition|;
name|fn_p
operator|=
name|fn
operator|,
name|fn
operator|=
name|fn_n
control|)
block|{
name|fn_n
operator|=
name|fn
operator|->
name|line_next
expr_stmt|;
name|fn
operator|->
name|line_next
operator|=
name|fn_p
expr_stmt|;
block|}
name|src
operator|->
name|functions
operator|=
name|fn_p
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|src
operator|->
name|num_lines
operator|,
name|line
operator|=
name|src
operator|->
name|lines
init|;
name|ix
operator|--
condition|;
name|line
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|flag_all_blocks
condition|)
block|{
name|arc_t
modifier|*
name|arc
decl_stmt|,
modifier|*
name|arc_p
decl_stmt|,
modifier|*
name|arc_n
decl_stmt|;
comment|/* Total and reverse the branch information.  */
for|for
control|(
name|arc
operator|=
name|line
operator|->
name|u
operator|.
name|branches
operator|,
name|arc_p
operator|=
name|NULL
init|;
name|arc
condition|;
name|arc_p
operator|=
name|arc
operator|,
name|arc
operator|=
name|arc_n
control|)
block|{
name|arc_n
operator|=
name|arc
operator|->
name|line_next
expr_stmt|;
name|arc
operator|->
name|line_next
operator|=
name|arc_p
expr_stmt|;
name|add_branch_counts
argument_list|(
operator|&
name|src
operator|->
name|coverage
argument_list|,
name|arc
argument_list|)
expr_stmt|;
block|}
name|line
operator|->
name|u
operator|.
name|branches
operator|=
name|arc_p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|->
name|u
operator|.
name|blocks
condition|)
block|{
comment|/* The user expects the line count to be the number of times 	     a line has been executed. Simply summing the block count 	     will give an artificially high number.  The Right Thing 	     is to sum the entry counts to the graph of blocks on this 	     line, then find the elementary cycles of the local graph 	     and add the transition counts of those cycles.  */
name|block_t
modifier|*
name|block
decl_stmt|,
modifier|*
name|block_p
decl_stmt|,
modifier|*
name|block_n
decl_stmt|;
name|gcov_type
name|count
init|=
literal|0
decl_stmt|;
comment|/* Reverse the block information.  */
for|for
control|(
name|block
operator|=
name|line
operator|->
name|u
operator|.
name|blocks
operator|,
name|block_p
operator|=
name|NULL
init|;
name|block
condition|;
name|block_p
operator|=
name|block
operator|,
name|block
operator|=
name|block_n
control|)
block|{
name|block_n
operator|=
name|block
operator|->
name|chain
expr_stmt|;
name|block
operator|->
name|chain
operator|=
name|block_p
expr_stmt|;
name|block
operator|->
name|u
operator|.
name|cycle
operator|.
name|ident
operator|=
name|ix
expr_stmt|;
block|}
name|line
operator|->
name|u
operator|.
name|blocks
operator|=
name|block_p
expr_stmt|;
comment|/* Sum the entry arcs.  */
for|for
control|(
name|block
operator|=
name|line
operator|->
name|u
operator|.
name|blocks
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|chain
control|)
block|{
name|arc_t
modifier|*
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|block
operator|->
name|pred
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|src
operator|->
name|u
operator|.
name|cycle
operator|.
name|ident
operator|!=
name|ix
condition|)
name|count
operator|+=
name|arc
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|flag_branches
condition|)
name|add_branch_counts
argument_list|(
operator|&
name|src
operator|->
name|coverage
argument_list|,
name|arc
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the cs_count.  */
for|for
control|(
name|arc
operator|=
name|block
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
control|)
name|arc
operator|->
name|cs_count
operator|=
name|arc
operator|->
name|count
expr_stmt|;
block|}
comment|/* Find the loops. This uses the algorithm described in 	     Tiernan 'An Efficient Search Algorithm to Find the 	     Elementary Circuits of a Graph', CACM Dec 1970. We hold 	     the P array by having each block point to the arc that 	     connects to the previous block. The H array is implicitly 	     held because of the arc ordering, and the block's 	     previous arc pointer.  	     Although the algorithm is O(N^3) for highly connected 	     graphs, at worst we'll have O(N^2), as most blocks have 	     only one or two exits. Most graphs will be small.  	     For each loop we find, locate the arc with the smallest 	     transition count, and add that to the cumulative 	     count.  Decrease flow over the cycle and remove the arc 	     from consideration.  */
for|for
control|(
name|block
operator|=
name|line
operator|->
name|u
operator|.
name|blocks
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|chain
control|)
block|{
name|block_t
modifier|*
name|head
init|=
name|block
decl_stmt|;
name|arc_t
modifier|*
name|arc
decl_stmt|;
name|next_vertex
label|:
empty_stmt|;
name|arc
operator|=
name|head
operator|->
name|succ
expr_stmt|;
name|current_vertex
label|:
empty_stmt|;
while|while
condition|(
name|arc
condition|)
block|{
name|block_t
modifier|*
name|dst
init|=
name|arc
operator|->
name|dst
decl_stmt|;
if|if
condition|(
comment|/* Already used that arc.  */
name|arc
operator|->
name|cycle
comment|/* Not to same graph, or before first vertex.  */
operator|||
name|dst
operator|->
name|u
operator|.
name|cycle
operator|.
name|ident
operator|!=
name|ix
comment|/* Already in path.  */
operator|||
name|dst
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
condition|)
block|{
name|arc
operator|=
name|arc
operator|->
name|succ_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dst
operator|==
name|block
condition|)
block|{
comment|/* Found a closing arc.  */
name|gcov_type
name|cycle_count
init|=
name|arc
operator|->
name|cs_count
decl_stmt|;
name|arc_t
modifier|*
name|cycle_arc
init|=
name|arc
decl_stmt|;
name|arc_t
modifier|*
name|probe_arc
decl_stmt|;
comment|/* Locate the smallest arc count of the loop.  */
for|for
control|(
name|dst
operator|=
name|head
init|;
operator|(
name|probe_arc
operator|=
name|dst
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
operator|)
condition|;
name|dst
operator|=
name|probe_arc
operator|->
name|src
control|)
if|if
condition|(
name|cycle_count
operator|>
name|probe_arc
operator|->
name|cs_count
condition|)
block|{
name|cycle_count
operator|=
name|probe_arc
operator|->
name|cs_count
expr_stmt|;
name|cycle_arc
operator|=
name|probe_arc
expr_stmt|;
block|}
name|count
operator|+=
name|cycle_count
expr_stmt|;
name|cycle_arc
operator|->
name|cycle
operator|=
literal|1
expr_stmt|;
comment|/* Remove the flow from the cycle.  */
name|arc
operator|->
name|cs_count
operator|-=
name|cycle_count
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|head
init|;
operator|(
name|probe_arc
operator|=
name|dst
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
operator|)
condition|;
name|dst
operator|=
name|probe_arc
operator|->
name|src
control|)
name|probe_arc
operator|->
name|cs_count
operator|-=
name|cycle_count
expr_stmt|;
comment|/* Unwind to the cyclic arc.  */
while|while
condition|(
name|head
operator|!=
name|cycle_arc
operator|->
name|src
condition|)
block|{
name|arc
operator|=
name|head
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
expr_stmt|;
name|head
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
operator|=
name|NULL
expr_stmt|;
name|head
operator|=
name|arc
operator|->
name|src
expr_stmt|;
block|}
comment|/* Move on.  */
name|arc
operator|=
name|arc
operator|->
name|succ_next
expr_stmt|;
continue|continue;
block|}
comment|/* Add new block to chain.  */
name|dst
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|head
operator|=
name|dst
expr_stmt|;
goto|goto
name|next_vertex
goto|;
block|}
comment|/* We could not add another vertex to the path. Remove 		 the last vertex from the list.  */
name|arc
operator|=
name|head
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
expr_stmt|;
if|if
condition|(
name|arc
condition|)
block|{
comment|/* It was not the first vertex. Move onto next arc.  */
name|head
operator|->
name|u
operator|.
name|cycle
operator|.
name|arc
operator|=
name|NULL
expr_stmt|;
name|head
operator|=
name|arc
operator|->
name|src
expr_stmt|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
expr_stmt|;
goto|goto
name|current_vertex
goto|;
block|}
comment|/* Mark this block as unusable.  */
name|block
operator|->
name|u
operator|.
name|cycle
operator|.
name|ident
operator|=
operator|~
literal|0U
expr_stmt|;
block|}
name|line
operator|->
name|count
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|->
name|exists
condition|)
block|{
name|src
operator|->
name|coverage
operator|.
name|lines
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|count
condition|)
name|src
operator|->
name|coverage
operator|.
name|lines_executed
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Ouput information about ARC number IX.  Returns nonzero if    anything is output.  */
end_comment

begin_function
specifier|static
name|int
name|output_branch_count
parameter_list|(
name|FILE
modifier|*
name|gcov_file
parameter_list|,
name|int
name|ix
parameter_list|,
specifier|const
name|arc_t
modifier|*
name|arc
parameter_list|)
block|{
if|if
condition|(
name|arc
operator|->
name|is_call_non_return
condition|)
block|{
if|if
condition|(
name|arc
operator|->
name|src
operator|->
name|count
condition|)
block|{
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"call   %2d returned %s\n"
argument_list|,
name|ix
argument_list|,
name|format_gcov
argument_list|(
name|arc
operator|->
name|src
operator|->
name|count
operator|-
name|arc
operator|->
name|count
argument_list|,
name|arc
operator|->
name|src
operator|->
name|count
argument_list|,
operator|-
name|flag_counts
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"call   %2d never executed\n"
argument_list|,
name|ix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|arc
operator|->
name|is_unconditional
condition|)
block|{
if|if
condition|(
name|arc
operator|->
name|src
operator|->
name|count
condition|)
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"branch %2d taken %s%s\n"
argument_list|,
name|ix
argument_list|,
name|format_gcov
argument_list|(
name|arc
operator|->
name|count
argument_list|,
name|arc
operator|->
name|src
operator|->
name|count
argument_list|,
operator|-
name|flag_counts
argument_list|)
argument_list|,
name|arc
operator|->
name|fall_through
condition|?
literal|" (fallthrough)"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"branch %2d never executed\n"
argument_list|,
name|ix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_unconditional
operator|&&
operator|!
name|arc
operator|->
name|dst
operator|->
name|is_call_return
condition|)
block|{
if|if
condition|(
name|arc
operator|->
name|src
operator|->
name|count
condition|)
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"unconditional %2d taken %s\n"
argument_list|,
name|ix
argument_list|,
name|format_gcov
argument_list|(
name|arc
operator|->
name|count
argument_list|,
name|arc
operator|->
name|src
operator|->
name|count
argument_list|,
operator|-
name|flag_counts
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"unconditional %2d never executed\n"
argument_list|,
name|ix
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read in the source file one line at a time, and output that line to    the gcov file preceded by its execution count and other    information.  */
end_comment

begin_function
specifier|static
name|void
name|output_lines
parameter_list|(
name|FILE
modifier|*
name|gcov_file
parameter_list|,
specifier|const
name|source_t
modifier|*
name|src
parameter_list|)
block|{
name|FILE
modifier|*
name|source_file
decl_stmt|;
name|unsigned
name|line_num
decl_stmt|;
comment|/* current line number.  */
specifier|const
name|line_t
modifier|*
name|line
decl_stmt|;
comment|/* current line info ptr.  */
name|char
name|string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
comment|/* line buffer.  */
name|char
specifier|const
modifier|*
name|retval
init|=
literal|""
decl_stmt|;
comment|/* status of source file reading.  */
name|function_t
modifier|*
name|fn
init|=
name|src
operator|->
name|functions
decl_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Source:%s\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|,
name|src
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Graph:%s\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Data:%s\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Runs:%u\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|,
name|object_summary
operator|.
name|ctrs
index|[
name|GCOV_COUNTER_ARCS
index|]
operator|.
name|runs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Programs:%u\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|,
name|program_count
argument_list|)
expr_stmt|;
name|source_file
operator|=
name|fopen
argument_list|(
name|src
operator|->
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source_file
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:cannot open source file\n"
argument_list|,
name|src
operator|->
name|name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|fstat
argument_list|(
name|fileno
argument_list|(
name|source_file
argument_list|)
argument_list|,
operator|&
name|status
argument_list|)
operator|&&
name|status
operator|.
name|st_mtime
operator|>
name|bbg_file_time
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:source file is newer than graph file `%s'\n"
argument_list|,
name|src
operator|->
name|name
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Source is newer than graph\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|line_num
operator|=
literal|1
operator|,
name|line
operator|=
operator|&
name|src
operator|->
name|lines
index|[
name|line_num
index|]
init|;
name|line_num
operator|<
name|src
operator|->
name|num_lines
condition|;
name|line_num
operator|++
operator|,
name|line
operator|++
control|)
block|{
for|for
control|(
init|;
name|fn
operator|&&
name|fn
operator|->
name|line
operator|==
name|line_num
condition|;
name|fn
operator|=
name|fn
operator|->
name|line_next
control|)
block|{
name|arc_t
modifier|*
name|arc
init|=
name|fn
operator|->
name|blocks
index|[
name|fn
operator|->
name|num_blocks
operator|-
literal|1
index|]
operator|.
name|pred
decl_stmt|;
name|gcov_type
name|return_count
init|=
name|fn
operator|->
name|blocks
index|[
name|fn
operator|->
name|num_blocks
operator|-
literal|1
index|]
operator|.
name|count
decl_stmt|;
for|for
control|(
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|pred_next
control|)
if|if
condition|(
name|arc
operator|->
name|fake
condition|)
name|return_count
operator|-=
name|arc
operator|->
name|count
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"function %s"
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|" called %s"
argument_list|,
name|format_gcov
argument_list|(
name|fn
operator|->
name|blocks
index|[
literal|0
index|]
operator|.
name|count
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|" returned %s"
argument_list|,
name|format_gcov
argument_list|(
name|return_count
argument_list|,
name|fn
operator|->
name|blocks
index|[
literal|0
index|]
operator|.
name|count
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|" blocks executed %s"
argument_list|,
name|format_gcov
argument_list|(
name|fn
operator|->
name|blocks_executed
argument_list|,
name|fn
operator|->
name|num_blocks
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For lines which don't exist in the .bb file, print '-' before 	 the source line.  For lines which exist but were never 	 executed, print '#####' before the source line.  Otherwise, 	 print the execution count before the source line.  There are 	 16 spaces of indentation added before the source line so that 	 tabs won't be messed up.  */
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5u:"
argument_list|,
operator|!
name|line
operator|->
name|exists
condition|?
literal|"-"
else|:
operator|!
name|line
operator|->
name|count
condition|?
literal|"#####"
else|:
name|format_gcov
argument_list|(
name|line
operator|->
name|count
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|line_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
comment|/* Copy source line.  */
do|do
block|{
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
break|break;
name|fputs
argument_list|(
name|retval
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|retval
index|[
literal|0
index|]
operator|||
name|retval
index|[
name|strlen
argument_list|(
name|retval
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|retval
condition|)
name|fputs
argument_list|(
literal|"/*EOF*/\n"
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_all_blocks
condition|)
block|{
name|block_t
modifier|*
name|block
decl_stmt|;
name|arc_t
modifier|*
name|arc
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|jx
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|jx
operator|=
literal|0
operator|,
name|block
operator|=
name|line
operator|->
name|u
operator|.
name|blocks
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|chain
control|)
block|{
if|if
condition|(
operator|!
name|block
operator|->
name|is_call_return
condition|)
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5u-block %2d\n"
argument_list|,
operator|!
name|line
operator|->
name|exists
condition|?
literal|"-"
else|:
operator|!
name|block
operator|->
name|count
condition|?
literal|"$$$$$"
else|:
name|format_gcov
argument_list|(
name|block
operator|->
name|count
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|line_num
argument_list|,
name|ix
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_branches
condition|)
for|for
control|(
name|arc
operator|=
name|block
operator|->
name|succ
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|succ_next
control|)
name|jx
operator|+=
name|output_branch_count
argument_list|(
name|gcov_file
argument_list|,
name|jx
argument_list|,
name|arc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag_branches
condition|)
block|{
name|int
name|ix
decl_stmt|;
name|arc_t
modifier|*
name|arc
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
operator|,
name|arc
operator|=
name|line
operator|->
name|u
operator|.
name|branches
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|line_next
control|)
name|ix
operator|+=
name|output_branch_count
argument_list|(
name|gcov_file
argument_list|,
name|ix
argument_list|,
name|arc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle all remaining source lines.  There may be lines after the      last line of code.  */
if|if
condition|(
name|retval
condition|)
block|{
for|for
control|(
init|;
operator|(
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
operator|)
condition|;
name|line_num
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5u:%s"
argument_list|,
literal|"-"
argument_list|,
name|line_num
argument_list|,
name|retval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|retval
index|[
literal|0
index|]
operator|||
name|retval
index|[
name|strlen
argument_list|(
name|retval
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
break|break;
name|fputs
argument_list|(
name|retval
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|source_file
condition|)
name|fclose
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

