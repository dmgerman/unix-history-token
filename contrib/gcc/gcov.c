begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Gcov.c: prepend line execution counts and branch probabilities to a    source file.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by James E. Wilson of Cygnus Support.    Mangled by Bob Manson of Cygnus Support.  Gcov is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Gcov is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Gcov; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ??? The code in final.c that produces the struct bb assumes that there is    no padding between the fields.  This is not necessary true.  The current    code can only be trusted if longs and pointers are the same size.  */
end_comment

begin_comment
comment|/* ??? No need to print an execution count on every line, could just print    it on the first line of each block, and only print it on a subsequent    line in the same block if the count changes.  */
end_comment

begin_comment
comment|/* ??? Print a list of the ten blocks with the highest execution counts,    and list the line numbers corresponding to those blocks.  Also, perhaps    list the line numbers with the highest execution counts, only printing    the first if there are several which are all listed in the same block.  */
end_comment

begin_comment
comment|/* ??? Should have an option to print the number of basic blocks, and the    percent of them that are covered.  */
end_comment

begin_comment
comment|/* ??? Does not correctly handle the case where two .bb files refer to the    same included source file.  For example, if one has a short file containing    only inline functions, which is then included in two other files, then    there will be two .bb files which refer to the include file, but there    is no way to get the total execution counts for the included file, can    only get execution counts for one or the other of the including files.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_typedef
typedef|typedef
name|HOST_WIDEST_INT
name|gcov_type
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_comment
comment|/* The .bb file format consists of several lists of 4-byte integers    which are the line numbers of each basic block in the file.  Each    list is terminated by a zero.  These lists correspond to the basic    blocks in the reconstructed program flow graph.     A line number of -1 indicates that a source file name (padded to a    long boundary) follows.  The padded file name is followed by    another -1 to make it easy to scan past file names.  A -2 indicates    that a function name (padded to a long boundary) follows; the name    is followed by another -2 to make it easy to scan past the function    name.     The .bbg file contains enough info to enable gcov to reconstruct the    program flow graph.  The first word is the number of basic blocks,    the second word is the number of arcs, followed by the list of arcs    (source bb, dest bb pairs), then a -1, then the number of instrumented    arcs followed by the instrumented arcs, followed by another -1.  This    is repeated for each function.     The .da file contains the execution count for each instrumented branch.     The .bb and .bbg files are created by giving GCC the -ftest-coverage option,    and the .da files are created when an executable compiled with    -fprofile-arcs is run.  */
end_comment

begin_comment
comment|/* The functions in this file for creating and solution program flow graphs    are very similar to functions in the gcc source file profile.c.  */
end_comment

begin_comment
comment|/* This is the size of the buffer used to read in source file lines.  */
end_comment

begin_define
define|#
directive|define
name|STRING_SIZE
value|200
end_define

begin_comment
comment|/* One copy of this structure is created for each source file mentioned in the    .bb file.  */
end_comment

begin_struct
struct|struct
name|sourcefile
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|maxlineno
decl_stmt|;
name|struct
name|sourcefile
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This points to the head of the sourcefile structure list.  */
end_comment

begin_decl_stmt
name|struct
name|sourcefile
modifier|*
name|sources
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One of these is dynamically created whenever we identify an arc in the    function.  */
end_comment

begin_struct
struct|struct
name|adj_list
block|{
name|int
name|source
decl_stmt|;
name|int
name|target
decl_stmt|;
name|gcov_type
name|arc_count
decl_stmt|;
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fake
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fall_through
range|:
literal|1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Not needed for gcov, but defined in profile.c.  */
block|rtx branch_insn;
endif|#
directive|endif
name|struct
name|adj_list
modifier|*
name|pred_next
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|succ_next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Count the number of basic blocks, and create an array of these structures,    one for each bb in the function.  */
end_comment

begin_struct
struct|struct
name|bb_info
block|{
name|struct
name|adj_list
modifier|*
name|succ
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|pred
decl_stmt|;
name|gcov_type
name|succ_count
decl_stmt|;
name|gcov_type
name|pred_count
decl_stmt|;
name|gcov_type
name|exec_count
decl_stmt|;
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Not needed for gcov, but defined in profile.c.  */
block|rtx first_insn;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* When outputting branch probabilities, one of these structures is created    for each branch/call.  */
end_comment

begin_struct
struct|struct
name|arcdata
block|{
name|gcov_type
name|hits
decl_stmt|;
name|gcov_type
name|total
decl_stmt|;
name|int
name|call_insn
decl_stmt|;
name|struct
name|arcdata
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to save the list of bb_graphs, one per function.  */
end_comment

begin_struct
struct|struct
name|bb_info_list
block|{
comment|/* Indexed by block number, holds the basic block graph for one function.  */
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
name|int
name|num_blocks
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to hold information about each line.  */
end_comment

begin_struct
struct|struct
name|line_info
block|{
name|gcov_type
name|count
decl_stmt|;
comment|/* execution count */
name|struct
name|arcdata
modifier|*
name|branches
decl_stmt|;
comment|/* list of branch probabilities for line.  */
name|unsigned
name|exists
range|:
literal|1
decl_stmt|;
comment|/* has code associated with it.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|coverage
block|{
name|int
name|lines
decl_stmt|;
name|int
name|lines_executed
decl_stmt|;
name|int
name|branches
decl_stmt|;
name|int
name|branches_executed
decl_stmt|;
name|int
name|branches_taken
decl_stmt|;
name|int
name|calls
decl_stmt|;
name|int
name|calls_executed
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Holds a list of function basic block graphs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb_info_list
modifier|*
name|bb_graph_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Modification time of data files.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|bb_file_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the basic block graph.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bbg_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bbg_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the arc count data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|da_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|da_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the basic block line counts.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bb_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bb_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the entire contents of the bb_file read into memory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bb_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of bb_data array in longs.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|bb_data_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file mentioned on the command line.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_file_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output branch probabilities if true.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_branch_probs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output a gcov file if this is true.  This is on by default, and can    be turned off by the -n option.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_gcov_file
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For included files, make the gcov output file name include the name of    the input source file.  For example, if x.h is included in a.c, then the    output file name is a.c.x.h.gcov instead of x.h.gcov.  This works only    when a single source file is specified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_long_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output summary info for each function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_function_summary
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Object directory file prefix.  This is the directory/file    where .bb and .bbg files are looked for, if nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|object_directory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preserve all pathname components. Needed when object files and    source files are in subdirectories.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|preserve_paths
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output the number of times a branch was taken as opposed to the percentage    of times it was taken.  Turned on by the -c option */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_branch_counts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|process_args
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|open_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_for_source_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_data
name|PARAMS
argument_list|(
operator|(
expr|struct
name|sourcefile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_usage
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_version
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_arc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|adj_list
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|bb_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|adj_list
modifier|*
name|reverse_arcs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|adj_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gcov_type
modifier|*
name|read_profile
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_program_flow_graph
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bb_info_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|solve_program_flow_graph
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bb_info_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|accumulate_branch_counts
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coverage
operator|*
operator|,
expr|struct
name|arcdata
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calculate_branch_probs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bb_info
operator|*
operator|,
expr|struct
name|line_info
operator|*
operator|,
expr|struct
name|coverage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|function_summary
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coverage
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_line_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|line_info
operator|*
operator|,
expr|struct
name|coverage
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_line_info
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|line_info
operator|*
operator|,
specifier|const
expr|struct
name|coverage
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|make_gcov_file_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|format_hwint
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDEST_INT
operator|,
name|HOST_WIDEST_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|sourcefile
modifier|*
name|s_ptr
decl_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
name|process_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|open_files
argument_list|()
expr_stmt|;
name|read_files
argument_list|()
expr_stmt|;
name|scan_for_source_files
argument_list|()
expr_stmt|;
for|for
control|(
name|s_ptr
operator|=
name|sources
init|;
name|s_ptr
condition|;
name|s_ptr
operator|=
name|s_ptr
operator|->
name|next
control|)
name|output_data
argument_list|(
name|s_ptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|fnotice
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fnotice
name|VPARAMS
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|FILE
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|fancy_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Internal gcov abort.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a usage message and exit.  If ERROR_P is nonzero, this is an error,    otherwise the output of --help.  */
end_comment

begin_function
specifier|static
name|void
name|print_usage
parameter_list|(
name|error_p
parameter_list|)
name|int
name|error_p
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
name|error_p
condition|?
name|stderr
else|:
name|stdout
decl_stmt|;
name|int
name|status
init|=
name|error_p
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
decl_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"Usage: gcov [OPTION]... SOURCEFILE\n\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"Print code coverage information.\n\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -h, --help                      Print this help, then exit\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -v, --version                   Print version number, then exit\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -b, --branch-probabilities      Include branch probabilities in output\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -c, --branch-counts             Given counts of branches taken\n\                                     rather than percentages\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -n, --no-output                 Do not create an output file\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -l, --long-file-names           Use long output file names for included\n\                                     source files\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -f, --function-summaries        Output summaries for each function\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"  -p, --preserve-paths            Preserve all pathname components\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"\nFor bug reporting instructions, please see:\n%s.\n"
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print version information and exit.  */
end_comment

begin_function
specifier|static
name|void
name|print_version
parameter_list|()
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"gcov (GCC) %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"Copyright (C) 2001 Free Software Foundation, Inc.\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"This is free software; see the source for copying conditions.  There is NO\n\ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"branch-probabilities"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"branch-counts"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"no-output"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"long-file-names"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"function-summaries"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"preserve-paths"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"object-directory"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"object-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the command line.  */
end_comment

begin_function
specifier|static
name|void
name|process_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|opt
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hvbclnfo:p"
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'h'
case|:
name|print_usage
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* print_usage will exit.  */
case|case
literal|'v'
case|:
name|print_version
argument_list|()
expr_stmt|;
comment|/* print_version will exit.  */
case|case
literal|'b'
case|:
name|output_branch_probs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|output_branch_counts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|output_gcov_file
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|output_long_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|output_function_summary
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|object_directory
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|preserve_paths
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|print_usage
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* print_usage will exit.  */
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
operator|-
literal|1
condition|)
name|print_usage
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|input_file_name
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find and open the .bb, .da, and .bbg files. If OBJECT_DIRECTORY is    not specified, these are looked for in the current directory, and    named from the basename of the input_file_name sans extension. If    OBJECT_DIRECTORY is specified and is a directory, the files are in    that directory, but named from the basename of the input_file_name,    sans extension. Otherwise OBJECT_DIRECTORY is taken to be the name    of the object *file*, and the data files are named from that.  */
end_comment

begin_function
specifier|static
name|void
name|open_files
parameter_list|()
block|{
name|char
modifier|*
name|cptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|input_file_name
argument_list|)
decl_stmt|;
name|int
name|base
decl_stmt|;
if|if
condition|(
name|object_directory
operator|&&
name|object_directory
index|[
literal|0
index|]
condition|)
block|{
name|struct
name|stat
name|status
decl_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|object_directory
argument_list|)
operator|+
literal|2
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|base
operator|=
operator|!
name|stat
argument_list|(
name|object_directory
argument_list|,
operator|&
name|status
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|status
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|object_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|&&
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|base
condition|)
block|{
comment|/* Append source file name */
name|cptr
operator|=
name|strrchr
argument_list|(
name|input_file_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|cptr
condition|?
name|cptr
operator|+
literal|1
else|:
name|input_file_name
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the extension.  */
name|cptr
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
operator|*
name|cptr
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|da_file_name
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bb_file_name
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bbg_file_name
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|da_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bb_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|da_file_name
operator|+
name|length
argument_list|,
literal|".da"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bb_file_name
operator|+
name|length
argument_list|,
literal|".bb"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
operator|+
name|length
argument_list|,
literal|".bbg"
argument_list|)
expr_stmt|;
name|bb_file
operator|=
name|fopen
argument_list|(
name|bb_file_name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open basic block file %s.\n"
argument_list|,
name|bb_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|bbg_file
operator|=
name|fopen
argument_list|(
name|bbg_file_name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bbg_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open program flow graph file %s.\n"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|stat
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|fstat
argument_list|(
name|fileno
argument_list|(
name|bb_file
argument_list|)
argument_list|,
operator|&
name|status
argument_list|)
condition|)
name|bb_file_time
operator|=
name|status
operator|.
name|st_mtime
expr_stmt|;
block|}
comment|/* If none of the functions in the file were executed, then there won't      be a .da file.  Just assume that all counts are zero in this case.  */
name|da_file
operator|=
name|fopen
argument_list|(
name|da_file_name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|da_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open data file %s.\n"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Assuming that all execution counts are zero.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for empty .bbg file.  This indicates that there is no executable      code in this source file.  */
comment|/* Set the EOF condition if at the end of file.  */
name|ungetc
argument_list|(
name|getc
argument_list|(
name|bbg_file
argument_list|)
argument_list|,
name|bbg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|bbg_file
argument_list|)
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"No executable code associated with file %s.\n"
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize a new arc.  */
end_comment

begin_function
specifier|static
name|void
name|init_arc
parameter_list|(
name|arcptr
parameter_list|,
name|source
parameter_list|,
name|target
parameter_list|,
name|bb_graph
parameter_list|)
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|int
name|source
decl_stmt|,
name|target
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
block|{
name|arcptr
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|arcptr
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|arcptr
operator|->
name|arc_count
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|on_tree
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|succ_next
operator|=
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ
expr_stmt|;
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ
operator|=
name|arcptr
expr_stmt|;
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ_count
operator|++
expr_stmt|;
name|arcptr
operator|->
name|pred_next
operator|=
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred
expr_stmt|;
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred
operator|=
name|arcptr
expr_stmt|;
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reverse the arcs on an arc list.  */
end_comment

begin_function
specifier|static
name|struct
name|adj_list
modifier|*
name|reverse_arcs
parameter_list|(
name|arcptr
parameter_list|)
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
block|{
name|struct
name|adj_list
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|arcptr
operator|->
name|succ_next
expr_stmt|;
name|arcptr
operator|->
name|succ_next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|arcptr
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Reads profiles from the .da file and compute a hybrid profile.  */
end_comment

begin_function
specifier|static
name|gcov_type
modifier|*
name|read_profile
parameter_list|(
name|function_name
parameter_list|,
name|cfg_checksum
parameter_list|,
name|instr_arcs
parameter_list|)
name|char
modifier|*
name|function_name
decl_stmt|;
name|long
name|cfg_checksum
decl_stmt|;
name|int
name|instr_arcs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|okay
init|=
literal|1
decl_stmt|;
name|gcov_type
modifier|*
name|profile
decl_stmt|;
name|char
modifier|*
name|function_name_buffer
decl_stmt|;
name|int
name|function_name_buffer_len
decl_stmt|;
name|profile
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gcov_type
argument_list|)
operator|*
name|instr_arcs
argument_list|)
expr_stmt|;
name|function_name_buffer_len
operator|=
name|strlen
argument_list|(
name|function_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|function_name_buffer
operator|=
name|xmalloc
argument_list|(
name|function_name_buffer_len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|instr_arcs
condition|;
name|i
operator|++
control|)
name|profile
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|da_file
condition|)
return|return
name|profile
return|;
name|rewind
argument_list|(
name|da_file
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|long
name|magic
decl_stmt|,
name|extra_bytes
decl_stmt|;
name|long
name|func_count
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|magic
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|magic
operator|!=
operator|-
literal|123
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|func_count
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|extra_bytes
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* skip extra data emited by __bb_exit_func.  */
name|fseek
argument_list|(
name|da_file
argument_list|,
name|extra_bytes
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|func_count
condition|;
name|i
operator|++
control|)
block|{
name|long
name|arc_count
decl_stmt|;
name|long
name|chksum
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|__read_gcov_string
argument_list|(
name|function_name_buffer
argument_list|,
name|function_name_buffer_len
argument_list|,
name|da_file
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|chksum
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|arc_count
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|function_name_buffer
argument_list|,
name|function_name
argument_list|)
operator|!=
literal|0
operator|||
name|arc_count
operator|!=
name|instr_arcs
operator|||
name|chksum
operator|!=
name|cfg_checksum
condition|)
block|{
comment|/* skip */
if|if
condition|(
name|fseek
argument_list|(
name|da_file
argument_list|,
name|arc_count
operator|*
literal|8
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|gcov_type
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|arc_count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|__read_gcov_type
argument_list|(
operator|&
name|tmp
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|okay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|profile
index|[
name|j
index|]
operator|+=
name|tmp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|okay
condition|)
break|break;
block|}
name|free
argument_list|(
name|function_name_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|okay
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".da file corrupted!\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|profile
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|profile
return|;
block|}
end_function

begin_comment
comment|/* Construct the program flow graph from the .bbg file, and read in the data    in the .da file.  */
end_comment

begin_function
specifier|static
name|void
name|create_program_flow_graph
parameter_list|(
name|bptr
parameter_list|)
name|struct
name|bb_info_list
modifier|*
name|bptr
decl_stmt|;
block|{
name|long
name|num_blocks
decl_stmt|,
name|number_arcs
decl_stmt|,
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|flag_bits
decl_stmt|,
name|num_arcs_per_block
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
name|long
name|cfg_checksum
decl_stmt|;
name|long
name|instr_arcs
init|=
literal|0
decl_stmt|;
name|gcov_type
modifier|*
name|profile
decl_stmt|;
name|int
name|profile_pos
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|function_name
decl_stmt|;
name|long
name|function_name_len
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Read function name.  */
name|__read_long
argument_list|(
operator|&
name|tmp
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* ignore -1.  */
name|__read_long
argument_list|(
operator|&
name|function_name_len
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|function_name
operator|=
name|xmalloc
argument_list|(
name|function_name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|function_name
argument_list|,
literal|1
argument_list|,
name|function_name_len
operator|+
literal|1
argument_list|,
name|bbg_file
argument_list|)
expr_stmt|;
comment|/* Skip padding.  */
name|tmp
operator|=
operator|(
name|function_name_len
operator|+
literal|1
operator|)
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|fseek
argument_list|(
name|bbg_file
argument_list|,
literal|4
operator|-
name|tmp
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|__read_long
argument_list|(
operator|&
name|tmp
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* ignore -1.  */
comment|/* Read the cfg checksum.  */
name|__read_long
argument_list|(
operator|&
name|cfg_checksum
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Read the number of blocks.  */
name|__read_long
argument_list|(
operator|&
name|num_blocks
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Create an array of size bb number of bb_info structs.  */
name|bb_graph
operator|=
operator|(
expr|struct
name|bb_info
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_blocks
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
name|bptr
operator|->
name|bb_graph
operator|=
name|bb_graph
expr_stmt|;
name|bptr
operator|->
name|num_blocks
operator|=
name|num_blocks
expr_stmt|;
comment|/* Read and create each arc from the .bbg file.  */
name|__read_long
argument_list|(
operator|&
name|number_arcs
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|__read_long
argument_list|(
operator|&
name|num_arcs_per_block
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_arcs_per_block
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|number_arcs
operator|--
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|i
expr_stmt|;
name|__read_long
argument_list|(
operator|&
name|dest
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|bb_graph
argument_list|)
expr_stmt|;
name|__read_long
argument_list|(
operator|&
name|flag_bits
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_bits
operator|&
literal|0x1
condition|)
name|arcptr
operator|->
name|on_tree
operator|++
expr_stmt|;
else|else
name|instr_arcs
operator|++
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
operator|!
operator|!
operator|(
name|flag_bits
operator|&
literal|0x2
operator|)
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
operator|!
operator|!
operator|(
name|flag_bits
operator|&
literal|0x4
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|number_arcs
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Read and ignore the -1 separating the arc list from the arc list of the      next function.  */
name|__read_long
argument_list|(
operator|&
name|src
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Must reverse the order of all succ arcs, to ensure that they match      the order of the data in the .da file.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
condition|)
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
operator|=
name|reverse_arcs
argument_list|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
argument_list|)
expr_stmt|;
comment|/* Read profile from the .da file.  */
name|profile
operator|=
name|read_profile
argument_list|(
name|function_name
argument_list|,
name|cfg_checksum
argument_list|,
name|instr_arcs
argument_list|)
expr_stmt|;
comment|/* For each arc not on the spanning tree, set its execution count from      the .da file.  */
comment|/* The first count in the .da file is the number of times that the function      was entered.  This is the exec_count for block zero.  */
comment|/* This duplicates code in branch_prob in profile.c.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|on_tree
condition|)
block|{
name|arcptr
operator|->
name|arc_count
operator|=
name|profile
index|[
name|profile_pos
operator|++
index|]
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|arcptr
operator|->
name|target
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|profile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|function_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|solve_program_flow_graph
parameter_list|(
name|bptr
parameter_list|)
name|struct
name|bb_info_list
modifier|*
name|bptr
decl_stmt|;
block|{
name|int
name|passes
decl_stmt|,
name|changes
decl_stmt|;
name|gcov_type
name|total
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
name|int
name|num_blocks
decl_stmt|;
name|num_blocks
operator|=
name|bptr
operator|->
name|num_blocks
expr_stmt|;
name|bb_graph
operator|=
name|bptr
operator|->
name|bb_graph
expr_stmt|;
comment|/* For every block in the file,      - if every exit/entrance arc has a known count, then set the block count      - if the block count is known, and every exit/entrance arc but one has        a known execution count, then set the count of the remaining arc       As arc counts are set, decrement the succ/pred count, but don't delete      the arc, that way we can easily tell when all arcs are known, or only      one arc is unknown.  */
comment|/* The order that the basic blocks are iterated through is important.      Since the code that finds spanning trees starts with block 0, low numbered      arcs are put on the spanning tree in preference to high numbered arcs.      Hence, most instrumented arcs are at the end.  Graph solving works much      faster if we propagate numbers from the end to the start.       This takes an average of slightly more than 3 passes.  */
name|changes
operator|=
literal|1
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|passes
operator|++
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
condition|)
block|{
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|==
literal|0
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
operator|==
literal|0
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
condition|)
block|{
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|==
literal|1
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
comment|/* Calculate count for remaining arc by conservation.  */
name|total
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|-
name|total
expr_stmt|;
comment|/* Search for the invalid arc, and set its count.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|count_valid
condition|)
break|break;
if|if
condition|(
operator|!
name|arcptr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|arcptr
operator|->
name|arc_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|arcptr
operator|->
name|target
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
operator|==
literal|1
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
comment|/* Calculate count for remaining arc by conservation.  */
name|total
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|-
name|total
expr_stmt|;
comment|/* Search for the invalid arc, and set its count.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|count_valid
condition|)
break|break;
if|if
condition|(
operator|!
name|arcptr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|arcptr
operator|->
name|arc_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|arcptr
operator|->
name|source
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If the graph has been correctly solved, every block will have a      succ and pred count of zero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|||
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_files
parameter_list|()
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|list_end
init|=
literal|0
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|b_ptr
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|bbg_file
argument_list|)
condition|)
block|{
name|b_ptr
operator|=
operator|(
expr|struct
name|bb_info_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info_list
argument_list|)
argument_list|)
expr_stmt|;
name|b_ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list_end
condition|)
name|list_end
operator|->
name|next
operator|=
name|b_ptr
expr_stmt|;
else|else
name|bb_graph_list
operator|=
name|b_ptr
expr_stmt|;
name|list_end
operator|=
name|b_ptr
expr_stmt|;
comment|/* Read in the data in the .bbg file and reconstruct the program flow 	 graph for one function.  */
name|create_program_flow_graph
argument_list|(
name|b_ptr
argument_list|)
expr_stmt|;
comment|/* Set the EOF condition if at the end of file.  */
name|ungetc
argument_list|(
name|getc
argument_list|(
name|bbg_file
argument_list|)
argument_list|,
name|bbg_file
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate all of the basic block execution counts and branch      taken probabilities.  */
for|for
control|(
name|b_ptr
operator|=
name|bb_graph_list
init|;
name|b_ptr
condition|;
name|b_ptr
operator|=
name|b_ptr
operator|->
name|next
control|)
name|solve_program_flow_graph
argument_list|(
name|b_ptr
argument_list|)
expr_stmt|;
comment|/* Read in all of the data from the .bb file.   This info will be accessed      sequentially twice.  */
name|stat
argument_list|(
name|bb_file_name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|bb_data_size
operator|=
name|buf
operator|.
name|st_size
operator|/
literal|4
expr_stmt|;
name|bb_data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|bb_data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|buf
operator|.
name|st_size
argument_list|,
name|bb_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|bb_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|da_file
condition|)
name|fclose
argument_list|(
name|da_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|bbg_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the data in the .bb file to find all source files referenced,    and the largest line number mentioned in each one.  */
end_comment

begin_function
specifier|static
name|void
name|scan_for_source_files
parameter_list|()
block|{
name|struct
name|sourcefile
modifier|*
name|s_ptr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|count
decl_stmt|;
name|long
name|line_num
decl_stmt|;
comment|/* Search the bb_data to find:      1) The number of sources files contained herein, and      2) The largest line number for each source file.  */
name|ptr
operator|=
name|bb_data
expr_stmt|;
name|sources
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bb_data_size
condition|;
name|count
operator|++
control|)
block|{
name|__fetch_long
argument_list|(
operator|&
name|line_num
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|line_num
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* A source file name follows.  Check to see if we already have 	   a sourcefile structure for this file.  */
name|s_ptr
operator|=
name|sources
expr_stmt|;
while|while
condition|(
name|s_ptr
operator|&&
name|strcmp
argument_list|(
name|s_ptr
operator|->
name|name
argument_list|,
name|ptr
argument_list|)
condition|)
name|s_ptr
operator|=
name|s_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|s_ptr
operator|==
literal|0
condition|)
block|{
comment|/* No sourcefile structure for this file name exists, create 		 a new one, and append it to the front of the sources list.  */
name|s_ptr
operator|=
operator|(
expr|struct
name|sourcefile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sourcefile
argument_list|)
argument_list|)
expr_stmt|;
name|s_ptr
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|s_ptr
operator|->
name|maxlineno
operator|=
literal|0
expr_stmt|;
name|s_ptr
operator|->
name|next
operator|=
name|sources
expr_stmt|;
name|sources
operator|=
name|s_ptr
expr_stmt|;
block|}
comment|/* Scan past the file name.  */
block|{
name|long
name|delim
decl_stmt|;
do|do
block|{
name|count
operator|++
expr_stmt|;
name|__fetch_long
argument_list|(
operator|&
name|delim
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|line_num
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
name|line_num
operator|==
operator|-
literal|2
condition|)
block|{
name|long
name|delim
decl_stmt|;
comment|/* A function name follows.  Ignore it.  */
do|do
block|{
name|count
operator|++
expr_stmt|;
name|__fetch_long
argument_list|(
operator|&
name|delim
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|line_num
condition|)
do|;
block|}
comment|/* There will be a zero before the first file name, in which case s_ptr 	 will still be uninitialized.  So, only try to set the maxlineno 	 field if line_num is nonzero.  */
elseif|else
if|if
condition|(
name|line_num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s_ptr
operator|->
name|maxlineno
operator|<=
name|line_num
condition|)
name|s_ptr
operator|->
name|maxlineno
operator|=
name|line_num
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_num
operator|<
literal|0
condition|)
block|{
comment|/* Don't know what this is, but it's garbage.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Increment totals in FUNCTION according to arc A_PTR.  */
end_comment

begin_function
specifier|static
name|void
name|accumulate_branch_counts
parameter_list|(
name|function
parameter_list|,
name|a_ptr
parameter_list|)
name|struct
name|coverage
modifier|*
name|function
decl_stmt|;
name|struct
name|arcdata
modifier|*
name|a_ptr
decl_stmt|;
block|{
if|if
condition|(
name|a_ptr
operator|->
name|call_insn
condition|)
block|{
name|function
operator|->
name|calls
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|total
condition|)
name|function
operator|->
name|calls_executed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|function
operator|->
name|branches
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|total
condition|)
name|function
operator|->
name|branches_executed
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|hits
condition|)
name|function
operator|->
name|branches_taken
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the branch taken probabilities for all arcs branches at the    end of this block.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_branch_probs
parameter_list|(
name|block_ptr
parameter_list|,
name|line_info
parameter_list|,
name|function
parameter_list|)
name|struct
name|bb_info
modifier|*
name|block_ptr
decl_stmt|;
name|struct
name|line_info
modifier|*
name|line_info
decl_stmt|;
name|struct
name|coverage
modifier|*
name|function
decl_stmt|;
block|{
name|gcov_type
name|total
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|total
operator|=
name|block_ptr
operator|->
name|exec_count
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|block_ptr
operator|->
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
block|{
name|struct
name|arcdata
modifier|*
name|a_ptr
decl_stmt|;
comment|/* Ignore fall through arcs as they aren't really branches.  */
if|if
condition|(
name|arcptr
operator|->
name|fall_through
condition|)
continue|continue;
name|a_ptr
operator|=
operator|(
expr|struct
name|arcdata
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arcdata
argument_list|)
argument_list|)
expr_stmt|;
name|a_ptr
operator|->
name|total
operator|=
name|total
expr_stmt|;
name|a_ptr
operator|->
name|hits
operator|=
name|total
condition|?
name|arcptr
operator|->
name|arc_count
else|:
literal|0
expr_stmt|;
name|a_ptr
operator|->
name|call_insn
operator|=
name|arcptr
operator|->
name|fake
expr_stmt|;
if|if
condition|(
name|function
condition|)
name|accumulate_branch_counts
argument_list|(
name|function
argument_list|,
name|a_ptr
argument_list|)
expr_stmt|;
comment|/* Prepend the new branch to the list.  */
name|a_ptr
operator|->
name|next
operator|=
name|line_info
operator|->
name|branches
expr_stmt|;
name|line_info
operator|->
name|branches
operator|=
name|a_ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Format a HOST_WIDE_INT as either a percent ratio, or absolute    count.  If dp>= 0, format TOP/BOTTOM * 100 to DP decimal places.    If DP is zero, no decimal point is printed. Only print 100% when    TOP==BOTTOM and only print 0% when TOP=0.  If dp< 0, then simply    format TOP.  Return pointer to a static string.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|format_hwint
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|dp
parameter_list|)
name|HOST_WIDEST_INT
name|top
decl_stmt|,
name|bottom
decl_stmt|;
name|int
name|dp
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|dp
operator|>=
literal|0
condition|)
block|{
name|float
name|ratio
init|=
name|bottom
condition|?
operator|(
name|float
operator|)
name|top
operator|/
name|bottom
else|:
literal|0
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|unsigned
name|limit
init|=
literal|100
decl_stmt|;
name|unsigned
name|percent
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|dp
init|;
name|ix
operator|--
condition|;
control|)
name|limit
operator|*=
literal|10
expr_stmt|;
name|percent
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|ratio
operator|*
name|limit
operator|+
operator|(
name|float
operator|)
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|percent
operator|<=
literal|0
operator|&&
name|top
condition|)
name|percent
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|percent
operator|>=
name|limit
operator|&&
name|top
operator|!=
name|bottom
condition|)
name|percent
operator|=
name|limit
operator|-
literal|1
expr_stmt|;
name|ix
operator|=
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%.*u%%"
argument_list|,
name|dp
operator|+
literal|1
argument_list|,
name|percent
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
name|dp
operator|++
expr_stmt|;
do|do
block|{
name|buffer
index|[
name|ix
operator|+
literal|1
index|]
operator|=
name|buffer
index|[
name|ix
index|]
expr_stmt|;
name|ix
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|dp
operator|--
condition|)
do|;
name|buffer
index|[
name|ix
operator|+
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Output summary info for a function.  */
end_comment

begin_function
specifier|static
name|void
name|function_summary
parameter_list|(
name|function
parameter_list|,
name|title
parameter_list|)
name|struct
name|coverage
modifier|*
name|function
decl_stmt|;
specifier|const
name|char
modifier|*
name|title
decl_stmt|;
block|{
if|if
condition|(
name|function
operator|->
name|lines
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d lines executed in %s %s\n"
argument_list|,
name|format_hwint
argument_list|(
name|function
operator|->
name|lines_executed
argument_list|,
name|function
operator|->
name|lines
argument_list|,
literal|2
argument_list|)
argument_list|,
name|function
operator|->
name|lines
argument_list|,
name|title
argument_list|,
name|function
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No executable lines in %s %s\n"
argument_list|,
name|title
argument_list|,
name|function
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_branch_probs
condition|)
block|{
if|if
condition|(
name|function
operator|->
name|branches
condition|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d branches executed in %s %s\n"
argument_list|,
name|format_hwint
argument_list|(
name|function
operator|->
name|branches_executed
argument_list|,
name|function
operator|->
name|branches
argument_list|,
literal|2
argument_list|)
argument_list|,
name|function
operator|->
name|branches
argument_list|,
name|title
argument_list|,
name|function
operator|->
name|name
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d branches taken at least once in %s %s\n"
argument_list|,
name|format_hwint
argument_list|(
name|function
operator|->
name|branches_taken
argument_list|,
name|function
operator|->
name|branches
argument_list|,
literal|2
argument_list|)
argument_list|,
name|function
operator|->
name|branches
argument_list|,
name|title
argument_list|,
name|function
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No branches in %s %s\n"
argument_list|,
name|title
argument_list|,
name|function
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|->
name|calls
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d calls executed in %s %s\n"
argument_list|,
name|format_hwint
argument_list|(
name|function
operator|->
name|calls_executed
argument_list|,
name|function
operator|->
name|calls
argument_list|,
literal|2
argument_list|)
argument_list|,
name|function
operator|->
name|calls
argument_list|,
name|title
argument_list|,
name|function
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No calls in %s %s\n"
argument_list|,
name|title
argument_list|,
name|function
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate an output file name. LONG_OUTPUT_NAMES and PRESERVE_PATHS    affect name generation. With preserve_paths we create a filename    from all path components of the source file, replacing '/' with    '#', without it we simply take the basename component. With    long_output_names we prepend the processed name of the input file    to each output name (except when the current source file is the    input file, so you don't get a double concatenation). The two    components are separated by '##'. Also '.' filename components are    removed and '..'  components are renamed to '^'.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_gcov_file_name
parameter_list|(
name|src_name
parameter_list|)
name|char
modifier|*
name|src_name
decl_stmt|;
block|{
name|char
modifier|*
name|cptr
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|src_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|input_file_name
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output_long_names
operator|&&
name|strcmp
argument_list|(
name|src_name
argument_list|,
name|input_file_name
argument_list|)
condition|)
block|{
comment|/* Generate the input filename part.  */
name|cptr
operator|=
name|preserve_paths
condition|?
name|NULL
else|:
name|strrchr
argument_list|(
name|input_file_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|cptr
condition|?
name|cptr
operator|+
literal|1
else|:
name|input_file_name
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"##"
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the source filename part.  */
name|cptr
operator|=
name|preserve_paths
condition|?
name|NULL
else|:
name|strrchr
argument_list|(
name|src_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|cptr
condition|?
name|cptr
operator|+
literal|1
else|:
name|src_name
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve_paths
condition|)
block|{
comment|/* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */
name|char
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|cptr
operator|=
name|name
init|;
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
operator|(
name|prev
operator|=
name|cptr
operator|)
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|;
control|)
block|{
name|unsigned
name|shift
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|prev
operator|+
literal|1
operator|==
name|cptr
operator|&&
name|prev
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* Remove '.' */
name|shift
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev
operator|+
literal|2
operator|==
name|cptr
operator|&&
name|prev
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|prev
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* Convert '..' */
name|shift
operator|=
literal|1
expr_stmt|;
name|prev
index|[
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
block|}
else|else
operator|*
name|cptr
operator|++
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|cptr
operator|=
name|prev
expr_stmt|;
do|do
name|prev
index|[
literal|0
index|]
operator|=
name|prev
index|[
name|shift
index|]
expr_stmt|;
do|while
condition|(
operator|*
name|prev
operator|++
condition|)
do|;
block|}
block|}
block|}
comment|/* Don't strip off the ending for compatibility with tcov, since      this results in confusion if there is more than one file with the      same basename, e.g. tmp.c and tmp.h.  */
name|strcat
argument_list|(
name|name
argument_list|,
literal|".gcov"
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Scan through the bb_data, and when the file name matches the    source file name, then for each following line number, increment    the line number execution count indicated by the execution count of    the appropriate basic block.  */
end_comment

begin_function
specifier|static
name|void
name|init_line_info
parameter_list|(
name|line_info
parameter_list|,
name|total
parameter_list|,
name|maxlineno
parameter_list|)
name|struct
name|line_info
modifier|*
name|line_info
decl_stmt|;
name|struct
name|coverage
modifier|*
name|total
decl_stmt|;
name|long
name|maxlineno
decl_stmt|;
block|{
name|long
name|block_num
init|=
literal|0
decl_stmt|;
comment|/* current block number */
name|struct
name|bb_info
modifier|*
name|block_ptr
init|=
name|NULL
decl_stmt|;
comment|/* current block ptr */
name|struct
name|coverage
name|function
decl_stmt|;
name|struct
name|coverage
modifier|*
name|func_ptr
init|=
name|NULL
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|current_graph
init|=
name|NULL
decl_stmt|;
comment|/* Graph for current function.  */
name|int
name|is_this_file
init|=
literal|0
decl_stmt|;
comment|/* We're scanning a block from the desired file.  */
name|char
modifier|*
name|ptr
init|=
name|bb_data
decl_stmt|;
name|long
name|count
decl_stmt|;
name|long
name|line_num
decl_stmt|;
name|struct
name|line_info
modifier|*
name|line_ptr
init|=
literal|0
decl_stmt|;
comment|/* line info ptr.  */
name|memset
argument_list|(
operator|&
name|function
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_function_summary
condition|)
name|func_ptr
operator|=
operator|&
name|function
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bb_data_size
condition|;
name|count
operator|++
control|)
block|{
name|__fetch_long
argument_list|(
operator|&
name|line_num
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|line_num
operator|<
literal|0
condition|)
block|{
name|long
name|delim
decl_stmt|;
if|if
condition|(
name|line_num
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Marks the beginning of a file name.  Check to see 	     	 whether this is the filename we are currently 	     	 collecting data for.  */
name|is_this_file
operator|=
operator|!
name|strcmp
argument_list|(
name|total
operator|->
name|name
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_num
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* Marks the start of a new function.  Advance to the 	     	 next program flow graph.  */
if|if
condition|(
operator|!
name|current_graph
condition|)
name|current_graph
operator|=
name|bb_graph_list
expr_stmt|;
else|else
block|{
if|if
condition|(
name|block_num
operator|==
name|current_graph
operator|->
name|num_blocks
operator|-
literal|1
condition|)
comment|/* Last block falls through to exit.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|block_num
operator|==
name|current_graph
operator|->
name|num_blocks
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|output_branch_probs
operator|&&
name|is_this_file
condition|)
name|calculate_branch_probs
argument_list|(
name|block_ptr
argument_list|,
name|line_ptr
argument_list|,
name|func_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"didn't use all bb entries of graph, function %s\n"
argument_list|,
name|function
operator|.
name|name
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"block_num = %ld, num_blocks = %d\n"
argument_list|,
name|block_num
argument_list|,
name|current_graph
operator|->
name|num_blocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|func_ptr
operator|&&
name|is_this_file
condition|)
name|function_summary
argument_list|(
name|func_ptr
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|current_graph
operator|=
name|current_graph
operator|->
name|next
expr_stmt|;
block|}
name|block_num
operator|=
literal|0
expr_stmt|;
name|block_ptr
operator|=
name|current_graph
operator|->
name|bb_graph
expr_stmt|;
name|memset
argument_list|(
operator|&
name|function
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|function
operator|.
name|name
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: unexpected line number %ld\n"
argument_list|,
name|line_num
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Scan past the string.  */
for|for
control|(
name|delim
operator|=
literal|0
init|;
name|delim
operator|!=
name|line_num
condition|;
name|count
operator|++
control|)
block|{
name|__fetch_long
argument_list|(
operator|&
name|delim
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|line_num
condition|)
block|{
comment|/* Marks the end of a block.  */
if|if
condition|(
name|block_num
operator|>=
name|current_graph
operator|->
name|num_blocks
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: too many basic blocks in function %s\n"
argument_list|,
name|function
operator|.
name|name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_branch_probs
operator|&&
name|is_this_file
condition|)
name|calculate_branch_probs
argument_list|(
name|block_ptr
argument_list|,
name|line_ptr
argument_list|,
name|func_ptr
argument_list|)
expr_stmt|;
name|block_num
operator|++
expr_stmt|;
name|block_ptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_this_file
condition|)
block|{
if|if
condition|(
name|line_num
operator|>=
name|maxlineno
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: out of range line number in function %s\n"
argument_list|,
name|function
operator|.
name|name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|line_ptr
operator|=
operator|&
name|line_info
index|[
name|line_num
index|]
expr_stmt|;
if|if
condition|(
name|func_ptr
condition|)
block|{
if|if
condition|(
operator|!
name|line_ptr
operator|->
name|exists
condition|)
name|func_ptr
operator|->
name|lines
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|line_ptr
operator|->
name|count
operator|&&
name|block_ptr
operator|->
name|exec_count
condition|)
name|func_ptr
operator|->
name|lines_executed
operator|++
expr_stmt|;
block|}
comment|/* Accumulate execution data for this line number.  */
name|line_ptr
operator|->
name|count
operator|+=
name|block_ptr
operator|->
name|exec_count
expr_stmt|;
name|line_ptr
operator|->
name|exists
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|func_ptr
operator|&&
name|is_this_file
condition|)
name|function_summary
argument_list|(
name|func_ptr
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
comment|/* Calculate summary test coverage statistics.  */
for|for
control|(
name|line_num
operator|=
literal|1
operator|,
name|line_ptr
operator|=
operator|&
name|line_info
index|[
name|line_num
index|]
init|;
name|line_num
operator|<
name|maxlineno
condition|;
name|line_num
operator|++
operator|,
name|line_ptr
operator|++
control|)
block|{
name|struct
name|arcdata
modifier|*
name|a_ptr
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|line_ptr
operator|->
name|exists
condition|)
block|{
name|total
operator|->
name|lines
operator|++
expr_stmt|;
if|if
condition|(
name|line_ptr
operator|->
name|count
condition|)
name|total
operator|->
name|lines_executed
operator|++
expr_stmt|;
block|}
comment|/* Total and reverse the branch information.  */
for|for
control|(
name|a_ptr
operator|=
name|line_ptr
operator|->
name|branches
operator|,
name|prev
operator|=
name|NULL
init|;
name|a_ptr
condition|;
name|a_ptr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|a_ptr
operator|->
name|next
expr_stmt|;
name|a_ptr
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|a_ptr
expr_stmt|;
name|accumulate_branch_counts
argument_list|(
name|total
argument_list|,
name|a_ptr
argument_list|)
expr_stmt|;
block|}
name|line_ptr
operator|->
name|branches
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in the source file one line at a time, and output that line to    the gcov file preceded by its execution count and other    information.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_info
parameter_list|(
name|gcov_file
parameter_list|,
name|line_info
parameter_list|,
name|total
parameter_list|,
name|maxlineno
parameter_list|)
name|FILE
modifier|*
name|gcov_file
decl_stmt|;
specifier|const
name|struct
name|line_info
modifier|*
name|line_info
decl_stmt|;
specifier|const
name|struct
name|coverage
modifier|*
name|total
decl_stmt|;
name|long
name|maxlineno
decl_stmt|;
block|{
name|FILE
modifier|*
name|source_file
decl_stmt|;
name|long
name|line_num
decl_stmt|;
comment|/* current line number */
specifier|const
name|struct
name|line_info
modifier|*
name|line_ptr
decl_stmt|;
comment|/* current line info ptr.  */
name|char
name|string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
comment|/* line buffer.  */
name|char
specifier|const
modifier|*
name|retval
init|=
literal|""
decl_stmt|;
comment|/* status of source file reading.  */
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Source:%s\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|,
name|total
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Object:%s\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|,
name|bb_file_name
argument_list|)
expr_stmt|;
name|source_file
operator|=
name|fopen
argument_list|(
name|total
operator|->
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source_file
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open source file %s.\n"
argument_list|,
name|total
operator|->
name|name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|fstat
argument_list|(
name|fileno
argument_list|(
name|source_file
argument_list|)
argument_list|,
operator|&
name|status
argument_list|)
operator|&&
name|status
operator|.
name|st_mtime
operator|>
name|bb_file_time
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Warning: source file %s is newer than %s\n"
argument_list|,
name|total
operator|->
name|name
argument_list|,
name|bb_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5d:Source is newer than compiler output\n"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|line_num
operator|=
literal|1
operator|,
name|line_ptr
operator|=
operator|&
name|line_info
index|[
name|line_num
index|]
init|;
name|line_num
operator|<
name|maxlineno
condition|;
name|line_num
operator|++
operator|,
name|line_ptr
operator|++
control|)
block|{
comment|/* For lines which don't exist in the .bb file, print '-' before  	 the source line.  For lines which exist but were never  	 executed, print '#####' before the source line.  Otherwise,  	 print the execution count before the source line.  There are  	 16 spaces of indentation added before the source line so that  	 tabs won't be messed up.  */
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5ld:"
argument_list|,
operator|!
name|line_ptr
operator|->
name|exists
condition|?
literal|"-"
else|:
operator|!
name|line_ptr
operator|->
name|count
condition|?
literal|"#####"
else|:
name|format_hwint
argument_list|(
name|line_ptr
operator|->
name|count
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|line_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
comment|/* Copy source line.  */
do|do
block|{
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Unexpected EOF while reading source file %s.\n"
argument_list|,
name|total
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs
argument_list|(
name|retval
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|retval
index|[
literal|0
index|]
operator|||
name|retval
index|[
name|strlen
argument_list|(
name|retval
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|retval
condition|)
name|fputs
argument_list|(
literal|"??\n"
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_branch_probs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|arcdata
modifier|*
name|a_ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|a_ptr
operator|=
name|line_ptr
operator|->
name|branches
init|;
name|a_ptr
condition|;
name|a_ptr
operator|=
name|a_ptr
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a_ptr
operator|->
name|call_insn
condition|)
block|{
if|if
condition|(
name|a_ptr
operator|->
name|total
operator|==
literal|0
condition|)
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"call   %2d never executed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"call   %2d returns %s\n"
argument_list|,
name|i
argument_list|,
name|format_hwint
argument_list|(
name|a_ptr
operator|->
name|total
operator|-
name|a_ptr
operator|->
name|hits
argument_list|,
name|a_ptr
operator|->
name|total
argument_list|,
operator|-
name|output_branch_counts
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a_ptr
operator|->
name|total
operator|==
literal|0
condition|)
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"branch %2d never executed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"branch %2d taken %s\n"
argument_list|,
name|i
argument_list|,
name|format_hwint
argument_list|(
name|a_ptr
operator|->
name|hits
argument_list|,
name|a_ptr
operator|->
name|total
argument_list|,
operator|-
name|output_branch_counts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Handle all remaining source lines.  There may be lines after the      last line of code.  */
if|if
condition|(
name|retval
condition|)
block|{
for|for
control|(
init|;
operator|(
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
operator|)
condition|;
name|line_num
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%9s:%5ld:%s"
argument_list|,
literal|"-"
argument_list|,
name|line_num
argument_list|,
name|retval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|retval
index|[
literal|0
index|]
operator|||
name|retval
index|[
name|strlen
argument_list|(
name|retval
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
break|break;
name|fputs
argument_list|(
name|retval
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|source_file
condition|)
name|fclose
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate line execution counts, and output a .gcov file for source    file S_PTR. Allocate an array big enough to hold a count for each    line.  Scan through the bb_data, and when the file name matches the    current file name, then for each following line number, increment    the line number execution count indicated by the execution count of    the appropriate basic block.  */
end_comment

begin_function
specifier|static
name|void
name|output_data
parameter_list|(
name|s_ptr
parameter_list|)
name|struct
name|sourcefile
modifier|*
name|s_ptr
decl_stmt|;
block|{
name|struct
name|line_info
modifier|*
name|line_info
comment|/* line info data */
init|=
operator|(
expr|struct
name|line_info
operator|*
operator|)
name|xcalloc
argument_list|(
name|s_ptr
operator|->
name|maxlineno
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|line_info
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|line_num
decl_stmt|;
name|struct
name|coverage
name|total
decl_stmt|;
name|memset
argument_list|(
operator|&
name|total
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|.
name|name
operator|=
name|s_ptr
operator|->
name|name
expr_stmt|;
name|init_line_info
argument_list|(
name|line_info
argument_list|,
operator|&
name|total
argument_list|,
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
name|function_summary
argument_list|(
operator|&
name|total
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_gcov_file
condition|)
block|{
comment|/* Now the statistics are ready.  Read in the source file one 	 line at a time, and output that line to the gcov file 	 preceded by its execution information.  */
name|char
modifier|*
name|gcov_file_name
init|=
name|make_gcov_file_name
argument_list|(
name|total
operator|.
name|name
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|gcov_file
init|=
name|fopen
argument_list|(
name|gcov_file_name
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gcov_file
condition|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"Creating %s.\n"
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
name|output_line_info
argument_list|(
name|gcov_file
argument_list|,
name|line_info
argument_list|,
operator|&
name|total
argument_list|,
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|gcov_file
argument_list|)
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Error writing output file %s.\n"
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|gcov_file
argument_list|)
expr_stmt|;
block|}
else|else
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open output file %s.\n"
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gcov_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Free data.  */
for|for
control|(
name|line_num
operator|=
literal|1
init|;
name|line_num
operator|!=
name|s_ptr
operator|->
name|maxlineno
condition|;
name|line_num
operator|++
control|)
block|{
name|struct
name|arcdata
modifier|*
name|branch
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|branch
operator|=
name|line_info
index|[
name|line_num
index|]
operator|.
name|branches
init|;
name|branch
condition|;
name|branch
operator|=
name|next
control|)
block|{
name|next
operator|=
name|branch
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|line_info
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

