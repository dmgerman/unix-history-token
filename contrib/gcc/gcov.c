begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Gcov.c: prepend line execution counts and branch probabilities to a    source file.    Copyright (C) 1990, 91-94, 96, 97, 98, 1999 Free Software Foundation, Inc.    Contributed by James E. Wilson of Cygnus Support.    Mangled by Bob Manson of Cygnus Support.  Gcov is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Gcov is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Gcov; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ??? The code in final.c that produces the struct bb assumes that there is    no padding between the fields.  This is not necessary true.  The current    code can only be trusted if longs and pointers are the same size.  */
end_comment

begin_comment
comment|/* ??? No need to print an execution count on every line, could just print    it on the first line of each block, and only print it on a subsequent    line in the same block if the count changes.  */
end_comment

begin_comment
comment|/* ??? Print a list of the ten blocks with the highest execution counts,    and list the line numbers corresponding to those blocks.  Also, perhaps    list the line numbers with the highest execution counts, only printing    the first if there are several which are all listed in the same block.  */
end_comment

begin_comment
comment|/* ??? Should have an option to print the number of basic blocks, and the    percent of them that are covered.  */
end_comment

begin_comment
comment|/* ??? Does not correctly handle the case where two .bb files refer to the    same included source file.  For example, if one has a short file containing    only inline functions, which is then included in two other files, then    there will be two .bb files which refer to the include file, but there    is no way to get the total execution counts for the included file, can    only get execution counts for one or the other of the including files.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_comment
comment|/* The .bb file format consists of several lists of 4-byte integers    which are the line numbers of each basic block in the file.  Each    list is terminated by a zero.  These lists correspond to the basic    blocks in the reconstructed program flow graph.     A line number of -1 indicates that a source file name (padded to a    long boundary) follows.  The padded file name is followed by    another -1 to make it easy to scan past file names.  A -2 indicates    that a function name (padded to a long boundary) follows; the name    is followed by another -2 to make it easy to scan past the function    name.     The .bbg file contains enough info to enable gcov to reconstruct the    program flow graph.  The first word is the number of basic blocks,    the second word is the number of arcs, followed by the list of arcs    (source bb, dest bb pairs), then a -1, then the number of instrumented    arcs followed by the instrumented arcs, followed by another -1.  This    is repeated for each function.     The .da file contains the execution count for each instrumented branch.     The .bb and .bbg files are created by giving GCC the -ftest-coverage option,    and the .da files are created when an executable compiled with    -fprofile-arcs is run.  */
end_comment

begin_comment
comment|/* The functions in this file for creating and solution program flow graphs    are very similar to functions in the gcc source file profile.c.  */
end_comment

begin_decl_stmt
name|char
name|gcov_version_string
index|[]
init|=
literal|"GNU gcov version 1.5\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the size of the buffer used to read in source file lines.  */
end_comment

begin_define
define|#
directive|define
name|STRING_SIZE
value|200
end_define

begin_comment
comment|/* One copy of this structure is created for each source file mentioned in the    .bb file.  */
end_comment

begin_struct
struct|struct
name|sourcefile
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|maxlineno
decl_stmt|;
name|struct
name|sourcefile
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This points to the head of the sourcefile structure list.  */
end_comment

begin_decl_stmt
name|struct
name|sourcefile
modifier|*
name|sources
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One of these is dynamically created whenever we identify an arc in the    function.  */
end_comment

begin_struct
struct|struct
name|adj_list
block|{
name|int
name|source
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|arc_count
decl_stmt|;
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fake
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fall_through
range|:
literal|1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Not needed for gcov, but defined in profile.c.  */
block|rtx branch_insn;
endif|#
directive|endif
name|struct
name|adj_list
modifier|*
name|pred_next
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|succ_next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Count the number of basic blocks, and create an array of these structures,    one for each bb in the function.  */
end_comment

begin_struct
struct|struct
name|bb_info
block|{
name|struct
name|adj_list
modifier|*
name|succ
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|pred
decl_stmt|;
name|int
name|succ_count
decl_stmt|;
name|int
name|pred_count
decl_stmt|;
name|int
name|exec_count
decl_stmt|;
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Not needed for gcov, but defined in profile.c.  */
block|rtx first_insn;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* When outputting branch probabilities, one of these structures is created    for each branch/call.  */
end_comment

begin_struct
struct|struct
name|arcdata
block|{
name|int
name|prob
decl_stmt|;
name|int
name|call_insn
decl_stmt|;
name|struct
name|arcdata
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to save the list of bb_graphs, one per function.  */
end_comment

begin_struct
struct|struct
name|bb_info_list
block|{
comment|/* Indexed by block number, holds the basic block graph for one function.  */
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
name|int
name|num_blocks
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Holds a list of function basic block graphs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb_info_list
modifier|*
name|bb_graph_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the basic block graph.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bbg_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bbg_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the arc count data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|da_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|da_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the basic block line counts.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bb_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bb_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the entire contents of the bb_file read into memory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bb_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of bb_data array in longs.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|bb_data_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the output file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gcov_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|gcov_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file mentioned on the command line.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_file_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output branch probabilities if true.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_branch_probs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output a gcov file if this is true.  This is on by default, and can    be turned off by the -n option.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_gcov_file
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For included files, make the gcov output file name include the name of    the input source file.  For example, if x.h is included in a.c, then the    output file name is a.c.x.h.gcov instead of x.h.gcov.  This works only    when a single source file is specified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_long_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output summary info for each function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_function_summary
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Object directory file prefix.  This is the directory where .bb and .bbg    files are looked for, if non-zero.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|object_directory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|process_args
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|open_files
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_files
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_for_source_files
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_data
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_usage
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_LC_MESSAGES
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|localedir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|process_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|open_files
argument_list|()
expr_stmt|;
name|read_files
argument_list|()
expr_stmt|;
name|scan_for_source_files
argument_list|()
expr_stmt|;
name|output_data
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|fnotice
name|PVPROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fnotice
name|VPROTO
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|value
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"error: virtual memory exhausted"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Internal gcc abort.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a usage message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|print_usage
parameter_list|()
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"gcov [-b] [-v] [-n] [-l] [-f] [-o OBJDIR] file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the command line.  */
end_comment

begin_function
specifier|static
name|void
name|process_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
name|output_branch_probs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'v'
condition|)
name|fputs
argument_list|(
name|gcov_version_string
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
name|output_gcov_file
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
name|output_long_names
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
name|output_function_summary
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|object_directory
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|print_usage
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|input_file_name
condition|)
name|input_file_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|print_usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|input_file_name
condition|)
name|print_usage
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find and open the .bb, .da, and .bbg files.  */
end_comment

begin_function
specifier|static
name|void
name|open_files
parameter_list|()
block|{
name|int
name|count
decl_stmt|,
name|objdir_count
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|;
comment|/* Determine the names of the .bb, .bbg, and .da files.  Strip off the      extension, if any, and append the new extensions.  */
name|count
operator|=
name|strlen
argument_list|(
name|input_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_directory
condition|)
name|objdir_count
operator|=
name|strlen
argument_list|(
name|object_directory
argument_list|)
expr_stmt|;
else|else
name|objdir_count
operator|=
literal|0
expr_stmt|;
name|da_file_name
operator|=
name|xmalloc
argument_list|(
name|count
operator|+
name|objdir_count
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bb_file_name
operator|=
name|xmalloc
argument_list|(
name|count
operator|+
name|objdir_count
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bbg_file_name
operator|=
name|xmalloc
argument_list|(
name|count
operator|+
name|objdir_count
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_directory
condition|)
block|{
name|strcpy
argument_list|(
name|da_file_name
argument_list|,
name|object_directory
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bb_file_name
argument_list|,
name|object_directory
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
argument_list|,
name|object_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_directory
index|[
name|objdir_count
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|strcat
argument_list|(
name|da_file_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bb_file_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bbg_file_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|cptr
operator|=
name|rindex
argument_list|(
name|input_file_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
block|{
name|strcat
argument_list|(
name|da_file_name
argument_list|,
name|cptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bb_file_name
argument_list|,
name|cptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bbg_file_name
argument_list|,
name|cptr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|da_file_name
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bb_file_name
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bbg_file_name
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|strcpy
argument_list|(
name|da_file_name
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bb_file_name
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
block|}
name|cptr
operator|=
name|rindex
argument_list|(
name|bb_file_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|strcpy
argument_list|(
name|cptr
argument_list|,
literal|".bb"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|bb_file_name
argument_list|,
literal|".bb"
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|rindex
argument_list|(
name|da_file_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|strcpy
argument_list|(
name|cptr
argument_list|,
literal|".da"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|da_file_name
argument_list|,
literal|".da"
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|rindex
argument_list|(
name|bbg_file_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|strcpy
argument_list|(
name|cptr
argument_list|,
literal|".bbg"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|bbg_file_name
argument_list|,
literal|".bbg"
argument_list|)
expr_stmt|;
name|bb_file
operator|=
name|fopen
argument_list|(
name|bb_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open basic block file %s.\n"
argument_list|,
name|bb_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
comment|/* If none of the functions in the file were executed, then there won't      be a .da file.  Just assume that all counts are zero in this case.  */
name|da_file
operator|=
name|fopen
argument_list|(
name|da_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|da_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open data file %s.\n"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Assuming that all execution counts are zero.\n"
argument_list|)
expr_stmt|;
block|}
name|bbg_file
operator|=
name|fopen
argument_list|(
name|bbg_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bbg_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open program flow graph file %s.\n"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
comment|/* Check for empty .bbg file.  This indicates that there is no executable      code in this source file.  */
comment|/* Set the EOF condition if at the end of file.  */
name|ungetc
argument_list|(
name|getc
argument_list|(
name|bbg_file
argument_list|)
argument_list|,
name|bbg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|bbg_file
argument_list|)
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"No executable code associated with file %s.\n"
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize a new arc.  */
end_comment

begin_function
specifier|static
name|void
name|init_arc
parameter_list|(
name|arcptr
parameter_list|,
name|source
parameter_list|,
name|target
parameter_list|,
name|bb_graph
parameter_list|)
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|int
name|source
decl_stmt|,
name|target
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
block|{
name|arcptr
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|arcptr
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|arcptr
operator|->
name|arc_count
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|on_tree
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|succ_next
operator|=
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ
expr_stmt|;
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ
operator|=
name|arcptr
expr_stmt|;
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ_count
operator|++
expr_stmt|;
name|arcptr
operator|->
name|pred_next
operator|=
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred
expr_stmt|;
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred
operator|=
name|arcptr
expr_stmt|;
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reverse the arcs on a arc list.  */
end_comment

begin_function
specifier|static
name|struct
name|adj_list
modifier|*
name|reverse_arcs
parameter_list|(
name|arcptr
parameter_list|)
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
block|{
name|struct
name|adj_list
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|arcptr
operator|->
name|succ_next
expr_stmt|;
name|arcptr
operator|->
name|succ_next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|arcptr
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Construct the program flow graph from the .bbg file, and read in the data    in the .da file.  */
end_comment

begin_function
specifier|static
name|void
name|create_program_flow_graph
parameter_list|(
name|bptr
parameter_list|)
name|struct
name|bb_info_list
modifier|*
name|bptr
decl_stmt|;
block|{
name|long
name|num_blocks
decl_stmt|,
name|number_arcs
decl_stmt|,
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|flag_bits
decl_stmt|,
name|num_arcs_per_block
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
comment|/* Read the number of blocks.  */
name|__read_long
argument_list|(
operator|&
name|num_blocks
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Create an array of size bb number of bb_info structs.  Bzero it.  */
name|bb_graph
operator|=
operator|(
expr|struct
name|bb_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_graph
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
operator|*
name|num_blocks
argument_list|)
expr_stmt|;
name|bptr
operator|->
name|bb_graph
operator|=
name|bb_graph
expr_stmt|;
name|bptr
operator|->
name|num_blocks
operator|=
name|num_blocks
expr_stmt|;
comment|/* Read and create each arc from the .bbg file.  */
name|__read_long
argument_list|(
operator|&
name|number_arcs
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|__read_long
argument_list|(
operator|&
name|num_arcs_per_block
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_arcs_per_block
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|number_arcs
operator|--
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|i
expr_stmt|;
name|__read_long
argument_list|(
operator|&
name|dest
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|bb_graph
argument_list|)
expr_stmt|;
name|__read_long
argument_list|(
operator|&
name|flag_bits
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|arcptr
operator|->
name|on_tree
operator|=
name|flag_bits
operator|&
literal|0x1
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
operator|!
operator|!
operator|(
name|flag_bits
operator|&
literal|0x2
operator|)
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
operator|!
operator|!
operator|(
name|flag_bits
operator|&
literal|0x4
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|number_arcs
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Read and ignore the -1 separating the arc list from the arc list of the      next function.  */
name|__read_long
argument_list|(
operator|&
name|src
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Must reverse the order of all succ arcs, to ensure that they match      the order of the data in the .da file.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
condition|)
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
operator|=
name|reverse_arcs
argument_list|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
argument_list|)
expr_stmt|;
comment|/* For each arc not on the spanning tree, set its execution count from      the .da file.  */
comment|/* The first count in the .da file is the number of times that the function      was entered.  This is the exec_count for block zero.  */
comment|/* This duplicates code in branch_prob in profile.c.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|on_tree
condition|)
block|{
name|long
name|tmp_count
init|=
literal|0
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|da_file
operator|&&
name|__read_long
argument_list|(
operator|&
name|tmp_count
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arcptr
operator|->
name|arc_count
operator|=
name|tmp_count
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|arcptr
operator|->
name|target
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|solve_program_flow_graph
parameter_list|(
name|bptr
parameter_list|)
name|struct
name|bb_info_list
modifier|*
name|bptr
decl_stmt|;
block|{
name|int
name|passes
decl_stmt|,
name|changes
decl_stmt|,
name|total
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
name|int
name|num_blocks
decl_stmt|;
name|num_blocks
operator|=
name|bptr
operator|->
name|num_blocks
expr_stmt|;
name|bb_graph
operator|=
name|bptr
operator|->
name|bb_graph
expr_stmt|;
comment|/* For every block in the file,      - if every exit/entrance arc has a known count, then set the block count      - if the block count is known, and every exit/entrance arc but one has        a known execution count, then set the count of the remaining arc       As arc counts are set, decrement the succ/pred count, but don't delete      the arc, that way we can easily tell when all arcs are known, or only      one arc is unknown.  */
comment|/* The order that the basic blocks are iterated through is important.      Since the code that finds spanning trees starts with block 0, low numbered      arcs are put on the spanning tree in preference to high numbered arcs.      Hence, most instrumented arcs are at the end.  Graph solving works much      faster if we propagate numbers from the end to the start.       This takes an average of slightly more than 3 passes.  */
name|changes
operator|=
literal|1
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|passes
operator|++
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
condition|)
block|{
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|==
literal|0
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
operator|==
literal|0
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|count_valid
condition|)
block|{
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|==
literal|1
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
comment|/* Calculate count for remaining arc by conservation.  */
name|total
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|-
name|total
expr_stmt|;
comment|/* Search for the invalid arc, and set its count.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|count_valid
condition|)
break|break;
if|if
condition|(
operator|!
name|arcptr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|arcptr
operator|->
name|arc_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|arcptr
operator|->
name|target
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
operator|==
literal|1
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
name|total
operator|+=
name|arcptr
operator|->
name|arc_count
expr_stmt|;
comment|/* Calculate count for remaining arc by conservation.  */
name|total
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|exec_count
operator|-
name|total
expr_stmt|;
comment|/* Search for the invalid arc, and set its count.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|count_valid
condition|)
break|break;
if|if
condition|(
operator|!
name|arcptr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|arcptr
operator|->
name|arc_count
operator|=
name|total
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|arcptr
operator|->
name|source
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If the graph has been correctly solved, every block will have a      succ and pred count of zero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|||
name|bb_graph
index|[
name|i
index|]
operator|.
name|pred_count
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_files
parameter_list|()
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|list_end
init|=
literal|0
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|b_ptr
decl_stmt|;
name|long
name|total
decl_stmt|;
comment|/* Read and ignore the first word of the .da file, which is the count of      how many numbers follow.  */
if|if
condition|(
name|da_file
operator|&&
name|__read_long
argument_list|(
operator|&
name|total
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|bbg_file
argument_list|)
condition|)
block|{
name|b_ptr
operator|=
operator|(
expr|struct
name|bb_info_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info_list
argument_list|)
argument_list|)
expr_stmt|;
name|b_ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list_end
condition|)
name|list_end
operator|->
name|next
operator|=
name|b_ptr
expr_stmt|;
else|else
name|bb_graph_list
operator|=
name|b_ptr
expr_stmt|;
name|list_end
operator|=
name|b_ptr
expr_stmt|;
comment|/* Read in the data in the .bbg file and reconstruct the program flow 	 graph for one function.  */
name|create_program_flow_graph
argument_list|(
name|b_ptr
argument_list|)
expr_stmt|;
comment|/* Set the EOF condition if at the end of file.  */
name|ungetc
argument_list|(
name|getc
argument_list|(
name|bbg_file
argument_list|)
argument_list|,
name|bbg_file
argument_list|)
expr_stmt|;
block|}
comment|/* Check to make sure the .da file data is valid.  */
if|if
condition|(
name|da_file
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|da_file
argument_list|)
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|".da file contents exhausted too early\n"
argument_list|)
expr_stmt|;
comment|/* Should be at end of file now.  */
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|total
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|".da file contents not exhausted\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate all of the basic block execution counts and branch      taken probabilities.  */
for|for
control|(
name|b_ptr
operator|=
name|bb_graph_list
init|;
name|b_ptr
condition|;
name|b_ptr
operator|=
name|b_ptr
operator|->
name|next
control|)
name|solve_program_flow_graph
argument_list|(
name|b_ptr
argument_list|)
expr_stmt|;
comment|/* Read in all of the data from the .bb file.   This info will be accessed      sequentially twice.  */
name|stat
argument_list|(
name|bb_file_name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|bb_data_size
operator|=
name|buf
operator|.
name|st_size
operator|/
literal|4
expr_stmt|;
name|bb_data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|bb_data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|buf
operator|.
name|st_size
argument_list|,
name|bb_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|bb_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|da_file
condition|)
name|fclose
argument_list|(
name|da_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|bbg_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the data in the .bb file to find all source files referenced,    and the largest line number mentioned in each one.  */
end_comment

begin_function
specifier|static
name|void
name|scan_for_source_files
parameter_list|()
block|{
name|struct
name|sourcefile
modifier|*
name|s_ptr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|long
name|line_num
decl_stmt|;
comment|/* Search the bb_data to find:      1) The number of sources files contained herein, and      2) The largest line number for each source file.  */
name|ptr
operator|=
name|bb_data
expr_stmt|;
name|sources
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bb_data_size
condition|;
name|count
operator|++
control|)
block|{
name|__fetch_long
argument_list|(
operator|&
name|line_num
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|line_num
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* A source file name follows.  Check to see if we already have 	   a sourcefile structure for this file.  */
name|s_ptr
operator|=
name|sources
expr_stmt|;
while|while
condition|(
name|s_ptr
operator|&&
name|strcmp
argument_list|(
name|s_ptr
operator|->
name|name
argument_list|,
name|ptr
argument_list|)
condition|)
name|s_ptr
operator|=
name|s_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|s_ptr
operator|==
literal|0
condition|)
block|{
comment|/* No sourcefile structure for this file name exists, create 		 a new one, and append it to the front of the sources list.  */
name|s_ptr
operator|=
operator|(
expr|struct
name|sourcefile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sourcefile
argument_list|)
argument_list|)
expr_stmt|;
name|s_ptr
operator|->
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s_ptr
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
name|s_ptr
operator|->
name|maxlineno
operator|=
literal|0
expr_stmt|;
name|s_ptr
operator|->
name|next
operator|=
name|sources
expr_stmt|;
name|sources
operator|=
name|s_ptr
expr_stmt|;
block|}
comment|/* Scan past the file name.  */
block|{
name|long
name|delim
decl_stmt|;
do|do
block|{
name|count
operator|++
expr_stmt|;
name|__fetch_long
argument_list|(
operator|&
name|delim
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|line_num
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
name|line_num
operator|==
operator|-
literal|2
condition|)
block|{
name|long
name|delim
decl_stmt|;
comment|/* A function name follows.  Ignore it.  */
do|do
block|{
name|count
operator|++
expr_stmt|;
name|__fetch_long
argument_list|(
operator|&
name|delim
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|line_num
condition|)
do|;
block|}
comment|/* There will be a zero before the first file name, in which case s_ptr 	 will still be uninitialized.  So, only try to set the maxlineno 	 field if line_num is non-zero.  */
elseif|else
if|if
condition|(
name|line_num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s_ptr
operator|->
name|maxlineno
operator|<=
name|line_num
condition|)
name|s_ptr
operator|->
name|maxlineno
operator|=
name|line_num
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_num
operator|<
literal|0
condition|)
block|{
comment|/* Don't know what this is, but it's garbage. */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For calculating coverage at the function level.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|function_source_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_source_lines_executed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_branches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_branches_executed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_branches_taken
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_calls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_calls_executed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calculate the branch taken probabilities for all arcs branches at the    end of this block.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_branch_probs
parameter_list|(
name|current_graph
parameter_list|,
name|block_num
parameter_list|,
name|branch_probs
parameter_list|,
name|last_line_num
parameter_list|)
name|struct
name|bb_info_list
modifier|*
name|current_graph
decl_stmt|;
name|int
name|block_num
decl_stmt|;
name|struct
name|arcdata
modifier|*
modifier|*
name|branch_probs
decl_stmt|;
name|int
name|last_line_num
decl_stmt|;
block|{
name|int
name|total
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|struct
name|arcdata
modifier|*
name|end_ptr
decl_stmt|,
modifier|*
name|a_ptr
decl_stmt|;
name|total
operator|=
name|current_graph
operator|->
name|bb_graph
index|[
name|block_num
index|]
operator|.
name|exec_count
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|current_graph
operator|->
name|bb_graph
index|[
name|block_num
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
block|{
comment|/* Ignore fall through arcs as they aren't really branches.  */
if|if
condition|(
name|arcptr
operator|->
name|fall_through
condition|)
continue|continue;
name|a_ptr
operator|=
operator|(
expr|struct
name|arcdata
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arcdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|==
literal|0
condition|)
name|a_ptr
operator|->
name|prob
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|a_ptr
operator|->
name|prob
operator|=
operator|(
operator|(
name|arcptr
operator|->
name|arc_count
operator|*
literal|100
operator|)
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
expr_stmt|;
name|a_ptr
operator|->
name|call_insn
operator|=
name|arcptr
operator|->
name|fake
expr_stmt|;
if|if
condition|(
name|output_function_summary
condition|)
block|{
if|if
condition|(
name|a_ptr
operator|->
name|call_insn
condition|)
block|{
name|function_calls
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|!=
operator|-
literal|1
condition|)
name|function_calls_executed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|function_branches
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|!=
operator|-
literal|1
condition|)
name|function_branches_executed
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|>
literal|0
condition|)
name|function_branches_taken
operator|++
expr_stmt|;
block|}
block|}
comment|/* Append the new branch to the end of the list.  */
name|a_ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|branch_probs
index|[
name|last_line_num
index|]
condition|)
name|branch_probs
index|[
name|last_line_num
index|]
operator|=
name|a_ptr
expr_stmt|;
else|else
block|{
name|end_ptr
operator|=
name|branch_probs
index|[
name|last_line_num
index|]
expr_stmt|;
while|while
condition|(
name|end_ptr
operator|->
name|next
operator|!=
literal|0
condition|)
name|end_ptr
operator|=
name|end_ptr
operator|->
name|next
expr_stmt|;
name|end_ptr
operator|->
name|next
operator|=
name|a_ptr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output summary info for a function.  */
end_comment

begin_function
specifier|static
name|void
name|function_summary
parameter_list|()
block|{
if|if
condition|(
name|function_source_lines
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d source lines executed in function %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|function_source_lines_executed
operator|/
name|function_source_lines
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|function_source_lines
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No executable source lines in function %s\n"
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_branch_probs
condition|)
block|{
if|if
condition|(
name|function_branches
condition|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d branches executed in function %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|function_branches_executed
operator|/
name|function_branches
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|function_branches
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d branches taken at least once in function %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|function_branches_taken
operator|/
name|function_branches
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|function_branches
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
block|}
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No branches in function %s\n"
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_calls
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d calls executed in function %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|function_calls_executed
operator|/
name|function_calls
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|function_calls
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No calls in function %s\n"
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Calculate line execution counts, and output the data to a .tcov file.  */
end_comment

begin_function
specifier|static
name|void
name|output_data
parameter_list|()
block|{
comment|/* When scanning data, this is true only if the data applies to the      current source file.  */
name|int
name|this_file
decl_stmt|;
comment|/* An array indexed by line number which indicates how many times that line      was executed.  */
name|long
modifier|*
name|line_counts
decl_stmt|;
comment|/* An array indexed by line number which indicates whether the line was      present in the bb file (i.e. whether it had code associate with it).      Lines never executed are those which both exist, and have zero execution      counts.  */
name|char
modifier|*
name|line_exists
decl_stmt|;
comment|/* An array indexed by line number, which contains a list of branch      probabilities, one for each branch on that line.  */
name|struct
name|arcdata
modifier|*
modifier|*
name|branch_probs
init|=
name|NULL
decl_stmt|;
name|struct
name|sourcefile
modifier|*
name|s_ptr
decl_stmt|;
name|char
modifier|*
name|source_file_name
decl_stmt|;
name|FILE
modifier|*
name|source_file
decl_stmt|;
name|struct
name|bb_info_list
modifier|*
name|current_graph
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|;
name|long
name|block_num
decl_stmt|;
name|long
name|line_num
decl_stmt|;
name|long
name|last_line_num
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|arcdata
modifier|*
name|a_ptr
decl_stmt|;
comment|/* Buffer used for reading in lines from the source file.  */
name|char
name|string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
comment|/* For calculating coverage at the file level.  */
name|int
name|total_source_lines
decl_stmt|;
name|int
name|total_source_lines_executed
decl_stmt|;
name|int
name|total_branches
decl_stmt|;
name|int
name|total_branches_executed
decl_stmt|;
name|int
name|total_branches_taken
decl_stmt|;
name|int
name|total_calls
decl_stmt|;
name|int
name|total_calls_executed
decl_stmt|;
comment|/* Now, for each source file, allocate an array big enough to hold a count      for each line.  Scan through the bb_data, and when the file name matches      the current file name, then for each following line number, increment      the line number execution count indicated by the execution count of      the appropriate basic block.  */
for|for
control|(
name|s_ptr
operator|=
name|sources
init|;
name|s_ptr
condition|;
name|s_ptr
operator|=
name|s_ptr
operator|->
name|next
control|)
block|{
comment|/* If this is a relative file name, and an object directory has been 	 specified, then make it relative to the object directory name.  */
if|if
condition|(
operator|*
name|s_ptr
operator|->
name|name
operator|!=
literal|'/'
operator|&&
name|object_directory
operator|!=
literal|0
operator|&&
operator|*
name|object_directory
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|objdir_count
init|=
name|strlen
argument_list|(
name|object_directory
argument_list|)
decl_stmt|;
name|source_file_name
operator|=
name|xmalloc
argument_list|(
name|objdir_count
operator|+
name|strlen
argument_list|(
name|s_ptr
operator|->
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|source_file_name
argument_list|,
name|object_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_directory
index|[
name|objdir_count
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|source_file_name
index|[
name|objdir_count
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|source_file_name
operator|+
name|objdir_count
argument_list|,
name|s_ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|source_file_name
operator|=
name|s_ptr
operator|->
name|name
expr_stmt|;
name|line_counts
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_counts
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
name|line_exists
operator|=
name|xmalloc
argument_list|(
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|line_exists
argument_list|,
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_branch_probs
condition|)
block|{
name|branch_probs
operator|=
operator|(
expr|struct
name|arcdata
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arcdata
operator|*
argument_list|)
operator|*
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|branch_probs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arcdata
operator|*
argument_list|)
operator|*
name|s_ptr
operator|->
name|maxlineno
argument_list|)
expr_stmt|;
block|}
comment|/* There will be a zero at the beginning of the bb info, before the 	 first list of line numbers, so must initialize block_num to 0.  */
name|block_num
operator|=
literal|0
expr_stmt|;
name|this_file
operator|=
literal|0
expr_stmt|;
name|current_graph
operator|=
literal|0
expr_stmt|;
block|{
comment|/* Pointer into the bb_data, incremented while scanning the data.  */
name|char
modifier|*
name|ptr
init|=
name|bb_data
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bb_data_size
condition|;
name|count
operator|++
control|)
block|{
name|long
name|delim
decl_stmt|;
name|__fetch_long
argument_list|(
operator|&
name|line_num
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|line_num
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Marks the beginning of a file name.  Check to see whether 		   this is the filename we are currently collecting data for.  */
if|if
condition|(
name|strcmp
argument_list|(
name|s_ptr
operator|->
name|name
argument_list|,
name|ptr
argument_list|)
condition|)
name|this_file
operator|=
literal|0
expr_stmt|;
else|else
name|this_file
operator|=
literal|1
expr_stmt|;
comment|/* Scan past the file name.  */
do|do
block|{
name|count
operator|++
expr_stmt|;
name|__fetch_long
argument_list|(
operator|&
name|delim
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|line_num
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|line_num
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* Marks the start of a new function.  Advance to the next 		   program flow graph.  */
if|if
condition|(
operator|!
name|current_graph
condition|)
name|current_graph
operator|=
name|bb_graph_list
expr_stmt|;
else|else
block|{
if|if
condition|(
name|block_num
operator|==
name|current_graph
operator|->
name|num_blocks
operator|-
literal|1
condition|)
comment|/* Last block falls through to exit.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|block_num
operator|==
name|current_graph
operator|->
name|num_blocks
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|output_branch_probs
operator|&&
name|this_file
condition|)
name|calculate_branch_probs
argument_list|(
name|current_graph
argument_list|,
name|block_num
argument_list|,
name|branch_probs
argument_list|,
name|last_line_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"didn't use all bb entries of graph, function %s\n"
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"block_num = %ld, num_blocks = %d\n"
argument_list|,
name|block_num
argument_list|,
name|current_graph
operator|->
name|num_blocks
argument_list|)
expr_stmt|;
block|}
name|current_graph
operator|=
name|current_graph
operator|->
name|next
expr_stmt|;
name|block_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output_function_summary
operator|&&
name|this_file
condition|)
name|function_summary
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_function_summary
condition|)
block|{
name|function_source_lines
operator|=
literal|0
expr_stmt|;
name|function_source_lines_executed
operator|=
literal|0
expr_stmt|;
name|function_branches
operator|=
literal|0
expr_stmt|;
name|function_branches_executed
operator|=
literal|0
expr_stmt|;
name|function_branches_taken
operator|=
literal|0
expr_stmt|;
name|function_calls
operator|=
literal|0
expr_stmt|;
name|function_calls_executed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Save the function name for later use.  */
name|function_name
operator|=
name|ptr
expr_stmt|;
comment|/* Scan past the file name.  */
do|do
block|{
name|count
operator|++
expr_stmt|;
name|__fetch_long
argument_list|(
operator|&
name|delim
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|line_num
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|line_num
operator|==
literal|0
condition|)
block|{
comment|/* Marks the end of a block.  */
if|if
condition|(
name|block_num
operator|>=
name|current_graph
operator|->
name|num_blocks
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: too many basic blocks in .bb file %s\n"
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_branch_probs
operator|&&
name|this_file
condition|)
name|calculate_branch_probs
argument_list|(
name|current_graph
argument_list|,
name|block_num
argument_list|,
name|branch_probs
argument_list|,
name|last_line_num
argument_list|)
expr_stmt|;
name|block_num
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_file
condition|)
block|{
if|if
condition|(
name|output_function_summary
condition|)
block|{
if|if
condition|(
name|line_exists
index|[
name|line_num
index|]
operator|==
literal|0
condition|)
name|function_source_lines
operator|++
expr_stmt|;
if|if
condition|(
name|line_counts
index|[
name|line_num
index|]
operator|==
literal|0
operator|&&
name|current_graph
operator|->
name|bb_graph
index|[
name|block_num
index|]
operator|.
name|exec_count
operator|!=
literal|0
condition|)
name|function_source_lines_executed
operator|++
expr_stmt|;
block|}
comment|/* Accumulate execution data for this line number.  */
name|line_counts
index|[
name|line_num
index|]
operator|+=
name|current_graph
operator|->
name|bb_graph
index|[
name|block_num
index|]
operator|.
name|exec_count
expr_stmt|;
name|line_exists
index|[
name|line_num
index|]
operator|=
literal|1
expr_stmt|;
name|last_line_num
operator|=
name|line_num
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|output_function_summary
operator|&&
name|this_file
condition|)
name|function_summary
argument_list|()
expr_stmt|;
comment|/* Calculate summary test coverage statistics.  */
name|total_source_lines
operator|=
literal|0
expr_stmt|;
name|total_source_lines_executed
operator|=
literal|0
expr_stmt|;
name|total_branches
operator|=
literal|0
expr_stmt|;
name|total_branches_executed
operator|=
literal|0
expr_stmt|;
name|total_branches_taken
operator|=
literal|0
expr_stmt|;
name|total_calls
operator|=
literal|0
expr_stmt|;
name|total_calls_executed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<
name|s_ptr
operator|->
name|maxlineno
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|line_exists
index|[
name|count
index|]
condition|)
block|{
name|total_source_lines
operator|++
expr_stmt|;
if|if
condition|(
name|line_counts
index|[
name|count
index|]
condition|)
name|total_source_lines_executed
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|output_branch_probs
condition|)
block|{
for|for
control|(
name|a_ptr
operator|=
name|branch_probs
index|[
name|count
index|]
init|;
name|a_ptr
condition|;
name|a_ptr
operator|=
name|a_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|a_ptr
operator|->
name|call_insn
condition|)
block|{
name|total_calls
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|!=
operator|-
literal|1
condition|)
name|total_calls_executed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|total_branches
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|!=
operator|-
literal|1
condition|)
name|total_branches_executed
operator|++
expr_stmt|;
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|>
literal|0
condition|)
name|total_branches_taken
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|total_source_lines
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d source lines executed in file %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|total_source_lines_executed
operator|/
name|total_source_lines
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|total_source_lines
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No executable source lines in file %s\n"
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_branch_probs
condition|)
block|{
if|if
condition|(
name|total_branches
condition|)
block|{
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d branches executed in file %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|total_branches_executed
operator|/
name|total_branches
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|total_branches
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d branches taken at least once in file %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|total_branches_taken
operator|/
name|total_branches
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|total_branches
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
block|}
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No branches in file %s\n"
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_calls
condition|)
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"%6.2f%% of %d calls executed in file %s\n"
argument_list|,
operator|(
operator|(
operator|(
name|double
operator|)
name|total_calls_executed
operator|/
name|total_calls
operator|)
operator|*
literal|100
operator|)
argument_list|,
name|total_calls
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"No calls in file %s\n"
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_gcov_file
condition|)
block|{
comment|/* Now the statistics are ready.  Read in the source file one line 	     at a time, and output that line to the gcov file preceded by 	     its execution count if non zero.  */
name|source_file
operator|=
name|fopen
argument_list|(
name|source_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open source file %s.\n"
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line_counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line_exists
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|count
operator|=
name|strlen
argument_list|(
name|source_file_name
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|rindex
argument_list|(
name|s_ptr
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|cptr
operator|=
name|cptr
operator|+
literal|1
expr_stmt|;
else|else
name|cptr
operator|=
name|s_ptr
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|output_long_names
operator|&&
name|strcmp
argument_list|(
name|cptr
argument_list|,
name|input_file_name
argument_list|)
condition|)
block|{
name|gcov_file_name
operator|=
name|xmalloc
argument_list|(
name|count
operator|+
literal|7
operator|+
name|strlen
argument_list|(
name|input_file_name
argument_list|)
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|rindex
argument_list|(
name|input_file_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|strcpy
argument_list|(
name|gcov_file_name
argument_list|,
name|cptr
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|gcov_file_name
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|gcov_file_name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|rindex
argument_list|(
name|source_file_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|strcat
argument_list|(
name|gcov_file_name
argument_list|,
name|cptr
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|gcov_file_name
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcov_file_name
operator|=
name|xmalloc
argument_list|(
name|count
operator|+
literal|6
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|rindex
argument_list|(
name|source_file_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|strcpy
argument_list|(
name|gcov_file_name
argument_list|,
name|cptr
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|gcov_file_name
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Don't strip off the ending for compatibility with tcov, since 	     this results in confusion if there is more than one file with 	     the same basename, e.g. tmp.c and tmp.h.  */
name|strcat
argument_list|(
name|gcov_file_name
argument_list|,
literal|".gcov"
argument_list|)
expr_stmt|;
name|gcov_file
operator|=
name|fopen
argument_list|(
name|gcov_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcov_file
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Could not open output file %s.\n"
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line_counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line_exists
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fnotice
argument_list|(
name|stdout
argument_list|,
literal|"Creating %s.\n"
argument_list|,
name|gcov_file_name
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<
name|s_ptr
operator|->
name|maxlineno
condition|;
name|count
operator|++
control|)
block|{
name|char
modifier|*
name|retval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
comment|/* For lines which don't exist in the .bb file, print nothing 		 before the source line.  For lines which exist but were never 		 executed, print ###### before the source line.  Otherwise, 		 print the execution count before the source line.  */
comment|/* There are 16 spaces of indentation added before the source 		 line so that tabs won't be messed up.  */
if|if
condition|(
name|line_exists
index|[
name|count
index|]
condition|)
block|{
if|if
condition|(
name|line_counts
index|[
name|count
index|]
condition|)
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"%12ld    %s"
argument_list|,
name|line_counts
index|[
name|count
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"      ######    %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"\t\t%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* In case the source file line is larger than our buffer, keep 		 reading and outputting lines until we get a newline.  */
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|==
literal|0
operator|||
name|string
index|[
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
operator|&&
name|retval
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|string
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_branch_probs
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|a_ptr
operator|=
name|branch_probs
index|[
name|count
index|]
init|;
name|a_ptr
condition|;
name|a_ptr
operator|=
name|a_ptr
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a_ptr
operator|->
name|call_insn
condition|)
block|{
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|==
operator|-
literal|1
condition|)
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"call %d never executed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"call %d returns = %d%%\n"
argument_list|,
name|i
argument_list|,
literal|100
operator|-
name|a_ptr
operator|->
name|prob
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a_ptr
operator|->
name|prob
operator|==
operator|-
literal|1
condition|)
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"branch %d never executed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fnotice
argument_list|(
name|gcov_file
argument_list|,
literal|"branch %d taken = %d%%\n"
argument_list|,
name|i
argument_list|,
name|a_ptr
operator|->
name|prob
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Gracefully handle errors while reading the source file.  */
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Unexpected EOF while reading source file %s.\n"
argument_list|,
name|source_file_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Handle all remaining source lines.  There may be lines 	     after the last line of code.  */
block|{
name|char
modifier|*
name|retval
init|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
decl_stmt|;
while|while
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|gcov_file
argument_list|,
literal|"\t\t%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* In case the source file line is larger than our buffer, keep 		   reading and outputting lines until we get a newline.  */
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|==
literal|0
operator|||
name|string
index|[
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
operator|&&
name|retval
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|string
argument_list|,
name|gcov_file
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|STRING_SIZE
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|gcov_file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line_counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line_exists
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

