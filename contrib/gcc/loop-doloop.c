begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform doloop optimizations    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.    Based on code by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* This module is used to modify loops with a determinable number of    iterations to use special low-overhead looping instructions.     It first validates whether the loop is well behaved and has a    determinable number of iterations (either at compile or run-time).    It then modifies the loop to use a low-overhead looping pattern as    follows:     1. A pseudo register is allocated as the loop iteration counter.     2. The number of loop iterations is calculated and is stored       in the loop counter.     3. At the end of the loop, the jump insn is replaced by the       doloop_end pattern.  The compare must remain because it might be       used elsewhere.  If the loop-variable or condition register are       used elsewhere, they will be eliminated by flow.     4. An optional doloop_begin pattern is inserted at the top of the       loop.     TODO The optimization should only performed when either the biv used for exit    condition is unused at all except for the exit test, or if we do not have to    change its value, since otherwise we have to add a new induction variable,    which usually will not pay up (unless the cost of the doloop pattern is    somehow extremely lower than the cost of compare& jump, or unless the bct    register cannot be used for anything else but doloop -- ??? detect these    cases).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_doloop_end
end_ifdef

begin_comment
comment|/* Return the loop termination condition for PATTERN or zero    if it is not a decrement and branch jump insn.  */
end_comment

begin_function
name|rtx
name|doloop_condition_get
parameter_list|(
name|rtx
name|pattern
parameter_list|)
block|{
name|rtx
name|cmp
decl_stmt|;
name|rtx
name|inc
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|inc_src
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
comment|/* The canonical doloop pattern we expect is:       (parallel [(set (pc) (if_then_else (condition)                                         (label_ref (label))                                         (pc)))                 (set (reg) (plus (reg) (const_int -1)))                 (additional clobbers and uses)])       Some targets (IA-64) wrap the set of the loop counter in      an if_then_else too.       In summary, the branch must be the first entry of the      parallel (also required by jump.c), and the second      entry of the parallel must be a set of the loop counter      register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|PARALLEL
condition|)
return|return
literal|0
return|;
name|cmp
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inc
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for (set (reg) (something)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
name|reg
operator|=
name|SET_DEST
argument_list|(
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check if something = (plus (reg) (const_int -1)).      On IA-64, this decrement is wrapped in an if_then_else.  */
name|inc_src
operator|=
name|SET_SRC
argument_list|(
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc_src
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|inc_src
operator|=
name|XEXP
argument_list|(
name|inc_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc_src
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|inc_src
argument_list|,
literal|0
argument_list|)
operator|!=
name|reg
operator|||
name|XEXP
argument_list|(
name|inc_src
argument_list|,
literal|1
argument_list|)
operator|!=
name|constm1_rtx
condition|)
return|return
literal|0
return|;
comment|/* Check for (set (pc) (if_then_else (condition)                                        (label_ref (label))                                        (pc))).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|cmp
argument_list|)
operator|!=
name|pc_rtx
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return
literal|0
return|;
comment|/* Extract loop termination condition.  */
name|condition
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We expect a GE or NE comparison with 0 or 1.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|GE
operator|&&
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|NE
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
operator|&&
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|!=
name|const1_rtx
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|)
condition|)
return|return
name|condition
return|;
comment|/* ??? If a machine uses a funny comparison, we could return a      canonicalized form here.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the loop specified by LOOP is suitable for    the use of special low-overhead looping instructions.  DESC    describes the number of iterations of the loop.  */
end_comment

begin_function
specifier|static
name|bool
name|doloop_valid_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
decl_stmt|,
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bool
name|result
init|=
name|true
decl_stmt|;
comment|/* Check for loops that may not terminate under special conditions.  */
if|if
condition|(
operator|!
name|desc
operator|->
name|simple_p
operator|||
name|desc
operator|->
name|assumptions
operator|||
name|desc
operator|->
name|infinite
condition|)
block|{
comment|/* There are some cases that would require a special attention. 	 For example if the comparison is LEU and the comparison value 	 is UINT_MAX then the loop will not terminate.  Similarly, if the 	 comparison code is GEU and the comparison value is 0, the 	 loop will not terminate.  	 If the absolute increment is not 1, the loop can be infinite 	 even with LTU/GTU, e.g. for (i = 3; i> 0; i -= 2)  	 ??? We could compute these conditions at run-time and have a 	 additional jump around the loop to ensure an infinite loop. 	 However, it is very unlikely that this is the intended 	 behavior of the loop and checking for these rare boundary 	 conditions would pessimize all other code.  	 If the loop is executed only a few times an extra check to 	 restart the loop could use up most of the benefits of using a 	 count register loop.  Note however, that normally, this 	 restart branch would never execute, so it could be predicted 	 well by the CPU.  We should generate the pessimistic code by 	 default, and have an option, e.g. -funsafe-loops that would 	 enable count-register loops in this case.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: Possible infinite iteration case.\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|false
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|body
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Different targets have different necessities for low-overhead 	     looping.  Call the back end for each instruction within the loop 	     to let it decide whether the insn prohibits a low-overhead loop. 	     It will then return the cause for it to emit to the dump file.  */
specifier|const
name|char
modifier|*
name|invalid
init|=
name|targetm
operator|.
name|invalid_within_doloop
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|invalid
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: %s\n"
argument_list|,
name|invalid
argument_list|)
expr_stmt|;
name|result
operator|=
name|false
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
name|result
operator|=
name|true
expr_stmt|;
name|cleanup
label|:
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Adds test of COND jumping to DEST on edge *E and set *E to the new fallthru    edge.  If the condition is always false, do not do anything.  If it is always    true, redirect E to DEST and return false.  In all other cases, true is    returned.  */
end_comment

begin_function
specifier|static
name|bool
name|add_test
parameter_list|(
name|rtx
name|cond
parameter_list|,
name|edge
modifier|*
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|rtx
name|seq
decl_stmt|,
name|jump
decl_stmt|,
name|label
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|jump
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|jump
argument_list|)
condition|)
block|{
comment|/* The condition is always false and the jump was optimized out.  */
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|bb
operator|=
name|loop_split_edge_with
argument_list|(
operator|*
name|e
argument_list|,
name|seq
argument_list|)
expr_stmt|;
operator|*
name|e
operator|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|jump
argument_list|)
condition|)
block|{
comment|/* The condition is always true.  */
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
operator|*
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
comment|/* The jump is supposed to handle an unlikely special case.  */
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
name|make_edge
argument_list|(
name|bb
argument_list|,
name|dest
argument_list|,
operator|(
operator|*
name|e
operator|)
operator|->
name|flags
operator|&
operator|~
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Modify the loop to use the low-overhead looping insn where LOOP    describes the loop, DESC describes the number of iterations of the    loop, and DOLOOP_INSN is the low-overhead looping insn to emit at the    end of the loop.  CONDITION is the condition separated from the    DOLOOP_SEQ.  COUNT is the number of iterations of the LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|doloop_modify
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|,
name|rtx
name|doloop_seq
parameter_list|,
name|rtx
name|condition
parameter_list|,
name|rtx
name|count
parameter_list|)
block|{
name|rtx
name|counter_reg
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|noloop
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|jump_insn
decl_stmt|;
name|rtx
name|jump_label
decl_stmt|;
name|int
name|nonneg
init|=
literal|0
decl_stmt|;
name|bool
name|increment_count
decl_stmt|;
name|basic_block
name|loop_end
init|=
name|desc
operator|->
name|out_edge
operator|->
name|src
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|jump_insn
operator|=
name|BB_END
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: Inserting doloop pattern ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|const_iter
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|desc
operator|->
name|niter
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"runtime"
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" iterations).\n"
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Discard original jump to continue loop.  The original compare      result may still be live, so it cannot be discarded explicitly.  */
name|delete_insn
argument_list|(
name|jump_insn
argument_list|)
expr_stmt|;
name|counter_reg
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|counter_reg
argument_list|)
operator|==
name|PLUS
condition|)
name|counter_reg
operator|=
name|XEXP
argument_list|(
name|counter_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|counter_reg
argument_list|)
expr_stmt|;
name|increment_count
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|NE
case|:
comment|/* Currently only NE tests against zero and one are supported.  */
name|noloop
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noloop
operator|!=
name|const0_rtx
condition|)
block|{
name|gcc_assert
argument_list|(
name|noloop
operator|==
name|const1_rtx
argument_list|)
expr_stmt|;
name|increment_count
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|GE
case|:
comment|/* Currently only GE tests against zero are supported.  */
name|gcc_assert
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
name|noloop
operator|=
name|constm1_rtx
expr_stmt|;
comment|/* The iteration count does not need incrementing for a GE test.  */
name|increment_count
operator|=
name|false
expr_stmt|;
comment|/* Determine if the iteration counter will be non-negative. 	 Note that the maximum value loaded is iterations_max - 1.  */
if|if
condition|(
name|desc
operator|->
name|niter_max
operator|<=
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|nonneg
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Abort if an invalid doloop pattern has been generated.  */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|increment_count
condition|)
name|count
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
comment|/* Insert initialization of the count register into the loop header.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|force_operand
argument_list|(
name|count
argument_list|,
name|counter_reg
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|counter_reg
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|sequence
argument_list|,
name|BB_END
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|noloop_assumptions
condition|)
block|{
name|rtx
name|ass
init|=
name|copy_rtx
argument_list|(
name|desc
operator|->
name|noloop_assumptions
argument_list|)
decl_stmt|;
name|basic_block
name|preheader
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
decl_stmt|;
name|basic_block
name|set_zero
init|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|basic_block
name|new_preheader
init|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|edge
name|te
decl_stmt|;
comment|/* Expand the condition testing the assumptions and if it does not pass, 	 reset the count register to 0.  */
name|redirect_edge_and_branch_force
argument_list|(
name|single_succ_edge
argument_list|(
name|preheader
argument_list|)
argument_list|,
name|new_preheader
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_preheader
argument_list|,
name|preheader
argument_list|)
expr_stmt|;
name|set_zero
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|set_zero
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
name|te
operator|=
name|single_succ_edge
argument_list|(
name|preheader
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ass
condition|;
name|ass
operator|=
name|XEXP
argument_list|(
name|ass
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|!
name|add_test
argument_list|(
name|XEXP
argument_list|(
name|ass
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|te
argument_list|,
name|set_zero
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ass
condition|)
block|{
comment|/* We reached a condition that is always true.  This is very hard to 	     reproduce (such a loop does not roll, and thus it would most 	     likely get optimized out by some of the preceding optimizations). 	     In fact, I do not have any testcase for it.  However, it would 	     also be very hard to show that it is impossible, so we must 	     handle this case.  */
name|set_zero
operator|->
name|count
operator|=
name|preheader
operator|->
name|count
expr_stmt|;
name|set_zero
operator|->
name|frequency
operator|=
name|preheader
operator|->
name|frequency
expr_stmt|;
block|}
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|set_zero
operator|->
name|preds
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* All the conditions were simplified to false, remove the 	     unreachable set_zero block.  */
name|remove_bb_from_loops
argument_list|(
name|set_zero
argument_list|)
expr_stmt|;
name|delete_basic_block
argument_list|(
name|set_zero
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reset the counter to zero in the set_zero block.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|convert_move
argument_list|(
name|counter_reg
argument_list|,
name|noloop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|sequence
argument_list|,
name|BB_END
argument_list|(
name|set_zero
argument_list|)
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|set_zero
argument_list|,
name|recount_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|set_zero
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_preheader
argument_list|,
name|recount_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_preheader
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Some targets (eg, C4x) need to initialize special looping      registers.  */
ifdef|#
directive|ifdef
name|HAVE_doloop_begin
block|{
name|rtx
name|init
decl_stmt|;
name|unsigned
name|level
init|=
name|get_loop_level
argument_list|(
name|loop
argument_list|)
operator|+
literal|1
decl_stmt|;
name|init
operator|=
name|gen_doloop_begin
argument_list|(
name|counter_reg
argument_list|,
name|desc
operator|->
name|const_iter
condition|?
name|desc
operator|->
name|niter_expr
else|:
name|const0_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|desc
operator|->
name|niter_max
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|sequence
argument_list|,
name|BB_END
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Insert the new low-overhead looping insn.  */
name|emit_jump_insn_after
argument_list|(
name|doloop_seq
argument_list|,
name|BB_END
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|BB_END
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
name|jump_label
operator|=
name|block_label
argument_list|(
name|desc
operator|->
name|in_edge
operator|->
name|dest
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
operator|=
name|jump_label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|jump_label
argument_list|)
operator|++
expr_stmt|;
comment|/* Ensure the right fallthru edge is marked, for case we have reversed      the condition.  */
name|desc
operator|->
name|in_edge
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|desc
operator|->
name|out_edge
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
comment|/* Add a REG_NONNEG note if the actual or estimated maximum number      of iterations is non-negative.  */
if|if
condition|(
name|nonneg
condition|)
block|{
name|REG_NOTES
argument_list|(
name|jump_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process loop described by LOOP validating that the loop is suitable for    conversion to use a low overhead looping instruction, replacing the jump    insn where suitable.  Returns true if the loop was successfully    modified.  */
end_comment

begin_function
specifier|static
name|bool
name|doloop_optimize
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|doloop_seq
decl_stmt|,
name|doloop_pat
decl_stmt|,
name|doloop_reg
decl_stmt|;
name|rtx
name|iterations
decl_stmt|,
name|count
decl_stmt|;
name|rtx
name|iterations_max
decl_stmt|;
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|unsigned
name|level
decl_stmt|,
name|est_niter
decl_stmt|;
name|int
name|max_cost
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
decl_stmt|;
name|unsigned
name|word_mode_size
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|word_mode_max
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: Processing loop %d.\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|iv_analysis_loop_init
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Find the simple exit of a LOOP.  */
name|desc
operator|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check that loop is a candidate for a low-overhead looping insn.  */
if|if
condition|(
operator|!
name|doloop_valid_p
argument_list|(
name|loop
argument_list|,
name|desc
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: The loop is not suitable.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|mode
operator|=
name|desc
operator|->
name|mode
expr_stmt|;
name|est_niter
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|const_iter
condition|)
name|est_niter
operator|=
name|desc
operator|->
name|niter
expr_stmt|;
comment|/* If the estimate on number of iterations is reliable (comes from profile      feedback), use it.  Do not use it normally, since the expected number      of iterations of an unrolled loop is 2.  */
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
condition|)
name|est_niter
operator|=
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|est_niter
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: Too few iterations (%u) to be profitable.\n"
argument_list|,
name|est_niter
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|max_cost
operator|=
name|COSTS_N_INSNS
argument_list|(
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_ITERATIONS_COMPUTATION_COST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_cost
argument_list|(
name|desc
operator|->
name|niter_expr
argument_list|,
name|SET
argument_list|)
operator|>
name|max_cost
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: number of iterations too costly to compute.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|count
operator|=
name|copy_rtx
argument_list|(
name|desc
operator|->
name|niter_expr
argument_list|)
expr_stmt|;
name|iterations
operator|=
name|desc
operator|->
name|const_iter
condition|?
name|desc
operator|->
name|niter_expr
else|:
name|const0_rtx
expr_stmt|;
name|iterations_max
operator|=
name|GEN_INT
argument_list|(
name|desc
operator|->
name|niter_max
argument_list|)
expr_stmt|;
name|level
operator|=
name|get_loop_level
argument_list|(
name|loop
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Generate looping insn.  If the pattern FAILs then give up trying      to modify the loop since there is some aspect the back-end does      not like.  */
name|start_label
operator|=
name|block_label
argument_list|(
name|desc
operator|->
name|in_edge
operator|->
name|dest
argument_list|)
expr_stmt|;
name|doloop_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|doloop_seq
operator|=
name|gen_doloop_end
argument_list|(
name|doloop_reg
argument_list|,
name|iterations
argument_list|,
name|iterations_max
argument_list|,
name|GEN_INT
argument_list|(
name|level
argument_list|)
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
name|word_mode_size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|word_mode_max
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|word_mode_size
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|doloop_seq
operator|&&
name|mode
operator|!=
name|word_mode
comment|/* Before trying mode different from the one in that # of iterations is 	 computed, we must be sure that the number of iterations fits into 	 the new mode.  */
operator|&&
operator|(
name|word_mode_size
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|||
name|desc
operator|->
name|niter_max
operator|<=
name|word_mode_max
operator|)
condition|)
block|{
if|if
condition|(
name|word_mode_size
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|count
operator|=
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|word_mode
argument_list|,
name|count
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|iterations
operator|=
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|word_mode
argument_list|,
name|iterations
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|iterations_max
operator|=
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|word_mode
argument_list|,
name|iterations_max
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|lowpart_subreg
argument_list|(
name|word_mode
argument_list|,
name|count
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|iterations
operator|=
name|lowpart_subreg
argument_list|(
name|word_mode
argument_list|,
name|iterations
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|iterations_max
operator|=
name|lowpart_subreg
argument_list|(
name|word_mode
argument_list|,
name|iterations_max
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|doloop_reg
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
name|doloop_seq
operator|=
name|gen_doloop_end
argument_list|(
name|doloop_reg
argument_list|,
name|iterations
argument_list|,
name|iterations_max
argument_list|,
name|GEN_INT
argument_list|(
name|level
argument_list|)
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doloop_seq
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: Target unwilling to use doloop pattern!\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If multiple instructions were created, the last must be the      jump instruction.  Also, a raw define_insn may yield a plain      pattern.  */
name|doloop_pat
operator|=
name|doloop_seq
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|doloop_pat
argument_list|)
condition|)
block|{
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|doloop_pat
argument_list|)
operator|!=
name|NULL_RTX
condition|)
name|doloop_pat
operator|=
name|NEXT_INSN
argument_list|(
name|doloop_pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|doloop_pat
argument_list|)
condition|)
name|doloop_pat
operator|=
name|PATTERN
argument_list|(
name|doloop_pat
argument_list|)
expr_stmt|;
else|else
name|doloop_pat
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doloop_pat
operator|||
operator|!
operator|(
name|condition
operator|=
name|doloop_condition_get
argument_list|(
name|doloop_pat
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Doloop: Unrecognizable doloop pattern!\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|doloop_modify
argument_list|(
name|loop
argument_list|,
name|desc
argument_list|,
name|doloop_seq
argument_list|,
name|condition
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is the main entry point.  Process all LOOPS using doloop_optimize.  */
end_comment

begin_function
name|void
name|doloop_optimize_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|doloop_optimize
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
name|iv_analysis_done
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_doloop_end */
end_comment

end_unit

