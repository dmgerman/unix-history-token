begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SSA-PRE for trees.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dan@dberlin.org> and Steven Bosscher<stevenb@suse.de>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_comment
comment|/* TODO:     1. Avail sets can be shared by making an avail_find_leader that       walks up the dominator tree and looks in those avail sets.       This might affect code optimality, it's unclear right now.    2. Strength reduction can be performed by anticipating expressions       we can repair later on.    3. We can do back-substitution or smarter value numbering to catch       commutative expressions split up over multiple statements.    4. ANTIC_SAFE_LOADS could be a lot smarter than it is now.       Right now, it is simply calculating loads that occur before       any store in a block, instead of loads that occur before       stores that affect them.  This is relatively more expensive, and       it's not clear how much more it will buy us. */
end_comment

begin_comment
comment|/* For ease of terminology, "expression node" in the below refers to    every expression node but MODIFY_EXPR, because MODIFY_EXPR's represent    the actual statement containing the expressions we care about, and    we cache the value number by putting it in the expression.  */
end_comment

begin_comment
comment|/* Basic algorithm     First we walk the statements to generate the AVAIL sets, the    EXP_GEN sets, and the tmp_gen sets.  EXP_GEN sets represent the    generation of values/expressions by a given block.  We use them    when computing the ANTIC sets.  The AVAIL sets consist of    SSA_NAME's that represent values, so we know what values are    available in what blocks.  AVAIL is a forward dataflow problem.  In    SSA, values are never killed, so we don't need a kill set, or a    fixpoint iteration, in order to calculate the AVAIL sets.  In    traditional parlance, AVAIL sets tell us the downsafety of the    expressions/values.     Next, we generate the ANTIC sets.  These sets represent the    anticipatable expressions.  ANTIC is a backwards dataflow    problem.An expression is anticipatable in a given block if it could    be generated in that block.  This means that if we had to perform    an insertion in that block, of the value of that expression, we    could.  Calculating the ANTIC sets requires phi translation of    expressions, because the flow goes backwards through phis.  We must    iterate to a fixpoint of the ANTIC sets, because we have a kill    set.  Even in SSA form, values are not live over the entire    function, only from their definition point onwards.  So we have to    remove values from the ANTIC set once we go past the definition    point of the leaders that make them up.    compute_antic/compute_antic_aux performs this computation.     Third, we perform insertions to make partially redundant    expressions fully redundant.     An expression is partially redundant (excluding partial    anticipation) if:     1. It is AVAIL in some, but not all, of the predecessors of a       given block.    2. It is ANTIC in all the predecessors.     In order to make it fully redundant, we insert the expression into    the predecessors where it is not available, but is ANTIC.    insert/insert_aux performs this insertion.     Fourth, we eliminate fully redundant expressions.    This is a simple statement walk that replaces redundant    calculations  with the now available values.  */
end_comment

begin_comment
comment|/* Representations of value numbers:     Value numbers are represented using the "value handle" approach.    This means that each SSA_NAME (and for other reasons to be    disclosed in a moment, expression nodes) has a value handle that    can be retrieved through get_value_handle.  This value handle, *is*    the value number of the SSA_NAME.  You can pointer compare the    value handles for equivalence purposes.     For debugging reasons, the value handle is internally more than    just a number, it is a VAR_DECL named "value.x", where x is a    unique number for each value number in use.  This allows    expressions with SSA_NAMES replaced by value handles to still be    pretty printed in a sane way.  They simply print as "value.3 *    value.5", etc.     Expression nodes have value handles associated with them as a    cache.  Otherwise, we'd have to look them up again in the hash    table This makes significant difference (factor of two or more) on    some test cases.  They can be thrown away after the pass is    finished.  */
end_comment

begin_comment
comment|/* Representation of expressions on value numbers:     In some portions of this code, you will notice we allocate "fake"    analogues to the expression we are value numbering, and replace the    operands with the values of the expression.  Since we work on    values, and not just names, we canonicalize expressions to value    expressions for use in the ANTIC sets, the EXP_GEN set, etc.     This is theoretically unnecessary, it just saves a bunch of    repeated get_value_handle and find_leader calls in the remainder of    the code, trading off temporary memory usage for speed.  The tree    nodes aren't actually creating more garbage, since they are    allocated in a special pools which are thrown away at the end of    this pass.     All of this also means that if you print the EXP_GEN or ANTIC sets,    you will see "value.5 + value.7" in the set, instead of "a_55 +    b_66" or something.  The only thing that actually cares about    seeing the value leaders is phi translation, and it needs to be    able to find the leader for a value in an arbitrary block, so this    "value expression" form is perfect for it (otherwise you'd do    get_value_handle->find_leader->translate->get_value_handle->find_leader).*/
end_comment

begin_comment
comment|/* Representation of sets:     There are currently two types of sets used, hopefully to be unified soon.    The AVAIL sets do not need to be sorted in any particular order,    and thus, are simply represented as two bitmaps, one that keeps    track of values present in the set, and one that keeps track of    expressions present in the set.     The other sets are represented as doubly linked lists kept in topological    order, with an optional supporting bitmap of values present in the    set.  The sets represent values, and the elements can be values or    expressions.  The elements can appear in different sets, but each    element can only appear once in each set.     Since each node in the set represents a value, we also want to be    able to map expression, set pairs to something that tells us    whether the value is present is a set.  We use a per-set bitmap for    that.  The value handles also point to a linked list of the    expressions they represent via a tree annotation.  This is mainly    useful only for debugging, since we don't do identity lookups.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|in_fre
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A value set element.  Basically a single linked list of    expressions/values.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|value_set_node
block|{
comment|/* An expression.  */
name|tree
name|expr
decl_stmt|;
comment|/* A pointer to the next element of the value set.  */
name|struct
name|value_set_node
modifier|*
name|next
decl_stmt|;
block|}
typedef|*
name|value_set_node_t
typedef|;
end_typedef

begin_comment
comment|/* A value set.  This is a singly linked list of value_set_node    elements with a possible bitmap that tells us what values exist in    the set.  This set must be kept in topologically sorted order.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|value_set
block|{
comment|/* The head of the list.  Used for iterating over the list in      order.  */
name|value_set_node_t
name|head
decl_stmt|;
comment|/* The tail of the list.  Used for tail insertions, which are      necessary to keep the set in topologically sorted order because      of how the set is built.  */
name|value_set_node_t
name|tail
decl_stmt|;
comment|/* The length of the list.  */
name|size_t
name|length
decl_stmt|;
comment|/* True if the set is indexed, which means it contains a backing      bitmap for quick determination of whether certain values exist in the      set.  */
name|bool
name|indexed
decl_stmt|;
comment|/* The bitmap of values that exist in the set.  May be NULL in an      empty or non-indexed set.  */
name|bitmap
name|values
decl_stmt|;
block|}
typedef|*
name|value_set_t
typedef|;
end_typedef

begin_comment
comment|/* An unordered bitmap set.  One bitmap tracks values, the other,    expressions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bitmap_set
block|{
name|bitmap
name|expressions
decl_stmt|;
name|bitmap
name|values
decl_stmt|;
block|}
typedef|*
name|bitmap_set_t
typedef|;
end_typedef

begin_comment
comment|/* Sets that we need to keep track of.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bb_value_sets
block|{
comment|/* The EXP_GEN set, which represents expressions/values generated in      a basic block.  */
name|value_set_t
name|exp_gen
decl_stmt|;
comment|/* The PHI_GEN set, which represents PHI results generated in a      basic block.  */
name|bitmap_set_t
name|phi_gen
decl_stmt|;
comment|/* The TMP_GEN set, which represents results/temporaries generated      in a basic block. IE the LHS of an expression.  */
name|bitmap_set_t
name|tmp_gen
decl_stmt|;
comment|/* The AVAIL_OUT set, which represents which values are available in      a given basic block.  */
name|bitmap_set_t
name|avail_out
decl_stmt|;
comment|/* The ANTIC_IN set, which represents which values are anticipatable      in a given basic block.  */
name|value_set_t
name|antic_in
decl_stmt|;
comment|/* The NEW_SETS set, which is used during insertion to augment the      AVAIL_OUT set of blocks with the new insertions performed during      the current iteration.  */
name|bitmap_set_t
name|new_sets
decl_stmt|;
comment|/* The RVUSE sets, which are used during ANTIC computation to ensure      that we don't mark loads ANTIC once they have died.  */
name|bitmap
name|rvuse_in
decl_stmt|;
name|bitmap
name|rvuse_out
decl_stmt|;
name|bitmap
name|rvuse_gen
decl_stmt|;
name|bitmap
name|rvuse_kill
decl_stmt|;
comment|/* For actually occurring loads, as long as they occur before all the      other stores in the block, we know they are antic at the top of      the block, regardless of RVUSE_KILL.  */
name|value_set_t
name|antic_safe_loads
decl_stmt|;
block|}
typedef|*
name|bb_value_sets_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EXP_GEN
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->exp_gen
end_define

begin_define
define|#
directive|define
name|PHI_GEN
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->phi_gen
end_define

begin_define
define|#
directive|define
name|TMP_GEN
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->tmp_gen
end_define

begin_define
define|#
directive|define
name|AVAIL_OUT
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->avail_out
end_define

begin_define
define|#
directive|define
name|ANTIC_IN
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->antic_in
end_define

begin_define
define|#
directive|define
name|RVUSE_IN
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->rvuse_in
end_define

begin_define
define|#
directive|define
name|RVUSE_GEN
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->rvuse_gen
end_define

begin_define
define|#
directive|define
name|RVUSE_KILL
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->rvuse_kill
end_define

begin_define
define|#
directive|define
name|RVUSE_OUT
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->rvuse_out
end_define

begin_define
define|#
directive|define
name|NEW_SETS
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->new_sets
end_define

begin_define
define|#
directive|define
name|ANTIC_SAFE_LOADS
parameter_list|(
name|BB
parameter_list|)
value|((bb_value_sets_t) ((BB)->aux))->antic_safe_loads
end_define

begin_comment
comment|/* This structure is used to keep track of statistics on what    optimization PRE was able to perform.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* The number of RHS computations eliminated by PRE.  */
name|int
name|eliminations
decl_stmt|;
comment|/* The number of new expressions/temporaries generated by PRE.  */
name|int
name|insertions
decl_stmt|;
comment|/* The number of new PHI nodes added by PRE.  */
name|int
name|phis
decl_stmt|;
comment|/* The number of values found constant.  */
name|int
name|constified
decl_stmt|;
block|}
name|pre_stats
struct|;
end_struct

begin_function_decl
specifier|static
name|tree
name|bitmap_find_leader
parameter_list|(
name|bitmap_set_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_leader
parameter_list|(
name|value_set_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|value_insert_into_set
parameter_list|(
name|value_set_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bitmap_value_insert_into_set
parameter_list|(
name|bitmap_set_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bitmap_value_replace_in_set
parameter_list|(
name|bitmap_set_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_into_set
parameter_list|(
name|value_set_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bitmap_set_copy
parameter_list|(
name|bitmap_set_t
parameter_list|,
name|bitmap_set_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bitmap_set_contains_value
parameter_list|(
name|bitmap_set_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bitmap_set_t
name|bitmap_set_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|value_set_t
name|set_new
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_undefined_value
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|create_expression_by_pieces
parameter_list|(
name|basic_block
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_or_generate_expression
parameter_list|(
name|basic_block
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We can add and remove elements and entries to and from sets    and hash tables, so we use alloc pools for them.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|value_set_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|bitmap_set_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|value_set_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|binary_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|unary_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|reference_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|comparison_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|expression_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|list_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|modify_expr_node_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|grand_bitmap_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To avoid adding 300 temporary variables when we only need one, we    only create one temporary variable, on demand, and build ssa names    off that.  We do have to change the variable if the types don't    match the current variable's type.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pretemp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|storetemp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|mergephitemp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|prephitemp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of blocks with statements that have had its EH information    cleaned up.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|need_eh_cleanup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The phi_translate_table caches phi translations for a given    expression and predecessor.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|phi_translate_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A three tuple {e, pred, v} used to cache phi translations in the    phi_translate_table.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|expr_pred_trans_d
block|{
comment|/* The expression.  */
name|tree
name|e
decl_stmt|;
comment|/* The predecessor block along which we translated the expression.  */
name|basic_block
name|pred
decl_stmt|;
comment|/* vuses associated with the expression.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
expr_stmt|;
comment|/* The value that resulted from the translation.  */
name|tree
name|v
decl_stmt|;
comment|/* The hashcode for the expression, pred pair. This is cached for      speed reasons.  */
name|hashval_t
name|hashcode
decl_stmt|;
block|}
typedef|*
name|expr_pred_trans_t
typedef|;
end_typedef

begin_comment
comment|/* Return the hash value for a phi translation table entry.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|expr_pred_trans_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|expr_pred_trans_t
name|ve
init|=
operator|(
name|expr_pred_trans_t
operator|)
name|p
decl_stmt|;
return|return
name|ve
operator|->
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Return true if two phi translation table entries are the same.    P1 and P2 should point to the expr_pred_trans_t's to be compared.*/
end_comment

begin_function
specifier|static
name|int
name|expr_pred_trans_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|expr_pred_trans_t
name|ve1
init|=
operator|(
name|expr_pred_trans_t
operator|)
name|p1
decl_stmt|;
specifier|const
name|expr_pred_trans_t
name|ve2
init|=
operator|(
name|expr_pred_trans_t
operator|)
name|p2
decl_stmt|;
name|basic_block
name|b1
init|=
name|ve1
operator|->
name|pred
decl_stmt|;
name|basic_block
name|b2
init|=
name|ve2
operator|->
name|pred
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|vuse1
decl_stmt|;
comment|/* If they are not translations for the same basic block, they can't      be equal.  */
if|if
condition|(
name|b1
operator|!=
name|b2
condition|)
return|return
name|false
return|;
comment|/* If they are for the same basic block, determine if the      expressions are equal.  */
if|if
condition|(
operator|!
name|expressions_equal_p
argument_list|(
name|ve1
operator|->
name|e
argument_list|,
name|ve2
operator|->
name|e
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Make sure the vuses are equivalent.  */
if|if
condition|(
name|ve1
operator|->
name|vuses
operator|==
name|ve2
operator|->
name|vuses
condition|)
return|return
name|true
return|;
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|ve1
operator|->
name|vuses
argument_list|)
operator|!=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|ve2
operator|->
name|vuses
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ve1
operator|->
name|vuses
argument_list|,
name|i
argument_list|,
name|vuse1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|ve2
operator|->
name|vuses
argument_list|,
name|i
argument_list|)
operator|!=
name|vuse1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Search in the phi translation table for the translation of    expression E in basic block PRED with vuses VUSES.    Return the translated value, if found, NULL otherwise.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|tree
name|phi_trans_lookup
argument_list|(
name|tree
name|e
argument_list|,
name|basic_block
name|pred
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|expr_pred_trans_d
name|ept
decl_stmt|;
name|ept
operator|.
name|e
operator|=
name|e
expr_stmt|;
name|ept
operator|.
name|pred
operator|=
name|pred
expr_stmt|;
name|ept
operator|.
name|vuses
operator|=
name|vuses
expr_stmt|;
name|ept
operator|.
name|hashcode
operator|=
name|vn_compute
argument_list|(
name|e
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pred
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|phi_translate_table
argument_list|,
operator|&
name|ept
argument_list|,
name|ept
operator|.
name|hashcode
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
operator|(
name|expr_pred_trans_t
operator|)
operator|*
name|slot
operator|)
operator|->
name|v
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Add the tuple mapping from {expression E, basic block PRED, vuses VUSES} to    value V, to the phi translation table.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|phi_trans_add
argument_list|(
name|tree
name|e
argument_list|,
name|tree
name|v
argument_list|,
name|basic_block
name|pred
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|expr_pred_trans_t
name|new_pair
init|=
name|XNEW
argument_list|(
expr|struct
name|expr_pred_trans_d
argument_list|)
decl_stmt|;
name|new_pair
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|new_pair
operator|->
name|pred
operator|=
name|pred
expr_stmt|;
name|new_pair
operator|->
name|vuses
operator|=
name|vuses
expr_stmt|;
name|new_pair
operator|->
name|v
operator|=
name|v
expr_stmt|;
name|new_pair
operator|->
name|hashcode
operator|=
name|vn_compute
argument_list|(
name|e
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pred
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|phi_translate_table
argument_list|,
name|new_pair
argument_list|,
name|new_pair
operator|->
name|hashcode
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
name|free
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|new_pair
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Add expression E to the expression set of value V.  */
end_comment

begin_function
name|void
name|add_to_value
parameter_list|(
name|tree
name|v
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
comment|/* Constants have no expression sets.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|v
argument_list|)
condition|)
return|return;
if|if
condition|(
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|v
argument_list|)
operator|==
name|NULL
condition|)
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|v
argument_list|)
operator|=
name|set_new
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|insert_into_set
argument_list|(
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|v
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if value V exists in the bitmap for SET.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|value_exists_in_set_bitmap
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|set
operator|->
name|values
condition|)
return|return
name|false
return|;
return|return
name|bitmap_bit_p
argument_list|(
name|set
operator|->
name|values
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove value V from the bitmap for SET.  */
end_comment

begin_function
specifier|static
name|void
name|value_remove_from_set_bitmap
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|v
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|set
operator|->
name|indexed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|values
condition|)
return|return;
name|bitmap_clear_bit
argument_list|(
name|set
operator|->
name|values
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the value number V into the bitmap of values existing in    SET.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|value_insert_into_set_bitmap
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|v
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|set
operator|->
name|indexed
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|values
operator|==
name|NULL
condition|)
name|set
operator|->
name|values
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|set
operator|->
name|values
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new bitmap set and return it.  */
end_comment

begin_function
specifier|static
name|bitmap_set_t
name|bitmap_set_new
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap_set_t
name|ret
init|=
operator|(
name|bitmap_set_t
operator|)
name|pool_alloc
argument_list|(
name|bitmap_set_pool
argument_list|)
decl_stmt|;
name|ret
operator|->
name|expressions
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|ret
operator|->
name|values
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a new set.  */
end_comment

begin_function
specifier|static
name|value_set_t
name|set_new
parameter_list|(
name|bool
name|indexed
parameter_list|)
block|{
name|value_set_t
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|value_set_t
operator|)
name|pool_alloc
argument_list|(
name|value_set_pool
argument_list|)
expr_stmt|;
name|ret
operator|->
name|head
operator|=
name|ret
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|indexed
operator|=
name|indexed
expr_stmt|;
name|ret
operator|->
name|values
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Insert an expression EXPR into a bitmapped set.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_insert_into_set
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
comment|/* XXX: For now, we only let SSA_NAMES into the bitmap sets.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|val
operator|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|set
operator|->
name|values
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|set
operator|->
name|expressions
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert EXPR into SET.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_set
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|value_set_node_t
name|newnode
init|=
operator|(
name|value_set_node_t
operator|)
name|pool_alloc
argument_list|(
name|value_set_node_pool
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return;
comment|/* For indexed sets, insert the value into the set value bitmap.      For all sets, add it to the linked list and increment the list      length.  */
if|if
condition|(
name|set
operator|->
name|indexed
condition|)
name|value_insert_into_set_bitmap
argument_list|(
name|set
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|newnode
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newnode
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|set
operator|->
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|head
operator|==
name|NULL
condition|)
block|{
name|set
operator|->
name|head
operator|=
name|set
operator|->
name|tail
operator|=
name|newnode
expr_stmt|;
block|}
else|else
block|{
name|set
operator|->
name|tail
operator|->
name|next
operator|=
name|newnode
expr_stmt|;
name|set
operator|->
name|tail
operator|=
name|newnode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy a bitmapped set ORIG, into bitmapped set DEST.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_set_copy
parameter_list|(
name|bitmap_set_t
name|dest
parameter_list|,
name|bitmap_set_t
name|orig
parameter_list|)
block|{
name|bitmap_copy
argument_list|(
name|dest
operator|->
name|expressions
argument_list|,
name|orig
operator|->
name|expressions
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|dest
operator|->
name|values
argument_list|,
name|orig
operator|->
name|values
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform bitmapped set operation DEST&= ORIG.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_set_and
parameter_list|(
name|bitmap_set_t
name|dest
parameter_list|,
name|bitmap_set_t
name|orig
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap
name|temp
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
decl_stmt|;
name|bitmap_and_into
argument_list|(
name|dest
operator|->
name|values
argument_list|,
name|orig
operator|->
name|values
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|temp
argument_list|,
name|dest
operator|->
name|expressions
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|temp
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|dest
operator|->
name|values
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|bitmap_clear_bit
argument_list|(
name|dest
operator|->
name|expressions
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform bitmapped value set operation DEST = DEST& ~ORIG.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_set_and_compl
parameter_list|(
name|bitmap_set_t
name|dest
parameter_list|,
name|bitmap_set_t
name|orig
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap
name|temp
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
decl_stmt|;
name|bitmap_and_compl_into
argument_list|(
name|dest
operator|->
name|values
argument_list|,
name|orig
operator|->
name|values
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|temp
argument_list|,
name|dest
operator|->
name|expressions
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|temp
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|dest
operator|->
name|values
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|bitmap_clear_bit
argument_list|(
name|dest
operator|->
name|expressions
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the bitmap set SET is empty.  */
end_comment

begin_function
specifier|static
name|bool
name|bitmap_set_empty_p
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|)
block|{
return|return
name|bitmap_empty_p
argument_list|(
name|set
operator|->
name|values
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the set ORIG to the set DEST.  */
end_comment

begin_function
specifier|static
name|void
name|set_copy
parameter_list|(
name|value_set_t
name|dest
parameter_list|,
name|value_set_t
name|orig
parameter_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|orig
operator|||
operator|!
name|orig
operator|->
name|head
condition|)
return|return;
for|for
control|(
name|node
operator|=
name|orig
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|insert_into_set
argument_list|(
name|dest
argument_list|,
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove EXPR from SET.  */
end_comment

begin_function
specifier|static
name|void
name|set_remove
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|,
name|prev
decl_stmt|;
comment|/* Remove the value of EXPR from the bitmap, decrement the set      length, and remove it from the actual double linked list.  */
name|value_remove_from_set_bitmap
argument_list|(
name|set
argument_list|,
name|get_value_handle
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|->
name|length
operator|--
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|node
operator|=
name|set
operator|->
name|head
init|;
name|node
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|node
operator|,
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|node
operator|->
name|expr
operator|==
name|expr
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|set
operator|->
name|head
operator|=
name|node
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|set
operator|->
name|tail
condition|)
name|set
operator|->
name|tail
operator|=
name|prev
expr_stmt|;
name|pool_free
argument_list|(
name|value_set_node_pool
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if SET contains the value VAL.  */
end_comment

begin_function
specifier|static
name|bool
name|set_contains_value
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
comment|/* All constants are in every set.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|set
operator|||
name|set
operator|->
name|length
operator|==
literal|0
condition|)
return|return
name|false
return|;
return|return
name|value_exists_in_set_bitmap
argument_list|(
name|set
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if bitmapped set SET contains the expression EXPR.  */
end_comment

begin_function
specifier|static
name|bool
name|bitmap_set_contains
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
comment|/* All constants are in every set.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|get_value_handle
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* XXX: Bitmapped sets only contain SSA_NAME's for now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
return|return
name|bitmap_bit_p
argument_list|(
name|set
operator|->
name|expressions
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if bitmapped set SET contains the value VAL.  */
end_comment

begin_function
specifier|static
name|bool
name|bitmap_set_contains_value
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|bitmap_bit_p
argument_list|(
name|set
operator|->
name|values
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Replace an instance of value LOOKFOR with expression EXPR in SET.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_set_replace_value
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|,
name|tree
name|lookfor
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|value_set_t
name|exprset
decl_stmt|;
name|value_set_node_t
name|node
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|lookfor
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|bitmap_set_contains_value
argument_list|(
name|set
argument_list|,
name|lookfor
argument_list|)
condition|)
return|return;
comment|/* The number of expressions having a given value is usually      significantly less than the total number of expressions in SET.      Thus, rather than check, for each expression in SET, whether it      has the value LOOKFOR, we walk the reverse mapping that tells us      what expressions have a given value, and see if any of those      expressions are in our set.  For large testcases, this is about      5-10x faster than walking the bitmap.  If this is somehow a      significant lose for some cases, we can choose which set to walk      based on the set size.  */
name|exprset
operator|=
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|lookfor
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|exprset
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
operator|->
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|set
operator|->
name|expressions
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|node
operator|->
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|set
operator|->
name|expressions
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|node
operator|->
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|set
operator|->
name|expressions
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subtract bitmapped set B from value set A, and return the new set.  */
end_comment

begin_function
specifier|static
name|value_set_t
name|bitmap_set_subtract_from_value_set
parameter_list|(
name|value_set_t
name|a
parameter_list|,
name|bitmap_set_t
name|b
parameter_list|,
name|bool
name|indexed
parameter_list|)
block|{
name|value_set_t
name|ret
init|=
name|set_new
argument_list|(
name|indexed
argument_list|)
decl_stmt|;
name|value_set_node_t
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|a
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bitmap_set_contains
argument_list|(
name|b
argument_list|,
name|node
operator|->
name|expr
argument_list|)
condition|)
name|insert_into_set
argument_list|(
name|ret
argument_list|,
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return true if two sets are equal.  */
end_comment

begin_function
specifier|static
name|bool
name|set_equal
parameter_list|(
name|value_set_t
name|a
parameter_list|,
name|value_set_t
name|b
parameter_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|length
operator|!=
name|b
operator|->
name|length
condition|)
return|return
name|false
return|;
for|for
control|(
name|node
operator|=
name|a
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|set_contains_value
argument_list|(
name|b
argument_list|,
name|get_value_handle
argument_list|(
name|node
operator|->
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Replace an instance of EXPR's VALUE with EXPR in SET if it exists,    and add it otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_value_replace_in_set
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitmap_set_contains_value
argument_list|(
name|set
argument_list|,
name|val
argument_list|)
condition|)
name|bitmap_set_replace_value
argument_list|(
name|set
argument_list|,
name|val
argument_list|,
name|expr
argument_list|)
expr_stmt|;
else|else
name|bitmap_insert_into_set
argument_list|(
name|set
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert EXPR into SET if EXPR's value is not already present in    SET.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_value_insert_into_set
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|bitmap_set_contains_value
argument_list|(
name|set
argument_list|,
name|val
argument_list|)
condition|)
name|bitmap_insert_into_set
argument_list|(
name|set
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the value for EXPR into SET, if it doesn't exist already.  */
end_comment

begin_function
specifier|static
name|void
name|value_insert_into_set
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* Constant and invariant values exist everywhere, and thus,      actually keeping them in the sets is pointless.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|val
argument_list|)
condition|)
name|insert_into_set
argument_list|(
name|set
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out SET to OUTFILE.  */
end_comment

begin_function
specifier|static
name|void
name|bitmap_print_value_set
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|bitmap_set_t
name|set
parameter_list|,
specifier|const
name|char
modifier|*
name|setname
parameter_list|,
name|int
name|blockindex
parameter_list|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s[%d] := { "
argument_list|,
name|setname
argument_list|,
name|blockindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|bool
name|first
init|=
name|true
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|set->expressions
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|print_generic_expr
argument_list|(
name|outfile
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|outfile
argument_list|,
name|get_value_handle
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the value_set SET to OUTFILE.  */
end_comment

begin_function
specifier|static
name|void
name|print_value_set
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|value_set_t
name|set
parameter_list|,
specifier|const
name|char
modifier|*
name|setname
parameter_list|,
name|int
name|blockindex
parameter_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s[%d] := { "
argument_list|,
name|setname
argument_list|,
name|blockindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
for|for
control|(
name|node
operator|=
name|set
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|print_generic_expr
argument_list|(
name|outfile
argument_list|,
name|node
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|outfile
argument_list|,
name|get_value_handle
argument_list|(
name|node
operator|->
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the expressions that have VAL to OUTFILE.  */
end_comment

begin_function
name|void
name|print_value_expressions
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
if|if
condition|(
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|char
name|s
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"VH.%04d"
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|print_value_set
argument_list|(
name|outfile
argument_list|,
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|val
argument_list|)
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|debug_value_expressions
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
name|print_value_expressions
argument_list|(
name|stderr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|debug_value_set
parameter_list|(
name|value_set_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|debug_value_set
parameter_list|(
name|value_set_t
name|set
parameter_list|,
specifier|const
name|char
modifier|*
name|setname
parameter_list|,
name|int
name|blockindex
parameter_list|)
block|{
name|print_value_set
argument_list|(
name|stderr
argument_list|,
name|set
argument_list|,
name|setname
argument_list|,
name|blockindex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the folded version of T if T, when folded, is a gimple    min_invariant.  Otherwise, return T.  */
end_comment

begin_function
specifier|static
name|tree
name|fully_constant_expression
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|folded
argument_list|)
condition|)
return|return
name|folded
return|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.    For example, this can copy a list made of TREE_LIST nodes.    Allocates the nodes in list_node_pool*/
end_comment

begin_function
specifier|static
name|tree
name|pool_copy_list
parameter_list|(
name|tree
name|list
parameter_list|)
block|{
name|tree
name|head
decl_stmt|;
name|tree
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|head
operator|=
operator|(
name|tree
operator|)
name|pool_alloc
argument_list|(
name|list_node_pool
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|head
argument_list|,
name|list
argument_list|,
name|tree_size
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|head
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|pool_alloc
argument_list|(
name|list_node_pool
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
argument_list|,
name|next
argument_list|,
name|tree_size
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* Translate the vuses in the VUSES vector backwards through phi    nodes, so that they have the value they would have in BLOCK. */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|translate_vuses_through_block
argument_list|(
argument|VEC (tree, gc) *vuses
argument_list|,
argument|basic_block block
argument_list|)
block|{
name|tree
name|oldvuse
block|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|result
operator|=
name|NULL
block|;
name|int
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|,
name|i
argument_list|,
name|oldvuse
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|phi
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|oldvuse
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|edge
name|e
init|=
name|find_edge
argument_list|(
name|block
argument_list|,
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|tree
name|def
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
operator|!=
name|oldvuse
condition|)
block|{
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|VEC_copy
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|vuses
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|result
argument_list|,
name|i
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 	}     }   if
operator|(
name|result
operator|)
block|{
name|sort_vuses
argument_list|(
name|result
argument_list|)
block|;
return|return
name|result
return|;
block|}
end_expr_stmt

begin_return
return|return
name|vuses
return|;
end_return

begin_comment
unit|}
comment|/* Translate EXPR using phis in PHIBLOCK, so that it has the values of    the phis in PRED.  Return NULL if we can't find a leader for each    part of the translated expression.  */
end_comment

begin_function
unit|static
name|tree
name|phi_translate
parameter_list|(
name|tree
name|expr
parameter_list|,
name|value_set_t
name|set
parameter_list|,
name|basic_block
name|pred
parameter_list|,
name|basic_block
name|phiblock
parameter_list|)
block|{
name|tree
name|phitrans
init|=
name|NULL
decl_stmt|;
name|tree
name|oldexpr
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
comment|/* Phi translations of a given expression don't change.  */
if|if
condition|(
name|EXPR_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|vh
decl_stmt|;
name|vh
operator|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vh
operator|&&
name|TREE_CODE
argument_list|(
name|vh
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|phitrans
operator|=
name|phi_trans_lookup
argument_list|(
name|expr
argument_list|,
name|pred
argument_list|,
name|VALUE_HANDLE_VUSES
argument_list|(
name|vh
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|phitrans
operator|=
name|phi_trans_lookup
argument_list|(
name|expr
argument_list|,
name|pred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|phitrans
operator|=
name|phi_trans_lookup
argument_list|(
name|expr
argument_list|,
name|pred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phitrans
condition|)
return|return
name|phitrans
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_expression
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|tree
name|oldop0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|oldarglist
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|oldop2
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|newop0
decl_stmt|;
name|tree
name|newarglist
decl_stmt|;
name|tree
name|newop2
init|=
name|NULL
decl_stmt|;
name|tree
name|oldwalker
decl_stmt|;
name|tree
name|newwalker
decl_stmt|;
name|tree
name|newexpr
decl_stmt|;
name|tree
name|vh
init|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|bool
name|listchanged
init|=
name|false
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
operator|=
name|VALUE_HANDLE_VUSES
argument_list|(
name|vh
argument_list|)
expr_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|tvuses
expr_stmt|;
comment|/* Call expressions are kind of weird because they have an 	       argument list.  We don't want to value number the list 	       as one value number, because that doesn't make much 	       sense, and just breaks the support functions we call, 	       which expect TREE_OPERAND (call_expr, 2) to be a 	       TREE_LIST. */
name|newop0
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop0
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop0
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|oldop2
condition|)
block|{
name|newop2
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop2
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop2
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
comment|/* phi translate the argument list piece by piece.  	      We could actually build the list piece by piece here, 	      but it's likely to not be worth the memory we will save, 	      unless you have millions of call arguments.  */
name|newarglist
operator|=
name|pool_copy_list
argument_list|(
name|oldarglist
argument_list|)
expr_stmt|;
for|for
control|(
name|oldwalker
operator|=
name|oldarglist
operator|,
name|newwalker
operator|=
name|newarglist
init|;
name|oldwalker
operator|&&
name|newwalker
condition|;
name|oldwalker
operator|=
name|TREE_CHAIN
argument_list|(
name|oldwalker
argument_list|)
operator|,
name|newwalker
operator|=
name|TREE_CHAIN
argument_list|(
name|newwalker
argument_list|)
control|)
block|{
name|tree
name|oldval
init|=
name|TREE_VALUE
argument_list|(
name|oldwalker
argument_list|)
decl_stmt|;
name|tree
name|newval
decl_stmt|;
if|if
condition|(
name|oldval
condition|)
block|{
comment|/* This may seem like a weird place for this 		       check, but it's actually the easiest place to 		       do it.  We can't do it lower on in the 		       recursion because it's valid for pieces of a 		       component ref to be of AGGREGATE_TYPE, as long 		       as the outermost one is not. 		       To avoid *that* case, we have a check for 		       AGGREGATE_TYPE_P in insert_aux.  However, that 		       check will *not* catch this case because here 		       it occurs in the argument list.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldval
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|newval
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldval
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|newval
operator|!=
name|oldval
condition|)
block|{
name|listchanged
operator|=
name|true
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|newwalker
argument_list|)
operator|=
name|get_value_handle
argument_list|(
name|newval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|listchanged
condition|)
name|vn_lookup_or_add
argument_list|(
name|newarglist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tvuses
operator|=
name|translate_vuses_through_block
argument_list|(
name|vuses
argument_list|,
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|listchanged
operator|||
operator|(
name|newop0
operator|!=
name|oldop0
operator|)
operator|||
operator|(
name|oldop2
operator|!=
name|newop2
operator|)
operator|||
name|vuses
operator|!=
name|tvuses
condition|)
block|{
name|newexpr
operator|=
operator|(
name|tree
operator|)
name|pool_alloc
argument_list|(
name|expression_node_pool
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newexpr
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|0
argument_list|)
operator|=
name|newop0
operator|==
name|oldop0
condition|?
name|oldop0
else|:
name|get_value_handle
argument_list|(
name|newop0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|1
argument_list|)
operator|=
name|listchanged
condition|?
name|newarglist
else|:
name|oldarglist
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|2
argument_list|)
operator|=
name|newop2
operator|==
name|oldop2
condition|?
name|oldop2
else|:
name|get_value_handle
argument_list|(
name|newop2
argument_list|)
expr_stmt|;
name|newexpr
operator|->
name|common
operator|.
name|ann
operator|=
name|NULL
expr_stmt|;
name|vn_lookup_or_add_with_vuses
argument_list|(
name|newexpr
argument_list|,
name|tvuses
argument_list|)
expr_stmt|;
name|expr
operator|=
name|newexpr
expr_stmt|;
name|phi_trans_add
argument_list|(
name|oldexpr
argument_list|,
name|newexpr
argument_list|,
name|pred
argument_list|,
name|tvuses
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|expr
return|;
case|case
name|tcc_declaration
case|:
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|oldvuses
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|newvuses
operator|=
name|NULL
expr_stmt|;
name|oldvuses
operator|=
name|VALUE_HANDLE_VUSES
argument_list|(
name|get_value_handle
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvuses
condition|)
name|newvuses
operator|=
name|translate_vuses_through_block
argument_list|(
name|oldvuses
argument_list|,
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvuses
operator|!=
name|newvuses
condition|)
name|vn_lookup_or_add_with_vuses
argument_list|(
name|expr
argument_list|,
name|newvuses
argument_list|)
expr_stmt|;
name|phi_trans_add
argument_list|(
name|oldexpr
argument_list|,
name|expr
argument_list|,
name|pred
argument_list|,
name|newvuses
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
case|case
name|tcc_reference
case|:
block|{
name|tree
name|oldop0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|oldop1
init|=
name|NULL
decl_stmt|;
name|tree
name|newop0
decl_stmt|;
name|tree
name|newop1
init|=
name|NULL
decl_stmt|;
name|tree
name|oldop2
init|=
name|NULL
decl_stmt|;
name|tree
name|newop2
init|=
name|NULL
decl_stmt|;
name|tree
name|oldop3
init|=
name|NULL
decl_stmt|;
name|tree
name|newop3
init|=
name|NULL
decl_stmt|;
name|tree
name|newexpr
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|oldvuses
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|newvuses
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|ARRAY_REF
condition|)
return|return
name|NULL
return|;
name|newop0
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop0
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop0
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|oldop1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newop1
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop1
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop1
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|oldop2
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldop2
condition|)
block|{
name|newop2
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop2
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop2
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|oldop3
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldop3
condition|)
block|{
name|newop3
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop3
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop3
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
block|}
name|oldvuses
operator|=
name|VALUE_HANDLE_VUSES
argument_list|(
name|get_value_handle
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvuses
condition|)
name|newvuses
operator|=
name|translate_vuses_through_block
argument_list|(
name|oldvuses
argument_list|,
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop0
operator|!=
name|oldop0
operator|||
name|newvuses
operator|!=
name|oldvuses
operator|||
name|newop1
operator|!=
name|oldop1
operator|||
name|newop2
operator|!=
name|oldop2
operator|||
name|newop3
operator|!=
name|oldop3
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|newexpr
operator|=
name|pool_alloc
argument_list|(
name|reference_node_pool
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newexpr
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|0
argument_list|)
operator|=
name|get_value_handle
argument_list|(
name|newop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|1
argument_list|)
operator|=
name|get_value_handle
argument_list|(
name|newop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop2
condition|)
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|2
argument_list|)
operator|=
name|get_value_handle
argument_list|(
name|newop2
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop3
condition|)
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|3
argument_list|)
operator|=
name|get_value_handle
argument_list|(
name|newop3
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|fully_constant_expression
argument_list|(
name|newexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|newexpr
condition|)
block|{
name|pool_free
argument_list|(
name|reference_node_pool
argument_list|,
name|newexpr
argument_list|)
expr_stmt|;
name|newexpr
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|newexpr
operator|->
name|common
operator|.
name|ann
operator|=
name|NULL
expr_stmt|;
name|vn_lookup_or_add_with_vuses
argument_list|(
name|newexpr
argument_list|,
name|newvuses
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|newexpr
expr_stmt|;
name|phi_trans_add
argument_list|(
name|oldexpr
argument_list|,
name|newexpr
argument_list|,
name|pred
argument_list|,
name|newvuses
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expr
return|;
break|break;
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
block|{
name|tree
name|oldop1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|oldop2
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|newop1
decl_stmt|;
name|tree
name|newop2
decl_stmt|;
name|tree
name|newexpr
decl_stmt|;
name|newop1
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop1
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop1
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|newop2
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop2
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop2
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|newop1
operator|!=
name|oldop1
operator|||
name|newop2
operator|!=
name|oldop2
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|newexpr
operator|=
operator|(
name|tree
operator|)
name|pool_alloc
argument_list|(
name|binary_node_pool
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newexpr
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|0
argument_list|)
operator|=
name|newop1
operator|==
name|oldop1
condition|?
name|oldop1
else|:
name|get_value_handle
argument_list|(
name|newop1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|1
argument_list|)
operator|=
name|newop2
operator|==
name|oldop2
condition|?
name|oldop2
else|:
name|get_value_handle
argument_list|(
name|newop2
argument_list|)
expr_stmt|;
name|t
operator|=
name|fully_constant_expression
argument_list|(
name|newexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|newexpr
condition|)
block|{
name|pool_free
argument_list|(
name|binary_node_pool
argument_list|,
name|newexpr
argument_list|)
expr_stmt|;
name|newexpr
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|newexpr
operator|->
name|common
operator|.
name|ann
operator|=
name|NULL
expr_stmt|;
name|vn_lookup_or_add
argument_list|(
name|newexpr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|newexpr
expr_stmt|;
name|phi_trans_add
argument_list|(
name|oldexpr
argument_list|,
name|newexpr
argument_list|,
name|pred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expr
return|;
case|case
name|tcc_unary
case|:
block|{
name|tree
name|oldop1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|newop1
decl_stmt|;
name|tree
name|newexpr
decl_stmt|;
name|newop1
operator|=
name|phi_translate
argument_list|(
name|find_leader
argument_list|(
name|set
argument_list|,
name|oldop1
argument_list|)
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newop1
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|newop1
operator|!=
name|oldop1
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|newexpr
operator|=
operator|(
name|tree
operator|)
name|pool_alloc
argument_list|(
name|unary_node_pool
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newexpr
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|0
argument_list|)
operator|=
name|get_value_handle
argument_list|(
name|newop1
argument_list|)
expr_stmt|;
name|t
operator|=
name|fully_constant_expression
argument_list|(
name|newexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|newexpr
condition|)
block|{
name|pool_free
argument_list|(
name|unary_node_pool
argument_list|,
name|newexpr
argument_list|)
expr_stmt|;
name|newexpr
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|newexpr
operator|->
name|common
operator|.
name|ann
operator|=
name|NULL
expr_stmt|;
name|vn_lookup_or_add
argument_list|(
name|newexpr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|newexpr
expr_stmt|;
name|phi_trans_add
argument_list|(
name|oldexpr
argument_list|,
name|newexpr
argument_list|,
name|pred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expr
return|;
case|case
name|tcc_exceptional
case|:
block|{
name|tree
name|phi
init|=
name|NULL
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|PHI_NODE
condition|)
name|phi
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
expr_stmt|;
else|else
return|return
name|expr
return|;
name|e
operator|=
name|find_edge
argument_list|(
name|pred
argument_list|,
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|is_undefined_value
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|vn_lookup_or_add
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
return|;
block|}
block|}
return|return
name|expr
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For each expression in SET, translate the value handles through phi nodes    in PHIBLOCK using edge PHIBLOCK->PRED, and store the resulting    expressions in DEST.  */
end_comment

begin_function
specifier|static
name|void
name|phi_translate_set
parameter_list|(
name|value_set_t
name|dest
parameter_list|,
name|value_set_t
name|set
parameter_list|,
name|basic_block
name|pred
parameter_list|,
name|basic_block
name|phiblock
parameter_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|set
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|tree
name|translated
decl_stmt|;
name|translated
operator|=
name|phi_translate
argument_list|(
name|node
operator|->
name|expr
argument_list|,
name|set
argument_list|,
name|pred
argument_list|,
name|phiblock
argument_list|)
expr_stmt|;
comment|/* Don't add constants or empty translations to the cache, since 	 we won't look them up that way, or use the result, anyway.  */
if|if
condition|(
name|translated
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|translated
argument_list|)
condition|)
block|{
name|tree
name|vh
init|=
name|get_value_handle
argument_list|(
name|translated
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
expr_stmt|;
comment|/* The value handle itself may also be an invariant, in 	     which case, it has no vuses.  */
name|vuses
operator|=
operator|!
name|is_gimple_min_invariant
argument_list|(
name|vh
argument_list|)
condition|?
name|VALUE_HANDLE_VUSES
argument_list|(
name|vh
argument_list|)
else|:
name|NULL
expr_stmt|;
name|phi_trans_add
argument_list|(
name|node
operator|->
name|expr
argument_list|,
name|translated
argument_list|,
name|pred
argument_list|,
name|vuses
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|translated
operator|!=
name|NULL
condition|)
name|value_insert_into_set
argument_list|(
name|dest
argument_list|,
name|translated
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the leader for a value (i.e., the name representing that    value) in a given set, and return it.  Return NULL if no leader is    found.  */
end_comment

begin_function
specifier|static
name|tree
name|bitmap_find_leader
parameter_list|(
name|bitmap_set_t
name|set
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|bitmap_set_contains_value
argument_list|(
name|set
argument_list|,
name|val
argument_list|)
condition|)
block|{
comment|/* Rather than walk the entire bitmap of expressions, and see 	 whether any of them has the value we are looking for, we look 	 at the reverse mapping, which tells us the set of expressions 	 that have a given value (IE value->expressions with that 	 value) and see if any of those expressions are in our set. 	 The number of expressions per value is usually significantly 	 less than the number of expressions in the set.  In fact, for 	 large testcases, doing it this way is roughly 5-10x faster 	 than walking the bitmap. 	 If this is somehow a significant lose for some cases, we can 	 choose which set to walk based on which set is smaller.  */
name|value_set_t
name|exprset
decl_stmt|;
name|value_set_node_t
name|node
decl_stmt|;
name|exprset
operator|=
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|exprset
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
operator|->
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|set
operator|->
name|expressions
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|node
operator|->
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|node
operator|->
name|expr
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find the leader for a value (i.e., the name representing that    value) in a given set, and return it.  Return NULL if no leader is    found.  */
end_comment

begin_function
specifier|static
name|tree
name|find_leader
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Constants represent themselves.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|set
operator|->
name|length
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|value_exists_in_set_bitmap
argument_list|(
name|set
argument_list|,
name|val
argument_list|)
condition|)
block|{
for|for
control|(
name|node
operator|=
name|set
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|get_value_handle
argument_list|(
name|node
operator|->
name|expr
argument_list|)
operator|==
name|val
condition|)
return|return
name|node
operator|->
name|expr
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given the vuse representative map, MAP, and an SSA version number,    ID, return the bitmap of names ID represents, or NULL, if none    exists.  */
end_comment

begin_function
specifier|static
name|bitmap
name|get_representative
parameter_list|(
name|bitmap
modifier|*
name|map
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|map
index|[
name|id
index|]
operator|!=
name|NULL
condition|)
return|return
name|map
index|[
name|id
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* A vuse is anticipable at the top of block x, from the bottom of the    block, if it reaches the top of the block, and is not killed in the    block.  In effect, we are trying to see if the vuse is transparent    backwards in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|vuses_dies_in_block_x
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|,
name|basic_block
name|block
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|vuse
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|,
name|i
argument_list|,
name|vuse
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Any places where this is too conservative, are places 	 where we created a new version and shouldn't have.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|RVUSE_IN
argument_list|(
name|block
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|vuse
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|RVUSE_KILL
argument_list|(
name|block
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|vuse
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Determine if the expression EXPR is valid in SET.  This means that    we have a leader for each part of the expression (if it consists of    values), or the expression is an SSA_NAME.     NB: We never should run into a case where we have SSA_NAME +    SSA_NAME or SSA_NAME + value.  The sets valid_in_set is called on,    the ANTIC sets, will only ever have SSA_NAME's or value expressions    (IE VALUE1 + VALUE2, *VALUE1, VALUE1< VALUE2)  */
end_comment

begin_function
specifier|static
name|bool
name|valid_in_set
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|tree
name|expr
parameter_list|,
name|basic_block
name|block
parameter_list|)
block|{
name|tree
name|vh
init|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op2
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op1
argument_list|)
operator|&&
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op2
argument_list|)
return|;
block|}
case|case
name|tcc_unary
case|:
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op1
argument_list|)
return|;
block|}
case|case
name|tcc_expression
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|op2
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* Check the non-list operands first.  */
if|if
condition|(
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op0
argument_list|)
operator|||
operator|(
name|op2
operator|&&
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op2
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Now check the operands.  */
for|for
control|(
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
operator|!
name|vuses_dies_in_block_x
argument_list|(
name|VALUE_HANDLE_VUSES
argument_list|(
name|vh
argument_list|)
argument_list|,
name|block
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
case|case
name|tcc_reference
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|is_gimple_min_invariant
argument_list|(
name|op0
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VALUE_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|op2
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|op3
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|VALUE_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
operator|!
name|op2
operator|||
name|is_gimple_min_invariant
argument_list|(
name|op2
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|VALUE_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|&&
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op2
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
operator|!
name|op3
operator|||
name|is_gimple_min_invariant
argument_list|(
name|op3
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|op3
argument_list|)
operator|==
name|VALUE_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|op3
operator|&&
operator|!
name|set_contains_value
argument_list|(
name|set
argument_list|,
name|op3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|set_contains_value
argument_list|(
name|ANTIC_SAFE_LOADS
argument_list|(
name|block
argument_list|)
argument_list|,
name|vh
argument_list|)
operator|||
operator|!
name|vuses_dies_in_block_x
argument_list|(
name|VALUE_HANDLE_VUSES
argument_list|(
name|vh
argument_list|)
argument_list|,
name|block
argument_list|)
return|;
block|}
block|}
return|return
name|false
return|;
case|case
name|tcc_exceptional
case|:
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|tcc_declaration
case|:
return|return
operator|!
name|vuses_dies_in_block_x
argument_list|(
name|VALUE_HANDLE_VUSES
argument_list|(
name|vh
argument_list|)
argument_list|,
name|block
argument_list|)
return|;
default|default:
comment|/* No other cases should be encountered.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clean the set of expressions that are no longer valid in SET.  This    means expressions that are made up of values we have no leaders for    in SET.  */
end_comment

begin_function
specifier|static
name|void
name|clean
parameter_list|(
name|value_set_t
name|set
parameter_list|,
name|basic_block
name|block
parameter_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
name|value_set_node_t
name|next
decl_stmt|;
name|node
operator|=
name|set
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|valid_in_set
argument_list|(
name|set
argument_list|,
name|node
operator|->
name|expr
argument_list|,
name|block
argument_list|)
condition|)
name|set_remove
argument_list|(
name|set
argument_list|,
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|sbitmap
name|has_abnormal_preds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute the ANTIC set for BLOCK.     If succs(BLOCK)> 1 then      ANTIC_OUT[BLOCK] = intersection of ANTIC_IN[b] for all succ(BLOCK)    else if succs(BLOCK) == 1 then      ANTIC_OUT[BLOCK] = phi_translate (ANTIC_IN[succ(BLOCK)])     ANTIC_IN[BLOCK] = clean(ANTIC_OUT[BLOCK] U EXP_GEN[BLOCK] - TMP_GEN[BLOCK])     XXX: It would be nice to either write a set_clear, and use it for    ANTIC_OUT, or to mark the antic_out set as deleted at the end    of this routine, so that the pool can hand the same memory back out    again for the next ANTIC_OUT.  */
end_comment

begin_function
specifier|static
name|bool
name|compute_antic_aux
parameter_list|(
name|basic_block
name|block
parameter_list|,
name|bool
name|block_has_abnormal_pred_edge
parameter_list|)
block|{
name|basic_block
name|son
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|value_set_t
name|S
decl_stmt|,
name|old
decl_stmt|,
name|ANTIC_OUT
decl_stmt|;
name|value_set_node_t
name|node
decl_stmt|;
name|ANTIC_OUT
operator|=
name|S
operator|=
name|NULL
expr_stmt|;
comment|/* If any edges from predecessors are abnormal, antic_in is empty,      so do nothing.  */
if|if
condition|(
name|block_has_abnormal_pred_edge
condition|)
goto|goto
name|maybe_dump_sets
goto|;
name|old
operator|=
name|set_new
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|set_copy
argument_list|(
name|old
argument_list|,
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|ANTIC_OUT
operator|=
name|set_new
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* If the block has no successors, ANTIC_OUT is empty.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|block
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* If we have one successor, we could have some phi nodes to      translate through.  */
elseif|else
if|if
condition|(
name|single_succ_p
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|phi_translate_set
argument_list|(
name|ANTIC_OUT
argument_list|,
name|ANTIC_IN
argument_list|(
name|single_succ
argument_list|(
name|block
argument_list|)
argument_list|)
argument_list|,
name|block
argument_list|,
name|single_succ
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have multiple successors, we take the intersection of all of      them.  */
else|else
block|{
name|VEC
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|)
operator|*
name|worklist
expr_stmt|;
name|edge
name|e
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|basic_block
name|bprime
decl_stmt|,
name|first
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|worklist
operator|=
name|VEC_alloc
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|EDGE_COUNT
argument_list|(
name|block
operator|->
name|succs
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->succs
argument_list|)
name|VEC_quick_push
argument_list|(
name|basic_block
argument_list|,
name|worklist
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|first
operator|=
name|VEC_index
argument_list|(
name|basic_block
argument_list|,
name|worklist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_copy
argument_list|(
name|ANTIC_OUT
argument_list|,
name|ANTIC_IN
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|VEC_iterate
argument_list|(
name|basic_block
argument_list|,
name|worklist
argument_list|,
name|i
argument_list|,
name|bprime
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|ANTIC_OUT
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|tree
name|val
decl_stmt|;
name|value_set_node_t
name|next
init|=
name|node
operator|->
name|next
decl_stmt|;
name|val
operator|=
name|get_value_handle
argument_list|(
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_contains_value
argument_list|(
name|ANTIC_IN
argument_list|(
name|bprime
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
name|set_remove
argument_list|(
name|ANTIC_OUT
argument_list|,
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
block|}
name|VEC_free
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
block|}
comment|/* Generate ANTIC_OUT - TMP_GEN.  */
name|S
operator|=
name|bitmap_set_subtract_from_value_set
argument_list|(
name|ANTIC_OUT
argument_list|,
name|TMP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Start ANTIC_IN with EXP_GEN - TMP_GEN */
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
operator|=
name|bitmap_set_subtract_from_value_set
argument_list|(
name|EXP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|TMP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Then union in the ANTIC_OUT - TMP_GEN values,      to get ANTIC_OUT U EXP_GEN - TMP_GEN */
for|for
control|(
name|node
operator|=
name|S
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|value_insert_into_set
argument_list|(
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
argument_list|,
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_equal
argument_list|(
name|old
argument_list|,
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
argument_list|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
name|maybe_dump_sets
label|:
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
if|if
condition|(
name|ANTIC_OUT
condition|)
name|print_value_set
argument_list|(
name|dump_file
argument_list|,
name|ANTIC_OUT
argument_list|,
literal|"ANTIC_OUT"
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ANTIC_SAFE_LOADS
argument_list|(
name|block
argument_list|)
condition|)
name|print_value_set
argument_list|(
name|dump_file
argument_list|,
name|ANTIC_SAFE_LOADS
argument_list|(
name|block
argument_list|)
argument_list|,
literal|"ANTIC_SAFE_LOADS"
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_value_set
argument_list|(
name|dump_file
argument_list|,
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
argument_list|,
literal|"ANTIC_IN"
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|S
condition|)
name|print_value_set
argument_list|(
name|dump_file
argument_list|,
name|S
argument_list|,
literal|"S"
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|block
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
block|{
name|changed
operator||=
name|compute_antic_aux
argument_list|(
name|son
argument_list|,
name|TEST_BIT
argument_list|(
name|has_abnormal_preds
argument_list|,
name|son
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Compute ANTIC sets.  */
end_comment

begin_function
specifier|static
name|void
name|compute_antic
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|changed
init|=
name|true
decl_stmt|;
name|int
name|num_iterations
init|=
literal|0
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
comment|/* If any predecessor edges are abnormal, we punt, so antic_in is empty.      We pre-build the map of blocks with incoming abnormal edges here.  */
name|has_abnormal_preds
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|has_abnormal_preds
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|block
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|SET_BIT
argument_list|(
name|has_abnormal_preds
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* While we are here, give empty ANTIC_IN sets to each block.  */
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
operator|=
name|set_new
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* At the exit block we anticipate nothing.  */
name|ANTIC_IN
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
operator|=
name|set_new
argument_list|(
name|true
argument_list|)
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|num_iterations
operator|++
expr_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
name|changed
operator|=
name|compute_antic_aux
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|has_abnormal_preds
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"compute_antic required %d iterations\n"
argument_list|,
name|num_iterations
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the names represented by the bitmap NAMES, to the file OUT.  */
end_comment

begin_function
specifier|static
name|void
name|dump_bitmap_of_names
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|bitmap
name|names
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" { "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|print_generic_expr
argument_list|(
name|out
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a set of representative vuse versions for each phi.  This      is so we can compute conservative kill sets in terms of all vuses      that are killed, instead of continually walking chains.       We also have to be able kill all names associated with a phi when      the phi dies in order to ensure we don't generate overlapping      live ranges, which are not allowed in virtual SSA.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
modifier|*
name|vuse_names
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|compute_vuse_representatives
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|phis
operator|=
name|NULL
expr_stmt|;
name|bool
name|changed
init|=
name|true
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|phis
argument_list|,
name|phi
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|,
name|i
argument_list|,
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
decl_stmt|;
name|use_operand_p
name|usep
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
if|if
condition|(
name|vuse_names
index|[
name|ver
index|]
operator|==
name|NULL
condition|)
block|{
name|vuse_names
index|[
name|ver
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|vuse_names
index|[
name|ver
index|]
argument_list|,
name|ver
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_PHI_ARG
argument_list|(
argument|usep
argument_list|,
argument|phi
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|usep
argument_list|)
decl_stmt|;
name|bitmap
name|usebitmap
init|=
name|get_representative
argument_list|(
name|vuse_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|usebitmap
operator|!=
name|NULL
condition|)
block|{
name|changed
operator||=
name|bitmap_ior_into
argument_list|(
name|vuse_names
index|[
name|ver
index|]
argument_list|,
name|usebitmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changed
operator||=
operator|!
name|bitmap_bit_p
argument_list|(
name|vuse_names
index|[
name|ver
index|]
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
name|bitmap_set_bit
argument_list|(
name|vuse_names
index|[
name|ver
index|]
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|,
name|i
argument_list|,
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bitmap
name|reps
init|=
name|get_representative
argument_list|(
name|vuse_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reps
condition|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" represents "
argument_list|)
expr_stmt|;
name|dump_bitmap_of_names
argument_list|(
name|dump_file
argument_list|,
name|reps
argument_list|)
expr_stmt|;
block|}
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|phis
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute reaching vuses and antic safe loads.  RVUSE computation is    is a small bit of iterative dataflow to determine what virtual uses    reach what blocks.  Because we can't generate overlapping virtual    uses, and virtual uses *do* actually die, this ends up being faster    in most cases than continually walking the virtual use/def chains    to determine whether we are inside a block where a given virtual is    still available to be used.     ANTIC_SAFE_LOADS are those loads that actually occur before any kill to    their vuses in the block,and thus, are safe at the top of the    block.     An example:<block begin>    b = *a    *a = 9<block end>     b = *a is an antic safe load because it still safe to consider it    ANTIC at the top of the block.     We currently compute a conservative approximation to    ANTIC_SAFE_LOADS.  We compute those loads that occur before *any*    stores in the block.  This is not because it is difficult to    compute the precise answer, but because it is expensive.  More    testing is necessary to determine whether it is worth computing the    precise answer.  */
end_comment

begin_function
specifier|static
name|void
name|compute_rvuse_and_antic_safe
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
modifier|*
name|postorder
decl_stmt|;
name|bool
name|changed
init|=
name|true
decl_stmt|;
name|unsigned
name|int
modifier|*
name|first_store_uid
decl_stmt|;
name|first_store_uid
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|compute_vuse_representatives
argument_list|()
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|RVUSE_IN
argument_list|(
name|bb
argument_list|)
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|RVUSE_GEN
argument_list|(
name|bb
argument_list|)
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|RVUSE_KILL
argument_list|(
name|bb
argument_list|)
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|RVUSE_OUT
argument_list|(
name|bb
argument_list|)
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|ANTIC_SAFE_LOADS
argument_list|(
name|bb
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Mark live on entry */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|name
argument_list|)
operator|&&
name|IS_EMPTY_STMT
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|RVUSE_OUT
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Compute local sets for reaching vuses.      GEN(block) = generated in block and not locally killed.      KILL(block) = set of vuses killed in block.   */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|def_operand_p
name|defp
decl_stmt|;
name|use_operand_p
name|usep
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|first_store_uid
index|[
name|bb
operator|->
name|index
index|]
operator|==
literal|0
operator|&&
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMAYUSE
operator||
name|SSA_OP_VMAYDEF
operator||
name|SSA_OP_VMUSTDEF
operator||
name|SSA_OP_VMUSTKILL
argument_list|)
condition|)
block|{
name|first_store_uid
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|uid
expr_stmt|;
block|}
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|usep
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_KILLS 				    | SSA_OP_VMAYUSE
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|usep
argument_list|)
decl_stmt|;
name|bitmap
name|repbit
init|=
name|get_representative
argument_list|(
name|vuse_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|repbit
operator|!=
name|NULL
condition|)
block|{
name|bitmap_and_compl_into
argument_list|(
name|RVUSE_GEN
argument_list|(
name|bb
argument_list|)
argument_list|,
name|repbit
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|RVUSE_KILL
argument_list|(
name|bb
argument_list|)
argument_list|,
name|repbit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bitmap_set_bit
argument_list|(
name|RVUSE_KILL
argument_list|(
name|bb
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|RVUSE_GEN
argument_list|(
name|bb
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|defp
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
block|{
name|tree
name|def
init|=
name|DEF_FROM_PTR
argument_list|(
name|defp
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|RVUSE_GEN
argument_list|(
name|bb
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|def
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
comment|/* In reality, the PHI result is generated at the end of 		 each predecessor block.  This will make the value 		 LVUSE_IN for the bb containing the PHI, which is 		 correct.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|bitmap_set_bit
argument_list|(
name|RVUSE_GEN
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Solve reaching vuses.       RVUSE_IN[BB] = Union of RVUSE_OUT of predecessors.      RVUSE_OUT[BB] = RVUSE_GEN[BB] U (RVUSE_IN[BB] - RVUSE_KILL[BB])   */
name|postorder
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
name|pre_and_rev_post_order_compute
argument_list|(
name|NULL
argument_list|,
name|postorder
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|int
name|j
decl_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
condition|;
name|j
operator|++
control|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|postorder
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|bitmap_ior_into
argument_list|(
name|RVUSE_IN
argument_list|(
name|bb
argument_list|)
argument_list|,
name|RVUSE_OUT
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator||=
name|bitmap_ior_and_compl
argument_list|(
name|RVUSE_OUT
argument_list|(
name|bb
argument_list|)
argument_list|,
name|RVUSE_GEN
argument_list|(
name|bb
argument_list|)
argument_list|,
name|RVUSE_IN
argument_list|(
name|bb
argument_list|)
argument_list|,
name|RVUSE_KILL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|postorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"RVUSE_IN (%d) ="
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_bitmap_of_names
argument_list|(
name|dump_file
argument_list|,
name|RVUSE_IN
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"RVUSE_KILL (%d) ="
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_bitmap_of_names
argument_list|(
name|dump_file
argument_list|,
name|RVUSE_KILL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"RVUSE_GEN (%d) ="
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_bitmap_of_names
argument_list|(
name|dump_file
argument_list|,
name|RVUSE_GEN
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"RVUSE_OUT (%d) ="
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_bitmap_of_names
argument_list|(
name|dump_file
argument_list|,
name|RVUSE_OUT
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|RVUSE_KILL
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|node
operator|=
name|EXP_GEN
argument_list|(
name|bb
argument_list|)
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|node
operator|->
name|expr
argument_list|)
condition|)
block|{
name|tree
name|vh
init|=
name|get_value_handle
argument_list|(
name|node
operator|->
name|expr
argument_list|)
decl_stmt|;
name|tree
name|maybe
init|=
name|bitmap_find_leader
argument_list|(
name|AVAIL_OUT
argument_list|(
name|bb
argument_list|)
argument_list|,
name|vh
argument_list|)
decl_stmt|;
if|if
condition|(
name|maybe
condition|)
block|{
name|tree
name|def
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|maybe
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|def
argument_list|)
operator|!=
name|bb
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|PHI_NODE
operator|||
name|stmt_ann
argument_list|(
name|def
argument_list|)
operator|->
name|uid
operator|<
name|first_store_uid
index|[
name|bb
operator|->
name|index
index|]
condition|)
block|{
if|if
condition|(
name|ANTIC_SAFE_LOADS
argument_list|(
name|bb
argument_list|)
operator|==
name|NULL
condition|)
name|ANTIC_SAFE_LOADS
argument_list|(
name|bb
argument_list|)
operator|=
name|set_new
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|value_insert_into_set
argument_list|(
name|ANTIC_SAFE_LOADS
argument_list|(
name|bb
argument_list|)
argument_list|,
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|first_store_uid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if we can value number the call in STMT.  This is true    if we have a pure or constant call.  */
end_comment

begin_function
specifier|static
name|bool
name|can_value_number_call
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|call_expr_flags
argument_list|(
name|call
argument_list|)
operator|&
operator|(
name|ECF_PURE
operator||
name|ECF_CONST
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a tree which we can perform value numbering    on.  */
end_comment

begin_function
specifier|static
name|bool
name|can_value_number_operation
parameter_list|(
name|tree
name|op
parameter_list|)
block|{
return|return
name|UNARY_CLASS_P
argument_list|(
name|op
argument_list|)
operator|||
name|BINARY_CLASS_P
argument_list|(
name|op
argument_list|)
operator|||
name|COMPARISON_CLASS_P
argument_list|(
name|op
argument_list|)
operator|||
name|REFERENCE_CLASS_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|can_value_number_call
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a tree which we can perform PRE on    on.  This may not match the operations we can value number, but in    a perfect world would.  */
end_comment

begin_function
specifier|static
name|bool
name|can_PRE_operation
parameter_list|(
name|tree
name|op
parameter_list|)
block|{
return|return
name|UNARY_CLASS_P
argument_list|(
name|op
argument_list|)
operator|||
name|BINARY_CLASS_P
argument_list|(
name|op
argument_list|)
operator|||
name|COMPARISON_CLASS_P
argument_list|(
name|op
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ARRAY_REF
return|;
block|}
end_function

begin_comment
comment|/* Inserted expressions are placed onto this worklist, which is used    for performing quick dead code elimination of insertions we made    that didn't turn out to be necessary.   */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|inserted_exprs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pool allocated fake store expressions are placed onto this    worklist, which, after performing dead code elimination, is walked    to see which expressions need to be put into GC'able memory  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|need_creation
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* For COMPONENT_REF's and ARRAY_REF's, we can't have any intermediates for the    COMPONENT_REF or INDIRECT_REF or ARRAY_REF portion, because we'd end up with    trying to rename aggregates into ssa form directly, which is a no    no.     Thus, this routine doesn't create temporaries, it just builds a    single access expression for the array, calling    find_or_generate_expression to build the innermost pieces.     This function is a subroutine of create_expression_by_pieces, and    should not be called on it's own unless you really know what you    are doing. */
end_comment

begin_function
specifier|static
name|tree
name|create_component_ref_by_pieces
parameter_list|(
name|basic_block
name|block
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
name|stmts
parameter_list|)
block|{
name|tree
name|genop
init|=
name|expr
decl_stmt|;
name|tree
name|folded
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|genop
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
block|{
name|tree
name|found
init|=
name|bitmap_find_leader
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|found
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|genop
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|genop
operator|=
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|expr
argument_list|)
operator|->
name|head
operator|->
name|expr
expr_stmt|;
switch|switch TREE_CODE
condition|(
name|genop
condition|)
block|{
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|op0
decl_stmt|;
name|tree
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|op3
decl_stmt|;
name|op0
operator|=
name|create_component_ref_by_pieces
argument_list|(
name|block
argument_list|,
name|TREE_OPERAND
argument_list|(
name|genop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|genop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|op1
operator|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op1
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|op2
operator|=
name|TREE_OPERAND
argument_list|(
name|genop
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|&&
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|op2
operator|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op2
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|op3
operator|=
name|TREE_OPERAND
argument_list|(
name|genop
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|op3
operator|&&
name|TREE_CODE
argument_list|(
name|op3
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|op3
operator|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op3
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|folded
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|genop
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|op0
decl_stmt|;
name|tree
name|op1
decl_stmt|;
name|op0
operator|=
name|create_component_ref_by_pieces
argument_list|(
name|block
argument_list|,
name|TREE_OPERAND
argument_list|(
name|genop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|op1
operator|=
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|TREE_OPERAND
argument_list|(
name|genop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|->
name|head
operator|->
name|expr
expr_stmt|;
name|folded
operator|=
name|fold_build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|genop
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
break|break;
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|genop
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|genop1
init|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op1
argument_list|,
name|stmts
argument_list|)
decl_stmt|;
name|folded
operator|=
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|genop
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|genop
argument_list|)
argument_list|,
name|genop1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|SSA_NAME
case|:
case|case
name|STRING_CST
case|:
return|return
name|genop
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Find a leader for an expression, or generate one using    create_expression_by_pieces if it's ANTIC but    complex.    BLOCK is the basic_block we are looking for leaders in.    EXPR is the expression to find a leader or generate for.    STMTS is the statement list to put the inserted expressions on.    Returns the SSA_NAME of the LHS of the generated expression or the    leader.  */
end_comment

begin_function
specifier|static
name|tree
name|find_or_generate_expression
parameter_list|(
name|basic_block
name|block
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
name|stmts
parameter_list|)
block|{
name|tree
name|genop
init|=
name|bitmap_find_leader
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|expr
argument_list|)
decl_stmt|;
comment|/* If it's still NULL, it must be a complex expression, so generate      it recursively.  */
if|if
condition|(
name|genop
operator|==
name|NULL
condition|)
block|{
name|genop
operator|=
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|expr
argument_list|)
operator|->
name|head
operator|->
name|expr
expr_stmt|;
name|gcc_assert
argument_list|(
name|can_PRE_operation
argument_list|(
name|genop
argument_list|)
argument_list|)
expr_stmt|;
name|genop
operator|=
name|create_expression_by_pieces
argument_list|(
name|block
argument_list|,
name|genop
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
block|}
return|return
name|genop
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NECESSARY
parameter_list|(
name|stmt
parameter_list|)
value|stmt->common.asm_written_flag
end_define

begin_comment
comment|/* Create an expression in pieces, so that we can handle very complex    expressions that may be ANTIC, but not necessary GIMPLE.    BLOCK is the basic block the expression will be inserted into,    EXPR is the expression to insert (in value form)    STMTS is a statement list to append the necessary insertions into.     This function will die if we hit some value that shouldn't be    ANTIC but is (IE there is no leader for it, or its components).    This function may also generate expressions that are themselves    partially or fully redundant.  Those that are will be either made    fully redundant during the next iteration of insert (for partially    redundant ones), or eliminated by eliminate (for fully redundant    ones).  */
end_comment

begin_function
specifier|static
name|tree
name|create_expression_by_pieces
parameter_list|(
name|basic_block
name|block
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
name|stmts
parameter_list|)
block|{
name|tree
name|temp
decl_stmt|,
name|name
decl_stmt|;
name|tree
name|folded
decl_stmt|,
name|forced_stmts
decl_stmt|,
name|newexpr
decl_stmt|;
name|tree
name|v
decl_stmt|;
name|tree_stmt_iterator
name|tsi
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_expression
case|:
block|{
name|tree
name|op0
decl_stmt|,
name|op2
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|tree
name|genop0
decl_stmt|,
name|genop2
decl_stmt|;
name|tree
name|genarglist
decl_stmt|;
name|tree
name|walker
decl_stmt|,
name|genwalker
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|genop2
operator|=
name|NULL
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|genop0
operator|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op0
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|genarglist
operator|=
name|copy_list
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
for|for
control|(
name|walker
operator|=
name|arglist
operator|,
name|genwalker
operator|=
name|genarglist
init|;
name|genwalker
operator|&&
name|walker
condition|;
name|genwalker
operator|=
name|TREE_CHAIN
argument_list|(
name|genwalker
argument_list|)
operator|,
name|walker
operator|=
name|TREE_CHAIN
argument_list|(
name|walker
argument_list|)
control|)
block|{
name|TREE_VALUE
argument_list|(
name|genwalker
argument_list|)
operator|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|TREE_VALUE
argument_list|(
name|walker
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op2
condition|)
name|genop2
operator|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op2
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold_build3
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|genop0
argument_list|,
name|genarglist
argument_list|,
name|genop2
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|tcc_reference
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|folded
operator|=
name|create_component_ref_by_pieces
argument_list|(
name|block
argument_list|,
name|expr
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|genop1
init|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op1
argument_list|,
name|stmts
argument_list|)
decl_stmt|;
name|folded
operator|=
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|genop1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op2
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|genop1
init|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op1
argument_list|,
name|stmts
argument_list|)
decl_stmt|;
name|tree
name|genop2
init|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op2
argument_list|,
name|stmts
argument_list|)
decl_stmt|;
name|folded
operator|=
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|genop1
argument_list|,
name|genop2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|tcc_unary
case|:
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|genop1
init|=
name|find_or_generate_expression
argument_list|(
name|block
argument_list|,
name|op1
argument_list|,
name|stmts
argument_list|)
decl_stmt|;
name|folded
operator|=
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|genop1
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Force the generated expression to be a sequence of GIMPLE      statements.      We have to call unshare_expr because force_gimple_operand may      modify the tree we pass to it.  */
name|newexpr
operator|=
name|force_gimple_operand
argument_list|(
name|unshare_expr
argument_list|(
name|folded
argument_list|)
argument_list|,
operator|&
name|forced_stmts
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we have any intermediate expressions to the value sets, add them      to the value sets and chain them on in the instruction stream.  */
if|if
condition|(
name|forced_stmts
condition|)
block|{
name|tsi
operator|=
name|tsi_start
argument_list|(
name|forced_stmts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
name|tsi
argument_list|)
decl_stmt|;
name|tree
name|forcedname
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|forcedexpr
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|vn_lookup_or_add
argument_list|(
name|forcedexpr
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|inserted_exprs
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|vn_add
argument_list|(
name|forcedname
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bitmap_value_replace_in_set
argument_list|(
name|NEW_SETS
argument_list|(
name|block
argument_list|)
argument_list|,
name|forcedname
argument_list|)
expr_stmt|;
name|bitmap_value_replace_in_set
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|forcedname
argument_list|)
expr_stmt|;
name|mark_new_vars_to_rename
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|forced_stmts
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
comment|/* Build and insert the assignment of the end result to the temporary      that we will return.  */
if|if
condition|(
operator|!
name|pretemp
operator|||
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|pretemp
argument_list|)
condition|)
block|{
name|pretemp
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|"pretmp"
argument_list|)
expr_stmt|;
name|get_var_ann
argument_list|(
name|pretemp
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|pretemp
expr_stmt|;
name|add_referenced_var
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|newexpr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|temp
argument_list|,
name|newexpr
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|temp
argument_list|,
name|newexpr
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|newexpr
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|NECESSARY
argument_list|(
name|newexpr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|newexpr
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|inserted_exprs
argument_list|,
name|newexpr
argument_list|)
expr_stmt|;
name|mark_new_vars_to_rename
argument_list|(
name|newexpr
argument_list|)
expr_stmt|;
comment|/* Add a value handle to the temporary.      The value may already exist in either NEW_SETS, or AVAIL_OUT, because      we are creating the expression by pieces, and this particular piece of      the expression may have been represented.  There is no harm in replacing      here.  */
name|v
operator|=
name|get_value_handle
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|vn_add
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|bitmap_value_replace_in_set
argument_list|(
name|NEW_SETS
argument_list|(
name|block
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bitmap_value_replace_in_set
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pre_stats
operator|.
name|insertions
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Inserted "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|newexpr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in predecessor %d\n"
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Insert the to-be-made-available values of NODE for each    predecessor, stored in AVAIL, into the predecessors of BLOCK, and    merge the result with a phi node, given the same value handle as    NODE.  Return true if we have inserted new stuff.  */
end_comment

begin_function
specifier|static
name|bool
name|insert_into_preds_of_block
parameter_list|(
name|basic_block
name|block
parameter_list|,
name|value_set_node_t
name|node
parameter_list|,
name|tree
modifier|*
name|avail
parameter_list|)
block|{
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|node
operator|->
name|expr
argument_list|)
decl_stmt|;
name|edge
name|pred
decl_stmt|;
name|bool
name|insertions
init|=
name|false
decl_stmt|;
name|bool
name|nophi
init|=
name|false
decl_stmt|;
name|basic_block
name|bprime
decl_stmt|;
name|tree
name|eprime
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|avail
index|[
name|EDGE_PRED
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
decl_stmt|;
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found partial redundancy for expression "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|node
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we aren't creating an induction variable.  */
if|if
condition|(
name|block
operator|->
name|loop_depth
operator|>
literal|0
operator|&&
name|EDGE_COUNT
argument_list|(
name|block
operator|->
name|preds
argument_list|)
operator|==
literal|2
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
operator|->
name|expr
argument_list|)
argument_list|)
operator|!=
name|tcc_reference
condition|)
block|{
name|bool
name|firstinsideloop
init|=
name|false
decl_stmt|;
name|bool
name|secondinsideloop
init|=
name|false
decl_stmt|;
name|firstinsideloop
operator|=
name|flow_bb_inside_loop_p
argument_list|(
name|block
operator|->
name|loop_father
argument_list|,
name|EDGE_PRED
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
operator|->
name|src
argument_list|)
expr_stmt|;
name|secondinsideloop
operator|=
name|flow_bb_inside_loop_p
argument_list|(
name|block
operator|->
name|loop_father
argument_list|,
name|EDGE_PRED
argument_list|(
name|block
argument_list|,
literal|1
argument_list|)
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* Induction variables only have one edge inside the loop.  */
if|if
condition|(
name|firstinsideloop
operator|^
name|secondinsideloop
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Skipping insertion of phi for partial redundancy: Looks like an induction variable\n"
argument_list|)
expr_stmt|;
name|nophi
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Make the necessary insertions.  */
name|FOR_EACH_EDGE
argument_list|(
argument|pred
argument_list|,
argument|ei
argument_list|,
argument|block->preds
argument_list|)
block|{
name|tree
name|stmts
init|=
name|alloc_stmt_list
argument_list|()
decl_stmt|;
name|tree
name|builtexpr
decl_stmt|;
name|bprime
operator|=
name|pred
operator|->
name|src
expr_stmt|;
name|eprime
operator|=
name|avail
index|[
name|bprime
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|can_PRE_operation
argument_list|(
name|eprime
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|tree
name|vh
decl_stmt|;
comment|/* eprime may be an invariant.  */
name|vh
operator|=
name|TREE_CODE
argument_list|(
name|eprime
argument_list|)
operator|==
name|VALUE_HANDLE
condition|?
name|eprime
else|:
name|get_value_handle
argument_list|(
name|eprime
argument_list|)
expr_stmt|;
comment|/* ensure that the virtual uses we need reach our block.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vh
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|vuse
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|VALUE_HANDLE_VUSES
argument_list|(
name|vh
argument_list|)
argument_list|,
name|i
argument_list|,
name|vuse
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|id
init|=
name|SSA_NAME_VERSION
argument_list|(
name|vuse
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|bitmap_bit_p
argument_list|(
name|RVUSE_OUT
argument_list|(
name|bprime
argument_list|)
argument_list|,
name|id
argument_list|)
operator|||
name|IS_EMPTY_STMT
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|vuse
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|builtexpr
operator|=
name|create_expression_by_pieces
argument_list|(
name|bprime
argument_list|,
name|eprime
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|bsi_insert_on_edge
argument_list|(
name|pred
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|avail
index|[
name|bprime
operator|->
name|index
index|]
operator|=
name|builtexpr
expr_stmt|;
name|insertions
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If we didn't want a phi node, and we made insertions, we still have      inserted new stuff, and thus return true.  If we didn't want a phi node,      and didn't make insertions, we haven't added anything new, so return      false.  */
if|if
condition|(
name|nophi
operator|&&
name|insertions
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|nophi
operator|&&
operator|!
name|insertions
condition|)
return|return
name|false
return|;
comment|/* Now build a phi for the new variable.  */
if|if
condition|(
operator|!
name|prephitemp
operator|||
name|TREE_TYPE
argument_list|(
name|prephitemp
argument_list|)
operator|!=
name|type
condition|)
block|{
name|prephitemp
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"prephitmp"
argument_list|)
expr_stmt|;
name|get_var_ann
argument_list|(
name|prephitemp
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|prephitemp
expr_stmt|;
name|add_referenced_var
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|create_phi_node
argument_list|(
name|temp
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|NECESSARY
argument_list|(
name|temp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|inserted_exprs
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|pred
argument_list|,
argument|ei
argument_list|,
argument|block->preds
argument_list|)
name|add_phi_arg
argument_list|(
name|temp
argument_list|,
name|avail
index|[
name|pred
operator|->
name|src
operator|->
name|index
index|]
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|vn_add
argument_list|(
name|PHI_RESULT
argument_list|(
name|temp
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* The value should *not* exist in PHI_GEN, or else we wouldn't be doing      this insertion, since we test for the existence of this value in PHI_GEN      before proceeding with the partial redundancy checks in insert_aux.       The value may exist in AVAIL_OUT, in particular, it could be represented      by the expression we are trying to eliminate, in which case we want the      replacement to occur.  If it's not existing in AVAIL_OUT, we want it      inserted there.       Similarly, to the PHI_GEN case, the value should not exist in NEW_SETS of      this block, because if it did, it would have existed in our dominator's      AVAIL_OUT, and would have been skipped due to the full redundancy check.   */
name|bitmap_insert_into_set
argument_list|(
name|PHI_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|PHI_RESULT
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_value_replace_in_set
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|PHI_RESULT
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_insert_into_set
argument_list|(
name|NEW_SETS
argument_list|(
name|block
argument_list|)
argument_list|,
name|PHI_RESULT
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Created phi "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in block %d\n"
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|pre_stats
operator|.
name|phis
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Perform insertion of partially redundant values.    For BLOCK, do the following:    1.  Propagate the NEW_SETS of the dominator into the current block.    If the block has multiple predecessors,        2a. Iterate over the ANTIC expressions for the block to see if            any of them are partially redundant.        2b. If so, insert them into the necessary predecessors to make            the expression fully redundant.        2c. Insert a new PHI merging the values of the predecessors.        2d. Insert the new PHI, and the new expressions, into the            NEW_SETS set.    3. Recursively call ourselves on the dominator children of BLOCK.  */
end_comment

begin_function
specifier|static
name|bool
name|insert_aux
parameter_list|(
name|basic_block
name|block
parameter_list|)
block|{
name|basic_block
name|son
decl_stmt|;
name|bool
name|new_stuff
init|=
name|false
decl_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|basic_block
name|dom
decl_stmt|;
name|dom
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap_set_t
name|newset
init|=
name|NEW_SETS
argument_list|(
name|dom
argument_list|)
decl_stmt|;
if|if
condition|(
name|newset
condition|)
block|{
comment|/* Note that we need to value_replace both NEW_SETS, and 		 AVAIL_OUT. For both the case of NEW_SETS, the value may be 		 represented by some non-simple expression here that we want 		 to replace it with.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|newset->expressions
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap_value_replace_in_set
argument_list|(
name|NEW_SETS
argument_list|(
name|block
argument_list|)
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_value_replace_in_set
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|value_set_node_t
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|can_PRE_operation
argument_list|(
name|node
operator|->
name|expr
argument_list|)
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|avail
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|bool
name|by_some
init|=
name|false
decl_stmt|;
name|bool
name|cant_insert
init|=
name|false
decl_stmt|;
name|bool
name|all_same
init|=
name|true
decl_stmt|;
name|tree
name|first_s
init|=
name|NULL
decl_stmt|;
name|edge
name|pred
decl_stmt|;
name|basic_block
name|bprime
decl_stmt|;
name|tree
name|eprime
init|=
name|NULL_TREE
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|val
operator|=
name|get_value_handle
argument_list|(
name|node
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_set_contains_value
argument_list|(
name|PHI_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bitmap_set_contains_value
argument_list|(
name|AVAIL_OUT
argument_list|(
name|dom
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found fully redundant value\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|avail
operator|=
name|XCNEWVEC
argument_list|(
name|tree
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|pred
argument_list|,
argument|ei
argument_list|,
argument|block->preds
argument_list|)
block|{
name|tree
name|vprime
decl_stmt|;
name|tree
name|edoubleprime
decl_stmt|;
comment|/* This can happen in the very weird case 			     that our fake infinite loop edges have caused a 			     critical edge to appear.  */
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|pred
argument_list|)
condition|)
block|{
name|cant_insert
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|bprime
operator|=
name|pred
operator|->
name|src
expr_stmt|;
name|eprime
operator|=
name|phi_translate
argument_list|(
name|node
operator|->
name|expr
argument_list|,
name|ANTIC_IN
argument_list|(
name|block
argument_list|)
argument_list|,
name|bprime
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* eprime will generally only be NULL if the 			     value of the expression, translated 			     through the PHI for this predecessor, is 			     undefined.  If that is the case, we can't 			     make the expression fully redundant, 			     because its value is undefined along a 			     predecessor path.  We can thus break out 			     early because it doesn't matter what the 			     rest of the results are.  */
if|if
condition|(
name|eprime
operator|==
name|NULL
condition|)
block|{
name|cant_insert
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|eprime
operator|=
name|fully_constant_expression
argument_list|(
name|eprime
argument_list|)
expr_stmt|;
name|vprime
operator|=
name|get_value_handle
argument_list|(
name|eprime
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|vprime
argument_list|)
expr_stmt|;
name|edoubleprime
operator|=
name|bitmap_find_leader
argument_list|(
name|AVAIL_OUT
argument_list|(
name|bprime
argument_list|)
argument_list|,
name|vprime
argument_list|)
expr_stmt|;
if|if
condition|(
name|edoubleprime
operator|==
name|NULL
condition|)
block|{
name|avail
index|[
name|bprime
operator|->
name|index
index|]
operator|=
name|eprime
expr_stmt|;
name|all_same
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|avail
index|[
name|bprime
operator|->
name|index
index|]
operator|=
name|edoubleprime
expr_stmt|;
name|by_some
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|first_s
operator|==
name|NULL
condition|)
name|first_s
operator|=
name|edoubleprime
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|first_s
argument_list|,
name|edoubleprime
argument_list|,
literal|0
argument_list|)
condition|)
name|all_same
operator|=
name|false
expr_stmt|;
block|}
block|}
comment|/* If we can insert it, it's not the same value 			 already existing along every predecessor, and 			 it's defined by some predecessor, it is 			 partially redundant.  */
if|if
condition|(
operator|!
name|cant_insert
operator|&&
operator|!
name|all_same
operator|&&
name|by_some
condition|)
block|{
if|if
condition|(
name|insert_into_preds_of_block
argument_list|(
name|block
argument_list|,
name|node
argument_list|,
name|avail
argument_list|)
condition|)
name|new_stuff
operator|=
name|true
expr_stmt|;
block|}
comment|/* If all edges produce the same value and that value is 			 an invariant, then the PHI has the same value on all 			 edges.  Note this.  */
elseif|else
if|if
condition|(
operator|!
name|cant_insert
operator|&&
name|all_same
operator|&&
name|eprime
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|eprime
argument_list|)
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|value_set_t
name|exprset
init|=
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|value_set_node_t
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|exprset
operator|->
name|head
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
operator|->
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|vn_add
argument_list|(
name|node
operator|->
name|expr
argument_list|,
name|eprime
argument_list|)
expr_stmt|;
name|pre_stats
operator|.
name|constified
operator|++
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|avail
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|block
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
block|{
name|new_stuff
operator||=
name|insert_aux
argument_list|(
name|son
argument_list|)
expr_stmt|;
block|}
return|return
name|new_stuff
return|;
block|}
end_function

begin_comment
comment|/* Perform insertion of partially redundant values.  */
end_comment

begin_function
specifier|static
name|void
name|insert
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|new_stuff
init|=
name|true
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|num_iterations
init|=
literal|0
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
name|NEW_SETS
argument_list|(
name|bb
argument_list|)
operator|=
name|bitmap_set_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|new_stuff
condition|)
block|{
name|num_iterations
operator|++
expr_stmt|;
name|new_stuff
operator|=
name|false
expr_stmt|;
name|new_stuff
operator|=
name|insert_aux
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_iterations
operator|>
literal|2
operator|&&
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"insert required %d iterations\n"
argument_list|,
name|num_iterations
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if VAR is an SSA variable with no defining statement in    this procedure, *AND* isn't a live-on-entry parameter.  */
end_comment

begin_function
specifier|static
name|bool
name|is_undefined_value
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|IS_EMPTY_STMT
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
argument_list|)
comment|/* PARM_DECLs and hard registers are always defined.  */
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|PARM_DECL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an SSA variable VAR and an expression EXPR, compute the value    number for EXPR and create a value handle (VAL) for it.  If VAR and    EXPR are not the same, associate VAL with VAR.  Finally, add VAR to    S1 and its value handle to S2.     VUSES represent the virtual use operands associated with EXPR (if    any).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_to_sets
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bitmap_set_t
name|s1
parameter_list|,
name|bitmap_set_t
name|s2
parameter_list|)
block|{
name|tree
name|val
init|=
name|vn_lookup_or_add
argument_list|(
name|expr
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
comment|/* VAR and EXPR may be the same when processing statements for which      we are not computing value numbers (e.g., non-assignments, or      statements that make aliased stores).  In those cases, we are      only interested in making VAR available as its own value.  */
if|if
condition|(
name|var
operator|!=
name|expr
condition|)
name|vn_add
argument_list|(
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
condition|)
name|bitmap_insert_into_set
argument_list|(
name|s1
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bitmap_value_insert_into_set
argument_list|(
name|s2
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a unary or binary expression EXPR, create and return a new    expression with the same structure as EXPR but with its operands    replaced with the value handles of each of the operands of EXPR.     VUSES represent the virtual use operands associated with EXPR (if    any). Insert EXPR's operands into the EXP_GEN set for BLOCK. */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|create_value_expr_from
parameter_list|(
name|tree
name|expr
parameter_list|,
name|basic_block
name|block
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|vexpr
decl_stmt|;
name|alloc_pool
name|pool
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_reference
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_expression
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_exceptional
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_declaration
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
condition|)
name|pool
operator|=
name|unary_node_pool
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_reference
condition|)
name|pool
operator|=
name|reference_node_pool
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
condition|)
name|pool
operator|=
name|binary_node_pool
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|pool
operator|=
name|comparison_node_pool
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_exceptional
condition|)
block|{
name|gcc_assert
argument_list|(
name|code
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
name|pool
operator|=
name|list_node_pool
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|code
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|pool
operator|=
name|expression_node_pool
expr_stmt|;
block|}
name|vexpr
operator|=
operator|(
name|tree
operator|)
name|pool_alloc
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vexpr
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This case is only for TREE_LIST's that appear as part of      CALL_EXPR's.  Anything else is a bug, but we can't easily verify      this, hence this comment.  TREE_LIST is not handled by the      general case below is because they don't have a fixed length, or      operands, so you can't access purpose/value/chain through      TREE_OPERAND macros.  */
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|op
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|temp
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|vexpr
argument_list|)
condition|)
name|temp
operator|=
name|create_value_expr_from
argument_list|(
name|TREE_CHAIN
argument_list|(
name|vexpr
argument_list|)
argument_list|,
name|block
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|vexpr
argument_list|)
operator|=
name|temp
condition|?
name|temp
else|:
name|TREE_CHAIN
argument_list|(
name|vexpr
argument_list|)
expr_stmt|;
comment|/* Recursively value-numberize reference ops.  */
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|vexpr
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tempop
decl_stmt|;
name|op
operator|=
name|TREE_VALUE
argument_list|(
name|vexpr
argument_list|)
expr_stmt|;
name|tempop
operator|=
name|create_value_expr_from
argument_list|(
name|op
argument_list|,
name|block
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|op
operator|=
name|tempop
condition|?
name|tempop
else|:
name|op
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|vexpr
argument_list|)
operator|=
name|vn_lookup_or_add
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|TREE_VALUE
argument_list|(
name|vexpr
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|vexpr
argument_list|)
operator|=
name|vn_lookup_or_add
argument_list|(
name|TREE_VALUE
argument_list|(
name|vexpr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* This is the equivalent of inserting op into EXP_GEN like we 	 do below */
if|if
condition|(
operator|!
name|is_undefined_value
argument_list|(
name|op
argument_list|)
condition|)
name|value_insert_into_set
argument_list|(
name|EXP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|vexpr
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|val
decl_stmt|,
name|op
decl_stmt|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL_TREE
condition|)
continue|continue;
comment|/* Recursively value-numberize reference ops and tree lists.  */
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|tree
name|tempop
init|=
name|create_value_expr_from
argument_list|(
name|op
argument_list|,
name|block
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|op
operator|=
name|tempop
condition|?
name|tempop
else|:
name|op
expr_stmt|;
name|val
operator|=
name|vn_lookup_or_add
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|tempop
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|tempop
operator|=
name|create_value_expr_from
argument_list|(
name|op
argument_list|,
name|block
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|op
operator|=
name|tempop
condition|?
name|tempop
else|:
name|op
expr_stmt|;
name|vn_lookup_or_add
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Unlike everywhere else, we do *not* want to replace the 	     TREE_LIST itself with a value number, because support 	     functions we call will blow up.  */
name|val
operator|=
name|op
expr_stmt|;
block|}
else|else
comment|/* Create a value handle for OP and add it to VEXPR.  */
name|val
operator|=
name|vn_lookup_or_add
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_undefined_value
argument_list|(
name|op
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|value_insert_into_set
argument_list|(
name|EXP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|vexpr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|vexpr
argument_list|,
name|i
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
return|return
name|vexpr
return|;
block|}
end_function

begin_comment
comment|/* Insert extra phis to merge values that are fully available from    preds of BLOCK, but have no dominating representative coming from    block DOM.   */
end_comment

begin_function
specifier|static
name|void
name|insert_extra_phis
parameter_list|(
name|basic_block
name|block
parameter_list|,
name|basic_block
name|dom
parameter_list|)
block|{
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|bitmap_set_t
name|tempset
init|=
name|bitmap_set_new
argument_list|()
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->preds
argument_list|)
block|{
comment|/* We cannot handle abnormal incoming edges correctly.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
return|return;
if|if
condition|(
name|first
condition|)
block|{
name|bitmap_set_copy
argument_list|(
name|tempset
argument_list|,
name|AVAIL_OUT
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
else|else
name|bitmap_set_and
argument_list|(
name|tempset
argument_list|,
name|AVAIL_OUT
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dom
condition|)
name|bitmap_set_and_compl
argument_list|(
name|tempset
argument_list|,
name|AVAIL_OUT
argument_list|(
name|dom
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_set_empty_p
argument_list|(
name|tempset
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|tempset->expressions
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|get_value_handle
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mergephitemp
operator|||
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|mergephitemp
argument_list|)
condition|)
block|{
name|mergephitemp
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"mergephitmp"
argument_list|)
expr_stmt|;
name|get_var_ann
argument_list|(
name|mergephitemp
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|mergephitemp
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Creating phi "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" to merge available but not dominating values "
argument_list|)
expr_stmt|;
block|}
name|add_referenced_var
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|create_phi_node
argument_list|(
name|temp
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|NECESSARY
argument_list|(
name|temp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|inserted_exprs
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->preds
argument_list|)
block|{
name|tree
name|leader
init|=
name|bitmap_find_leader
argument_list|(
name|AVAIL_OUT
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|val
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|leader
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|temp
argument_list|,
name|leader
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|leader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in block %d,"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|vn_add
argument_list|(
name|PHI_RESULT
argument_list|(
name|temp
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a statement STMT and its right hand side which is a load, try    to look for the expression stored in the location for the load, and    return true if a useful equivalence was recorded for LHS.  */
end_comment

begin_function
specifier|static
name|bool
name|try_look_through_load
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|tree
name|mem_ref
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|basic_block
name|block
parameter_list|)
block|{
name|tree
name|store_stmt
init|=
name|NULL
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
name|tree
name|vuse
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vuse
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_VIRTUAL_USES
argument_list|)
block|{
name|tree
name|def_stmt
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|vuse
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|vuse
argument_list|)
expr_stmt|;
comment|/* If there is no useful statement for this VUSE, we'll not find a 	 useful expression to return either.  Likewise, if there is a 	 statement but it is not a simple assignment or it has virtual 	 uses, we can stop right here.  Note that this means we do 	 not look through PHI nodes, which is intentional.  */
if|if
condition|(
operator|!
name|def_stmt
operator|||
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
operator|||
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|def_stmt
argument_list|,
name|SSA_OP_VIRTUAL_USES
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is not the same statement as one we have looked at for 	 another VUSE of STMT already, we have two statements producing 	 something that reaches our STMT.  */
if|if
condition|(
name|store_stmt
operator|&&
name|store_stmt
operator|!=
name|def_stmt
condition|)
return|return
name|false
return|;
else|else
block|{
comment|/* Is this a store to the exact same location as the one we are 	     loading from in STMT?  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_ref
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Otherwise remember this statement and see if all other VUSEs 	     come from the same statement.  */
name|store_stmt
operator|=
name|def_stmt
expr_stmt|;
block|}
block|}
comment|/* Alright then, we have visited all VUSEs of STMT and we've determined      that all of them come from the same statement STORE_STMT.  See if there      is a useful expression we can deduce from STORE_STMT.  */
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|store_stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|rhs
argument_list|)
operator|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|rhs
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_INVARIANT
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
comment|/* Yay!  Compute a value number for the RHS of the statement and  	 add its value to the AVAIL_OUT set for the block.  Add the LHS 	 to TMP_GEN.  */
name|add_to_sets
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|store_stmt
argument_list|,
name|TMP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|is_undefined_value
argument_list|(
name|rhs
argument_list|)
condition|)
name|value_insert_into_set
argument_list|(
name|EXP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of NODE that is stored in the temporary alloc_pool's.    This is made recursively true, so that the operands are stored in    the pool as well.  */
end_comment

begin_function
specifier|static
name|tree
name|poolify_tree
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|temp
init|=
name|pool_alloc
argument_list|(
name|reference_node_pool
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
name|node
argument_list|,
name|tree_size
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|poolify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
break|break;
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|temp
init|=
name|pool_alloc
argument_list|(
name|modify_expr_node_pool
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
name|node
argument_list|,
name|tree_size
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|poolify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
operator|=
name|poolify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
break|break;
case|case
name|SSA_NAME
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|PARM_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|RESULT_DECL
case|:
return|return
name|node
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|modify_expr_template
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a MODIFY_EXPR with TYPE, and operands OP1, OP2 in the    alloc pools and return it.  */
end_comment

begin_function
specifier|static
name|tree
name|poolify_modify_expr
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|)
block|{
if|if
condition|(
name|modify_expr_template
operator|==
name|NULL
condition|)
name|modify_expr_template
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|modify_expr_template
argument_list|,
literal|0
argument_list|)
operator|=
name|op1
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|modify_expr_template
argument_list|,
literal|1
argument_list|)
operator|=
name|op2
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|modify_expr_template
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|poolify_tree
argument_list|(
name|modify_expr_template
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For each real store operation of the form    *a =<value> that we see, create a corresponding fake store of the    form storetmp_<version> = *a.     This enables AVAIL computation to mark the results of stores as    available.  Without this, you'd need to do some computation to    mark the result of stores as ANTIC and AVAIL at all the right    points.    To save memory, we keep the store    statements pool allocated until we decide whether they are    necessary or not.  */
end_comment

begin_function
specifier|static
name|void
name|insert_fake_stores
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|block
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|block
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|block
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
comment|/* We can't generate SSA names for stores that are complex 	     or aggregate.  We also want to ignore things whose 	     virtual uses occur in abnormal phis.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|def_operand_p
name|defp
decl_stmt|;
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|new
decl_stmt|;
name|bool
name|notokay
init|=
name|false
decl_stmt|;
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|defp
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
block|{
name|tree
name|defvar
init|=
name|DEF_FROM_PTR
argument_list|(
name|defp
argument_list|)
decl_stmt|;
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|defvar
argument_list|)
condition|)
block|{
name|notokay
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|notokay
condition|)
continue|continue;
if|if
condition|(
operator|!
name|storetemp
operator|||
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|storetemp
argument_list|)
condition|)
block|{
name|storetemp
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|"storetmp"
argument_list|)
expr_stmt|;
name|get_var_ann
argument_list|(
name|storetemp
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|poolify_modify_expr
argument_list|(
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|storetemp
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|make_ssa_name
argument_list|(
name|storetemp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|=
name|lhs
expr_stmt|;
name|create_ssa_artficial_load_stmt
argument_list|(
name|new
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|NECESSARY
argument_list|(
name|new
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|inserted_exprs
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|need_creation
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|new
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Turn the pool allocated fake stores that we created back into real    GC allocated ones if they turned out to be necessary to PRE some    expressions.  */
end_comment

begin_function
specifier|static
name|void
name|realify_fake_stores
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|need_creation
argument_list|,
name|i
argument_list|,
name|stmt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|newstmt
decl_stmt|;
comment|/* Mark the temp variable as referenced */
name|add_referenced_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the new statement in GC memory, fix up the 	     SSA_NAME_DEF_STMT on it, and then put it in place of 	     the old statement before the store in the IR stream 	     as a plain ssa name copy.  */
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|newstmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|newstmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|newstmt
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|newstmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
name|release_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tree-combine a value number expression *EXPR_P that does a type    conversion with the value number expression of its operand.    Returns true, if *EXPR_P simplifies to a value number or    gimple min-invariant expression different from EXPR_P and    sets *EXPR_P to the simplified expression value number.    Otherwise returns false and does not change *EXPR_P.  */
end_comment

begin_function
specifier|static
name|bool
name|try_combine_conversion
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VALUE_HANDLE
operator|&&
operator|!
name|VALUE_HANDLE_VUSES
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|t
operator|=
name|fold_unary
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|VALUE_HANDLE_EXPR_SET
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|->
name|head
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|false
return|;
comment|/* Strip useless type conversions, which is safe in the optimizers but      not generally in fold.  */
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Disallow value expressions we have no value number for already, as      we would miss a leader for it here.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VALUE_HANDLE
operator|||
name|is_gimple_min_invariant
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|t
operator|=
name|vn_lookup
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|!=
name|expr
condition|)
block|{
operator|*
name|expr_p
operator|=
name|t
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Compute the AVAIL set for all basic blocks.     This function performs value numbering of the statements in each basic    block.  The AVAIL sets are built from information we glean while doing    this value numbering, since the AVAIL sets contain only one entry per    value.     AVAIL_IN[BLOCK] = AVAIL_OUT[dom(BLOCK)].    AVAIL_OUT[BLOCK] = AVAIL_IN[BLOCK] U PHI_GEN[BLOCK] U TMP_GEN[BLOCK].  */
end_comment

begin_function
specifier|static
name|void
name|compute_avail
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|block
decl_stmt|,
name|son
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|;
name|size_t
name|sp
init|=
literal|0
decl_stmt|;
name|tree
name|param
decl_stmt|;
comment|/* For arguments with default definitions, we pretend they are      defined in the entry block.  */
for|for
control|(
name|param
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|param
condition|;
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
control|)
block|{
if|if
condition|(
name|default_def
argument_list|(
name|param
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tree
name|def
init|=
name|default_def
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|vn_lookup_or_add
argument_list|(
name|def
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_insert_into_set
argument_list|(
name|TMP_GEN
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|bitmap_value_insert_into_set
argument_list|(
name|AVAIL_OUT
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Likewise for the static chain decl. */
if|if
condition|(
name|cfun
operator|->
name|static_chain_decl
condition|)
block|{
name|param
operator|=
name|cfun
operator|->
name|static_chain_decl
expr_stmt|;
if|if
condition|(
name|default_def
argument_list|(
name|param
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tree
name|def
init|=
name|default_def
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|vn_lookup_or_add
argument_list|(
name|def
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_insert_into_set
argument_list|(
name|TMP_GEN
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|bitmap_value_insert_into_set
argument_list|(
name|AVAIL_OUT
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate the worklist.  */
name|worklist
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Seed the algorithm by putting the dominator children of the entry      block on the worklist.  */
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|worklist
index|[
name|sp
operator|++
index|]
operator|=
name|son
expr_stmt|;
comment|/* Loop until the worklist is empty.  */
while|while
condition|(
name|sp
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|phi
decl_stmt|;
name|basic_block
name|dom
decl_stmt|;
name|unsigned
name|int
name|stmt_uid
init|=
literal|1
decl_stmt|;
comment|/* Pick a block from the worklist.  */
name|block
operator|=
name|worklist
index|[
operator|--
name|sp
index|]
expr_stmt|;
comment|/* Initially, the set of available values in BLOCK is that of 	 its immediate dominator.  */
name|dom
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom
condition|)
name|bitmap_set_copy
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|AVAIL_OUT
argument_list|(
name|dom
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_fre
condition|)
name|insert_extra_phis
argument_list|(
name|block
argument_list|,
name|dom
argument_list|)
expr_stmt|;
comment|/* Generate values for PHI nodes.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|block
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
comment|/* We have no need for virtual phis, as they don't represent 	   actual computations.  */
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
name|add_to_sets
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|PHI_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now compute value numbers and populate value sets with all 	 the expressions computed in BLOCK.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|block
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ann
operator|->
name|uid
operator|=
name|stmt_uid
operator|++
expr_stmt|;
comment|/* For regular value numbering, we are only interested in 	     assignments of the form X_i = EXPR, where EXPR represents 	     an "interesting" computation, it has no volatile operands 	     and X_i doesn't flow through an abnormal edge.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|!
name|ann
operator|->
name|has_volatile_ops
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Try to look through loads.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VIRTUAL_USES
argument_list|)
operator|&&
name|try_look_through_load
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|stmt
argument_list|,
name|block
argument_list|)
condition|)
continue|continue;
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_value_number_operation
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
comment|/* For value numberable operation, create a 		     duplicate expression with the operands replaced 		     with the value handles of the original RHS.  */
name|tree
name|newt
init|=
name|create_value_expr_from
argument_list|(
name|rhs
argument_list|,
name|block
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|newt
condition|)
block|{
comment|/* If we can combine a conversion expression 			 with the expression for its operand just 			 record the value number for it.  */
if|if
condition|(
name|try_combine_conversion
argument_list|(
operator|&
name|newt
argument_list|)
condition|)
name|vn_add
argument_list|(
name|lhs
argument_list|,
name|newt
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|val
init|=
name|vn_lookup_or_add
argument_list|(
name|newt
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|vn_add
argument_list|(
name|lhs
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|value_insert_into_set
argument_list|(
name|EXP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|newt
argument_list|)
expr_stmt|;
block|}
name|bitmap_insert_into_set
argument_list|(
name|TMP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|bitmap_value_insert_into_set
argument_list|(
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|rhs
argument_list|)
operator|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|rhs
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_INVARIANT
argument_list|(
name|rhs
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
comment|/* Compute a value number for the RHS of the statement 		     and add its value to the AVAIL_OUT set for the block. 		     Add the LHS to TMP_GEN.  */
name|add_to_sets
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|stmt
argument_list|,
name|TMP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|is_undefined_value
argument_list|(
name|rhs
argument_list|)
condition|)
name|value_insert_into_set
argument_list|(
name|EXP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* For any other statement that we don't recognize, simply 	     make the names generated by the statement available in 	     AVAIL_OUT and TMP_GEN.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
name|add_to_sets
argument_list|(
name|op
argument_list|,
name|op
argument_list|,
name|NULL
argument_list|,
name|TMP_GEN
argument_list|(
name|block
argument_list|)
argument_list|,
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
name|add_to_sets
argument_list|(
name|op
argument_list|,
name|op
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AVAIL_OUT
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put the dominator children of BLOCK on the worklist of blocks 	 to compute available sets for.  */
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|block
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|worklist
index|[
name|sp
operator|++
index|]
operator|=
name|son
expr_stmt|;
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Eliminate fully redundant computations.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|b
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|b
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Lookup the RHS of the expression, see if we have an 	     available computation for it.  If so, replace the RHS with 	     the available computation.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|has_volatile_ops
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|rhs_p
init|=
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|sprime
decl_stmt|;
name|sprime
operator|=
name|bitmap_find_leader
argument_list|(
name|AVAIL_OUT
argument_list|(
name|b
argument_list|)
argument_list|,
name|vn_lookup
argument_list|(
name|lhs
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sprime
operator|&&
name|sprime
operator|!=
name|lhs
operator|&&
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|rhs_p
argument_list|)
operator|!=
name|SSA_NAME
operator|||
name|may_propagate_copy
argument_list|(
operator|*
name|rhs_p
argument_list|,
name|sprime
argument_list|)
operator|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|sprime
operator|!=
operator|*
name|rhs_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Replaced "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
operator|*
name|rhs_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" with "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|sprime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sprime
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|NECESSARY
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|sprime
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We need to make sure the new and old types actually match, 		     which may require adding a simple cast, which fold_convert 		     will do for us.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|rhs_p
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|tree_ssa_useless_type_conversion_1
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|rhs_p
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|sprime
argument_list|)
argument_list|)
condition|)
name|sprime
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|rhs_p
argument_list|)
argument_list|,
name|sprime
argument_list|)
expr_stmt|;
name|pre_stats
operator|.
name|eliminations
operator|++
expr_stmt|;
name|propagate_tree_value
argument_list|(
name|rhs_p
argument_list|,
name|sprime
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If we removed EH side effects from the statement, clean 		     its EH information.  */
if|if
condition|(
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|need_eh_cleanup
argument_list|,
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Removed EH side effects.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Borrow a bit of tree-ssa-dce.c for the moment.    XXX: In 4.1, we should be able to just run a DCE pass after PRE, though    this may be a bit faster, and we may want critical edges kept split.  */
end_comment

begin_comment
comment|/* If OP's defining statement has not already been determined to be necessary,    mark that statement necessary. Return the stmt, if it is newly    necessary.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|mark_operand_necessary
parameter_list|(
name|tree
name|op
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|gcc_assert
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL
return|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
operator|||
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|NULL
return|;
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* Because we don't follow exactly the standard PRE algorithm, and decide not    to insert PHI nodes sometimes, and because value numbering of casts isn't    perfect, we sometimes end up inserting dead code.   This simple DCE-like    pass removes any insertions we made that weren't actually used.  */
end_comment

begin_function
specifier|static
name|void
name|remove_dead_inserted_code
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|worklist
operator|=
name|NULL
expr_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|worklist
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|inserted_exprs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|inserted_exprs
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NECESSARY
argument_list|(
name|t
argument_list|)
condition|)
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
comment|/* PHI nodes are somewhat special in that each PHI alternative has 	 data and control dependencies.  All the statements feeding the 	 PHI node's arguments are always necessary. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|int
name|k
decl_stmt|;
name|VEC_reserve
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|,
name|PHI_NUM_ARGS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|t
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|t
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|arg
operator|=
name|mark_operand_necessary
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Propagate through the operands.  Examine all the USE, VUSE and 	     V_MAY_DEF operands in this statement.  Mark all the statements 	     which feed this statement's uses as necessary.  */
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|use
decl_stmt|;
comment|/* The operands of V_MAY_DEF expressions are also needed as they 	     represent potential definitions that may reach this 	     statement (V_MAY_DEF operands allow us to follow def-def 	     links).  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|t
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES
argument_list|)
block|{
name|tree
name|n
init|=
name|mark_operand_necessary
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|inserted_exprs
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|NECESSARY
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Removing unnecessary insertion:"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|remove_phi_node
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|release_defs
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize data structures used by PRE.  */
end_comment

begin_function
specifier|static
name|void
name|init_pre
parameter_list|(
name|bool
name|do_fre
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|in_fre
operator|=
name|do_fre
expr_stmt|;
name|inserted_exprs
operator|=
name|NULL
expr_stmt|;
name|need_creation
operator|=
name|NULL
expr_stmt|;
name|pretemp
operator|=
name|NULL_TREE
expr_stmt|;
name|storetemp
operator|=
name|NULL_TREE
expr_stmt|;
name|mergephitemp
operator|=
name|NULL_TREE
expr_stmt|;
name|prephitemp
operator|=
name|NULL_TREE
expr_stmt|;
name|vn_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_fre
condition|)
name|current_loops
operator|=
name|loop_optimizer_init
argument_list|(
name|LOOPS_NORMAL
argument_list|)
expr_stmt|;
name|connect_infinite_loops_to_exit
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pre_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pre_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If block 0 has more than one predecessor, it means that its PHI      nodes will have arguments coming from block -1.  This creates      problems for several places in PRE that keep local arrays indexed      by block number.  To prevent this, we split the edge coming from      ENTRY_BLOCK_PTR (FIXME, if ENTRY_BLOCK_PTR had an index number      different than -1 we wouldn't have to hack this.  tree-ssa-dce.c      needs a similar change).  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
name|split_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bb_value_sets
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|phi_translate_table
operator|=
name|htab_create
argument_list|(
literal|511
argument_list|,
name|expr_pred_trans_hash
argument_list|,
name|expr_pred_trans_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|value_set_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Value sets"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value_set
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|bitmap_set_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Bitmap sets"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bitmap_set
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|value_set_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Value set nodes"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value_set_node
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|binary_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Binary tree nodes"
argument_list|,
name|tree_code_size
argument_list|(
name|PLUS_EXPR
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|unary_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Unary tree nodes"
argument_list|,
name|tree_code_size
argument_list|(
name|NEGATE_EXPR
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|reference_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Reference tree nodes"
argument_list|,
name|tree_code_size
argument_list|(
name|ARRAY_REF
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|expression_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Expression tree nodes"
argument_list|,
name|tree_code_size
argument_list|(
name|CALL_EXPR
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|list_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"List tree nodes"
argument_list|,
name|tree_code_size
argument_list|(
name|TREE_LIST
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|comparison_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Comparison tree nodes"
argument_list|,
name|tree_code_size
argument_list|(
name|EQ_EXPR
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|modify_expr_node_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"MODIFY_EXPR nodes"
argument_list|,
name|tree_code_size
argument_list|(
name|MODIFY_EXPR
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|modify_expr_template
operator|=
name|NULL
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|EXP_GEN
argument_list|(
name|bb
argument_list|)
operator|=
name|set_new
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|PHI_GEN
argument_list|(
name|bb
argument_list|)
operator|=
name|bitmap_set_new
argument_list|()
expr_stmt|;
name|TMP_GEN
argument_list|(
name|bb
argument_list|)
operator|=
name|bitmap_set_new
argument_list|()
expr_stmt|;
name|AVAIL_OUT
argument_list|(
name|bb
argument_list|)
operator|=
name|bitmap_set_new
argument_list|()
expr_stmt|;
block|}
name|need_eh_cleanup
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate data structures used by PRE.  */
end_comment

begin_function
specifier|static
name|void
name|fini_pre
parameter_list|(
name|bool
name|do_fre
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|inserted_exprs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|need_creation
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|grand_bitmap_obstack
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|value_set_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|bitmap_set_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|value_set_node_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|binary_node_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|reference_node_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|unary_node_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|list_node_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|expression_node_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|comparison_node_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|modify_expr_node_pool
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|phi_translate_table
argument_list|)
expr_stmt|;
name|remove_fake_exit_edges
argument_list|()
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|free
argument_list|(
name|bb
operator|->
name|aux
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|vn_delete
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|need_eh_cleanup
argument_list|)
condition|)
block|{
name|tree_purge_all_dead_eh_edges
argument_list|(
name|need_eh_cleanup
argument_list|)
expr_stmt|;
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|need_eh_cleanup
argument_list|)
expr_stmt|;
comment|/* Wipe out pointers to VALUE_HANDLEs.  In the not terribly distant      future we will want them to be persistent though.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
continue|continue;
if|if
condition|(
name|SSA_NAME_VALUE
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|SSA_NAME_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_fre
operator|&&
name|current_loops
condition|)
block|{
name|loop_optimizer_finalize
argument_list|(
name|current_loops
argument_list|)
expr_stmt|;
name|current_loops
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main entry point to the SSA-PRE pass.  DO_FRE is true if the caller    only wants to do full redundancy elimination.  */
end_comment

begin_function
specifier|static
name|void
name|execute_pre
parameter_list|(
name|bool
name|do_fre
parameter_list|)
block|{
name|init_pre
argument_list|(
name|do_fre
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_fre
condition|)
name|insert_fake_stores
argument_list|()
expr_stmt|;
comment|/* Collect and value number expressions computed in each basic block.  */
name|compute_avail
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|print_value_set
argument_list|(
name|dump_file
argument_list|,
name|EXP_GEN
argument_list|(
name|bb
argument_list|)
argument_list|,
literal|"exp_gen"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bitmap_print_value_set
argument_list|(
name|dump_file
argument_list|,
name|TMP_GEN
argument_list|(
name|bb
argument_list|)
argument_list|,
literal|"tmp_gen"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bitmap_print_value_set
argument_list|(
name|dump_file
argument_list|,
name|AVAIL_OUT
argument_list|(
name|bb
argument_list|)
argument_list|,
literal|"avail_out"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Insert can get quite slow on an incredibly large number of basic      blocks due to some quadratic behavior.  Until this behavior is      fixed, don't run it when he have an incredibly large number of      bb's.  If we aren't going to run insert, there is no point in      computing ANTIC, either, even though it's plenty fast.  */
if|if
condition|(
operator|!
name|do_fre
operator|&&
name|n_basic_blocks
operator|<
literal|4000
condition|)
block|{
name|vuse_names
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|compute_rvuse_and_antic_safe
argument_list|()
expr_stmt|;
name|compute_antic
argument_list|()
expr_stmt|;
name|insert
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|vuse_names
argument_list|)
expr_stmt|;
block|}
comment|/* Remove all the redundant expressions.  */
name|eliminate
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Insertions: %d\n"
argument_list|,
name|pre_stats
operator|.
name|insertions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"New PHIs: %d\n"
argument_list|,
name|pre_stats
operator|.
name|phis
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Eliminated: %d\n"
argument_list|,
name|pre_stats
operator|.
name|eliminations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Constified: %d\n"
argument_list|,
name|pre_stats
operator|.
name|constified
argument_list|)
expr_stmt|;
block|}
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_fre
condition|)
block|{
name|remove_dead_inserted_code
argument_list|()
expr_stmt|;
name|realify_fake_stores
argument_list|()
expr_stmt|;
block|}
name|fini_pre
argument_list|(
name|do_fre
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gate and execute functions for PRE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|do_pre
parameter_list|(
name|void
parameter_list|)
block|{
name|execute_pre
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_pre
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_pre
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_pre
init|=
block|{
literal|"pre"
block|,
comment|/* name */
name|gate_pre
block|,
comment|/* gate */
name|do_pre
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_PRE
block|,
comment|/* tv_id */
name|PROP_no_crit_edges
operator||
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_update_ssa_only_virtuals
operator||
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Gate and execute functions for FRE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_fre
parameter_list|(
name|void
parameter_list|)
block|{
name|execute_pre
argument_list|(
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_fre
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_fre
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_fre
init|=
block|{
literal|"fre"
block|,
comment|/* name */
name|gate_fre
block|,
comment|/* gate */
name|execute_fre
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_FRE
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

