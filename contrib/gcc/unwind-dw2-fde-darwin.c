begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU CC is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GNU CC; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* Locate the FDE entry for a given address, using Darwin's keymgr support.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_define
define|#
directive|define
name|NO_BASE_OF_ENCODED_VALUE
end_define

begin_define
define|#
directive|define
name|DWARF2_OBJECT_END_PTR_EXTENSION
end_define

begin_include
include|#
directive|include
file|"unwind-pe.h"
end_include

begin_include
include|#
directive|include
file|"unwind-dw2-fde.h"
end_include

begin_comment
comment|/* Carefully don't include gthr.h.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|__gthread_mutex_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|__gthread_mutex_lock
parameter_list|(
name|x
parameter_list|)
value|(void)(x)
end_define

begin_define
define|#
directive|define
name|__gthread_mutex_unlock
parameter_list|(
name|x
parameter_list|)
value|(void)(x)
end_define

begin_function_decl
specifier|static
name|fde
modifier|*
name|_Unwind_Find_registered_FDE
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
name|bases
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|_Unwind_Find_FDE
value|_Unwind_Find_registered_FDE
end_define

begin_include
include|#
directive|include
file|"unwind-dw2-fde.c"
end_include

begin_undef
undef|#
directive|undef
name|_Unwind_Find_FDE
end_undef

begin_comment
comment|/* KeyMgr stuff.  */
end_comment

begin_define
define|#
directive|define
name|KEYMGR_GCC3_LIVE_IMAGE_LIST
value|301
end_define

begin_comment
comment|/* loaded images  */
end_comment

begin_define
define|#
directive|define
name|KEYMGR_GCC3_DW2_OBJ_LIST
value|302
end_define

begin_comment
comment|/* Dwarf2 object list  */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|_keymgr_get_and_lock_processwide_ptr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_keymgr_set_and_unlock_processwide_ptr
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_keymgr_unlock_processwide_ptr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|mach_header
struct_decl|;
end_struct_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getsectdatafromheader
parameter_list|(
name|struct
name|mach_header
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is referenced from KEYMGR_GCC3_DW2_OBJ_LIST.  */
end_comment

begin_struct
struct|struct
name|km_object_info
block|{
name|struct
name|object
modifier|*
name|seen_objects
decl_stmt|;
name|struct
name|object
modifier|*
name|unseen_objects
decl_stmt|;
name|unsigned
name|spare
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Node of KEYMGR_GCC3_LIVE_IMAGE_LIST.  Info about each resident image.  */
end_comment

begin_struct
struct|struct
name|live_images
block|{
name|unsigned
name|long
name|this_size
decl_stmt|;
comment|/* sizeof (live_images)  */
name|struct
name|mach_header
modifier|*
name|mh
decl_stmt|;
comment|/* the image info  */
name|unsigned
name|long
name|vm_slide
decl_stmt|;
name|void
function_decl|(
modifier|*
name|destructor
function_decl|)
parameter_list|(
name|struct
name|live_images
modifier|*
parameter_list|)
function_decl|;
comment|/* destructor for this  */
name|struct
name|live_images
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|examined_p
decl_stmt|;
name|void
modifier|*
name|fde
decl_stmt|;
name|void
modifier|*
name|object_info
decl_stmt|;
name|unsigned
name|long
name|info
index|[
literal|2
index|]
decl_stmt|;
comment|/* Future use.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Bits in the examined_p field of struct live_images.  */
end_comment

begin_enum
enum|enum
block|{
name|EXAMINED_IMAGE_MASK
init|=
literal|1
block|,
comment|/* We've seen this one.  */
name|ALLOCED_IMAGE_MASK
init|=
literal|2
block|,
comment|/* The FDE entries were allocated by 				   malloc, and must be freed.  This isn't 				   used by newer libgcc versions.  */
name|IMAGE_IS_TEXT_MASK
init|=
literal|4
block|,
comment|/* This image is in the TEXT segment.  */
name|DESTRUCTOR_MAY_BE_CALLED_LIVE
init|=
literal|8
comment|/* The destructor may be called on an 					object that's part of the live 					image list.  */
block|}
enum|;
end_enum

begin_escape
end_escape

begin_comment
comment|/* Delete any data we allocated on a live_images structure.  Either    IMAGE has already been removed from the    KEYMGR_GCC3_LIVE_IMAGE_LIST and the struct will be deleted    after we return, or that list is locked and we're being called    because this object might be about to be unloaded.  Called by    KeyMgr.  */
end_comment

begin_function
specifier|static
name|void
name|live_image_destructor
parameter_list|(
name|struct
name|live_images
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|image
operator|->
name|object_info
condition|)
block|{
comment|/* Free any sorted arrays.  */
name|__deregister_frame_info_bases
argument_list|(
name|image
operator|->
name|fde
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|image
operator|->
name|object_info
argument_list|)
expr_stmt|;
name|image
operator|->
name|object_info
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|examined_p
operator|&
name|ALLOCED_IMAGE_MASK
condition|)
name|free
argument_list|(
name|image
operator|->
name|fde
argument_list|)
expr_stmt|;
name|image
operator|->
name|fde
operator|=
name|NULL
expr_stmt|;
block|}
name|image
operator|->
name|examined_p
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|destructor
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run through the list of live images.  If we can allocate memory,    give each unseen image a new `struct object'.  Even if we can't,    check whether the PC is inside the FDE of each unseen image.  */
end_comment

begin_function
specifier|static
specifier|inline
name|fde
modifier|*
name|examine_objects
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
name|bases
parameter_list|,
name|int
name|dont_alloc
parameter_list|)
block|{
name|fde
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|struct
name|live_images
modifier|*
name|image
decl_stmt|;
name|image
operator|=
name|_keymgr_get_and_lock_processwide_ptr
argument_list|(
name|KEYMGR_GCC3_LIVE_IMAGE_LIST
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|image
operator|!=
name|NULL
condition|;
name|image
operator|=
name|image
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|image
operator|->
name|examined_p
operator|&
name|EXAMINED_IMAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|fde
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
name|fde
operator|=
name|getsectdatafromheader
argument_list|(
name|image
operator|->
name|mh
argument_list|,
literal|"__DATA"
argument_list|,
literal|"__eh_frame"
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|==
name|NULL
condition|)
block|{
name|fde
operator|=
name|getsectdatafromheader
argument_list|(
name|image
operator|->
name|mh
argument_list|,
literal|"__TEXT"
argument_list|,
literal|"__eh_frame"
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|!=
name|NULL
condition|)
name|image
operator|->
name|examined_p
operator||=
name|IMAGE_IS_TEXT_MASK
expr_stmt|;
block|}
comment|/* If .eh_frame is empty, don't register at all.  */
if|if
condition|(
name|fde
operator|!=
name|NULL
operator|&&
name|sz
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|real_fde
init|=
operator|(
name|fde
operator|+
name|image
operator|->
name|vm_slide
operator|)
decl_stmt|;
name|struct
name|object
modifier|*
name|ob
init|=
name|NULL
decl_stmt|;
name|struct
name|object
name|panicob
decl_stmt|;
if|if
condition|(
operator|!
name|dont_alloc
condition|)
name|ob
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|dont_alloc
operator||=
name|ob
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
name|dont_alloc
condition|)
name|ob
operator|=
operator|&
name|panicob
expr_stmt|;
name|ob
operator|->
name|pc_begin
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|ob
operator|->
name|tbase
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|dbase
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|u
operator|.
name|single
operator|=
operator|(
expr|struct
name|dwarf_fde
operator|*
operator|)
name|real_fde
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|ob
operator|->
name|fde_end
operator|=
name|real_fde
operator|+
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|dont_alloc
condition|)
block|{
name|ob
operator|->
name|next
operator|=
name|unseen_objects
expr_stmt|;
name|unseen_objects
operator|=
name|ob
expr_stmt|;
name|image
operator|->
name|destructor
operator|=
name|live_image_destructor
expr_stmt|;
name|image
operator|->
name|object_info
operator|=
name|ob
expr_stmt|;
name|image
operator|->
name|examined_p
operator||=
operator|(
name|EXAMINED_IMAGE_MASK
operator||
name|DESTRUCTOR_MAY_BE_CALLED_LIVE
operator|)
expr_stmt|;
block|}
name|image
operator|->
name|fde
operator|=
name|real_fde
expr_stmt|;
name|result
operator|=
name|search_object
argument_list|(
name|ob
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|int
name|encoding
decl_stmt|;
name|bases
operator|->
name|tbase
operator|=
name|ob
operator|->
name|tbase
expr_stmt|;
name|bases
operator|->
name|dbase
operator|=
name|ob
operator|->
name|dbase
expr_stmt|;
name|encoding
operator|=
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
expr_stmt|;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|mixed_encoding
condition|)
name|encoding
operator|=
name|get_fde_encoding
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base_from_object
argument_list|(
name|encoding
argument_list|,
name|ob
argument_list|)
argument_list|,
name|result
operator|->
name|pc_begin
argument_list|,
operator|(
name|_Unwind_Ptr
operator|*
operator|)
operator|&
name|bases
operator|->
name|func
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|image
operator|->
name|examined_p
operator||=
name|EXAMINED_IMAGE_MASK
expr_stmt|;
block|}
name|_keymgr_unlock_processwide_ptr
argument_list|(
name|KEYMGR_GCC3_LIVE_IMAGE_LIST
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|fde
modifier|*
name|_Unwind_Find_FDE
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
name|bases
parameter_list|)
block|{
name|struct
name|km_object_info
modifier|*
name|the_obj_info
decl_stmt|;
name|fde
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|the_obj_info
operator|=
name|_keymgr_get_and_lock_processwide_ptr
argument_list|(
name|KEYMGR_GCC3_DW2_OBJ_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_obj_info
condition|)
name|the_obj_info
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|the_obj_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_obj_info
operator|!=
name|NULL
condition|)
block|{
name|seen_objects
operator|=
name|the_obj_info
operator|->
name|seen_objects
expr_stmt|;
name|unseen_objects
operator|=
name|the_obj_info
operator|->
name|unseen_objects
expr_stmt|;
name|ret
operator|=
name|_Unwind_Find_registered_FDE
argument_list|(
name|pc
argument_list|,
name|bases
argument_list|)
expr_stmt|;
block|}
comment|/* OK, didn't find it in the list of FDEs we've seen before,      so go through and look at the new ones.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|examine_objects
argument_list|(
name|pc
argument_list|,
name|bases
argument_list|,
name|the_obj_info
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_obj_info
operator|!=
name|NULL
condition|)
block|{
name|the_obj_info
operator|->
name|seen_objects
operator|=
name|seen_objects
expr_stmt|;
name|the_obj_info
operator|->
name|unseen_objects
operator|=
name|unseen_objects
expr_stmt|;
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_GCC3_DW2_OBJ_LIST
argument_list|,
name|the_obj_info
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

end_unit

