begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Try to unroll loops, and split induction variables.    Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by James E. Wilson, Cygnus Support/UC Berkeley.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Try to unroll a loop, and split induction variables.     Loops for which the number of iterations can be calculated exactly are    handled specially.  If the number of iterations times the insn_count is    less than MAX_UNROLLED_INSNS, then the loop is unrolled completely.    Otherwise, we try to unroll the loop a number of times modulo the number    of iterations, so that only one exit test will be needed.  It is unrolled    a number of times approximately equal to MAX_UNROLLED_INSNS divided by    the insn count.     Otherwise, if the number of iterations can be calculated exactly at    run time, and the loop is always entered at the top, then we try to    precondition the loop.  That is, at run time, calculate how many times    the loop will execute, and then execute the loop body a few times so    that the remaining iterations will be some multiple of 4 (or 2 if the    loop is large).  Then fall through to a loop unrolled 4 (or 2) times,    with only one exit test needed at the end of the loop.     Otherwise, if the number of iterations can not be calculated exactly,    not even at run time, then we still unroll the loop a number of times    approximately equal to MAX_UNROLLED_INSNS divided by the insn count,    but there must be an exit test after each copy of the loop body.     For each induction variable, which is dead outside the loop (replaceable)    or for which we can easily calculate the final value, if we can easily    calculate its value at each place where it is set as a function of the    current loop unroll count and the variable's value at loop entry, then    the induction variable is split into `N' different variables, one for    each copy of the loop body.  One variable is live across the backward    branch, and the others are all calculated as a function of this variable.    This helps eliminate data dependencies, and leads to further opportunities    for cse.  */
end_comment

begin_comment
comment|/* Possible improvements follow:  */
end_comment

begin_comment
comment|/* ??? Add an extra pass somewhere to determine whether unrolling will    give any benefit.  E.g. after generating all unrolled insns, compute the    cost of all insns and compare against cost of insns in rolled loop.     - On traditional architectures, unrolling a non-constant bound loop      is a win if there is a giv whose only use is in memory addresses, the      memory addresses can be split, and hence giv increments can be      eliminated.    - It is also a win if the loop is executed many times, and preconditioning      can be performed for the loop.    Add code to check for these and similar cases.  */
end_comment

begin_comment
comment|/* ??? Improve control of which loops get unrolled.  Could use profiling    info to only unroll the most commonly executed loops.  Perhaps have    a user specifyable option to control the amount of code expansion,    or the percent of loops to consider for unrolling.  Etc.  */
end_comment

begin_comment
comment|/* ??? Look at the register copies inside the loop to see if they form a    simple permutation.  If so, iterate the permutation until it gets back to    the start state.  This is how many times we should unroll the loop, for    best results, because then all register copies can be eliminated.    For example, the lisp nreverse function should be unrolled 3 times    while (this)      {        next = this->cdr;        this->cdr = prev;        prev = this;        this = next;      }     ??? The number of times to unroll the loop may also be based on data    references in the loop.  For example, if we have a loop that references    x[i-1], x[i], and x[i+1], we should unroll it a multiple of 3 times.  */
end_comment

begin_comment
comment|/* ??? Add some simple linear equation solving capability so that we can    determine the number of loop iterations for more complex loops.    For example, consider this loop from gdb    #define SWAP_TARGET_AND_HOST(buffer,len)      {        char tmp;        char *p = (char *) buffer;        char *q = ((char *) buffer) + len - 1;        int iterations = (len + 1)>> 1;        int i;        for (p; p< q; p++, q--;) 	 { 	   tmp = *q; 	   *q = *p; 	   *p = tmp; 	 }      }    Note that:      start value = p =&buffer + current_iteration      end value   = q =&buffer + len - 1 - current_iteration    Given the loop exit test of "p< q", then there must be "q - p" iterations,    set equal to zero and solve for number of iterations:      q - p = len - 1 - 2*current_iteration = 0      current_iteration = (len - 1) / 2    Hence, there are (len - 1) / 2 (rounded up to the nearest integer)    iterations of this loop.  */
end_comment

begin_comment
comment|/* ??? Currently, no labels are marked as loop invariant when doing loop    unrolling.  This is because an insn inside the loop, that loads the address    of a label inside the loop into a register, could be moved outside the loop    by the invariant code motion pass if labels were invariant.  If the loop    is subsequently unrolled, the code will be wrong because each unrolled    body of the loop will use the same address, whereas each actually needs a    different address.  A case where this happens is when a loop containing    a switch statement is unrolled.     It would be better to let labels be considered invariant.  When we    unroll loops here, check to see if any insns using a label local to the    loop were moved before the loop.  If so, then correct the problem, by    moving the insn back into the loop, or perhaps replicate the insn before    the loop, one copy for each time the loop is unrolled.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_comment
comment|/* The prime factors looked for when trying to unroll a loop by some    number which is modulo the total number of iterations.  Just checking    for these 4 prime factors will find at least one factor for 75% of    all numbers theoretically.  Practically speaking, this will succeed    almost all of the time since loops are generally a multiple of 2    and/or 5.  */
end_comment

begin_define
define|#
directive|define
name|NUM_FACTORS
value|4
end_define

begin_struct
specifier|static
struct|struct
name|_factor
block|{
specifier|const
name|int
name|factor
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
name|factors
index|[
name|NUM_FACTORS
index|]
init|=
block|{
block|{
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|7
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Describes the different types of loop unrolling performed.  */
end_comment

begin_enum
enum|enum
name|unroll_types
block|{
name|UNROLL_COMPLETELY
block|,
name|UNROLL_MODULO
block|,
name|UNROLL_NAIVE
block|}
enum|;
end_enum

begin_comment
comment|/* This controls which loops are unrolled, and by how much we unroll    them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_UNROLLED_INSNS
end_ifndef

begin_define
define|#
directive|define
name|MAX_UNROLLED_INSNS
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by register number, if non-zero, then it contains a pointer    to a struct induction for a DEST_REG giv which has been combined with    one of more address givs.  This is needed because whenever such a DEST_REG    giv is modified, we must modify the value of all split address givs    that were combined with this DEST_REG giv.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|induction
modifier|*
modifier|*
name|addr_combined_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, if this is a splittable induction variable,    then this will hold the current value of the register, which depends on the    iteration number.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|splittable_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, if this is a splittable induction variable,    then this will hold the number of instructions in the loop that modify    the induction variable.  Used to ensure that only the last insn modifying    a split iv will update the original iv of the dest.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|splittable_regs_updates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_reg_map
name|PARAMS
argument_list|(
operator|(
expr|struct
name|inline_remap
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|calculate_giv_inc
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|initial_reg_note_copy
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|inline_remap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|final_reg_note_copy
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
expr|struct
name|inline_remap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_loop_body
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|inline_remap
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
expr|enum
name|unroll_types
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_splittable_regs
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
expr|enum
name|unroll_types
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_splittable_givs
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|,
expr|enum
name|unroll_types
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_dead_after_loop
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fold_rtx_mult_add
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verify_addresses
name|PARAMS
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|remap_split_bivs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_common_reg_term
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|subtract_reg_term
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|loop_find_equiv_value
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ujump_to_loop_cont
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Try to unroll one loop and split induction variables in the loop.     The loop is described by the arguments LOOP and INSN_COUNT.    STRENGTH_REDUCTION_P indicates whether information generated in the    strength reduction pass is available.     This function is intended to be called from within `strength_reduce'    in loop.c.  */
end_comment

begin_function
name|void
name|unroll_loop
parameter_list|(
name|loop
parameter_list|,
name|insn_count
parameter_list|,
name|strength_reduce_p
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|int
name|strength_reduce_p
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|temp
decl_stmt|;
name|int
name|unroll_number
init|=
literal|1
decl_stmt|;
name|rtx
name|copy_start
decl_stmt|,
name|copy_end
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|sequence
decl_stmt|,
name|pattern
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|max_labelno
decl_stmt|,
name|max_insnno
decl_stmt|;
name|rtx
name|insert_before
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|local_label
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|local_regno
decl_stmt|;
name|unsigned
name|int
name|max_local_regnum
decl_stmt|;
name|unsigned
name|int
name|maxregnum
decl_stmt|;
name|rtx
name|exit_label
init|=
literal|0
decl_stmt|;
name|rtx
name|start_label
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|splitting_not_safe
init|=
literal|0
decl_stmt|;
name|enum
name|unroll_types
name|unroll_type
init|=
name|UNROLL_NAIVE
decl_stmt|;
name|int
name|loop_preconditioned
init|=
literal|0
decl_stmt|;
name|rtx
name|safety_label
decl_stmt|;
comment|/* This points to the last real insn in the loop, which should be either      a JUMP_INSN (for conditional jumps) or a BARRIER (for unconditional      jumps).  */
name|rtx
name|last_loop_insn
decl_stmt|;
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|loop_end
init|=
name|loop
operator|->
name|end
decl_stmt|;
comment|/* Don't bother unrolling huge loops.  Since the minimum factor is      two, loops greater than one half of MAX_UNROLLED_INSNS will never      be unrolled.  */
if|if
condition|(
name|insn_count
operator|>
name|MAX_UNROLLED_INSNS
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: Loop too big.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* When emitting debugger info, we can't unroll loops with unequal numbers      of block_beg and block_end notes, because that would unbalance the block      structure of the function.  This can happen as a result of the      "if (foo) bar; else break;" optimization in jump.c.  */
comment|/* ??? Gcc has a general policy that -g is never supposed to change the code      that the compiler emits, so we must disable this optimization always,      even if debug info is not being output.  This is rare, so this should      not be a significant performance problem.  */
if|if
condition|(
literal|1
comment|/* write_symbols != NO_DEBUG */
condition|)
block|{
name|int
name|block_begins
init|=
literal|0
decl_stmt|;
name|int
name|block_ends
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|loop_start
init|;
name|insn
operator|!=
name|loop_end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
name|block_begins
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
name|block_ends
operator|++
expr_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
comment|/* Note, would be nice to add code to unroll EH 		     regions, but until that time, we punt (don't 		     unroll).  For the proper way of doing it, see 		     expand_inline_function.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: cannot unroll EH regions.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|block_begins
operator|!=
name|block_ends
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: Unbalanced block notes.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Determine type of unroll to perform.  Depends on the number of iterations      and the size of the loop.  */
comment|/* If there is no strength reduce info, then set      loop_info->n_iterations to zero.  This can happen if      strength_reduce can't find any bivs in the loop.  A value of zero      indicates that the number of iterations could not be calculated.  */
if|if
condition|(
operator|!
name|strength_reduce_p
condition|)
name|loop_info
operator|->
name|n_iterations
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
operator|&&
name|loop_info
operator|->
name|n_iterations
operator|>
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"Loop unrolling: "
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|loop_info
operator|->
name|n_iterations
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" iterations.\n"
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
comment|/* Find and save a pointer to the last nonnote insn in the loop.  */
name|last_loop_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Calculate how many times to unroll the loop.  Indicate whether or      not the loop is being completely unrolled.  */
if|if
condition|(
name|loop_info
operator|->
name|n_iterations
operator|==
literal|1
condition|)
block|{
comment|/* Handle the case where the loop begins with an unconditional 	 jump to the loop condition.  Make sure to delete the jump 	 insn, otherwise the loop body will never execute.  */
name|rtx
name|ujump
init|=
name|ujump_to_loop_cont
argument_list|(
name|loop
operator|->
name|start
argument_list|,
name|loop
operator|->
name|cont
argument_list|)
decl_stmt|;
if|if
condition|(
name|ujump
condition|)
name|delete_related_insns
argument_list|(
name|ujump
argument_list|)
expr_stmt|;
comment|/* If number of iterations is exactly 1, then eliminate the compare and 	 branch at the end of the loop since they will never be taken. 	 Then return, since no other action is needed here.  */
comment|/* If the last instruction is not a BARRIER or a JUMP_INSN, then 	 don't do anything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* Delete the jump insn.  This will delete the barrier also.  */
name|delete_related_insns
argument_list|(
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|delete_related_insns
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The immediately preceding insn may be a compare which must be 	     deleted.  */
if|if
condition|(
name|only_sets_cc0_p
argument_list|(
name|prev
argument_list|)
condition|)
name|delete_related_insns
argument_list|(
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Remove the loop notes since this is no longer a loop.  */
if|if
condition|(
name|loop
operator|->
name|vtop
condition|)
name|delete_related_insns
argument_list|(
name|loop
operator|->
name|vtop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|cont
condition|)
name|delete_related_insns
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_start
condition|)
name|delete_related_insns
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_end
condition|)
name|delete_related_insns
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|loop_info
operator|->
name|n_iterations
operator|>
literal|0
comment|/* Avoid overflow in the next expression.  */
operator|&&
name|loop_info
operator|->
name|n_iterations
operator|<
name|MAX_UNROLLED_INSNS
operator|&&
name|loop_info
operator|->
name|n_iterations
operator|*
name|insn_count
operator|<
name|MAX_UNROLLED_INSNS
condition|)
block|{
name|unroll_number
operator|=
name|loop_info
operator|->
name|n_iterations
expr_stmt|;
name|unroll_type
operator|=
name|UNROLL_COMPLETELY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop_info
operator|->
name|n_iterations
operator|>
literal|0
condition|)
block|{
comment|/* Try to factor the number of iterations.  Don't bother with the 	 general case, only using 2, 3, 5, and 7 will get 75% of all 	 numbers theoretically, and almost all in practice.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FACTORS
condition|;
name|i
operator|++
control|)
name|factors
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|loop_info
operator|->
name|n_iterations
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_FACTORS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
while|while
condition|(
name|temp
operator|%
name|factors
index|[
name|i
index|]
operator|.
name|factor
operator|==
literal|0
condition|)
block|{
name|factors
index|[
name|i
index|]
operator|.
name|count
operator|++
expr_stmt|;
name|temp
operator|=
name|temp
operator|/
name|factors
index|[
name|i
index|]
operator|.
name|factor
expr_stmt|;
block|}
comment|/* Start with the larger factors first so that we generally 	 get lots of unrolling.  */
name|unroll_number
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|insn_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
while|while
condition|(
name|factors
index|[
name|i
index|]
operator|.
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|temp
operator|*
name|factors
index|[
name|i
index|]
operator|.
name|factor
operator|<
name|MAX_UNROLLED_INSNS
condition|)
block|{
name|unroll_number
operator|*=
name|factors
index|[
name|i
index|]
operator|.
name|factor
expr_stmt|;
name|temp
operator|*=
name|factors
index|[
name|i
index|]
operator|.
name|factor
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* If we couldn't find any factors, then unroll as in the normal 	 case.  */
if|if
condition|(
name|unroll_number
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop unrolling: No factors found.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|unroll_type
operator|=
name|UNROLL_MODULO
expr_stmt|;
block|}
comment|/* Default case, calculate number of times to unroll loop based on its      size.  */
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_NAIVE
condition|)
block|{
if|if
condition|(
literal|8
operator|*
name|insn_count
operator|<
name|MAX_UNROLLED_INSNS
condition|)
name|unroll_number
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
literal|4
operator|*
name|insn_count
operator|<
name|MAX_UNROLLED_INSNS
condition|)
name|unroll_number
operator|=
literal|4
expr_stmt|;
else|else
name|unroll_number
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Now we know how many times to unroll the loop.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling loop %d times.\n"
argument_list|,
name|unroll_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
operator|||
name|unroll_type
operator|==
name|UNROLL_MODULO
condition|)
block|{
comment|/* Loops of these types can start with jump down to the exit condition 	 in rare circumstances.  	 Consider a pair of nested loops where the inner loop is part 	 of the exit code for the outer loop.  	 In this case jump.c will not duplicate the exit test for the outer 	 loop, so it will start with a jump to the exit code.  	 Then consider if the inner loop turns out to iterate once and 	 only once.  We will end up deleting the jumps associated with 	 the inner loop.  However, the loop notes are not removed from 	 the instruction stream.  	 And finally assume that we can compute the number of iterations 	 for the outer loop.  	 In this case unroll may want to unroll the outer loop even though 	 it starts with a jump to the outer loop's exit code.  	 We could try to optimize this case, but it hardly seems worth it. 	 Just return without unrolling the loop in such cases.  */
name|insn
operator|=
name|loop_start
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return;
block|}
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
condition|)
block|{
comment|/* Completely unrolling the loop:  Delete the compare and branch at 	 the end (the last two instructions).   This delete must done at the 	 very end of loop unrolling, to avoid problems with calls to 	 back_branch_in_range_p, which is called by find_splittable_regs. 	 All increments of splittable bivs/givs are changed to load constant 	 instructions.  */
name|copy_start
operator|=
name|loop_start
expr_stmt|;
comment|/* Set insert_before to the instruction immediately after the JUMP_INSN 	 (or BARRIER), so that any NOTEs between the JUMP_INSN and the end of 	 the loop will be correctly handled by copy_loop_body.  */
name|insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
comment|/* Set copy_end to the insn before the jump at the end of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The instruction immediately before the JUMP_INSN may be a compare 	     instruction which we do not want to copy.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|copy_end
argument_list|)
argument_list|)
condition|)
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|copy_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We currently can't unroll a loop if it doesn't end with a 	     JUMP_INSN.  There would need to be a mechanism that recognizes 	     this case, and then inserts a jump after each loop body, which 	     jumps to after the last loop body.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: loop does not end with a JUMP_INSN.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_MODULO
condition|)
block|{
comment|/* Partially unrolling the loop:  The compare and branch at the end 	 (the last two instructions) must remain.  Don't copy the compare 	 and branch instructions at the end of the loop.  Insert the unrolled 	 code immediately before the compare/branch at the end so that the 	 code will fall through to them as before.  */
name|copy_start
operator|=
name|loop_start
expr_stmt|;
comment|/* Set insert_before to the jump insn at the end of the loop. 	 Set copy_end to before the jump insn at the end of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|insert_before
operator|=
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|insert_before
operator|=
name|last_loop_insn
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The instruction immediately before the JUMP_INSN may be a compare 	     instruction which we do not want to copy or delete.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
argument_list|)
condition|)
name|insert_before
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We currently can't unroll a loop if it doesn't end with a 	     JUMP_INSN.  There would need to be a mechanism that recognizes 	     this case, and then inserts a jump after each loop body, which 	     jumps to after the last loop body.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: loop does not end with a JUMP_INSN.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Normal case: Must copy the compare and branch instructions at the 	 end of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* Loop ends with an unconditional jump and a barrier. 	     Handle this like above, don't copy jump and barrier. 	     This is not strictly necessary, but doing so prevents generating 	     unconditional jumps to an immediately following label.  	     This will be corrected below if the target of this jump is 	     not the start_label.  */
name|insert_before
operator|=
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Set insert_before to immediately after the JUMP_INSN, so that 	     NOTEs at the end of the loop will be correctly handled by 	     copy_loop_body.  */
name|insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
name|copy_end
operator|=
name|last_loop_insn
expr_stmt|;
block|}
else|else
block|{
comment|/* We currently can't unroll a loop if it doesn't end with a 	     JUMP_INSN.  There would need to be a mechanism that recognizes 	     this case, and then inserts a jump after each loop body, which 	     jumps to after the last loop body.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: loop does not end with a JUMP_INSN.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If copying exit test branches because they can not be eliminated, 	 then must convert the fall through case of the branch to a jump past 	 the end of the loop.  Create a label to emit after the loop and save 	 it for later use.  Do not use the label after the loop, if any, since 	 it might be used by insns outside the loop, or there might be insns 	 added before it later by final_[bg]iv_value which must be after 	 the real exit label.  */
name|exit_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|insn
operator|=
name|loop_start
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* The loop starts with a jump down to the exit condition test. 	     Start copying the loop after the barrier following this 	     jump insn.  */
name|copy_start
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Splitting induction variables doesn't work when the loop is 	     entered via a jump to the bottom, because then we end up doing 	     a comparison against a new register for a split variable, but 	     we did not execute the set insn for the new register because 	     it was skipped over.  */
name|splitting_not_safe
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Splitting not safe, because loop not entered at top.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|copy_start
operator|=
name|loop_start
expr_stmt|;
block|}
comment|/* This should always be the first label in the loop.  */
name|start_label
operator|=
name|NEXT_INSN
argument_list|(
name|copy_start
argument_list|)
expr_stmt|;
comment|/* There may be a line number note and/or a loop continue note here.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|start_label
argument_list|)
operator|==
name|NOTE
condition|)
name|start_label
operator|=
name|NEXT_INSN
argument_list|(
name|start_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* This can happen as a result of jump threading.  If the first insns in 	 the loop test the same condition as the loop's backward jump, or the 	 opposite condition, then the backward jump will be modified to point 	 to elsewhere, and the loop's start label is deleted.  	 This case currently can not be handled by the loop unrolling code.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: unknown insns between BEG note and loop label.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LABEL_NAME
argument_list|(
name|start_label
argument_list|)
condition|)
block|{
comment|/* The jump optimization pass must have combined the original start label 	 with a named label for a goto.  We can't unroll this case because 	 jumps which go to the named label must be handled differently than 	 jumps to the loop start, and it is impossible to differentiate them 	 in this case.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: loop start label is gone\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_NAIVE
operator|&&
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|start_label
operator|!=
name|JUMP_LABEL
argument_list|(
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* In this case, we must copy the jump and barrier, because they will 	 not be converted to jumps to an immediately following label.  */
name|insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
name|copy_end
operator|=
name|last_loop_insn
expr_stmt|;
block|}
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_NAIVE
operator|&&
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|start_label
operator|!=
name|JUMP_LABEL
argument_list|(
name|last_loop_insn
argument_list|)
condition|)
block|{
comment|/* ??? The loop ends with a conditional branch that does not branch back 	 to the loop start label.  In this case, we must emit an unconditional 	 branch to the loop exit after emitting the final branch. 	 copy_loop_body does not have support for this currently, so we 	 give up.  It doesn't seem worthwhile to unroll anyways since 	 unrolling would increase the number of branch instructions 	 executed.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: final conditional branch not to loop start\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate a translation table for the labels and insn numbers.      They will be filled in as we copy the insns in the loop.  */
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|max_insnno
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
comment|/* Various paths through the unroll code may reach the "egress" label      without initializing fields within the map structure.       To be safe, we use xcalloc to zero the memory.  */
name|map
operator|=
operator|(
expr|struct
name|inline_remap
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inline_remap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the label map.  */
if|if
condition|(
name|max_labelno
operator|>
literal|0
condition|)
block|{
name|map
operator|->
name|label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_labelno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|local_label
operator|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_labelno
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Search the loop and mark all local labels, i.e. the ones which have to      be distinct labels when copied.  For all labels which might be      non-local, set their label_map entries to point to themselves.      If they happen to be local their label_map entries will be overwritten      before the loop body is copied.  The label_map entries for local labels      will be set to a different value each time the loop body is copied.  */
for|for
control|(
name|insn
operator|=
name|copy_start
init|;
name|insn
operator|!=
name|loop_end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|local_label
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|set_label_in_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|rtx
name|label
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|label
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_label_in_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|set_label_in_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate space for the insn map.  */
name|map
operator|->
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_insnno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set this to zero, to indicate that we are doing loop unrolling,      not function inlining.  */
name|map
operator|->
name|inline_target
operator|=
literal|0
expr_stmt|;
comment|/* The register and constant maps depend on the number of registers      present, so the final maps can't be created until after      find_splittable_regs is called.  However, they are needed for      preconditioning, so we create temporary maps when preconditioning      is performed.  */
comment|/* The preconditioning code may allocate two new pseudo registers.  */
name|maxregnum
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* local_regno is only valid for regnos< max_local_regnum.  */
name|max_local_regnum
operator|=
name|maxregnum
expr_stmt|;
comment|/* Allocate and zero out the splittable_regs and addr_combined_regs      arrays.  These must be zeroed here because they will be used if      loop preconditioning is performed, and must be zero for that case.       It is safe to do this here, since the extra registers created by the      preconditioning code and find_splittable_regs will never be used      to access the splittable_regs[] and addr_combined_regs[] arrays.  */
name|splittable_regs
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|maxregnum
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|splittable_regs_updates
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|maxregnum
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|addr_combined_regs
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|maxregnum
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|local_regno
operator|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|maxregnum
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark all local registers, i.e. the ones which are referenced only      inside the loop.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|copy_end
argument_list|)
operator|<
name|max_uid_for_loop
condition|)
block|{
name|int
name|copy_start_luid
init|=
name|INSN_LUID
argument_list|(
name|copy_start
argument_list|)
decl_stmt|;
name|int
name|copy_end_luid
init|=
name|INSN_LUID
argument_list|(
name|copy_end
argument_list|)
decl_stmt|;
comment|/* If a register is used in the jump insn, we must not duplicate it 	 since it will also be used outside the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|copy_end_luid
operator|--
expr_stmt|;
comment|/* If we have a target that uses cc0, then we also must not duplicate 	 the insn that sets cc0 before the jump insn, if one is present.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|copy_end
argument_list|)
argument_list|)
condition|)
name|copy_end_luid
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* If copy_start points to the NOTE that starts the loop, then we must 	 use the next luid, because invariant pseudo-regs moved out of the loop 	 have their lifetimes modified to start here, but they are not safe 	 to duplicate.  */
if|if
condition|(
name|copy_start
operator|==
name|loop_start
condition|)
name|copy_start_luid
operator|++
expr_stmt|;
comment|/* If a pseudo's lifetime is entirely contained within this loop, then we 	 can use a different pseudo in each unrolled copy of the loop.  This 	 results in better code.  */
comment|/* We must limit the generic test to max_reg_before_loop, because only 	 these pseudo registers have valid regno_first_uid info.  */
for|for
control|(
name|r
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|r
operator|<
name|max_reg_before_loop
condition|;
operator|++
name|r
control|)
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|r
argument_list|)
operator|>
literal|0
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|r
argument_list|)
operator|<=
name|max_uid_for_loop
operator|&&
name|REGNO_FIRST_LUID
argument_list|(
name|r
argument_list|)
operator|>=
name|copy_start_luid
operator|&&
name|REGNO_LAST_UID
argument_list|(
name|r
argument_list|)
operator|>
literal|0
operator|&&
name|REGNO_LAST_UID
argument_list|(
name|r
argument_list|)
operator|<=
name|max_uid_for_loop
operator|&&
name|REGNO_LAST_LUID
argument_list|(
name|r
argument_list|)
operator|<=
name|copy_end_luid
condition|)
block|{
comment|/* However, we must also check for loop-carried dependencies. 	       If the value the pseudo has at the end of iteration X is 	       used by iteration X+1, then we can not use a different pseudo 	       for each unrolled copy of the loop.  */
comment|/* A pseudo is safe if regno_first_uid is a set, and this 	       set dominates all instructions from regno_first_uid to 	       regno_last_uid.  */
comment|/* ??? This check is simplistic.  We would get better code if 	       this check was more sophisticated.  */
if|if
condition|(
name|set_dominates_use
argument_list|(
name|r
argument_list|,
name|REGNO_FIRST_UID
argument_list|(
name|r
argument_list|)
argument_list|,
name|REGNO_LAST_UID
argument_list|(
name|r
argument_list|)
argument_list|,
name|copy_start
argument_list|,
name|copy_end
argument_list|)
condition|)
name|local_regno
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|local_regno
index|[
name|r
index|]
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Marked reg %d as local\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Did not mark reg %d as local\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If this loop requires exit tests when unrolled, check to see if we      can precondition the loop so as to make the exit tests unnecessary.      Just like variable splitting, this is not safe if the loop is entered      via a jump to the bottom.  Also, can not do this if no strength      reduce info, because precondition_loop_p uses this info.  */
comment|/* Must copy the loop body for preconditioning before the following      find_splittable_regs call since that will emit insns which need to      be after the preconditioned loop copies, but immediately before the      unrolled loop copies.  */
comment|/* Also, it is not safe to split induction variables for the preconditioned      copies of the loop body.  If we split induction variables, then the code      assumes that each induction variable can be represented as a function      of its initial value and the loop iteration number.  This is not true      in this case, because the last preconditioned copy of the loop body      could be any iteration from the first up to the `unroll_number-1'th,      depending on the initial value of the iteration variable.  Therefore      we can not split induction variables here, because we can not calculate      their value.  Hence, this code must occur before find_splittable_regs      is called.  */
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_NAIVE
operator|&&
operator|!
name|splitting_not_safe
operator|&&
name|strength_reduce_p
condition|)
block|{
name|rtx
name|initial_value
decl_stmt|,
name|final_value
decl_stmt|,
name|increment
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|precondition_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|initial_value
argument_list|,
operator|&
name|final_value
argument_list|,
operator|&
name|increment
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|diff
decl_stmt|;
name|rtx
modifier|*
name|labels
decl_stmt|;
name|int
name|abs_inc
decl_stmt|,
name|neg_inc
decl_stmt|;
name|enum
name|rtx_code
name|cc
init|=
name|loop_info
operator|->
name|comparison_code
decl_stmt|;
name|int
name|less_p
init|=
operator|(
name|cc
operator|==
name|LE
operator|||
name|cc
operator|==
name|LEU
operator|||
name|cc
operator|==
name|LT
operator|||
name|cc
operator|==
name|LTU
operator|)
decl_stmt|;
name|int
name|unsigned_p
init|=
operator|(
name|cc
operator|==
name|LEU
operator|||
name|cc
operator|==
name|GEU
operator|||
name|cc
operator|==
name|LTU
operator|||
name|cc
operator|==
name|GTU
operator|)
decl_stmt|;
name|map
operator|->
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|maxregnum
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_CONST_EQUIV_INIT
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|maxregnum
argument_list|,
literal|"unroll_loop_precondition"
argument_list|)
expr_stmt|;
name|global_const_equiv_varray
operator|=
name|map
operator|->
name|const_equiv_varray
expr_stmt|;
name|init_reg_map
argument_list|(
name|map
argument_list|,
name|maxregnum
argument_list|)
expr_stmt|;
comment|/* Limit loop unrolling to 4, since this will make 7 copies of 	     the loop body.  */
if|if
condition|(
name|unroll_number
operator|>
literal|4
condition|)
name|unroll_number
operator|=
literal|4
expr_stmt|;
comment|/* Save the absolute value of the increment, and also whether or 	     not it is negative.  */
name|neg_inc
operator|=
literal|0
expr_stmt|;
name|abs_inc
operator|=
name|INTVAL
argument_list|(
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_inc
operator|<
literal|0
condition|)
block|{
name|abs_inc
operator|=
operator|-
name|abs_inc
expr_stmt|;
name|neg_inc
operator|=
literal|1
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Final value may have form of (PLUS val1 const1_rtx).  We need 	     to convert it into general operand, so compute the real value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|final_value
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|final_value
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|final_value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|final_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonmemory_operand
argument_list|(
name|final_value
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|final_value
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|final_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate the difference between the final and initial values. 	     Final value may be a (plus (reg x) (const_int 1)) rtx. 	     Let the following cse pass simplify this if initial value is 	     a constant.  	     We must copy the final and initial values here to avoid 	     improperly shared rtl.  	     We have to deal with for (i = 0; --i< 6;) type loops. 	     For such loops the real final value is the first time the 	     loop variable overflows, so the diff we calculate is the 	     distance from the overflow value.  This is 0 or ~0 for 	     unsigned loops depending on the direction, or INT_MAX, 	     INT_MAX+1 for signed loops.  We really do not need the 	     exact value, since we are only interested in the diff 	     modulo the increment, and the increment is a power of 2, 	     so we can pretend that the overflow value is 0/~0.  */
if|if
condition|(
name|cc
operator|==
name|NE
operator|||
name|less_p
operator|!=
name|neg_inc
condition|)
name|diff
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|MINUS
argument_list|,
name|final_value
argument_list|,
name|copy_rtx
argument_list|(
name|initial_value
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
else|else
name|diff
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|neg_inc
condition|?
name|NOT
else|:
name|NEG
argument_list|,
name|copy_rtx
argument_list|(
name|initial_value
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now calculate (diff % (unroll * abs (increment))) by using an 	     and instruction.  */
name|diff
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|diff
argument_list|)
argument_list|,
name|AND
argument_list|,
name|diff
argument_list|,
name|GEN_INT
argument_list|(
name|unroll_number
operator|*
name|abs_inc
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Now emit a sequence of branches to jump to the proper precond 	     loop entry point.  */
name|labels
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|unroll_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unroll_number
condition|;
name|i
operator|++
control|)
name|labels
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Check for the case where the initial value is greater than or 	     equal to the final value.  In that case, we want to execute 	     exactly one loop iteration.  The code below will fail for this 	     case.  This check does not apply if the loop has a NE 	     comparison at the end.  */
if|if
condition|(
name|cc
operator|!=
name|NE
condition|)
block|{
name|rtx
name|incremented_initval
decl_stmt|;
name|incremented_initval
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|initial_value
argument_list|,
name|increment
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|incremented_initval
argument_list|,
name|final_value
argument_list|,
name|less_p
condition|?
name|GE
else|:
name|LE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsigned_p
argument_list|,
name|labels
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|predict_insn_def
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|PRED_LOOP_CONDITION
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|=
name|labels
index|[
literal|1
index|]
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|labels
index|[
literal|1
index|]
argument_list|)
operator|++
expr_stmt|;
block|}
comment|/* Assuming the unroll_number is 4, and the increment is 2, then 	     for a negative increment:	for a positive increment: 	     diff = 0,1   precond 0	diff = 0,7   precond 0 	     diff = 2,3   precond 3     diff = 1,2   precond 1 	     diff = 4,5   precond 2     diff = 3,4   precond 2 	     diff = 6,7   precond 1     diff = 5,6   precond 3  */
comment|/* We only need to emit (unroll_number - 1) branches here, the 	     last case just falls through to the following code.  */
comment|/* ??? This would give better code if we emitted a tree of branches 	     instead of the current linear list of branches.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unroll_number
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|cmp_const
decl_stmt|;
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
comment|/* For negative increments, must invert the constant compared 		 against, except when comparing against zero.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|cmp_const
operator|=
literal|0
expr_stmt|;
name|cmp_code
operator|=
name|EQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|neg_inc
condition|)
block|{
name|cmp_const
operator|=
name|unroll_number
operator|-
name|i
expr_stmt|;
name|cmp_code
operator|=
name|GE
expr_stmt|;
block|}
else|else
block|{
name|cmp_const
operator|=
name|i
expr_stmt|;
name|cmp_code
operator|=
name|LE
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|diff
argument_list|,
name|GEN_INT
argument_list|(
name|abs_inc
operator|*
name|cmp_const
argument_list|)
argument_list|,
name|cmp_code
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|labels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|=
name|labels
index|[
name|i
index|]
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|labels
index|[
name|i
index|]
argument_list|)
operator|++
expr_stmt|;
name|predict_insn
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|PRED_LOOP_PRECONDITIONING
argument_list|,
name|REG_BR_PROB_BASE
operator|/
operator|(
name|unroll_number
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the increment is greater than one, then we need another branch, 	     to handle other cases equivalent to 0.  */
comment|/* ??? This should be merged into the code above somehow to help 	     simplify the code here, and reduce the number of branches emitted. 	     For the negative increment case, the branch here could easily 	     be merged with the `0' case branch above.  For the positive 	     increment case, it is not clear how this can be simplified.  */
if|if
condition|(
name|abs_inc
operator|!=
literal|1
condition|)
block|{
name|int
name|cmp_const
decl_stmt|;
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
if|if
condition|(
name|neg_inc
condition|)
block|{
name|cmp_const
operator|=
name|abs_inc
operator|-
literal|1
expr_stmt|;
name|cmp_code
operator|=
name|LE
expr_stmt|;
block|}
else|else
block|{
name|cmp_const
operator|=
name|abs_inc
operator|*
operator|(
name|unroll_number
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|cmp_code
operator|=
name|GE
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|diff
argument_list|,
name|GEN_INT
argument_list|(
name|cmp_const
argument_list|)
argument_list|,
name|cmp_code
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|labels
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|=
name|labels
index|[
literal|0
index|]
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|labels
index|[
literal|0
index|]
argument_list|)
operator|++
expr_stmt|;
block|}
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
comment|/* Only the last copy of the loop body here needs the exit 	     test, so set copy_end to exclude the compare/branch here, 	     and then reset it inside the loop when get to the last 	     copy.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The immediately preceding insn may be a compare which 		 we do not want to copy.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|copy_end
argument_list|)
argument_list|)
condition|)
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|copy_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|unroll_number
condition|;
name|i
operator|++
control|)
block|{
name|emit_label_after
argument_list|(
name|labels
index|[
name|unroll_number
operator|-
name|i
index|]
argument_list|,
name|PREV_INSN
argument_list|(
name|loop_start
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
operator|->
name|insn_map
argument_list|,
literal|0
argument_list|,
name|max_insnno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|VARRAY_SIZE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|const_equiv_data
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_labelno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|local_label
index|[
name|j
index|]
condition|)
name|set_label_in_map
argument_list|(
name|map
argument_list|,
name|j
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|r
operator|<
name|max_local_regnum
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|local_regno
index|[
name|r
index|]
condition|)
block|{
name|map
operator|->
name|reg_map
index|[
name|r
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|r
index|]
argument_list|)
argument_list|,
name|regno_reg_rtx
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The last copy needs the compare/branch insns at the end, 		 so reset copy_end here if the loop ends with a conditional 		 branch.  */
if|if
condition|(
name|i
operator|==
name|unroll_number
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|copy_end
operator|=
name|last_loop_insn
expr_stmt|;
block|}
comment|/* None of the copies are the `last_iteration', so just 		 pass zero for that parameter.  */
name|copy_loop_body
argument_list|(
name|loop
argument_list|,
name|copy_start
argument_list|,
name|copy_end
argument_list|,
name|map
argument_list|,
name|exit_label
argument_list|,
literal|0
argument_list|,
name|unroll_type
argument_list|,
name|start_label
argument_list|,
name|loop_end
argument_list|,
name|loop_start
argument_list|,
name|copy_end
argument_list|)
expr_stmt|;
block|}
name|emit_label_after
argument_list|(
name|labels
index|[
literal|0
index|]
argument_list|,
name|PREV_INSN
argument_list|(
name|loop_start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|insert_before
operator|=
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert_before
operator|=
name|last_loop_insn
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The instruction immediately before the JUMP_INSN may 		 be a compare instruction which we do not want to copy 		 or delete.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
argument_list|)
condition|)
name|insert_before
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|copy_end
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
block|}
comment|/* Set unroll type to MODULO now.  */
name|unroll_type
operator|=
name|UNROLL_MODULO
expr_stmt|;
name|loop_preconditioned
operator|=
literal|1
expr_stmt|;
comment|/* Clean up.  */
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If reach here, and the loop type is UNROLL_NAIVE, then don't unroll      the loop unless all loops are being unrolled.  */
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_NAIVE
operator|&&
operator|!
name|flag_unroll_all_loops
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Unrolling failure: Naive unrolling not being done.\n"
argument_list|)
expr_stmt|;
goto|goto
name|egress
goto|;
block|}
comment|/* At this point, we are guaranteed to unroll the loop.  */
comment|/* Keep track of the unroll factor for the loop.  */
name|loop_info
operator|->
name|unroll_number
operator|=
name|unroll_number
expr_stmt|;
comment|/* For each biv and giv, determine whether it can be safely split into      a different variable for each unrolled copy of the loop body.      We precalculate and save this info here, since computing it is      expensive.       Do this before deleting any instructions from the loop, so that      back_branch_in_range_p will work correctly.  */
if|if
condition|(
name|splitting_not_safe
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
else|else
name|temp
operator|=
name|find_splittable_regs
argument_list|(
name|loop
argument_list|,
name|unroll_type
argument_list|,
name|unroll_number
argument_list|)
expr_stmt|;
comment|/* find_splittable_regs may have created some new registers, so must      reallocate the reg_map with the new larger size, and must realloc      the constant maps also.  */
name|maxregnum
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|map
operator|->
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|maxregnum
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|init_reg_map
argument_list|(
name|map
argument_list|,
name|maxregnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|const_equiv_varray
operator|==
literal|0
condition|)
name|VARRAY_CONST_EQUIV_INIT
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|maxregnum
operator|+
name|temp
operator|*
name|unroll_number
operator|*
literal|2
argument_list|,
literal|"unroll_loop"
argument_list|)
expr_stmt|;
name|global_const_equiv_varray
operator|=
name|map
operator|->
name|const_equiv_varray
expr_stmt|;
comment|/* Search the list of bivs and givs to find ones which need to be remapped      when split, and set their reg_map entry appropriately.  */
for|for
control|(
name|bl
operator|=
name|ivs
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|)
operator|!=
name|bl
operator|->
name|regno
condition|)
name|map
operator|->
name|reg_map
index|[
name|bl
operator|->
name|regno
index|]
operator|=
name|bl
operator|->
name|biv
operator|->
name|src_reg
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Currently, non-reduced/final-value givs are never split.  */
block|for (v = bl->giv; v; v = v->next_iv) 	if (REGNO (v->src_reg) != bl->regno) 	  map->reg_map[REGNO (v->dest_reg)] = v->src_reg;
endif|#
directive|endif
block|}
comment|/* Use our current register alignment and pointer flags.  */
name|map
operator|->
name|regno_pointer_align
operator|=
name|cfun
operator|->
name|emit
operator|->
name|regno_pointer_align
expr_stmt|;
name|map
operator|->
name|x_regno_reg_rtx
operator|=
name|cfun
operator|->
name|emit
operator|->
name|x_regno_reg_rtx
expr_stmt|;
comment|/* If the loop is being partially unrolled, and the iteration variables      are being split, and are being renamed for the split, then must fix up      the compare/jump instruction at the end of the loop to refer to the new      registers.  This compare isn't copied, so the registers used in it      will never be replaced if it isn't done here.  */
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_MODULO
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|copy_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|remap_split_bivs
argument_list|(
name|loop
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For unroll_number times, make a copy of each instruction      between copy_start and copy_end, and insert these new instructions      before the end of the loop.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unroll_number
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
operator|->
name|insn_map
argument_list|,
literal|0
argument_list|,
name|max_insnno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VARRAY_SIZE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|const_equiv_data
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_labelno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|local_label
index|[
name|j
index|]
condition|)
name|set_label_in_map
argument_list|(
name|map
argument_list|,
name|j
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|r
operator|<
name|max_local_regnum
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|local_regno
index|[
name|r
index|]
condition|)
block|{
name|map
operator|->
name|reg_map
index|[
name|r
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|r
index|]
argument_list|)
argument_list|,
name|regno_reg_rtx
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If loop starts with a branch to the test, then fix it so that 	 it points to the test of the first unrolled copy of the loop.  */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|loop_start
operator|!=
name|copy_start
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|copy_start
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|tem
operator|=
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* Set the jump label so that it can be used by later loop unrolling 	     passes.  */
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|tem
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|tem
argument_list|)
operator|++
expr_stmt|;
block|}
name|copy_loop_body
argument_list|(
name|loop
argument_list|,
name|copy_start
argument_list|,
name|copy_end
argument_list|,
name|map
argument_list|,
name|exit_label
argument_list|,
name|i
operator|==
name|unroll_number
operator|-
literal|1
argument_list|,
name|unroll_type
argument_list|,
name|start_label
argument_list|,
name|loop_end
argument_list|,
name|insert_before
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
comment|/* Before deleting any insns, emit a CODE_LABEL immediately after the last      insn to be deleted.  This prevents any runaway delete_insn call from      more insns that it should, as it always stops at a CODE_LABEL.  */
comment|/* Delete the compare and branch at the end of the loop if completely      unrolling the loop.  Deleting the backward branch at the end also      deletes the code label at the start of the loop.  This is done at      the very end to avoid problems with back_branch_in_range_p.  */
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
condition|)
name|safety_label
operator|=
name|emit_label_after
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|last_loop_insn
argument_list|)
expr_stmt|;
else|else
name|safety_label
operator|=
name|emit_label_after
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|copy_end
argument_list|)
expr_stmt|;
comment|/* Delete all of the original loop instructions.  Don't delete the      LOOP_BEG note, or the first code label in the loop.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|copy_start
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|safety_label
condition|)
block|{
comment|/* ??? Don't delete named code labels.  They will be deleted when the 	 jump that references them is deleted.  Otherwise, we end up deleting 	 them twice, which causes them to completely disappear instead of turn 	 into NOTE_INSN_DELETED_LABEL notes.  This in turn causes aborts in 	 dwarfout.c/dwarf2out.c.  We could perhaps fix the dwarf*out.c files 	 to handle deleted labels instead.  Or perhaps fix DECL_RTL of the 	 associated LABEL_DECL to point to one of the new label instances.  */
comment|/* ??? Likewise, we can't delete a NOTE_INSN_DELETED_LABEL note.  */
if|if
condition|(
name|insn
operator|!=
name|start_label
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
condition|)
name|insn
operator|=
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Can now delete the 'safety' label emitted to protect us from runaway      delete_related_insns calls.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|safety_label
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|delete_related_insns
argument_list|(
name|safety_label
argument_list|)
expr_stmt|;
comment|/* If exit_label exists, emit it after the loop.  Doing the emit here      forces it to have a higher INSN_UID than any insn in the unrolled loop.      This is needed so that mostly_true_jump in reorg.c will treat jumps      to this loop end label correctly, i.e. predict that they are usually      not taken.  */
if|if
condition|(
name|exit_label
condition|)
name|emit_label_after
argument_list|(
name|exit_label
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|egress
label|:
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
condition|)
block|{
comment|/* Remove the loop notes since this is no longer a loop.  */
if|if
condition|(
name|loop
operator|->
name|vtop
condition|)
name|delete_related_insns
argument_list|(
name|loop
operator|->
name|vtop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|cont
condition|)
name|delete_related_insns
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_start
condition|)
name|delete_related_insns
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_end
condition|)
name|delete_related_insns
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|->
name|const_equiv_varray
condition|)
name|VARRAY_FREE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|label_map
condition|)
block|{
name|free
argument_list|(
name|map
operator|->
name|label_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|local_label
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|map
operator|->
name|insn_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|splittable_regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|splittable_regs_updates
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|addr_combined_regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|local_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|reg_map
condition|)
name|free
argument_list|(
name|map
operator|->
name|reg_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the loop can be safely, and profitably, preconditioned    so that the unrolled copies of the loop body don't need exit tests.     This only works if final_value, initial_value and increment can be    determined, and if increment is a constant power of 2.    If increment is not a power of 2, then the preconditioning modulo    operation would require a real modulo instead of a boolean AND, and this    is not considered `profitable'.  */
end_comment

begin_comment
comment|/* ??? If the loop is known to be executed very many times, or the machine    has a very cheap divide instruction, then preconditioning is a win even    when the increment is not a power of 2.  Use RTX_COST to compute    whether divide is cheap.    ??? A divide by constant doesn't actually need a divide, look at    expand_divmod.  The reduced cost of this optimized modulo is not    reflected in RTX_COST.  */
end_comment

begin_function
name|int
name|precondition_loop_p
parameter_list|(
name|loop
parameter_list|,
name|initial_value
parameter_list|,
name|final_value
parameter_list|,
name|increment
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
modifier|*
name|initial_value
decl_stmt|,
decl|*
name|final_value
decl_stmt|,
modifier|*
name|increment
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
modifier|*
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
name|loop_info
operator|->
name|n_iterations
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|*
name|initial_value
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|increment
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|final_value
operator|=
name|GEN_INT
argument_list|(
name|loop_info
operator|->
name|n_iterations
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|initial_value
operator|=
name|GEN_INT
argument_list|(
name|loop_info
operator|->
name|n_iterations
argument_list|)
expr_stmt|;
operator|*
name|increment
operator|=
name|constm1_rtx
expr_stmt|;
operator|*
name|final_value
operator|=
name|const0_rtx
expr_stmt|;
block|}
operator|*
name|mode
operator|=
name|word_mode
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fputs
argument_list|(
literal|"Preconditioning: Success, number of iterations known, "
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|loop_info
operator|->
name|n_iterations
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|".\n"
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|loop_info
operator|->
name|iteration_var
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Could not find iteration variable.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|loop_info
operator|->
name|initial_value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Could not find initial value.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|loop_info
operator|->
name|increment
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Could not find increment value.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Increment not a constant.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Increment not a constant power of 2.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Unsigned_compare and compare_dir can be ignored here, since they do      not matter for preconditioning.  */
if|if
condition|(
name|loop_info
operator|->
name|final_value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: EQ comparison loop.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Must ensure that final_value is invariant, so call      loop_invariant_p to check.  Before doing so, must check regno      against max_reg_before_loop to make sure that the register is in      the range covered by loop_invariant_p.  If it isn't, then it is      most likely a biv/giv which by definition are not invariant.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|loop_info
operator|->
name|final_value
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|loop_info
operator|->
name|final_value
argument_list|)
operator|>=
name|max_reg_before_loop
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|loop_info
operator|->
name|final_value
argument_list|)
operator|==
name|PLUS
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loop_info
operator|->
name|final_value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|max_reg_before_loop
operator|)
operator|||
operator|!
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|loop_info
operator|->
name|final_value
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Final value not invariant.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Fail for floating point values, since the caller of this function      does not have code to deal with them.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|loop_info
operator|->
name|final_value
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|loop_info
operator|->
name|initial_value
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Floating point final or initial value.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Fail if loop_info->iteration_var is not live before loop_start,      since we need to test its value in the preconditioning code.  */
if|if
condition|(
name|REGNO_FIRST_LUID
argument_list|(
name|REGNO
argument_list|(
name|loop_info
operator|->
name|iteration_var
argument_list|)
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Iteration var not live before loop start.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Note that loop_iterations biases the initial value for GIV iterators      such as "while (i--> 0)" so that we can calculate the number of      iterations just like for BIV iterators.       Also note that the absolute values of initial_value and      final_value are unimportant as only their difference is used for      calculating the number of loop iterations.  */
operator|*
name|initial_value
operator|=
name|loop_info
operator|->
name|initial_value
expr_stmt|;
operator|*
name|increment
operator|=
name|loop_info
operator|->
name|increment
expr_stmt|;
operator|*
name|final_value
operator|=
name|loop_info
operator|->
name|final_value
expr_stmt|;
comment|/* Decide what mode to do these calculations in.  Choose the larger      of final_value's mode and initial_value's mode, or a full-word if      both are constants.  */
operator|*
name|mode
operator|=
name|GET_MODE
argument_list|(
operator|*
name|final_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mode
operator|==
name|VOIDmode
condition|)
block|{
operator|*
name|mode
operator|=
name|GET_MODE
argument_list|(
operator|*
name|initial_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mode
operator|==
name|VOIDmode
condition|)
operator|*
name|mode
operator|=
name|word_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|mode
operator|!=
name|GET_MODE
argument_list|(
operator|*
name|initial_value
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
operator|*
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|initial_value
argument_list|)
argument_list|)
operator|)
condition|)
operator|*
name|mode
operator|=
name|GET_MODE
argument_list|(
operator|*
name|initial_value
argument_list|)
expr_stmt|;
comment|/* Success!  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Preconditioning: Successful.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* All pseudo-registers must be mapped to themselves.  Two hard registers    must be mapped, VIRTUAL_STACK_VARS_REGNUM and VIRTUAL_INCOMING_ARGS_    REGNUM, to avoid function-inlining specific conversions of these    registers.  All other hard regs can not be mapped because they may be    used with different    modes.  */
end_comment

begin_function
specifier|static
name|void
name|init_reg_map
parameter_list|(
name|map
parameter_list|,
name|maxregnum
parameter_list|)
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|int
name|maxregnum
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|maxregnum
operator|-
literal|1
init|;
name|i
operator|>
name|LAST_VIRTUAL_REGISTER
condition|;
name|i
operator|--
control|)
name|map
operator|->
name|reg_map
index|[
name|i
index|]
operator|=
name|regno_reg_rtx
index|[
name|i
index|]
expr_stmt|;
comment|/* Just clear the rest of the entries.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|map
operator|->
name|reg_map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|VIRTUAL_STACK_VARS_REGNUM
index|]
operator|=
name|regno_reg_rtx
index|[
name|VIRTUAL_STACK_VARS_REGNUM
index|]
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|VIRTUAL_INCOMING_ARGS_REGNUM
index|]
operator|=
name|regno_reg_rtx
index|[
name|VIRTUAL_INCOMING_ARGS_REGNUM
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Strength-reduction will often emit code for optimized biv/givs which    calculates their value in a temporary register, and then copies the result    to the iv.  This procedure reconstructs the pattern computing the iv;    verifying that all operands are of the proper form.     PATTERN must be the result of single_set.    The return value is the amount that the giv is incremented by.  */
end_comment

begin_function
specifier|static
name|rtx
name|calculate_giv_inc
parameter_list|(
name|pattern
parameter_list|,
name|src_insn
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|pattern
decl_stmt|,
name|src_insn
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|increment
decl_stmt|;
name|rtx
name|increment_total
init|=
literal|0
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
name|retry
label|:
comment|/* Verify that we have an increment insn here.  First check for a plus      as the set source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
block|{
comment|/* SR sometimes computes the new giv value in a temp, then copies it 	 to the new_reg.  */
name|src_insn
operator|=
name|PREV_INSN
argument_list|(
name|src_insn
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|single_set
argument_list|(
name|src_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The last insn emitted is not needed, so delete it to avoid confusing 	 the second cse pass.  This insn sets the giv unnecessarily.  */
name|delete_related_insns
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Verify that we have a constant as the second operand of the plus.  */
name|increment
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* SR sometimes puts the constant in a register, especially if it is 	 too big to be an add immed operand.  */
name|increment
operator|=
name|find_last_value
argument_list|(
name|increment
argument_list|,
operator|&
name|src_insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* SR may have used LO_SUM to compute the constant if it is too large 	 for a load immed operand.  In this case, the constant is in operand 	 one of the LO_SUM rtx.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|==
name|LO_SUM
condition|)
name|increment
operator|=
name|XEXP
argument_list|(
name|increment
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Some ports store large constants in memory and add a REG_EQUAL 	 note to the store insn.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|src_insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|increment
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The rs6000 port loads some constants with IOR. 	     The alpha port loads some constants with ASHIFT and PLUS.  */
name|rtx
name|second_part
init|=
name|XEXP
argument_list|(
name|increment
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|increment
argument_list|)
decl_stmt|;
name|increment
operator|=
name|find_last_value
argument_list|(
name|XEXP
argument_list|(
name|increment
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't need the last insn anymore.  */
name|delete_related_insns
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|second_part
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|IOR
condition|)
name|increment
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator||
name|INTVAL
argument_list|(
name|second_part
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
name|increment
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|second_part
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|increment
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|<<
name|INTVAL
argument_list|(
name|second_part
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The insn loading the constant into a register is no longer needed, 	 so delete it.  */
name|delete_related_insns
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|increment_total
condition|)
name|increment_total
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|increment_total
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|increment
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|increment_total
operator|=
name|increment
expr_stmt|;
comment|/* Check that the source register is the same as the register we expected      to see as the source.  If not, something is seriously wrong.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|regno
condition|)
block|{
comment|/* Some machines (e.g. the romp), may emit two add instructions for 	 certain constants, so lets try looking for another add immediately 	 before this one if we have only seen one add insn so far.  */
if|if
condition|(
name|tries
operator|==
literal|0
condition|)
block|{
name|tries
operator|++
expr_stmt|;
name|src_insn
operator|=
name|PREV_INSN
argument_list|(
name|src_insn
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|single_set
argument_list|(
name|src_insn
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|increment_total
return|;
block|}
end_function

begin_comment
comment|/* Copy REG_NOTES, except for insn references, because not all insn_map    entries are valid yet.  We do need to copy registers now though, because    the reg_map entries can change during copying.  */
end_comment

begin_function
specifier|static
name|rtx
name|initial_reg_note_copy
parameter_list|(
name|notes
parameter_list|,
name|map
parameter_list|)
name|rtx
name|notes
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|rtx
name|copy
decl_stmt|;
if|if
condition|(
name|notes
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|GET_CODE
argument_list|(
name|notes
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|copy
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|notes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|notes
argument_list|)
operator|==
name|EXPR_LIST
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|notes
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|notes
argument_list|)
operator|==
name|INSN_LIST
condition|)
comment|/* Don't substitute for these yet.  */
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|notes
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
operator|=
name|initial_reg_note_copy
argument_list|(
name|XEXP
argument_list|(
name|notes
argument_list|,
literal|1
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Fixup insn references in copied REG_NOTES.  */
end_comment

begin_function
specifier|static
name|void
name|final_reg_note_copy
parameter_list|(
name|notesp
parameter_list|,
name|map
parameter_list|)
name|rtx
modifier|*
name|notesp
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|notesp
condition|)
block|{
name|rtx
name|note
init|=
operator|*
name|notesp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|INSN_LIST
condition|)
block|{
comment|/* Sometimes, we have a REG_WAS_0 note that points to a 	     deleted instruction.  In that case, we can just delete the 	     note.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_WAS_0
condition|)
block|{
operator|*
name|notesp
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|rtx
name|insn
init|=
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
decl_stmt|;
comment|/* If we failed to remap the note, something is awry. 		 Allow REG_LABEL as it may reference label outside 		 the unrolled loop.  */
if|if
condition|(
operator|!
name|insn
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
name|notesp
operator|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy each instruction in the loop, substituting from map as appropriate.    This is very similar to a loop in expand_inline_function.  */
end_comment

begin_function
specifier|static
name|void
name|copy_loop_body
parameter_list|(
name|loop
parameter_list|,
name|copy_start
parameter_list|,
name|copy_end
parameter_list|,
name|map
parameter_list|,
name|exit_label
parameter_list|,
name|last_iteration
parameter_list|,
name|unroll_type
parameter_list|,
name|start_label
parameter_list|,
name|loop_end
parameter_list|,
name|insert_before
parameter_list|,
name|copy_notes_from
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|copy_start
decl_stmt|,
name|copy_end
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtx
name|exit_label
decl_stmt|;
name|int
name|last_iteration
decl_stmt|;
name|enum
name|unroll_types
name|unroll_type
decl_stmt|;
name|rtx
name|start_label
decl_stmt|,
name|loop_end
decl_stmt|,
name|insert_before
decl_stmt|,
name|copy_notes_from
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pattern
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|tem
decl_stmt|,
name|copy
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|dest_reg_was_split
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|cc0_insn
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|rtx
name|final_label
init|=
literal|0
decl_stmt|;
name|rtx
name|giv_inc
decl_stmt|,
name|giv_dest_reg
decl_stmt|,
name|giv_src_reg
decl_stmt|;
comment|/* If this isn't the last iteration, then map any references to the      start_label to final_label.  Final label will then be emitted immediately      after the end of this loop body if it was ever used.       If this is the last iteration, then map references to the start_label      to itself.  */
if|if
condition|(
operator|!
name|last_iteration
condition|)
block|{
name|final_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|set_label_in_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|start_label
argument_list|)
argument_list|,
name|final_label
argument_list|)
expr_stmt|;
block|}
else|else
name|set_label_in_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|start_label
argument_list|)
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Emit a NOTE_INSN_DELETED to force at least two insns onto the sequence.      Else gen_sequence could return a raw pattern for a jump which we pass      off to emit_insn_before (instead of emit_jump_insn_before) which causes      a variety of losing behaviors later.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|insn
operator|=
name|copy_start
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|map
operator|->
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
name|giv_inc
operator|=
literal|0
expr_stmt|;
comment|/* Check to see if this is a giv that has been combined with 	     some split address givs.  (Combined in the sense that 	     `combine_givs' in loop.c has put two givs in the same register.) 	     In this case, we must search all givs based on the same biv to 	     find the address givs.  Then split the address givs. 	     Do this before splitting the giv, since that may map the 	     SET_DEST to a new register.  */
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|addr_combined_regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|,
modifier|*
name|tv
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|=
name|addr_combined_regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Although the giv_inc amount is not needed here, we must call 		 calculate_giv_inc here since it might try to delete the 		 last insn emitted.  If we wait until later to call it, 		 we might accidentally delete insns generated immediately 		 below by emit_unrolled_add.  */
name|giv_inc
operator|=
name|calculate_giv_inc
argument_list|(
name|set
argument_list|,
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Now find all address giv's that were combined with this 		 giv 'v'.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|giv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
if|if
condition|(
name|tv
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|tv
operator|->
name|same
operator|==
name|v
condition|)
block|{
name|int
name|this_giv_inc
decl_stmt|;
comment|/* If this DEST_ADDR giv was not split, then ignore it.  */
if|if
condition|(
operator|*
name|tv
operator|->
name|location
operator|!=
name|tv
operator|->
name|dest_reg
condition|)
continue|continue;
comment|/* Scale this_giv_inc if the multiplicative factors of 		       the two givs are different.  */
name|this_giv_inc
operator|=
name|INTVAL
argument_list|(
name|giv_inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|!=
name|v
operator|->
name|mult_val
condition|)
name|this_giv_inc
operator|=
operator|(
name|this_giv_inc
operator|/
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|tv
operator|->
name|mult_val
argument_list|)
operator|)
expr_stmt|;
name|tv
operator|->
name|dest_reg
operator|=
name|plus_constant
argument_list|(
name|tv
operator|->
name|dest_reg
argument_list|,
name|this_giv_inc
argument_list|)
expr_stmt|;
operator|*
name|tv
operator|->
name|location
operator|=
name|tv
operator|->
name|dest_reg
expr_stmt|;
if|if
condition|(
name|last_iteration
operator|&&
name|unroll_type
operator|!=
name|UNROLL_COMPLETELY
condition|)
block|{
comment|/* Must emit an insn to increment the split address 			   giv.  Add in the const_adjust field in case there 			   was a constant eliminated from the address.  */
name|rtx
name|value
decl_stmt|,
name|dest_reg
decl_stmt|;
comment|/* tv->dest_reg will be either a bare register, 			   or else a register plus a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tv
operator|->
name|dest_reg
argument_list|)
operator|==
name|REG
condition|)
name|dest_reg
operator|=
name|tv
operator|->
name|dest_reg
expr_stmt|;
else|else
name|dest_reg
operator|=
name|XEXP
argument_list|(
name|tv
operator|->
name|dest_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for shared address givs, and avoid 			   incrementing the shared pseudo reg more than 			   once.  */
if|if
condition|(
operator|!
name|tv
operator|->
name|same_insn
operator|&&
operator|!
name|tv
operator|->
name|shared
condition|)
block|{
comment|/* tv->dest_reg may actually be a (PLUS (REG) 			       (CONST)) here, so we must call plus_constant 			       to add the const_adjust amount before calling 			       emit_unrolled_add below.  */
name|value
operator|=
name|plus_constant
argument_list|(
name|tv
operator|->
name|dest_reg
argument_list|,
name|tv
operator|->
name|const_adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The constant could be too large for an add 				   immediate, so can't directly emit an insn 				   here.  */
name|emit_unrolled_add
argument_list|(
name|dest_reg
argument_list|,
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset the giv to be just the register again, in case 			   it is used after the set we have just emitted. 			   We must subtract the const_adjust factor added in 			   above.  */
name|tv
operator|->
name|dest_reg
operator|=
name|plus_constant
argument_list|(
name|dest_reg
argument_list|,
operator|-
name|tv
operator|->
name|const_adjust
argument_list|)
expr_stmt|;
operator|*
name|tv
operator|->
name|location
operator|=
name|tv
operator|->
name|dest_reg
expr_stmt|;
block|}
block|}
block|}
comment|/* If this is a setting of a splittable variable, then determine 	     how to split the variable, create a new set based on this split, 	     and set up the reg_map so that later uses of the variable will 	     use the new split variable.  */
name|dest_reg_was_split
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|splittable_regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|dest_reg_was_split
operator|=
literal|1
expr_stmt|;
name|giv_dest_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|giv_src_reg
operator|=
name|giv_dest_reg
expr_stmt|;
comment|/* Compute the increment value for the giv, if it wasn't 		 already computed above.  */
if|if
condition|(
name|giv_inc
operator|==
literal|0
condition|)
name|giv_inc
operator|=
name|calculate_giv_inc
argument_list|(
name|set
argument_list|,
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|giv_src_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
condition|)
block|{
comment|/* Completely unrolling the loop.  Set the induction 		     variable to a known constant value.  */
comment|/* The value in splittable_regs may be an invariant 		     value, so we must use plus_constant here.  */
name|splittable_regs
index|[
name|regno
index|]
operator|=
name|plus_constant
argument_list|(
name|splittable_regs
index|[
name|src_regno
index|]
argument_list|,
name|INTVAL
argument_list|(
name|giv_inc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|splittable_regs
index|[
name|regno
index|]
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|giv_src_reg
operator|=
name|XEXP
argument_list|(
name|splittable_regs
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|giv_inc
operator|=
name|XEXP
argument_list|(
name|splittable_regs
index|[
name|regno
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The splittable_regs value must be a REG or a 			 CONST_INT, so put the entire value in the giv_src_reg 			 variable.  */
name|giv_src_reg
operator|=
name|splittable_regs
index|[
name|regno
index|]
expr_stmt|;
name|giv_inc
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Partially unrolling loop.  Create a new pseudo 		     register for the iteration variable, and set it to 		     be a constant plus the original register.  Except 		     on the last iteration, when the result has to 		     go back into the original iteration var register.  */
comment|/* Handle bivs which must be mapped to a new register 		     when split.  This happens for bivs which need their 		     final value set before loop entry.  The new register 		     for the biv was stored in the biv's first struct 		     induction entry by find_splittable_regs.  */
if|if
condition|(
name|regno
operator|<
name|ivs
operator|->
name|n_regs
operator|&&
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|regno
argument_list|)
operator|==
name|BASIC_INDUCT
condition|)
block|{
name|giv_src_reg
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|regno
argument_list|)
operator|->
name|biv
operator|->
name|src_reg
expr_stmt|;
name|giv_dest_reg
operator|=
name|giv_src_reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* If non-reduced/final-value givs were split, then 		     this would have to remap those givs also.  See 		     find_splittable_regs.  */
endif|#
directive|endif
name|splittable_regs
index|[
name|regno
index|]
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|giv_src_reg
argument_list|)
argument_list|,
name|giv_inc
argument_list|,
name|splittable_regs
index|[
name|src_regno
index|]
argument_list|)
expr_stmt|;
name|giv_inc
operator|=
name|splittable_regs
index|[
name|regno
index|]
expr_stmt|;
comment|/* Now split the induction variable by changing the dest 		     of this insn to a new register, and setting its 		     reg_map entry to point to this new register.  		     If this is the last iteration, and this is the last insn 		     that will update the iv, then reuse the original dest, 		     to ensure that the iv will have the proper value when 		     the loop exits or repeats.  		     Using splittable_regs_updates here like this is safe, 		     because it can only be greater than one if all 		     instructions modifying the iv are always executed in 		     order.  */
if|if
condition|(
operator|!
name|last_iteration
operator|||
operator|(
name|splittable_regs_updates
index|[
name|regno
index|]
operator|--
operator|!=
literal|1
operator|)
condition|)
block|{
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|giv_src_reg
argument_list|)
argument_list|)
expr_stmt|;
name|giv_dest_reg
operator|=
name|tem
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|tem
expr_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|giv_inc
operator|==
name|const0_rtx
condition|?
name|giv_src_reg
else|:
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|giv_src_reg
argument_list|)
argument_list|,
name|giv_src_reg
argument_list|,
name|giv_inc
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|giv_src_reg
expr_stmt|;
block|}
comment|/* The constant being added could be too large for an add 		 immediate, so can't directly emit an insn here.  */
name|emit_unrolled_add
argument_list|(
name|giv_dest_reg
argument_list|,
name|giv_src_reg
argument_list|,
name|giv_inc
argument_list|)
expr_stmt|;
name|copy
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|initial_reg_note_copy
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this insn is setting CC0, it may need to look at 	     the insn that uses CC0 to see what type of insn it is. 	     In that case, the call to recog via validate_change will 	     fail.  So don't substitute constants here.  Instead, 	     do it when we emit the following insn.  	     For example, see the pyr.md file.  That machine has signed and 	     unsigned compares.  The compare patterns must check the 	     following branch insn to see which what kind of compare to 	     emit.  	     If the previous insn set CC0, substitute constants on it as 	     well.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|cc0_insn
operator|=
name|copy
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make split induction variable constants `permanent' since we 	     know there are no backward branches across iteration variable 	     settings which would invalidate this.  */
if|if
condition|(
name|dest_reg_was_split
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|regno
operator|<
name|VARRAY_SIZE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
operator|&&
operator|(
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|.
name|age
operator|==
name|map
operator|->
name|const_age
operator|)
condition|)
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|.
name|age
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|JUMP_INSN
case|:
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_jump_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|initial_reg_note_copy
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
operator|=
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|start_label
operator|&&
name|insn
operator|==
name|copy_end
operator|&&
operator|!
name|last_iteration
condition|)
block|{
comment|/* This is a branch to the beginning of the loop; this is the 		 last insn being copied; and this is not the last iteration. 		 In this case, we want to change the original fall through 		 case to be a branch past the end of the loop, and the 		 original jump label case to fall_through.  */
if|if
condition|(
operator|!
name|invert_jump
argument_list|(
name|copy
argument_list|,
name|exit_label
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|jmp
decl_stmt|;
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Can't do it by reversing the jump (probably because we 		     couldn't reverse the conditions), so emit a new 		     jump_insn after COPY, and redirect the jump around 		     that.  */
name|jmp
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|exit_label
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jmp
argument_list|)
operator|=
name|exit_label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|exit_label
argument_list|)
operator|++
expr_stmt|;
name|jmp
operator|=
name|emit_barrier_after
argument_list|(
name|jmp
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|lab
argument_list|,
name|jmp
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|lab
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|copy
argument_list|,
name|lab
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Set the jump label of COPY correctly to avoid problems with 	     later passes of unroll_loop, if INSN had jump label set.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* Can't use the label_map for every insn, since this may be 		 the backward branch, and hence the label was not mapped.  */
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|copy
argument_list|)
operator|)
condition|)
block|{
name|tem
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
operator|!=
name|pc_rtx
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|label
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
operator|=
name|label
expr_stmt|;
else|else
block|{
comment|/* An unrecognizable jump insn, probably the entry jump 		     for a switch statement.  This label must have been mapped, 		     so just use the label_map to get the new jump label.  */
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
operator|=
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a non-local jump, then must increase the label 		 use count so that the label will not be deleted when the 		 original jump is deleted.  */
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|copy
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
comment|/* If this used to be a conditional jump insn but whose branch 	     direction is now known, we must do something special.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|map
operator|->
name|last_pc_value
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If the previous insn set cc0 for us, delete it.  */
if|if
condition|(
name|only_sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|)
name|delete_related_insns
argument_list|(
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is now a no-op, delete it.  */
if|if
condition|(
name|map
operator|->
name|last_pc_value
operator|==
name|pc_rtx
condition|)
block|{
name|delete_insn
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Otherwise, this is unconditional jump so we must put a 		   BARRIER after it.  We could do some dead code elimination 		   here, but jump.c will do it just as well.  */
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CALL_INSN
case|:
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_call_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|initial_reg_note_copy
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially contains objects other 	     than hard registers, we need to copy it.  */
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Be lazy and assume CALL_INSNs clobber all hard registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|i
argument_list|)
operator|.
name|rtx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
comment|/* If this is the loop start label, then we don't need to emit a 	     copy of this label since no one will use it.  */
if|if
condition|(
name|insn
operator|!=
name|start_label
condition|)
block|{
name|copy
operator|=
name|emit_label
argument_list|(
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BARRIER
case|:
name|copy
operator|=
name|emit_barrier
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
comment|/* VTOP and CONT notes are valid only before the loop exit test. 	     If placed anywhere else, loop may generate bad code.  */
comment|/* BASIC_BLOCK notes exist to stabilize basic block structures with 	     the associated rtl.  We do not want to share the structure in 	     this new block.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED_LABEL
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|&&
operator|(
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_VTOP
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_CONT
operator|)
operator|||
operator|(
name|last_iteration
operator|&&
name|unroll_type
operator|!=
name|UNROLL_COMPLETELY
operator|)
operator|)
condition|)
name|copy
operator|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|copy
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|copy_end
condition|)
do|;
comment|/* Now finish coping the REG_NOTES.  */
name|insn
operator|=
name|copy_start
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
name|final_reg_note_copy
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|copy_end
condition|)
do|;
comment|/* There may be notes between copy_notes_from and loop_end.  Emit a copy of      each of these notes here, since there may be some important ones, such as      NOTE_INSN_BLOCK_END notes, in this group.  We don't do this on the last      iteration, because the original notes won't be deleted.       We can't use insert_before here, because when from preconditioning,      insert_before points before the loop.  We can't use copy_end, because      there may be insns already inserted after it (which we don't want to      copy) when not from preconditioning code.  */
if|if
condition|(
operator|!
name|last_iteration
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|copy_notes_from
init|;
name|insn
operator|!=
name|loop_end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* VTOP notes are valid only before the loop exit test. 	     If placed anywhere else, loop may generate bad code. 	     There is no need to test for NOTE_INSN_LOOP_CONT notes 	     here, since COPY_NOTES_FROM will be at most one or two (for cc0) 	     instructions before the last insn in the loop, and if the 	     end test is that short, there will be a VTOP note between 	     the CONT note and the test.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_VTOP
condition|)
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|final_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|final_label
argument_list|)
operator|>
literal|0
condition|)
name|emit_label
argument_list|(
name|final_label
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|loop_insn_emit_before
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|insert_before
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn, using the expand_binop to ensure that a valid insn is    emitted.  This will correctly handle the case where the increment value    won't fit in the immediate field of a PLUS insns.  */
end_comment

begin_function
name|void
name|emit_unrolled_add
parameter_list|(
name|dest_reg
parameter_list|,
name|src_reg
parameter_list|,
name|increment
parameter_list|)
name|rtx
name|dest_reg
decl_stmt|,
name|src_reg
decl_stmt|,
name|increment
decl_stmt|;
block|{
name|rtx
name|result
decl_stmt|;
name|result
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|,
name|PLUS
argument_list|,
name|src_reg
argument_list|,
name|increment
argument_list|,
name|dest_reg
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_reg
operator|!=
name|result
condition|)
name|emit_move_insn
argument_list|(
name|dest_reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Searches the insns between INSN and LOOP->END.  Returns 1 if there    is a backward branch in that range that branches to somewhere between    LOOP->START and INSN.  Returns 0 otherwise.  */
end_comment

begin_comment
comment|/* ??? This is quadratic algorithm.  Could be rewritten to be linear.    In practice, this is not a problem, because this function is seldom called,    and uses a negligible amount of CPU time on average.  */
end_comment

begin_function
name|int
name|back_branch_in_range_p
parameter_list|(
name|loop
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|,
name|target_insn
decl_stmt|;
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|loop_end
init|=
name|loop
operator|->
name|end
decl_stmt|;
name|rtx
name|orig_loop_end
init|=
name|loop
operator|->
name|end
decl_stmt|;
comment|/* Stop before we get to the backward branch at the end of the loop.  */
name|loop_end
operator|=
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|loop_end
argument_list|)
operator|==
name|BARRIER
condition|)
name|loop_end
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Check in case insn has been deleted, search forward for first non      deleted insn following it.  */
while|while
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Check for the case where insn is the last insn in the loop.  Deal      with the case where INSN was a deleted loop test insn, in which case      it will now be the NOTE_LOOP_END.  */
if|if
condition|(
name|insn
operator|==
name|loop_end
operator|||
name|insn
operator|==
name|orig_loop_end
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|target_insn
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Search from loop_start to insn, to see if one of them is 	     the target_insn.  We can't use INSN_LUID comparisons here, 	     since insn may not have an LUID entry.  */
for|for
control|(
name|q
operator|=
name|loop_start
init|;
name|q
operator|!=
name|insn
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|q
operator|==
name|target_insn
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to generate the simplest rtx for the expression    (PLUS (MULT mult1 mult2) add1).  This is used to calculate the initial    value of giv's.  */
end_comment

begin_function
specifier|static
name|rtx
name|fold_rtx_mult_add
parameter_list|(
name|mult1
parameter_list|,
name|mult2
parameter_list|,
name|add1
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|mult1
decl_stmt|,
name|mult2
decl_stmt|,
name|add1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|mult_res
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* The modes must all be the same.  This should always be true.  For now,      check to make sure.  */
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|mult1
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|mult1
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|mult2
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|mult2
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|add1
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|add1
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ensure that if at least one of mult1/mult2 are constant, then mult2      will be a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mult1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|temp
operator|=
name|mult2
expr_stmt|;
name|mult2
operator|=
name|mult1
expr_stmt|;
name|mult1
operator|=
name|temp
expr_stmt|;
block|}
name|mult_res
operator|=
name|simplify_binary_operation
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|mult1
argument_list|,
name|mult2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mult_res
condition|)
name|mult_res
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|mult1
argument_list|,
name|mult2
argument_list|)
expr_stmt|;
comment|/* Again, put the constant second.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|add1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|temp
operator|=
name|add1
expr_stmt|;
name|add1
operator|=
name|mult_res
expr_stmt|;
name|mult_res
operator|=
name|temp
expr_stmt|;
block|}
name|result
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|add1
argument_list|,
name|mult_res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|add1
argument_list|,
name|mult_res
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Searches the list of induction struct's for the biv BL, to try to calculate    the total increment value for one iteration of the loop as a constant.     Returns the increment value as an rtx, simplified as much as possible,    if it can be calculated.  Otherwise, returns 0.  */
end_comment

begin_function
name|rtx
name|biv_total_increment
parameter_list|(
name|bl
parameter_list|)
specifier|const
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* For increment, must check every instruction that sets it.  Each      instruction must be executed only once each time through the loop.      To verify this, we check that the insn is always executed, and that      there are no backward branches after the insn that branch to before it.      Also, the insn must have a mult_val of one (to make sure it really is      an increment).  */
name|result
operator|=
name|const0_rtx
expr_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|biv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mult_val
operator|==
name|const1_rtx
operator|&&
operator|!
name|v
operator|->
name|maybe_multiple
condition|)
name|result
operator|=
name|fold_rtx_mult_add
argument_list|(
name|result
argument_list|,
name|const1_rtx
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* For each biv and giv, determine whether it can be safely split into    a different variable for each unrolled copy of the loop body.  If it    is safe to split, then indicate that by saving some useful info    in the splittable_regs array.     If the loop is being completely unrolled, then splittable_regs will hold    the current value of the induction variable while the loop is unrolled.    It must be set to the initial value of the induction variable here.    Otherwise, splittable_regs will hold the difference between the current    value of the induction variable and the value the induction variable had    at the top of the loop.  It must be set to the value 0 here.     Returns the total number of instructions that set registers that are    splittable.  */
end_comment

begin_comment
comment|/* ?? If the loop is only unrolled twice, then most of the restrictions to    constant values are unnecessary, since we can easily calculate increment    values in this case even if nothing is constant.  The increment value    should not involve a multiply however.  */
end_comment

begin_comment
comment|/* ?? Even if the biv/giv increment values aren't constant, it may still    be beneficial to split the variable if the loop is only unrolled a few    times, since multiplies by small integers (1,2,3,4) are very cheap.  */
end_comment

begin_function
specifier|static
name|int
name|find_splittable_regs
parameter_list|(
name|loop
parameter_list|,
name|unroll_type
parameter_list|,
name|unroll_number
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|enum
name|unroll_types
name|unroll_type
decl_stmt|;
name|int
name|unroll_number
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|increment
decl_stmt|,
name|tem
decl_stmt|;
name|rtx
name|biv_final_value
decl_stmt|;
name|int
name|biv_splittable
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|bl
operator|=
name|ivs
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
comment|/* Biv_total_increment must return a constant value, 	 otherwise we can not calculate the split values.  */
name|increment
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|increment
operator|||
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
continue|continue;
comment|/* The loop must be unrolled completely, or else have a known number 	 of iterations and only one exit, or else the biv must be dead 	 outside the loop, or else the final value must be known.  Otherwise, 	 it is unsafe to split the biv since it may not have the proper 	 value on loop exit.  */
comment|/* loop_number_exit_count is non-zero if the loop has an exit other than 	 a fall through at the end.  */
name|biv_splittable
operator|=
literal|1
expr_stmt|;
name|biv_final_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unroll_type
operator|!=
name|UNROLL_COMPLETELY
operator|&&
operator|(
name|loop
operator|->
name|exit_count
operator|||
name|unroll_type
operator|==
name|UNROLL_NAIVE
operator|)
operator|&&
operator|(
name|REGNO_LAST_LUID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|end
argument_list|)
operator|||
operator|!
name|bl
operator|->
name|init_insn
operator|||
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
name|REGNO_FIRST_LUID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|)
operator|||
name|reg_mentioned_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|biv_final_value
operator|=
name|final_biv_value
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|)
operator|)
condition|)
name|biv_splittable
operator|=
literal|0
expr_stmt|;
comment|/* If any of the insns setting the BIV don't do so with a simple 	 PLUS, we don't know how to split it.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|biv
init|;
name|biv_splittable
operator|&&
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
operator|(
name|tem
operator|=
name|single_set
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|bl
operator|->
name|regno
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|biv_splittable
operator|=
literal|0
expr_stmt|;
comment|/* If final value is non-zero, then must emit an instruction which sets 	 the value of the biv to the proper value.  This is done after 	 handling all of the givs, since some of them may need to use the 	 biv's value in their initialization code.  */
comment|/* This biv is splittable.  If completely unrolling the loop, save 	 the biv's initial value.  Otherwise, save the constant zero.  */
if|if
condition|(
name|biv_splittable
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
condition|)
block|{
comment|/* If the initial value of the biv is itself (i.e. it is too 		 complicated for strength_reduce to compute), or is a hard 		 register, or it isn't invariant, then we must create a new 		 pseudo reg to hold the initial value of the biv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|bl
operator|->
name|regno
operator|||
name|REGNO
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|mode
argument_list|)
decl_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d initial value remapped to %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|splittable_regs
index|[
name|bl
operator|->
name|regno
index|]
operator|=
name|tem
expr_stmt|;
block|}
else|else
name|splittable_regs
index|[
name|bl
operator|->
name|regno
index|]
operator|=
name|bl
operator|->
name|initial_value
expr_stmt|;
block|}
else|else
name|splittable_regs
index|[
name|bl
operator|->
name|regno
index|]
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Save the number of instructions that modify the biv, so that 	     we can treat the last one specially.  */
name|splittable_regs_updates
index|[
name|bl
operator|->
name|regno
index|]
operator|=
name|bl
operator|->
name|biv_count
expr_stmt|;
name|result
operator|+=
name|bl
operator|->
name|biv_count
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d safe to split.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Check every giv that depends on this biv to see whether it is 	 splittable also.  Even if the biv isn't splittable, givs which 	 depend on it may be splittable if the biv is live outside the 	 loop, and the givs aren't.  */
name|result
operator|+=
name|find_splittable_givs
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|,
name|unroll_type
argument_list|,
name|increment
argument_list|,
name|unroll_number
argument_list|)
expr_stmt|;
comment|/* If final value is non-zero, then must emit an instruction which sets 	 the value of the biv to the proper value.  This is done after 	 handling all of the givs, since some of them may need to use the 	 biv's value in their initialization code.  */
if|if
condition|(
name|biv_final_value
condition|)
block|{
comment|/* If the loop has multiple exits, emit the insns before the 	     loop to ensure that it will always be executed no matter 	     how the loop exits.  Otherwise emit the insn after the loop, 	     since this is slightly more efficient.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|exit_count
condition|)
name|loop_insn_sink
argument_list|(
name|loop
argument_list|,
name|gen_move_insn
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|,
name|biv_final_value
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create a new register to hold the value of the biv, and then 		 set the biv to its final value before the loop start.  The biv 		 is set to its final value before loop start to ensure that 		 this insn will always be executed, no matter how the loop 		 exits.  */
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|mode
argument_list|)
decl_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|gen_move_insn
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|,
name|biv_final_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d mapped to %d for split.\n"
argument_list|,
name|REGNO
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the mapping from the original biv register to the new 		 register.  */
name|bl
operator|->
name|biv
operator|->
name|src_reg
operator|=
name|tem
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the first and last unrolled copy of the address giv V is valid    for the instruction that is using it.  Do not make any changes to that    instruction.  */
end_comment

begin_function
specifier|static
name|int
name|verify_addresses
parameter_list|(
name|v
parameter_list|,
name|giv_inc
parameter_list|,
name|unroll_number
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|giv_inc
decl_stmt|;
name|int
name|unroll_number
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|rtx
name|orig_addr
init|=
operator|*
name|v
operator|->
name|location
decl_stmt|;
name|rtx
name|last_addr
init|=
name|plus_constant
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|INTVAL
argument_list|(
name|giv_inc
argument_list|)
operator|*
operator|(
name|unroll_number
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
comment|/* First check to see if either address would fail.   Handle the fact      that we have may have a match_dup.  */
if|if
condition|(
operator|!
name|validate_replace_rtx
argument_list|(
operator|*
name|v
operator|->
name|location
argument_list|,
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|insn
argument_list|)
operator|||
operator|!
name|validate_replace_rtx
argument_list|(
operator|*
name|v
operator|->
name|location
argument_list|,
name|last_addr
argument_list|,
name|v
operator|->
name|insn
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* Now put things back the way they were before.  This should always    succeed.  */
if|if
condition|(
operator|!
name|validate_replace_rtx
argument_list|(
operator|*
name|v
operator|->
name|location
argument_list|,
name|orig_addr
argument_list|,
name|v
operator|->
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* For every giv based on the biv BL, check to determine whether it is    splittable.  This is a subroutine to find_splittable_regs ().     Return the number of instructions that set splittable registers.  */
end_comment

begin_function
specifier|static
name|int
name|find_splittable_givs
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|,
name|unroll_type
parameter_list|,
name|increment
parameter_list|,
name|unroll_number
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|enum
name|unroll_types
name|unroll_type
decl_stmt|;
name|rtx
name|increment
decl_stmt|;
name|int
name|unroll_number
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|rtx
name|final_value
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Scan the list of givs, and set the same_insn field when there are      multiple identical givs in the same insn.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
for|for
control|(
name|v2
operator|=
name|v
operator|->
name|next_iv
init|;
name|v2
condition|;
name|v2
operator|=
name|v2
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|insn
operator|==
name|v2
operator|->
name|insn
operator|&&
name|rtx_equal_p
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|v2
operator|->
name|new_reg
argument_list|)
operator|&&
operator|!
name|v2
operator|->
name|same_insn
condition|)
name|v2
operator|->
name|same_insn
operator|=
name|v
expr_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|rtx
name|giv_inc
decl_stmt|,
name|value
decl_stmt|;
comment|/* Only split the giv if it has already been reduced, or if the loop is 	 being completely unrolled.  */
if|if
condition|(
name|unroll_type
operator|!=
name|UNROLL_COMPLETELY
operator|&&
name|v
operator|->
name|ignore
condition|)
continue|continue;
comment|/* The giv can be split if the insn that sets the giv is executed once 	 and only once on every iteration of the loop.  */
comment|/* An address giv can always be split.  v->insn is just a use not a set, 	 and hence it does not matter whether it is always executed.  All that 	 matters is that all the biv increments are always executed, and we 	 won't reach here if they aren't.  */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|!=
name|DEST_ADDR
operator|&&
operator|(
operator|!
name|v
operator|->
name|always_computable
operator|||
name|back_branch_in_range_p
argument_list|(
name|loop
argument_list|,
name|v
operator|->
name|insn
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* The giv increment value must be a constant.  */
name|giv_inc
operator|=
name|fold_rtx_mult_add
argument_list|(
name|v
operator|->
name|mult_val
argument_list|,
name|increment
argument_list|,
name|const0_rtx
argument_list|,
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|giv_inc
operator|||
name|GET_CODE
argument_list|(
name|giv_inc
argument_list|)
operator|!=
name|CONST_INT
condition|)
continue|continue;
comment|/* The loop must be unrolled completely, or else have a known number of 	 iterations and only one exit, or else the giv must be dead outside 	 the loop, or else the final value of the giv must be known. 	 Otherwise, it is not safe to split the giv since it may not have the 	 proper value on loop exit.  */
comment|/* The used outside loop test will fail for DEST_ADDR givs.  They are 	 never used outside the loop anyways, so it is always safe to split a 	 DEST_ADDR giv.  */
name|final_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unroll_type
operator|!=
name|UNROLL_COMPLETELY
operator|&&
operator|(
name|loop
operator|->
name|exit_count
operator|||
name|unroll_type
operator|==
name|UNROLL_NAIVE
operator|)
operator|&&
name|v
operator|->
name|giv_type
operator|!=
name|DEST_ADDR
comment|/* The next part is true if the pseudo is used outside the loop. 	     We assume that this is true for any pseudo created after loop 	     starts, because we don't have a reg_n_info entry for them.  */
operator|&&
operator|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
operator|>=
name|max_reg_before_loop
operator|||
operator|(
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
comment|/* Check for the case where the pseudo is set by a shift/add 		     sequence, in which case the first insn setting the pseudo 		     is the first insn of the shift/add sequence.  */
operator|&&
operator|(
operator|!
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|v
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
operator|(
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
comment|/* Line above always fails if INSN was moved by loop opt.  */
operator|||
operator|(
name|REGNO_LAST_LUID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|end
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|final_value
operator|=
name|v
operator|->
name|final_value
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* Currently, non-reduced/final-value givs are never split.  */
comment|/* Should emit insns after the loop if possible, as the biv final value 	 code below does.  */
comment|/* If the final value is non-zero, and the giv has not been reduced, 	 then must emit an instruction to set the final value.  */
block|if (final_value&& !v->new_reg) 	{
comment|/* Create a new register to hold the value of the giv, and then set 	     the giv to its final value before the loop start.  The giv is set 	     to its final value before loop start to ensure that this insn 	     will always be executed, no matter how we exit.  */
block|tem = gen_reg_rtx (v->mode); 	  loop_insn_hoist (loop, gen_move_insn (tem, v->dest_reg)); 	  loop_insn_hoist (loop, gen_move_insn (v->dest_reg, final_value));  	  if (loop_dump_stream) 	    fprintf (loop_dump_stream, "Giv %d mapped to %d for split.\n", 		     REGNO (v->dest_reg), REGNO (tem));  	  v->src_reg = tem; 	}
endif|#
directive|endif
comment|/* This giv is splittable.  If completely unrolling the loop, save the 	 giv's initial value.  Otherwise, save the constant zero for it.  */
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
condition|)
block|{
comment|/* It is not safe to use bl->initial_value here, because it may not 	     be invariant.  It is safe to use the initial value stored in 	     the splittable_regs array if it is set.  In rare cases, it won't 	     be set, so then we do exactly the same thing as 	     find_splittable_regs does to get a safe value.  */
name|rtx
name|biv_initial_value
decl_stmt|;
if|if
condition|(
name|splittable_regs
index|[
name|bl
operator|->
name|regno
index|]
condition|)
name|biv_initial_value
operator|=
name|splittable_regs
index|[
name|bl
operator|->
name|regno
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|!=
name|bl
operator|->
name|regno
operator|&&
name|REGNO
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|biv_initial_value
operator|=
name|bl
operator|->
name|initial_value
expr_stmt|;
else|else
block|{
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|mode
argument_list|)
decl_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
name|biv_initial_value
operator|=
name|tem
expr_stmt|;
block|}
name|biv_initial_value
operator|=
name|extend_value_for_giv
argument_list|(
name|v
argument_list|,
name|biv_initial_value
argument_list|)
expr_stmt|;
name|value
operator|=
name|fold_rtx_mult_add
argument_list|(
name|v
operator|->
name|mult_val
argument_list|,
name|biv_initial_value
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|new_reg
condition|)
block|{
comment|/* If a giv was combined with another giv, then we can only split 	     this giv if the giv it was combined with was reduced.  This 	     is because the value of v->new_reg is meaningless in this 	     case.  */
if|if
condition|(
name|v
operator|->
name|same
operator|&&
operator|!
name|v
operator|->
name|same
operator|->
name|new_reg
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv combined with unreduced giv not split.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the giv is an address destination, it could be something other 	     than a simple register, these have to be treated differently.  */
elseif|else
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
condition|)
block|{
comment|/* If value is not a constant, register, or register plus 		 constant, then compute its value into a register before 		 loop start.  This prevents invalid rtx sharing, and should 		 generate better code.  We can use bl->initial_value here 		 instead of splittable_regs[bl->regno] because this code 		 is going before the loop start.  */
if|if
condition|(
name|unroll_type
operator|==
name|UNROLL_COMPLETELY
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|v
operator|->
name|mode
argument_list|)
decl_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_iv_add_mult_hoist
argument_list|(
name|loop
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|value
operator|=
name|tem
expr_stmt|;
block|}
name|splittable_regs
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Splitting address givs is useful since it will often allow us 		 to eliminate some increment insns for the base giv as 		 unnecessary.  */
comment|/* If the addr giv is combined with a dest_reg giv, then all 		 references to that dest reg will be remapped, which is NOT 		 what we want for split addr regs. We always create a new 		 register for the split addr giv, just to be safe.  */
comment|/* If we have multiple identical address givs within a 		 single instruction, then use a single pseudo reg for 		 both.  This is necessary in case one is a match_dup 		 of the other.  */
name|v
operator|->
name|const_adjust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|same_insn
condition|)
block|{
name|v
operator|->
name|dest_reg
operator|=
name|v
operator|->
name|same_insn
operator|->
name|dest_reg
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Sharing address givs in insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If multiple address GIVs have been combined with the 		 same dest_reg GIV, do not create a new register for 		 each.  */
elseif|else
if|if
condition|(
name|unroll_type
operator|!=
name|UNROLL_COMPLETELY
operator|&&
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|v
operator|->
name|same
operator|&&
name|v
operator|->
name|same
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|v
operator|->
name|same
operator|->
name|unrolled
comment|/* combine_givs_p may return true for some cases 			  where the add and mult values are not equal. 			  To share a register here, the values must be 			  equal.  */
operator|&&
name|rtx_equal_p
argument_list|(
name|v
operator|->
name|same
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|v
operator|->
name|same
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
comment|/* If the memory references have different modes, 			  then the address may not be valid and we must 			  not share registers.  */
operator|&&
name|verify_addresses
argument_list|(
name|v
argument_list|,
name|giv_inc
argument_list|,
name|unroll_number
argument_list|)
condition|)
block|{
name|v
operator|->
name|dest_reg
operator|=
name|v
operator|->
name|same
operator|->
name|dest_reg
expr_stmt|;
name|v
operator|->
name|shared
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unroll_type
operator|!=
name|UNROLL_COMPLETELY
condition|)
block|{
comment|/* If not completely unrolling the loop, then create a new 		     register to hold the split value of the DEST_ADDR giv. 		     Emit insn to initialize its value before loop start.  */
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|v
operator|->
name|mode
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|same
init|=
name|v
operator|->
name|same
decl_stmt|;
name|rtx
name|new_reg
init|=
name|v
operator|->
name|new_reg
decl_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the address giv has a constant in its new_reg value, 		     then this constant can be pulled out and put in value, 		     instead of being part of the initialization code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new_reg
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|new_reg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|v
operator|->
name|dest_reg
operator|=
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|new_reg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only succeed if this will give valid addresses. 			 Try to validate both the first and the last 			 address resulting from loop unrolling, if 			 one fails, then can't do const elim here.  */
if|if
condition|(
name|verify_addresses
argument_list|(
name|v
argument_list|,
name|giv_inc
argument_list|,
name|unroll_number
argument_list|)
condition|)
block|{
comment|/* Save the negative of the eliminated const, so 			     that we can calculate the dest_reg's increment 			     value later.  */
name|v
operator|->
name|const_adjust
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|new_reg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new_reg
operator|=
name|XEXP
argument_list|(
name|new_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Eliminating constant from giv %d\n"
argument_list|,
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|v
operator|->
name|dest_reg
operator|=
name|tem
expr_stmt|;
block|}
else|else
name|v
operator|->
name|dest_reg
operator|=
name|tem
expr_stmt|;
comment|/* If the address hasn't been checked for validity yet, do so 		     now, and fail completely if either the first or the last 		     unrolled copy of the address is not a valid address 		     for the instruction that uses it.  */
if|if
condition|(
name|v
operator|->
name|dest_reg
operator|==
name|tem
operator|&&
operator|!
name|verify_addresses
argument_list|(
name|v
argument_list|,
name|giv_inc
argument_list|,
name|unroll_number
argument_list|)
condition|)
block|{
for|for
control|(
name|v2
operator|=
name|v
operator|->
name|next_iv
init|;
name|v2
condition|;
name|v2
operator|=
name|v2
operator|->
name|next_iv
control|)
if|if
condition|(
name|v2
operator|->
name|same_insn
operator|==
name|v
condition|)
name|v2
operator|->
name|same_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Invalid address for giv at insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|v
operator|->
name|new_reg
operator|=
name|new_reg
expr_stmt|;
name|v
operator|->
name|same
operator|=
name|same
expr_stmt|;
comment|/* We set this after the address check, to guarantee that 		     the register will be initialized.  */
name|v
operator|->
name|unrolled
operator|=
literal|1
expr_stmt|;
comment|/* To initialize the new register, just move the value of 		     new_reg into it.  This is not guaranteed to give a valid 		     instruction on machines with complex addressing modes. 		     If we can't recognize it, then delete it and emit insns 		     to calculate the value from scratch.  */
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tem
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|PREV_INSN
argument_list|(
name|loop
operator|->
name|start
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|sequence
decl_stmt|,
name|ret
decl_stmt|;
comment|/* We can't use bl->initial_value to compute the initial 			 value, because the loop may have been preconditioned. 			 We must calculate it from NEW_REG.  */
name|delete_related_insns
argument_list|(
name|PREV_INSN
argument_list|(
name|loop
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|ret
operator|=
name|force_operand
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|tem
condition|)
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Invalid init insn, rewritten.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|v
operator|->
name|dest_reg
operator|=
name|value
expr_stmt|;
comment|/* Check the resulting address for validity, and fail 		     if the resulting address would be invalid.  */
if|if
condition|(
operator|!
name|verify_addresses
argument_list|(
name|v
argument_list|,
name|giv_inc
argument_list|,
name|unroll_number
argument_list|)
condition|)
block|{
for|for
control|(
name|v2
operator|=
name|v
operator|->
name|next_iv
init|;
name|v2
condition|;
name|v2
operator|=
name|v2
operator|->
name|next_iv
control|)
if|if
condition|(
name|v2
operator|->
name|same_insn
operator|==
name|v
condition|)
name|v2
operator|->
name|same_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Invalid address for giv at insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Store the value of dest_reg into the insn.  This sharing 		 will not be a problem as this insn will always be copied 		 later.  */
operator|*
name|v
operator|->
name|location
operator|=
name|v
operator|->
name|dest_reg
expr_stmt|;
comment|/* If this address giv is combined with a dest reg giv, then 		 save the base giv's induction pointer so that we will be 		 able to handle this address giv properly.  The base giv 		 itself does not have to be splittable.  */
if|if
condition|(
name|v
operator|->
name|same
operator|&&
name|v
operator|->
name|same
operator|->
name|giv_type
operator|==
name|DEST_REG
condition|)
name|addr_combined_regs
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|same
operator|->
name|new_reg
argument_list|)
index|]
operator|=
name|v
operator|->
name|same
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* This giv maybe hasn't been combined with any others. 		     Make sure that it's giv is marked as splittable here.  */
name|splittable_regs
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
comment|/* Make it appear to depend upon itself, so that the 		     giv will be properly split in the main loop above.  */
if|if
condition|(
operator|!
name|v
operator|->
name|same
condition|)
block|{
name|v
operator|->
name|same
operator|=
name|v
expr_stmt|;
name|addr_combined_regs
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"DEST_ADDR giv being split.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* Currently, unreduced giv's can't be split.  This is not too much 	     of a problem since unreduced giv's are not live across loop 	     iterations anyways.  When unrolling a loop completely though, 	     it makes sense to reduce&split givs when possible, as this will 	     result in simpler instructions, and will not require that a reg 	     be live across loop iterations.  */
block|splittable_regs[REGNO (v->dest_reg)] = value; 	  fprintf (stderr, "Giv %d at insn %d not reduced\n", 		   REGNO (v->dest_reg), INSN_UID (v->insn));
else|#
directive|else
continue|continue;
endif|#
directive|endif
block|}
comment|/* Unreduced givs are only updated once by definition.  Reduced givs 	 are updated as many times as their biv is.  Mark it so if this is 	 a splittable register.  Don't need to do anything for address givs 	 where this may not be a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|ignore
condition|)
name|count
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|)
operator|->
name|biv_count
expr_stmt|;
name|splittable_regs_updates
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
index|]
operator|=
name|count
expr_stmt|;
block|}
name|result
operator|++
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
operator|==
name|CONST_INT
condition|)
name|regnum
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
operator|!=
name|REG
condition|)
name|regnum
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|regnum
operator|=
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Giv %d at insn %d safe to split.\n"
argument_list|,
name|regnum
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to prove that the register is dead after the loop exits.  Trace every    loop exit looking for an insn that will always be executed, which sets    the register to some value, and appears before the first use of the register    is found.  If successful, then return 1, otherwise return 0.  */
end_comment

begin_comment
comment|/* ?? Could be made more intelligent in the handling of jumps, so that    it can search past if statements and other similar structures.  */
end_comment

begin_function
specifier|static
name|int
name|reg_dead_after_loop
parameter_list|(
name|loop
parameter_list|,
name|reg
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|jump_count
init|=
literal|0
decl_stmt|;
name|int
name|label_count
init|=
literal|0
decl_stmt|;
comment|/* In addition to checking all exits of this loop, we must also check      all exits of inner nested loops that would exit this loop.  We don't      have any way to identify those, so we just give up if there are any      such inner loop exits.  */
for|for
control|(
name|label
operator|=
name|loop
operator|->
name|exit_labels
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
name|label_count
operator|++
expr_stmt|;
if|if
condition|(
name|label_count
operator|!=
name|loop
operator|->
name|exit_count
condition|)
return|return
literal|0
return|;
comment|/* HACK: Must also search the loop fall through exit, create a label_ref      here which points to the loop->end, and append the loop_number_exit_labels      list to it.  */
name|label
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
operator|=
name|loop
operator|->
name|exit_labels
expr_stmt|;
for|for
control|(
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
block|{
comment|/* Succeed if find an insn which sets the biv or if reach end of 	 function.  Fail if find an insn that uses the biv, or if come to 	 a conditional jump.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
comment|/* Prevent infinite loop following infinite loops.  */
operator|||
name|jump_count
operator|++
operator|>
literal|20
condition|)
return|return
literal|0
return|;
else|else
name|insn
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Success, the register is dead on all loop exits.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Try to calculate the final value of the biv, the value it will have at    the end of the loop.  If we can do it, return that value.  */
end_comment

begin_function
name|rtx
name|final_biv_value
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|n_iterations
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|n_iterations
decl_stmt|;
name|rtx
name|increment
decl_stmt|,
name|tem
decl_stmt|;
comment|/* ??? This only works for MODE_INT biv's.  Reject all others for now.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|mode
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
literal|0
return|;
comment|/* The final value for reversed bivs must be calculated differently than      for ordinary bivs.  In this case, there is already an insn after the      loop which sets this biv's final value (if necessary), and there are      no other loop exits, so we can return any value.  */
if|if
condition|(
name|bl
operator|->
name|reversed
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Final biv value for %d, reversed biv.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* Try to calculate the final value as initial value + (number of iterations      * increment).  For this to work, increment must be invariant, the only      exit from the loop must be the fall through at the bottom (otherwise      it may not have its final value when the loop exits), and the initial      value of the biv must be invariant.  */
if|if
condition|(
name|n_iterations
operator|!=
literal|0
operator|&&
operator|!
name|loop
operator|->
name|exit_count
operator|&&
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
condition|)
block|{
name|increment
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
operator|&&
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|increment
argument_list|)
condition|)
block|{
comment|/* Can calculate the loop exit value, emit insns after loop 	     end to calculate this value into a temporary register in 	     case it is needed later.  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|mode
argument_list|)
expr_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_iv_add_mult_sink
argument_list|(
name|loop
argument_list|,
name|increment
argument_list|,
name|GEN_INT
argument_list|(
name|n_iterations
argument_list|)
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Final biv value for %d, calculated.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
comment|/* Check to see if the biv is dead at all loop exits.  */
if|if
condition|(
name|reg_dead_after_loop
argument_list|(
name|loop
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Final biv value for %d, biv dead after loop exit.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to calculate the final value of the giv, the value it will have at    the end of the loop.  If we can do it, return that value.  */
end_comment

begin_function
name|rtx
name|final_giv_value
parameter_list|(
name|loop
parameter_list|,
name|v
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|increment
decl_stmt|,
name|tem
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|loop_end
init|=
name|loop
operator|->
name|end
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n_iterations
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|n_iterations
decl_stmt|;
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The final value for givs which depend on reversed bivs must be calculated      differently than for ordinary givs.  In this case, there is already an      insn after the loop which sets this giv's final value (if necessary),      and there are no other loop exits, so we can return any value.  */
if|if
condition|(
name|bl
operator|->
name|reversed
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Final giv value for %d, depends on reversed biv\n"
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* Try to calculate the final value as a function of the biv it depends      upon.  The only exit from the loop must be the fall through at the bottom      (otherwise it may not have its final value when the loop exits).  */
comment|/* ??? Can calculate the final giv value by subtracting off the      extra biv increments times the giv's mult_val.  The loop must have      only one exit for this to work, but the loop iterations does not need      to be known.  */
if|if
condition|(
name|n_iterations
operator|!=
literal|0
operator|&&
operator|!
name|loop
operator|->
name|exit_count
condition|)
block|{
comment|/* ?? It is tempting to use the biv's value here since these insns will 	 be put after the loop, and hence the biv will have its final value 	 then.  However, this fails if the biv is subsequently eliminated. 	 Perhaps determine whether biv's are eliminable before trying to 	 determine whether giv's are replaceable so that we can use the 	 biv value here if it is not eliminable.  */
comment|/* We are emitting code after the end of the loop, so we must make 	 sure that bl->initial_value is still valid then.  It will still 	 be valid if it is invariant.  */
name|increment
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
operator|&&
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|increment
argument_list|)
operator|&&
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
condition|)
block|{
comment|/* Can calculate the loop exit value of its biv as 	     (n_iterations * increment) + initial_value */
comment|/* The loop exit value of the giv is then 	     (final_biv_value - extra increments) * mult_val + add_val. 	     The extra increments are any increments to the biv which 	     occur in the loop after the giv's value is calculated. 	     We must search from the insn that sets the giv to the end 	     of the loop to calculate this value.  */
comment|/* Put the final biv value in tem.  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|tem
argument_list|)
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_iv_add_mult_sink
argument_list|(
name|loop
argument_list|,
name|extend_value_for_giv
argument_list|(
name|v
argument_list|,
name|increment
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|n_iterations
argument_list|)
argument_list|,
name|extend_value_for_giv
argument_list|(
name|v
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* Subtract off extra increments as we find them.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
init|;
name|insn
operator|!=
name|loop_end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|induction
modifier|*
name|biv
decl_stmt|;
for|for
control|(
name|biv
operator|=
name|bl
operator|->
name|biv
init|;
name|biv
condition|;
name|biv
operator|=
name|biv
operator|->
name|next_iv
control|)
if|if
condition|(
name|biv
operator|->
name|insn
operator|==
name|insn
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|tem
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|MINUS
argument_list|,
name|tem
argument_list|,
name|biv
operator|->
name|add_val
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|loop_insn_sink
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now calculate the giv's final value.  */
name|loop_iv_add_mult_sink
argument_list|(
name|loop
argument_list|,
name|tem
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Final giv value for %d, calc from biv's value.\n"
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
comment|/* Replaceable giv's should never reach here.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check to see if the biv is dead at all loop exits.  */
if|if
condition|(
name|reg_dead_after_loop
argument_list|(
name|loop
argument_list|,
name|v
operator|->
name|dest_reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Final giv value for %d, giv dead after loop exit.\n"
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look back before LOOP->START for the insn that sets REG and return    the equivalent constant if there is a REG_EQUAL note otherwise just    the SET_SRC of REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|loop_find_equiv_value
parameter_list|(
name|loop
parameter_list|,
name|reg
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|ret
operator|=
name|reg
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
block|{
comment|/* We found the last insn before the loop that sets the register. 	     If it sets the entire register, and has a REG_EQUAL note, 	     then use the value of the REG_EQUAL note.  */
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
comment|/* Only use the REG_EQUAL note if it is a constant. 		 Other things, divide in particular, will cause 		 problems later if we use them.  */
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* We cannot do this if it changes between the 		 assignment and loop start though.  */
if|if
condition|(
name|modified_between_p
argument_list|(
name|ret
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
condition|)
name|ret
operator|=
name|reg
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a simplified rtx for the expression OP - REG.     REG must appear in OP, and OP must be a register or the sum of a register    and a second term.     Thus, the return value must be const0_rtx or the second term.     The caller is responsible for verifying that REG appears in OP and OP has    the proper form.  */
end_comment

begin_function
specifier|static
name|rtx
name|subtract_reg_term
parameter_list|(
name|op
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|op
decl_stmt|,
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|reg
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|reg
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* OP does not contain REG as a term.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find and return register term common to both expressions OP0 and    OP1 or NULL_RTX if no such term exists.  Each expression must be a    REG or a PLUS of a REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_common_reg_term
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|)
condition|)
block|{
name|rtx
name|op00
decl_stmt|;
name|rtx
name|op01
decl_stmt|;
name|rtx
name|op10
decl_stmt|;
name|rtx
name|op11
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
condition|)
name|op01
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|,
name|op00
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op01
operator|=
name|const0_rtx
operator|,
name|op00
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
condition|)
name|op11
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|,
name|op10
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op11
operator|=
name|const0_rtx
operator|,
name|op10
operator|=
name|op1
expr_stmt|;
comment|/* Find and return common register term if present.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op00
argument_list|)
operator|&&
operator|(
name|op00
operator|==
name|op10
operator|||
name|op00
operator|==
name|op11
operator|)
condition|)
return|return
name|op00
return|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|op01
argument_list|)
operator|&&
operator|(
name|op01
operator|==
name|op10
operator|||
name|op01
operator|==
name|op11
operator|)
condition|)
return|return
name|op01
return|;
block|}
comment|/* No common register term found.  */
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Determine the loop iterator and calculate the number of loop    iterations.  Returns the exact number of loop iterations if it can    be calculated, otherwise returns zero.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|loop_iterations
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|comparison
decl_stmt|,
name|comparison_value
decl_stmt|;
name|rtx
name|iteration_var
decl_stmt|,
name|initial_value
decl_stmt|,
name|increment
decl_stmt|,
name|final_value
decl_stmt|;
name|enum
name|rtx_code
name|comparison_code
decl_stmt|;
name|HOST_WIDE_INT
name|inc
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|abs_inc
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|abs_diff
decl_stmt|;
name|int
name|off_by_one
decl_stmt|;
name|int
name|increment_dir
decl_stmt|;
name|int
name|unsigned_p
decl_stmt|,
name|compare_dir
decl_stmt|,
name|final_larger
decl_stmt|;
name|rtx
name|last_loop_insn
decl_stmt|;
name|rtx
name|reg_term
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|loop_info
operator|->
name|n_iterations
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|initial_value
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|initial_equiv_value
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|comparison_value
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|final_value
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|final_equiv_value
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|increment
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|iteration_var
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|unroll_number
operator|=
literal|1
expr_stmt|;
name|loop_info
operator|->
name|iv
operator|=
literal|0
expr_stmt|;
comment|/* We used to use prev_nonnote_insn here, but that fails because it might      accidentally get the branch for a contained loop if the branch for this      loop was deleted.  We can only trust branches immediately before the      loop_end.  */
name|last_loop_insn
operator|=
name|PREV_INSN
argument_list|(
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* ??? We should probably try harder to find the jump insn      at the end of the loop.  The following code assumes that      the last loop insn is a jump to the top of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: No final conditional branch found.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If there is a more than a single jump to the top of the loop      we cannot (easily) determine the iteration count.  */
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|last_loop_insn
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Loop has multiple back edges.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If there are multiple conditionalized loop exit tests, they may jump      back to differing CODE_LABELs.  */
if|if
condition|(
name|loop
operator|->
name|top
operator|&&
name|loop
operator|->
name|cont
condition|)
block|{
name|rtx
name|temp
init|=
name|PREV_INSN
argument_list|(
name|last_loop_insn
argument_list|)
decl_stmt|;
do|do
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* There are some kinds of jumps we can't deal with easily.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Jump insn has null JUMP_LABEL.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
comment|/* Previous unrolling may have generated new insns not 		     covered by the uid_luid array.  */
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
name|max_uid_for_loop
comment|/* Check if we jump back into the loop body.  */
operator|&&
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|top
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Loop has multiple back edges.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|loop
operator|->
name|cont
condition|)
do|;
block|}
comment|/* Find the iteration variable.  If the last insn is a conditional      branch, and the insn before tests a register value, make that the      iteration variable.  */
name|comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|loop
argument_list|,
name|last_loop_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: No final comparison found.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ??? Get_condition may switch position of induction variable and      invariant register when it canonicalizes the comparison.  */
name|comparison_code
operator|=
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
expr_stmt|;
name|iteration_var
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|comparison_value
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|iteration_var
argument_list|)
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Comparison not against register.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The only new registers that are created before loop iterations      are givs made from biv increments or registers created by      load_mems.  In the latter case, it is possible that try_copy_prop      will propagate a new pseudo into the old iteration register but      this will be marked by having the REG_USERVAR_P bit set.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
operator|>=
name|ivs
operator|->
name|n_regs
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|iteration_var
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Determine the initial value of the iteration variable, and the amount      that it is incremented each loop.  Use the tables constructed by      the strength reduction pass to calculate these values.  */
comment|/* Clear the result values, in case no answer can be found.  */
name|initial_value
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|0
expr_stmt|;
comment|/* The iteration variable can be either a giv or a biv.  Check to see      which it is, and compute the variable's initial value, and increment      value if possible.  */
comment|/* If this is a new register, can't handle it since we don't have any      reg_iv_type entry for it.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
operator|>=
name|ivs
operator|->
name|n_regs
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: No reg_iv_type entry for iteration var.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Reject iteration variables larger than the host wide int size, since they      could result in a number of iterations greater than the range of our      `unsigned HOST_WIDE_INT' variable loop_info->n_iterations.  */
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Iteration var rejected because mode too large.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Iteration var not an integer.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
operator|==
name|BASIC_INDUCT
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
operator|>=
name|ivs
operator|->
name|n_regs
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Grab initial value, only useful if it is a constant.  */
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
expr_stmt|;
name|initial_value
operator|=
name|bl
operator|->
name|initial_value
expr_stmt|;
if|if
condition|(
operator|!
name|bl
operator|->
name|biv
operator|->
name|always_executed
operator|||
name|bl
operator|->
name|biv
operator|->
name|maybe_multiple
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Basic induction var not set once in each iteration.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|increment
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
operator|==
name|GENERAL_INDUCT
condition|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
init|=
name|REG_IV_INFO
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|biv_initial_value
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
operator|>=
name|ivs
operator|->
name|n_regs
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|always_executed
operator|||
name|v
operator|->
name|maybe_multiple
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: General induction var not set once in each iteration.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Increment value is mult_val times the increment value of the biv.  */
name|increment
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
name|struct
name|induction
modifier|*
name|biv_inc
decl_stmt|;
name|increment
operator|=
name|fold_rtx_mult_add
argument_list|(
name|v
operator|->
name|mult_val
argument_list|,
name|extend_value_for_giv
argument_list|(
name|v
argument_list|,
name|increment
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* The caller assumes that one full increment has occurred at the 	     first loop test.  But that's not true when the biv is incremented 	     after the giv is set (which is the usual case), e.g.: 	     i = 6; do {;} while (i++< 9) . 	     Therefore, we bias the initial value by subtracting the amount of 	     the increment that occurs between the giv set and the giv test.  */
for|for
control|(
name|biv_inc
operator|=
name|bl
operator|->
name|biv
init|;
name|biv_inc
condition|;
name|biv_inc
operator|=
name|biv_inc
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|loop_insn_first_p
argument_list|(
name|v
operator|->
name|insn
argument_list|,
name|biv_inc
operator|->
name|insn
argument_list|)
condition|)
name|offset
operator|-=
name|INTVAL
argument_list|(
name|biv_inc
operator|->
name|add_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Giv iterator, initial value bias %ld.\n"
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Initial value is mult_val times the biv's initial value plus 	 add_val.  Only useful if it is a constant.  */
name|biv_initial_value
operator|=
name|extend_value_for_giv
argument_list|(
name|v
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
expr_stmt|;
name|initial_value
operator|=
name|fold_rtx_mult_add
argument_list|(
name|v
operator|->
name|mult_val
argument_list|,
name|plus_constant
argument_list|(
name|biv_initial_value
argument_list|,
name|offset
argument_list|)
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Not basic or general induction var.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|initial_value
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|unsigned_p
operator|=
literal|0
expr_stmt|;
name|off_by_one
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|comparison_code
condition|)
block|{
case|case
name|LEU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
case|case
name|LE
case|:
name|compare_dir
operator|=
literal|1
expr_stmt|;
name|off_by_one
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
case|case
name|GE
case|:
name|compare_dir
operator|=
operator|-
literal|1
expr_stmt|;
name|off_by_one
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|EQ
case|:
comment|/* Cannot determine loop iterations with this case.  */
name|compare_dir
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
case|case
name|LT
case|:
name|compare_dir
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
case|case
name|GT
case|:
name|compare_dir
operator|=
operator|-
literal|1
expr_stmt|;
case|case
name|NE
case|:
name|compare_dir
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If the comparison value is an invariant register, then try to find      its value from the insns before the start of the loop.  */
name|final_value
operator|=
name|comparison_value
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|REG
operator|&&
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|comparison_value
argument_list|)
condition|)
block|{
name|final_value
operator|=
name|loop_find_equiv_value
argument_list|(
name|loop
argument_list|,
name|comparison_value
argument_list|)
expr_stmt|;
comment|/* If we don't get an invariant final value, we are better 	 off with the original register.  */
if|if
condition|(
operator|!
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|final_value
argument_list|)
condition|)
name|final_value
operator|=
name|comparison_value
expr_stmt|;
block|}
comment|/* Calculate the approximate final value of the induction variable      (on the last successful iteration).  The exact final value      depends on the branch operator, and increment sign.  It will be      wrong if the iteration variable is not incremented by one each      time through the loop and (comparison_value + off_by_one -      initial_value) % increment != 0.      ??? Note that the final_value may overflow and thus final_larger      will be bogus.  A potentially infinite loop will be classified      as immediate, e.g. for (i = 0x7ffffff0; i<= 0x7fffffff; i++)  */
if|if
condition|(
name|off_by_one
condition|)
name|final_value
operator|=
name|plus_constant
argument_list|(
name|final_value
argument_list|,
name|off_by_one
argument_list|)
expr_stmt|;
comment|/* Save the calculated values describing this loop's bounds, in case      precondition_loop_p will need them later.  These values can not be      recalculated inside precondition_loop_p because strength reduction      optimizations may obscure the loop's structure.       These values are only required by precondition_loop_p and insert_bct      whenever the number of iterations cannot be computed at compile time.      Only the difference between final_value and initial_value is      important.  Note that final_value is only approximate.  */
name|loop_info
operator|->
name|initial_value
operator|=
name|initial_value
expr_stmt|;
name|loop_info
operator|->
name|comparison_value
operator|=
name|comparison_value
expr_stmt|;
name|loop_info
operator|->
name|final_value
operator|=
name|plus_constant
argument_list|(
name|comparison_value
argument_list|,
name|off_by_one
argument_list|)
expr_stmt|;
name|loop_info
operator|->
name|increment
operator|=
name|increment
expr_stmt|;
name|loop_info
operator|->
name|iteration_var
operator|=
name|iteration_var
expr_stmt|;
name|loop_info
operator|->
name|comparison_code
operator|=
name|comparison_code
expr_stmt|;
name|loop_info
operator|->
name|iv
operator|=
name|bl
expr_stmt|;
comment|/* Try to determine the iteration count for loops such      as (for i = init; i< init + const; i++).  When running the      loop optimization twice, the first pass often converts simple      loops into this form.  */
if|if
condition|(
name|REG_P
argument_list|(
name|initial_value
argument_list|)
condition|)
block|{
name|rtx
name|reg1
decl_stmt|;
name|rtx
name|reg2
decl_stmt|;
name|rtx
name|const2
decl_stmt|;
name|reg1
operator|=
name|initial_value
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|final_value
argument_list|)
operator|==
name|PLUS
condition|)
name|reg2
operator|=
name|XEXP
argument_list|(
name|final_value
argument_list|,
literal|0
argument_list|)
operator|,
name|const2
operator|=
name|XEXP
argument_list|(
name|final_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|reg2
operator|=
name|final_value
operator|,
name|const2
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Check for initial_value = reg1, final_value = reg2 + const2, 	 where reg1 != reg2.  */
if|if
condition|(
name|REG_P
argument_list|(
name|reg2
argument_list|)
operator|&&
name|reg2
operator|!=
name|reg1
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* Find what reg1 is equivalent to.  Hopefully it will 	     either be reg2 or reg2 plus a constant.  */
name|temp
operator|=
name|loop_find_equiv_value
argument_list|(
name|loop
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_common_reg_term
argument_list|(
name|temp
argument_list|,
name|reg2
argument_list|)
condition|)
name|initial_value
operator|=
name|temp
expr_stmt|;
else|else
block|{
comment|/* Find what reg2 is equivalent to.  Hopefully it will 		 either be reg1 or reg1 plus a constant.  Let's ignore 		 the latter case for now since it is not so common.  */
name|temp
operator|=
name|loop_find_equiv_value
argument_list|(
name|loop
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|loop_info
operator|->
name|iteration_var
condition|)
name|temp
operator|=
name|initial_value
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|reg1
condition|)
name|final_value
operator|=
operator|(
name|const2
operator|==
name|const0_rtx
operator|)
condition|?
name|reg1
else|:
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|reg1
argument_list|)
argument_list|,
name|reg1
argument_list|,
name|const2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|loop
operator|->
name|vtop
operator|&&
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* When running the loop optimizer twice, check_dbra_loop 	     further obfuscates reversible loops of the form: 	     for (i = init; i< init + const; i++).  We often end up with 	     final_value = 0, initial_value = temp, temp = temp2 - init, 	     where temp2 = init + const.  If the loop has a vtop we 	     can replace initial_value with const.  */
name|temp
operator|=
name|loop_find_equiv_value
argument_list|(
name|loop
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MINUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp2
init|=
name|loop_find_equiv_value
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
condition|)
name|initial_value
operator|=
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If have initial_value = reg + const1 and final_value = reg +      const2, then replace initial_value with const1 and final_value      with const2.  This should be safe since we are protected by the      initial comparison before entering the loop if we have a vtop.      For example, a + b< a + c is not equivalent to b< c for all a      when using modulo arithmetic.       ??? Without a vtop we could still perform the optimization if we check      the initial and final values carefully.  */
if|if
condition|(
name|loop
operator|->
name|vtop
operator|&&
operator|(
name|reg_term
operator|=
name|find_common_reg_term
argument_list|(
name|initial_value
argument_list|,
name|final_value
argument_list|)
operator|)
condition|)
block|{
name|initial_value
operator|=
name|subtract_reg_term
argument_list|(
name|initial_value
argument_list|,
name|reg_term
argument_list|)
expr_stmt|;
name|final_value
operator|=
name|subtract_reg_term
argument_list|(
name|final_value
argument_list|,
name|reg_term
argument_list|)
expr_stmt|;
block|}
name|loop_info
operator|->
name|initial_equiv_value
operator|=
name|initial_value
expr_stmt|;
name|loop_info
operator|->
name|final_equiv_value
operator|=
name|final_value
expr_stmt|;
comment|/* For EQ comparison loops, we don't have a valid final value.      Check this now so that we won't leave an invalid value if we      return early for any other reason.  */
if|if
condition|(
name|comparison_code
operator|==
name|EQ
condition|)
name|loop_info
operator|->
name|final_equiv_value
operator|=
name|loop_info
operator|->
name|final_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|increment
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Increment value can't be calculated.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* If we have a REG, check to see if REG holds a constant value.  */
comment|/* ??? Other RTL, such as (neg (reg)) is possible here, but it isn't 	 clear if it is worthwhile to try to handle such RTL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|==
name|SUBREG
condition|)
name|increment
operator|=
name|loop_find_equiv_value
argument_list|(
name|loop
argument_list|,
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Increment value not constant "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|increment
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|loop_info
operator|->
name|increment
operator|=
name|increment
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Initial value not constant "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|initial_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|comparison_code
operator|==
name|EQ
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: EQ comparison loop.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|final_value
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Final value not constant "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|final_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Final_larger is 1 if final larger, 0 if they are equal, otherwise -1.  */
if|if
condition|(
name|unsigned_p
condition|)
name|final_larger
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|final_value
argument_list|)
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
operator|)
operator|-
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|final_value
argument_list|)
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
operator|)
expr_stmt|;
else|else
name|final_larger
operator|=
operator|(
name|INTVAL
argument_list|(
name|final_value
argument_list|)
operator|>
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
operator|)
operator|-
operator|(
name|INTVAL
argument_list|(
name|final_value
argument_list|)
operator|<
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|>
literal|0
condition|)
name|increment_dir
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|==
literal|0
condition|)
name|increment_dir
operator|=
literal|0
expr_stmt|;
else|else
name|increment_dir
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* There are 27 different cases: compare_dir = -1, 0, 1;      final_larger = -1, 0, 1; increment_dir = -1, 0, 1.      There are 4 normal cases, 4 reverse cases (where the iteration variable      will overflow before the loop exits), 4 infinite loop cases, and 15      immediate exit (0 or 1 iteration depending on loop type) cases.      Only try to optimize the normal cases.  */
comment|/* (compare_dir/final_larger/increment_dir)      Normal cases: (0/-1/-1), (0/1/1), (-1/-1/-1), (1/1/1)      Reverse cases: (0/-1/1), (0/1/-1), (-1/-1/1), (1/1/-1)      Infinite loops: (0/-1/0), (0/1/0), (-1/-1/0), (1/1/0)      Immediate exit: (0/0/X), (-1/0/X), (-1/1/X), (1/0/X), (1/-1/X) */
comment|/* ?? If the meaning of reverse loops (where the iteration variable      will overflow before the loop exits) is undefined, then could      eliminate all of these special checks, and just always assume      the loops are normal/immediate/infinite.  Note that this means      the sign of increment_dir does not have to be known.  Also,      since it does not really hurt if immediate exit loops or infinite loops      are optimized, then that case could be ignored also, and hence all      loops can be optimized.       According to ANSI Spec, the reverse loop case result is undefined,      because the action on overflow is undefined.       See also the special test for NE loops below.  */
if|if
condition|(
name|final_larger
operator|==
name|increment_dir
operator|&&
name|final_larger
operator|!=
literal|0
operator|&&
operator|(
name|final_larger
operator|==
name|compare_dir
operator|||
name|compare_dir
operator|==
literal|0
operator|)
condition|)
comment|/* Normal case.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop iterations: Not normal loop.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Calculate the number of iterations, final_value is only an approximation,      so correct for that.  Note that abs_diff and n_iterations are      unsigned, because they can be as large as 2^n - 1.  */
name|inc
operator|=
name|INTVAL
argument_list|(
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|>
literal|0
condition|)
block|{
name|abs_diff
operator|=
name|INTVAL
argument_list|(
name|final_value
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
expr_stmt|;
name|abs_inc
operator|=
name|inc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inc
operator|<
literal|0
condition|)
block|{
name|abs_diff
operator|=
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|final_value
argument_list|)
expr_stmt|;
name|abs_inc
operator|=
operator|-
name|inc
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Given that iteration_var is going to iterate over its own mode,      not HOST_WIDE_INT, disregard higher bits that might have come      into the picture due to sign extension of initial and final      values.  */
name|abs_diff
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* For NE tests, make sure that the iteration variable won't miss      the final value.  If abs_diff mod abs_incr is not zero, then the      iteration variable will overflow before the loop exits, and we      can not calculate the number of iterations.  */
if|if
condition|(
name|compare_dir
operator|==
literal|0
operator|&&
operator|(
name|abs_diff
operator|%
name|abs_inc
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Note that the number of iterations could be calculated using      (abs_diff + abs_inc - 1) / abs_inc, provided care was taken to      handle potential overflow of the summation.  */
name|loop_info
operator|->
name|n_iterations
operator|=
name|abs_diff
operator|/
name|abs_inc
operator|+
operator|(
operator|(
name|abs_diff
operator|%
name|abs_inc
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|loop_info
operator|->
name|n_iterations
return|;
block|}
end_function

begin_comment
comment|/* Replace uses of split bivs with their split pseudo register.  This is    for original instructions which remain after loop unrolling without    copying.  */
end_comment

begin_function
specifier|static
name|rtx
name|remap_split_bivs
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
if|#
directive|if
literal|0
comment|/* If non-reduced/final-value givs were split, then this would also 	 have to remap those givs also.  */
endif|#
directive|endif
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|ivs
operator|->
name|n_regs
operator|&&
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|BASIC_INDUCT
condition|)
return|return
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|->
name|biv
operator|->
name|src_reg
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|remap_split_bivs
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|remap_split_bivs
argument_list|(
name|loop
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* If FIRST_UID is a set of REGNO, and FIRST_UID dominates LAST_UID (e.g.    FIST_UID is always executed if LAST_UID is), then return 1.  Otherwise    return 0.  COPY_START is where we can start looking for the insns    FIRST_UID and LAST_UID.  COPY_END is where we stop looking for these    insns.     If there is no JUMP_INSN between LOOP_START and FIRST_UID, then FIRST_UID    must dominate LAST_UID.     If there is a CODE_LABEL between FIRST_UID and LAST_UID, then FIRST_UID    may not dominate LAST_UID.     If there is no CODE_LABEL between FIRST_UID and LAST_UID, then FIRST_UID    must dominate LAST_UID.  */
end_comment

begin_function
name|int
name|set_dominates_use
parameter_list|(
name|regno
parameter_list|,
name|first_uid
parameter_list|,
name|last_uid
parameter_list|,
name|copy_start
parameter_list|,
name|copy_end
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|first_uid
decl_stmt|;
name|int
name|last_uid
decl_stmt|;
name|rtx
name|copy_start
decl_stmt|;
name|rtx
name|copy_end
decl_stmt|;
block|{
name|int
name|passed_jump
init|=
literal|0
decl_stmt|;
name|rtx
name|p
init|=
name|NEXT_INSN
argument_list|(
name|copy_start
argument_list|)
decl_stmt|;
while|while
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|!=
name|first_uid
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|passed_jump
operator|=
literal|1
expr_stmt|;
comment|/* Could not find FIRST_UID.  */
if|if
condition|(
name|p
operator|==
name|copy_end
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Verify that FIRST_UID is an insn that entirely sets REGNO.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|||
operator|!
name|dead_or_set_regno_p
argument_list|(
name|p
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FIRST_UID is always executed.  */
if|if
condition|(
name|passed_jump
operator|==
literal|0
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|!=
name|last_uid
condition|)
block|{
comment|/* If we see a CODE_LABEL between FIRST_UID and LAST_UID, then we 	 can not be sure that FIRST_UID dominates LAST_UID.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
comment|/* Could not find LAST_UID, but we reached the end of the loop, so 	 it must be safe.  */
elseif|else
if|if
condition|(
name|p
operator|==
name|copy_end
condition|)
return|return
literal|1
return|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* FIRST_UID is always executed if LAST_UID is executed.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine is called when the number of iterations for the unrolled    loop is one.   The goal is to identify a loop that begins with an    unconditional branch to the loop continuation note (or a label just after).    In this case, the unconditional branch that starts the loop needs to be    deleted so that we execute the single iteration.  */
end_comment

begin_function
specifier|static
name|rtx
name|ujump_to_loop_cont
parameter_list|(
name|loop_start
parameter_list|,
name|loop_cont
parameter_list|)
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|loop_cont
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|,
name|label
decl_stmt|,
name|label_ref
decl_stmt|;
comment|/* See if loop start, or the next insn is an unconditional jump.  */
name|loop_start
operator|=
name|next_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
name|x
operator|=
name|pc_set
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
name|NULL_RTX
return|;
name|label_ref
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|label_ref
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Examine insn after loop continuation note.  Return if not a label.  */
name|label
operator|=
name|next_nonnote_insn
argument_list|(
name|loop_cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Return the loop start if the branch label matches the code label.  */
if|if
condition|(
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|label_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|loop_start
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
end_function

end_unit

