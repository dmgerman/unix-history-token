begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* If-conversion for vectorizer.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.    Contributed by Devang Patel<dpatel@apple.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This pass implements tree level if-conversion transformation of loops.    Initial goal is to help vectorizer vectorize loops with conditions.     A short description of if-conversion:       o Decide if a loop is if-convertible or not.      o Walk all loop basic blocks in breadth first order (BFS order).        o Remove conditional statements (at the end of basic block)          and propagate condition into destination basic blocks' 	 predicate list.        o Replace modify expression with conditional modify expression          using current basic block's condition.      o Merge all basic blocks        o Replace phi nodes with conditional modify expr        o Merge all basic blocks into header       Sample transformation:       INPUT      -----       # i_23 = PHI<0(0), i_18(10)>;<L0>:;      j_15 = A[i_23];      if (j_15> 41) goto<L1>; else goto<L17>;<L17>:;      goto<bb 3> (<L3>);<L1>:;       # iftmp.2_4 = PHI<0(8), 42(2)>;<L3>:;      A[i_23] = iftmp.2_4;      i_18 = i_23 + 1;      if (i_18<= 15) goto<L19>; else goto<L18>;<L19>:;      goto<bb 1> (<L0>);<L18>:;       OUTPUT      ------       # i_23 = PHI<0(0), i_18(10)>;<L0>:;      j_15 = A[i_23];<L3>:;      iftmp.2_4 = j_15> 41 ? 42 : 0;      A[i_23] = iftmp.2_4;      i_18 = i_23 + 1;      if (i_18<= 15) goto<L19>; else goto<L18>;<L19>:;      goto<bb 1> (<L0>);<L18>:; */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* local function prototypes */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|int
name|main_tree_if_conversion
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tree_if_convert_stmt
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|block_stmt_iterator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tree_if_convert_cond_expr
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|block_stmt_iterator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|if_convertible_phi_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|if_convertible_modify_expr_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|if_convertible_stmt_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|if_convertible_bb_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|if_convertible_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_predicate_list
parameter_list|(
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|add_to_dst_predicate_list
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|block_stmt_iterator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clean_predicate_lists
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|find_phi_replacement_condition
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|block_stmt_iterator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_phi_with_cond_modify_expr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|basic_block
parameter_list|,
name|block_stmt_iterator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_phi_nodes
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|combine_blocks
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ifc_temp_var
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|pred_blocks_visited_p
parameter_list|(
name|basic_block
parameter_list|,
name|bitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
modifier|*
name|get_loop_body_in_if_conv_order
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bb_with_exit_edge_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* List of basic blocks in if-conversion-suitable order.  */
end_comment

begin_decl_stmt
specifier|static
name|basic_block
modifier|*
name|ifc_bbs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main entry point.    Apply if-conversion to the LOOP. Return true if successful otherwise return    false. If false is returned then loop remains unchanged.    FOR_VECTORIZER is a boolean flag. It indicates whether if-conversion is used    for vectorizer or not. If it is used for vectorizer, additional checks are    used. (Vectorization checks are not yet implemented).  */
end_comment

begin_function
specifier|static
name|bool
name|tree_if_conversion
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
name|for_vectorizer
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|itr
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ifc_bbs
operator|=
name|NULL
expr_stmt|;
comment|/* if-conversion is not appropriate for all loops. First, check if loop  is      if-convertible or not.  */
if|if
condition|(
operator|!
name|if_convertible_loop_p
argument_list|(
name|loop
argument_list|,
name|for_vectorizer
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"-------------------------\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifc_bbs
condition|)
block|{
name|free
argument_list|(
name|ifc_bbs
argument_list|)
expr_stmt|;
name|ifc_bbs
operator|=
name|NULL
expr_stmt|;
block|}
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Do actual work now.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|ifc_bbs
index|[
name|i
index|]
expr_stmt|;
comment|/* Update condition using predicate list.  */
name|cond
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
comment|/* Process all statements in this basic block. 	 Remove conditional expression, if any, and annotate 	 destination basic block(s) appropriately.  */
for|for
control|(
name|itr
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|itr
argument_list|)
condition|;
comment|/* empty */
control|)
block|{
name|tree
name|t
init|=
name|bsi_stmt
argument_list|(
name|itr
argument_list|)
decl_stmt|;
name|cond
operator|=
name|tree_if_convert_stmt
argument_list|(
name|loop
argument_list|,
name|t
argument_list|,
name|cond
argument_list|,
operator|&
name|itr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|itr
argument_list|)
condition|)
name|bsi_next
argument_list|(
operator|&
name|itr
argument_list|)
expr_stmt|;
block|}
comment|/* If current bb has only one successor, then consider it as an 	 unconditional goto.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|basic_block
name|bb_n
init|=
name|single_succ
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|!=
name|NULL_TREE
condition|)
name|add_to_predicate_list
argument_list|(
name|bb_n
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Now, all statements are if-converted and basic blocks are      annotated appropriately. Combine all basic block into one huge      basic block.  */
name|combine_blocks
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* clean up */
name|clean_predicate_lists
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifc_bbs
argument_list|)
expr_stmt|;
name|ifc_bbs
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* if-convert stmt T which is part of LOOP.    If T is a MODIFY_EXPR than it is converted into conditional modify    expression using COND.  For conditional expressions, add condition in the    destination basic block's predicate list and remove conditional    expression itself. BSI is the iterator used to traverse statements of    loop. It is used here when it is required to delete current statement.  */
end_comment

begin_function
specifier|static
name|tree
name|tree_if_convert_stmt
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
name|cond
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"------if-convert stmt\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|t
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|cond
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Labels are harmless here.  */
case|case
name|LABEL_EXPR
case|:
break|break;
case|case
name|MODIFY_EXPR
case|:
comment|/* This modify_expr is killing previous value of LHS. Appropriate value will 	 be selected by PHI node based on condition. It is possible that before 	 this transformation, PHI nodes was selecting default value and now it will 	 use this new value. This is OK because it does not change validity the 	 program.  */
break|break;
case|case
name|COND_EXPR
case|:
comment|/* Update destination blocks' predicate list and remove this 	 condition expression.  */
name|tree_if_convert_cond_expr
argument_list|(
name|loop
argument_list|,
name|t
argument_list|,
name|cond
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* STMT is COND_EXPR. Update two destination's predicate list.    Remove COND_EXPR, if it is not the loop exit condition. Otherwise    update loop exit condition appropriately.  BSI is the iterator    used to traverse statement list. STMT is part of loop LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|tree_if_convert_cond_expr
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|cond
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|edge
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
argument_list|)
expr_stmt|;
name|c
operator|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|extract_true_false_edges_from_block
argument_list|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* Add new condition into destination's predicate list.  */
comment|/* If 'c' is true then TRUE_EDGE is taken.  */
name|add_to_dst_predicate_list
argument_list|(
name|loop
argument_list|,
name|true_edge
operator|->
name|dest
argument_list|,
name|cond
argument_list|,
name|unshare_expr
argument_list|(
name|c
argument_list|)
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
comment|/* If 'c' is false then FALSE_EDGE is taken.  */
name|c2
operator|=
name|invert_truthvalue
argument_list|(
name|unshare_expr
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_dst_predicate_list
argument_list|(
name|loop
argument_list|,
name|false_edge
operator|->
name|dest
argument_list|,
name|cond
argument_list|,
name|c2
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
comment|/* Now this conditional statement is redundant. Remove it.      But, do not remove exit condition! Update exit condition      using new condition.  */
if|if
condition|(
operator|!
name|bb_with_exit_edge_p
argument_list|(
name|loop
argument_list|,
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
block|{
name|bsi_remove
argument_list|(
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Return true, iff PHI is if-convertible. PHI is part of loop LOOP    and it belongs to basic block BB.    PHI is not if-convertible    - if it has more than 2 arguments.    - Virtual PHI is immediately used in another PHI node.  */
end_comment

begin_function
specifier|static
name|bool
name|if_convertible_phi_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
name|phi
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"-------------------------\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|!=
name|loop
operator|->
name|header
operator|&&
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"More than two phi node args.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|PHI_RESULT (phi)
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Difficult to handle this virtual phi.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true, if M_EXPR is if-convertible.    MODIFY_EXPR is not if-convertible if,    - It is not movable.    - It could trap.    - LHS is not var decl.   MODIFY_EXPR is part of block BB, which is inside loop LOOP. */
end_comment

begin_function
specifier|static
name|bool
name|if_convertible_modify_expr_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
name|m_expr
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"-------------------------\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|m_expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Be conservative and do not handle immovable expressions.  */
if|if
condition|(
name|movement_possibility
argument_list|(
name|m_expr
argument_list|)
operator|==
name|MOVE_IMPOSSIBLE
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"stmt is movable. Don't take risk\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* See if it needs speculative loading or not.  */
if|if
condition|(
name|bb
operator|!=
name|loop
operator|->
name|header
operator|&&
name|tree_could_trap_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|m_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"tree could trap...\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|m_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"CALL_EXPR \n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|m_expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
name|bb
operator|!=
name|loop
operator|->
name|header
operator|&&
operator|!
name|bb_with_exit_edge_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"LHS is not var\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|m_expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true, iff STMT is if-convertible.    Statement is if-convertible if,    - It is if-convertible MODIFY_EXPR    - IT is LABEL_EXPR or COND_EXPR.    STMT is inside block BB, which is inside loop LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|if_convertible_stmt_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|LABEL_EXPR
case|:
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
operator|!
name|if_convertible_modify_expr_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|,
name|stmt
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|COND_EXPR
case|:
break|break;
default|default:
comment|/* Don't know what to do with 'em so don't do anything.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"don't know what to do\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true, iff BB is if-convertible.    Note: This routine does _not_ check basic block statements and phis.    Basic block is not if-convertible if,    - Basic block is non-empty and it is after exit block (in BFS order).    - Basic block is after exit block but before latch.    - Basic block edge(s) is not normal.    EXIT_BB_SEEN is true if basic block with exit edge is already seen.    BB is inside loop LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|if_convertible_bb_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|exit_bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"----------[%d]-------------\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_bb
condition|)
block|{
if|if
condition|(
name|bb
operator|!=
name|loop
operator|->
name|latch
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"basic block after exit bb but before latch\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|empty_block_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"non empty basic block after exit bb\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|bb
operator|==
name|loop
operator|->
name|latch
operator|&&
name|bb
operator|!=
name|exit_bb
operator|&&
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|exit_bb
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"latch is not dominated by exit_block\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Be less adventurous and handle only normal edges.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator||
name|EDGE_ABNORMAL
operator||
name|EDGE_IRREDUCIBLE_LOOP
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Difficult to handle edges\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true, iff LOOP is if-convertible.    LOOP is if-convertible if,    - It is innermost.    - It has two or more basic blocks.    - It has only one exit.    - Loop header is not the exit edge.    - If its basic blocks and phi nodes are if convertible. See above for      more info.    FOR_VECTORIZER enables vectorizer specific checks. For example, support    for vector conditions, data dependency checks etc.. (Not implemented yet).  */
end_comment

begin_function
specifier|static
name|bool
name|if_convertible_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
name|for_vectorizer
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|itr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|exit_bb
init|=
name|NULL
decl_stmt|;
comment|/* Handle only inner most loop.  */
if|if
condition|(
operator|!
name|loop
operator|||
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"not inner most loop\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If only one block, no need for if-conversion.  */
if|if
condition|(
name|loop
operator|->
name|num_nodes
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"less than 2 basic blocks\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* More than one loop exit is too much to handle.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|single_exit
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"multiple exits\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* ??? Check target's vector conditional operation support for vectorizer.  */
comment|/* If one of the loop header's edge is exit edge then do not apply      if-conversion.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|loop->header->succs
argument_list|)
block|{
if|if
condition|(
name|loop_exit_edge_p
argument_list|(
name|loop
argument_list|,
name|e
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Allow statements that can be handled during if-conversion.  */
name|ifc_bbs
operator|=
name|get_loop_body_in_if_conv_order
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifc_bbs
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Irreducible loop\n"
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|ifc_bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|if_convertible_bb_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|,
name|exit_bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Check statements.  */
for|for
control|(
name|itr
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|itr
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|itr
argument_list|)
control|)
if|if
condition|(
operator|!
name|if_convertible_stmt_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|,
name|bsi_stmt
argument_list|(
name|itr
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* ??? Check data dependency for vectorizer.  */
comment|/* What about phi nodes ? */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
operator|!
name|if_convertible_phi_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|,
name|phi
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bb_with_exit_edge_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
name|exit_bb
operator|=
name|bb
expr_stmt|;
block|}
comment|/* OK. Did not find any potential issues so go ahead in if-convert      this loop. Now there is no looking back.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Applying if-conversion\n"
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add condition COND into predicate list of basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_predicate_list
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|new_cond
parameter_list|)
block|{
name|tree
name|cond
init|=
name|bb
operator|->
name|aux
decl_stmt|;
if|if
condition|(
name|cond
condition|)
name|cond
operator|=
name|fold_build2
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|unshare_expr
argument_list|(
name|cond
argument_list|)
argument_list|,
name|new_cond
argument_list|)
expr_stmt|;
else|else
name|cond
operator|=
name|new_cond
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|cond
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add condition COND into BB's predicate list.  PREV_COND is    existing condition.  */
end_comment

begin_function
specifier|static
name|tree
name|add_to_dst_predicate_list
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
name|prev_cond
parameter_list|,
name|tree
name|cond
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|new_cond
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|prev_cond
operator|==
name|boolean_true_node
operator|||
operator|!
name|prev_cond
condition|)
name|new_cond
operator|=
name|unshare_expr
argument_list|(
name|cond
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|tmp_stmt
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tmp_stmts1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tmp_stmts2
init|=
name|NULL_TREE
decl_stmt|;
name|prev_cond
operator|=
name|force_gimple_operand
argument_list|(
name|unshare_expr
argument_list|(
name|prev_cond
argument_list|)
argument_list|,
operator|&
name|tmp_stmts1
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_stmts1
condition|)
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|tmp_stmts1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|cond
operator|=
name|force_gimple_operand
argument_list|(
name|unshare_expr
argument_list|(
name|cond
argument_list|)
argument_list|,
operator|&
name|tmp_stmts2
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_stmts2
condition|)
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|tmp_stmts2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* new_cond == prev_cond AND cond */
name|tmp
operator|=
name|build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|unshare_expr
argument_list|(
name|prev_cond
argument_list|)
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|tmp_stmt
operator|=
name|ifc_temp_var
argument_list|(
name|boolean_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|tmp_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|new_cond
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|add_to_predicate_list
argument_list|(
name|bb
argument_list|,
name|new_cond
argument_list|)
expr_stmt|;
return|return
name|new_cond
return|;
block|}
end_function

begin_comment
comment|/* During if-conversion aux field from basic block is used to hold predicate    list. Clean each basic block's predicate list for the given LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|clean_predicate_lists
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bb
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bb
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|bb
index|[
name|i
index|]
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basic block BB has two predecessors. Using predecessor's aux field, set    appropriate condition COND for the PHI node replacement. Return true block    whose phi arguments are selected when cond is true.  */
end_comment

begin_function
specifier|static
name|basic_block
name|find_phi_replacement_condition
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
modifier|*
name|cond
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|basic_block
name|first_bb
init|=
name|NULL
decl_stmt|;
name|basic_block
name|second_bb
init|=
name|NULL
decl_stmt|;
name|tree
name|tmp_cond
decl_stmt|,
name|new_stmts
decl_stmt|;
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|first_bb
operator|=
operator|(
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|)
operator|->
name|src
expr_stmt|;
name|second_bb
operator|=
operator|(
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
operator|)
operator|->
name|src
expr_stmt|;
comment|/* Use condition based on following criteria:      1)        S1: x = !c ? a : b;         S2: x = c ? b : a;         S2 is preferred over S1. Make 'b' first_bb and use its condition.              2) Do not make loop header first_bb.       3)        S1: x = !(c == d)? a : b;         S21: t1 = c == d;        S22: x = t1 ? b : a;         S3: x = (c == d) ? b : a;         S3 is preferred over S1 and S2*, Make 'b' first_bb and use         its condition.         4) If  pred B is dominated by pred A then use pred B's condition.         See PR23115.  */
comment|/* Select condition that is not TRUTH_NOT_EXPR.  */
name|tmp_cond
operator|=
name|first_bb
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp_cond
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
name|basic_block
name|tmp_bb
decl_stmt|;
name|tmp_bb
operator|=
name|first_bb
expr_stmt|;
name|first_bb
operator|=
name|second_bb
expr_stmt|;
name|second_bb
operator|=
name|tmp_bb
expr_stmt|;
block|}
comment|/* Check if FIRST_BB is loop header or not and make sure that      FIRST_BB does not dominate SECOND_BB.  */
if|if
condition|(
name|first_bb
operator|==
name|loop
operator|->
name|header
operator|||
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|second_bb
argument_list|,
name|first_bb
argument_list|)
condition|)
block|{
name|tmp_cond
operator|=
name|second_bb
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp_cond
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
comment|/* Select non loop header condition but do not switch basic blocks.  */
operator|*
name|cond
operator|=
name|invert_truthvalue
argument_list|(
name|unshare_expr
argument_list|(
name|tmp_cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Select non loop header condition.  */
name|first_bb
operator|=
name|second_bb
expr_stmt|;
operator|*
name|cond
operator|=
name|first_bb
operator|->
name|aux
expr_stmt|;
block|}
block|}
else|else
comment|/* FIRST_BB is not loop header */
operator|*
name|cond
operator|=
name|first_bb
operator|->
name|aux
expr_stmt|;
comment|/* Create temp. for the condition. Vectorizer prefers to have gimple      value as condition. Various targets use different means to communicate      condition in vector compare operation. Using gimple value allows compiler      to emit vector compare and select RTL without exposing compare's result.  */
operator|*
name|cond
operator|=
name|force_gimple_operand
argument_list|(
operator|*
name|cond
argument_list|,
operator|&
name|new_stmts
argument_list|,
name|false
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_stmts
condition|)
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|new_stmts
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
operator|*
name|cond
argument_list|)
operator|&&
operator|!
name|is_gimple_condexpr
argument_list|(
operator|*
name|cond
argument_list|)
condition|)
block|{
name|tree
name|new_stmt
decl_stmt|;
name|new_stmt
operator|=
name|ifc_temp_var
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|cond
argument_list|)
argument_list|,
name|unshare_expr
argument_list|(
operator|*
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|new_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
operator|*
name|cond
operator|=
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|*
name|cond
argument_list|)
expr_stmt|;
return|return
name|first_bb
return|;
block|}
end_function

begin_comment
comment|/* Replace PHI node with conditional modify expr using COND.    This routine does not handle PHI nodes with more than two arguments.    For example,      S1: A = PHI<x1(1), x2(5)    is converted into,      S2: A = cond ? x1 : x2;    S2 is inserted at the top of basic block's statement list.    When COND is true, phi arg from TRUE_BB is selected. */
end_comment

begin_function
specifier|static
name|void
name|replace_phi_with_cond_modify_expr
parameter_list|(
name|tree
name|phi
parameter_list|,
name|tree
name|cond
parameter_list|,
name|basic_block
name|true_bb
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|new_stmt
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|tree
name|arg_0
decl_stmt|,
name|arg_1
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
comment|/* If this is not filtered earlier, then now it is too late.  */
name|gcc_assert
argument_list|(
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* Find basic block and initialize iterator.  */
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|NULL_TREE
expr_stmt|;
name|arg_0
operator|=
name|NULL_TREE
expr_stmt|;
name|arg_1
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */
if|if
condition|(
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
operator|->
name|src
operator|==
name|true_bb
condition|)
block|{
name|arg_0
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg_1
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg_0
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_1
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Build new RHS using selected condition and arguments.  */
name|rhs
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|,
name|unshare_expr
argument_list|(
name|cond
argument_list|)
argument_list|,
name|unshare_expr
argument_list|(
name|arg_0
argument_list|)
argument_list|,
name|unshare_expr
argument_list|(
name|arg_1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create new MODIFY expression using RHS.  */
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|,
name|unshare_expr
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* Make new statement definition of the original phi result.  */
name|SSA_NAME_DEF_STMT
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|=
name|new_stmt
expr_stmt|;
comment|/* Insert using iterator.  */
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|new_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|new_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"new phi replacement stmt\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|new_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process phi nodes for the given  LOOP.  Replace phi nodes with cond    modify expr.  */
end_comment

begin_function
specifier|static
name|void
name|process_phi_nodes
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|orig_loop_num_nodes
init|=
name|loop
operator|->
name|num_nodes
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Replace phi nodes with cond. modify expr.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|orig_loop_num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|phi
decl_stmt|,
name|cond
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|true_bb
init|=
name|NULL
decl_stmt|;
name|bb
operator|=
name|ifc_bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|loop
operator|->
name|header
condition|)
continue|continue;
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_after_labels
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* BB has two predecessors. Using predecessor's aux field, set 	 appropriate condition for the PHI node replacement.  */
if|if
condition|(
name|phi
condition|)
name|true_bb
operator|=
name|find_phi_replacement_condition
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|,
operator|&
name|cond
argument_list|,
operator|&
name|bsi
argument_list|)
expr_stmt|;
while|while
condition|(
name|phi
condition|)
block|{
name|tree
name|next
init|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|replace_phi_with_cond_modify_expr
argument_list|(
name|phi
argument_list|,
name|cond
argument_list|,
name|true_bb
argument_list|,
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|release_phi_node
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|phi
operator|=
name|next
expr_stmt|;
block|}
name|bb
operator|->
name|phi_nodes
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Combine all basic block from the given LOOP into one or two super    basic block.  Replace PHI nodes with conditional modify expression.  */
end_comment

begin_function
specifier|static
name|void
name|combine_blocks
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|exit_bb
decl_stmt|,
name|merge_target_bb
decl_stmt|;
name|unsigned
name|int
name|orig_loop_num_nodes
init|=
name|loop
operator|->
name|num_nodes
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Process phi nodes to prepare blocks for merge.  */
name|process_phi_nodes
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Merge basic blocks.  First remove all the edges in the loop, except      for those from the exit block.  */
name|exit_bb
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_loop_num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|ifc_bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bb_with_exit_edge_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
block|{
name|exit_bb
operator|=
name|bb
expr_stmt|;
break|break;
block|}
block|}
name|gcc_assert
argument_list|(
name|exit_bb
operator|!=
name|loop
operator|->
name|latch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|orig_loop_num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|ifc_bbs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|exit_bb
condition|)
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
else|else
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exit_bb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|exit_bb
operator|!=
name|loop
operator|->
name|header
condition|)
block|{
comment|/* Connect this node with loop header.  */
name|make_edge
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|exit_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|exit_bb
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
block|}
comment|/* Redirect non-exit edges to loop->latch.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|exit_bb->succs
argument_list|)
block|{
if|if
condition|(
operator|!
name|loop_exit_edge_p
argument_list|(
name|loop
argument_list|,
name|e
argument_list|)
condition|)
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|loop
operator|->
name|latch
argument_list|)
expr_stmt|;
block|}
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|exit_bb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the loop does not have exit then reconnect header and latch.  */
name|make_edge
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
block|}
name|merge_target_bb
operator|=
name|loop
operator|->
name|header
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|orig_loop_num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree_stmt_iterator
name|last
decl_stmt|;
name|bb
operator|=
name|ifc_bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|exit_bb
operator|||
name|bb
operator|==
name|loop
operator|->
name|latch
condition|)
continue|continue;
comment|/* Remove labels and make stmts member of loop->header.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|set_bb_for_stmt
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|merge_target_bb
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update stmt list.  */
name|last
operator|=
name|tsi_last
argument_list|(
name|merge_target_bb
operator|->
name|stmt_list
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|last
argument_list|,
name|bb
operator|->
name|stmt_list
argument_list|,
name|TSI_NEW_STMT
argument_list|)
expr_stmt|;
name|bb
operator|->
name|stmt_list
operator|=
name|NULL
expr_stmt|;
comment|/* Update dominator info.  */
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
condition|)
name|delete_from_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_POST_DOMINATORS
index|]
condition|)
name|delete_from_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Remove basic block.  */
name|remove_bb_from_loops
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|expunge_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
comment|/* Now if possible, merge loop header and block with exit edge.      This reduces number of basic blocks to 2. Auto vectorizer addresses      loops with two nodes only.  FIXME: Use cleanup_tree_cfg().  */
if|if
condition|(
name|exit_bb
operator|&&
name|exit_bb
operator|!=
name|loop
operator|->
name|header
operator|&&
name|can_merge_blocks_p
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|exit_bb
argument_list|)
condition|)
block|{
name|remove_bb_from_loops
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
name|merge_blocks
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|exit_bb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make new  temp variable of type TYPE. Add MODIFY_EXPR to assign EXP    to the new variable.  */
end_comment

begin_function
specifier|static
name|tree
name|ifc_temp_var
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|exp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|"_ifc_"
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|stmt
decl_stmt|,
name|new_name
decl_stmt|;
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
comment|/* Create new temporary variable.  */
name|var
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Build new statement to assign EXP to new variable.  */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|var
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* Get SSA name for the new variable and set make new statement      its definition statement.  */
name|new_name
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_name
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|new_name
argument_list|)
operator|=
name|stmt
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff, all pred blocks of BB are visited.    Bitmap VISITED keeps history of visited blocks.  */
end_comment

begin_function
specifier|static
name|bool
name|pred_blocks_visited_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bitmap
modifier|*
name|visited
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
operator|*
name|visited
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get body of a LOOP in suitable order for if-conversion.    It is caller's responsibility to deallocate basic block    list.  If-conversion suitable order is, BFS order with one    additional constraint. Select block in BFS block, if all    pred are already selected.  */
end_comment

begin_function
specifier|static
name|basic_block
modifier|*
name|get_loop_body_in_if_conv_order
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|blocks
decl_stmt|,
modifier|*
name|blocks_in_bfs_order
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|bitmap
name|visited
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|visited_count
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|latch
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|visited
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|blocks_in_bfs_order
operator|=
name|get_loop_body_in_bfs_order
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|loop
operator|->
name|num_nodes
condition|)
block|{
name|bb
operator|=
name|blocks_in_bfs_order
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
condition|)
block|{
name|free
argument_list|(
name|blocks_in_bfs_order
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
name|pred_blocks_visited_p
argument_list|(
name|bb
argument_list|,
operator|&
name|visited
argument_list|)
operator|||
name|bb
operator|==
name|loop
operator|->
name|header
condition|)
block|{
comment|/* This block is now visited.  */
name|bitmap_set_bit
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|blocks
index|[
name|visited_count
operator|++
index|]
operator|=
name|bb
expr_stmt|;
block|}
block|}
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|loop
operator|->
name|num_nodes
operator|&&
name|visited_count
operator|!=
name|loop
operator|->
name|num_nodes
condition|)
block|{
comment|/* Not done yet.  */
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|blocks_in_bfs_order
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|blocks
return|;
block|}
end_function

begin_comment
comment|/* Return true if one of the basic block BB edge is exit of LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|bb_with_exit_edge_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|exit_edge_found
init|=
name|false
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|loop_exit_edge_p
argument_list|(
name|loop
argument_list|,
name|e
argument_list|)
condition|)
block|{
name|exit_edge_found
operator|=
name|true
expr_stmt|;
break|break;
block|}
return|return
name|exit_edge_found
return|;
block|}
end_function

begin_comment
comment|/* Tree if-conversion pass management.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|main_tree_if_conversion
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|loop_num
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
if|if
condition|(
operator|!
name|current_loops
condition|)
return|return
literal|0
return|;
name|loop_num
operator|=
name|current_loops
operator|->
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop_num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|current_loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|tree_if_conversion
argument_list|(
name|loop
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_tree_if_conversion
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_vectorize
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_if_conversion
init|=
block|{
literal|"ifcvt"
block|,
comment|/* name */
name|gate_tree_if_conversion
block|,
comment|/* gate */
name|main_tree_if_conversion
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_loops
operator||
name|TODO_verify_stmts
operator||
name|TODO_verify_flow
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

