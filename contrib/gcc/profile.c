begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate branch probabilities, and basic block execution counts.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003  Free Software Foundation, Inc.    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;    based on some ideas from Dain Samples of UC Berkeley.    Further mangling by Bob Manson, Cygnus Support.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Generate basic block profile instrumentation and auxiliary files.    Profile generation is optimized, so that not all arcs in the basic    block graph need instrumenting. First, the BB graph is closed with    one entry (function start), and one exit (function exit).  Any    ABNORMAL_EDGE cannot be instrumented (because there is no control    path to place the code). We close the graph by inserting fake    EDGE_FAKE edges to the EXIT_BLOCK, from the sources of abnormal    edges that do not go to the exit_block. We ignore such abnormal    edges.  Naturally these fake edges are never directly traversed,    and so *cannot* be directly instrumented.  Some other graph    massaging is done. To optimize the instrumentation we generate the    BB minimal span tree, only edges that are not on the span tree    (plus the entry point) need instrumenting. From that information    all other edge counts can be deduced.  By construction all fake    edges must be on the spanning tree. We also attempt to place    EDGE_CRITICAL edges on the spanning tree.     The auxiliary file generated is<dumpbase>.bbg. The format is    described in full in gcov-io.h.  */
end_comment

begin_comment
comment|/* ??? Register allocation should use basic block execution counts to    give preference to the most commonly executed blocks.  */
end_comment

begin_comment
comment|/* ??? Should calculate branch probabilities before instrumenting code, since    then we can use arc counts to help decide which arcs to instrument.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* Additional information about the edges we need.  */
end_comment

begin_struct
struct|struct
name|edge_info
block|{
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
comment|/* Is on the spanning tree.  */
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
comment|/* Pretend this edge does not exist (it is abnormal and we've      inserted a fake to compensate).  */
name|unsigned
name|int
name|ignore
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bb_info
block|{
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
comment|/* Number of successor and predecessor edges.  */
name|gcov_type
name|succ_count
decl_stmt|;
name|gcov_type
name|pred_count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EDGE_INFO
parameter_list|(
name|e
parameter_list|)
value|((struct edge_info *) (e)->aux)
end_define

begin_define
define|#
directive|define
name|BB_INFO
parameter_list|(
name|b
parameter_list|)
value|((struct bb_info *) (b)->aux)
end_define

begin_comment
comment|/* Counter summary from the last set of coverage counts read.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcov_ctr_summary
modifier|*
name|profile_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Collect statistics on the performance of this pass for the entire source    file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges_ignored
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges_instrumented
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks_created
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_passes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_times_called
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_hist_br_prob
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_never_executed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_branches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|find_spanning_tree
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_edge_profiler
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_interval_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_pow2_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_one_value_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_const_delta_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|instrument_edges
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instrument_values
parameter_list|(
name|unsigned
parameter_list|,
name|struct
name|histogram_value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_branch_probabilities
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_value_histograms
parameter_list|(
name|unsigned
parameter_list|,
name|struct
name|histogram_value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gcov_type
modifier|*
name|get_exec_counts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|find_group
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|union_groups
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Add edge instrumentation code to the entire insn chain.     F is the first insn of the chain.    NUM_BLOCKS is the number of basic blocks found in F.  */
end_comment

begin_function
specifier|static
name|unsigned
name|instrument_edges
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|unsigned
name|num_instr_edges
init|=
literal|0
decl_stmt|;
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|struct
name|edge_info
modifier|*
name|inf
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inf
operator|->
name|ignore
operator|&&
operator|!
name|inf
operator|->
name|on_tree
condition|)
block|{
name|rtx
name|edge_profile
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Edge %d to %d instrumented%s\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|?
literal|" (and split)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|edge_profile
operator|=
name|gen_edge_profiler
argument_list|(
name|num_instr_edges
operator|++
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|edge_profile
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|e
operator|->
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|total_num_blocks_created
operator|+=
name|num_edges
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d edges instrumented\n"
argument_list|,
name|num_instr_edges
argument_list|)
expr_stmt|;
return|return
name|num_instr_edges
return|;
block|}
end_function

begin_comment
comment|/* Add code to measure histograms list of VALUES of length N_VALUES.  */
end_comment

begin_function
specifier|static
name|void
name|instrument_values
parameter_list|(
name|unsigned
name|n_values
parameter_list|,
name|struct
name|histogram_value
modifier|*
name|values
parameter_list|)
block|{
name|rtx
name|sequence
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|t
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Emit code to generate the histograms before the insns.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_values
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|split_block
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|values
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|HIST_TYPE_INTERVAL
case|:
name|t
operator|=
name|GCOV_COUNTER_V_INTERVAL
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_POW2
case|:
name|t
operator|=
name|GCOV_COUNTER_V_POW2
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_SINGLE_VALUE
case|:
name|t
operator|=
name|GCOV_COUNTER_V_SINGLE
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_CONST_DELTA
case|:
name|t
operator|=
name|GCOV_COUNTER_V_DELTA
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coverage_counter_alloc
argument_list|(
name|t
argument_list|,
name|values
index|[
name|i
index|]
operator|.
name|n_counters
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|values
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|HIST_TYPE_INTERVAL
case|:
name|sequence
operator|=
name|gen_interval_profiler
argument_list|(
name|values
operator|+
name|i
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_POW2
case|:
name|sequence
operator|=
name|gen_pow2_profiler
argument_list|(
name|values
operator|+
name|i
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_SINGLE_VALUE
case|:
name|sequence
operator|=
name|gen_one_value_profiler
argument_list|(
name|values
operator|+
name|i
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_CONST_DELTA
case|:
name|sequence
operator|=
name|gen_const_delta_profiler
argument_list|(
name|values
operator|+
name|i
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|safe_insert_insn_on_edge
argument_list|(
name|sequence
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Computes hybrid profile for all matching entries in da_file.  */
end_comment

begin_function
specifier|static
name|gcov_type
modifier|*
name|get_exec_counts
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|num_edges
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|gcov_type
modifier|*
name|counts
decl_stmt|;
comment|/* Count the edges to be (possibly) instrumented.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
condition|)
name|num_edges
operator|++
expr_stmt|;
block|}
name|counts
operator|=
name|get_coverage_counts
argument_list|(
name|GCOV_COUNTER_ARCS
argument_list|,
name|num_edges
argument_list|,
operator|&
name|profile_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|counts
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|rtl_dump_file
operator|&&
name|profile_info
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Merged %u profiles with maximal count %u.\n"
argument_list|,
name|profile_info
operator|->
name|runs
argument_list|,
operator|(
name|unsigned
operator|)
name|profile_info
operator|->
name|sum_max
argument_list|)
expr_stmt|;
return|return
name|counts
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the branch probabilities for the various branches.    Annotate them accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|compute_branch_probabilities
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_edges
init|=
literal|0
decl_stmt|;
name|int
name|changes
decl_stmt|;
name|int
name|passes
decl_stmt|;
name|int
name|hist_br_prob
index|[
literal|20
index|]
decl_stmt|;
name|int
name|num_never_executed
decl_stmt|;
name|int
name|num_branches
decl_stmt|;
name|gcov_type
modifier|*
name|exec_counts
init|=
name|get_exec_counts
argument_list|()
decl_stmt|;
name|int
name|exec_counts_pos
init|=
literal|0
decl_stmt|;
comment|/* Very simple sanity checks so we catch bugs in our profiling code.  */
if|if
condition|(
name|profile_info
condition|)
block|{
if|if
condition|(
name|profile_info
operator|->
name|run_max
operator|*
name|profile_info
operator|->
name|runs
operator|<
name|profile_info
operator|->
name|sum_max
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: run_max * runs< sum_max"
argument_list|)
expr_stmt|;
name|exec_counts
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|profile_info
operator|->
name|sum_all
operator|<
name|profile_info
operator|->
name|sum_max
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: sum_all is smaller than sum_max"
argument_list|)
expr_stmt|;
name|exec_counts
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Attach extra info block to each bb.  */
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|++
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|pred_count
operator|++
expr_stmt|;
block|}
comment|/* Avoid predicting entry on exit nodes.  */
name|BB_INFO
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
operator|->
name|succ_count
operator|=
literal|2
expr_stmt|;
name|BB_INFO
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|pred_count
operator|=
literal|2
expr_stmt|;
comment|/* For each edge not on the spanning tree, set its execution count from      the .da file.  */
comment|/* The first count in the .da file is the number of times that the function      was entered.  This is the exec_count for block zero.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
condition|)
block|{
name|num_edges
operator|++
expr_stmt|;
if|if
condition|(
name|exec_counts
condition|)
block|{
name|e
operator|->
name|count
operator|=
name|exec_counts
index|[
name|exec_counts_pos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
operator|>
name|profile_info
operator|->
name|sum_max
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: edge from %i to %i exceeds maximal count"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|pred_count
operator|--
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nRead edge from %i to %i, count:"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n%d edge counts read\n"
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
comment|/* For every block in the file,      - if every exit/entrance edge has a known count, then set the block count      - if the block count is known, and every exit/entrance edge but one has      a known execution count, then set the count of the remaining edge       As edge counts are set, decrement the succ/pred count, but don't delete      the edge, that way we can easily tell when all edges are known, or only      one edge is unknown.  */
comment|/* The order that the basic blocks are iterated through is important.      Since the code that finds spanning trees starts with block 0, low numbered      edges are put on the spanning tree in preference to high numbered edges.      Hence, most instrumented edges are at the end.  Graph solving works much      faster if we propagate numbers from the end to the start.       This takes an average of slightly more than 3 passes.  */
name|changes
operator|=
literal|1
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|passes
operator|++
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|prev_bb
argument_list|)
block|{
name|struct
name|bb_info
modifier|*
name|bi
init|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|bi
operator|->
name|succ_count
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bi
operator|->
name|pred_count
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bi
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|bi
operator|->
name|succ_count
operator|==
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Seedgeh for the invalid edge, and set its count.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
break|break;
comment|/* Calculate count for remaining edge by conservation.  */
name|total
operator|=
name|bb
operator|->
name|count
operator|-
name|total
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|abort
argument_list|()
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|succ_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|pred_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bi
operator|->
name|pred_count
operator|==
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Search for the invalid edge, and set its count.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
break|break;
comment|/* Calculate count for remaining edge by conservation.  */
name|total
operator|=
name|bb
operator|->
name|count
operator|-
name|total
operator|+
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|abort
argument_list|()
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|pred_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|succ_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|total_num_passes
operator|+=
name|passes
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Graph solving took %d passes.\n\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
comment|/* If the graph has been correctly solved, every block will have a      succ and pred count of zero.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|||
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|pred_count
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* For every edge, calculate its branch probability and add a reg_note      to the branch insn to indicate this.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|num_never_executed
operator|=
literal|0
expr_stmt|;
name|num_branches
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: number of iterations for basic block %d thought to be %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
operator|(
name|int
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|bb
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
comment|/* Function may return twice in the cased the called function is 	     setjmp or calls fork, but we can't represent this by extra 	     edge from the entry, since extra edge from the exit is 	     already present.  We get negative frequency from the entry 	     point.  */
if|if
condition|(
operator|(
name|e
operator|->
name|count
operator|<
literal|0
operator|&&
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
operator|||
operator|(
name|e
operator|->
name|count
operator|>
name|bb
operator|->
name|count
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|)
condition|)
block|{
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|&&
name|keep_with_call_p
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|e
operator|->
name|count
operator|=
name|e
operator|->
name|count
operator|<
literal|0
condition|?
literal|0
else|:
name|bb
operator|->
name|count
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
operator|||
name|e
operator|->
name|count
operator|>
name|bb
operator|->
name|count
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: number of executions for edge %d-%d thought to be %i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb
operator|->
name|count
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|probability
operator|=
operator|(
name|e
operator|->
name|count
operator|*
name|REG_BR_PROB_BASE
operator|+
name|bb
operator|->
name|count
operator|/
literal|2
operator|)
operator|/
name|bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
literal|0
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|int
name|prob
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Find the branch edge.  It is possible that we do have fake 		 edges here.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_FAKE
operator||
name|EDGE_FALLTHRU
operator|)
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
continue|continue;
comment|/* Loop body has been intentionally left blank.  */
name|prob
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|index
operator|=
name|prob
operator|*
literal|20
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|20
condition|)
name|index
operator|=
literal|19
expr_stmt|;
name|hist_br_prob
index|[
name|index
index|]
operator|++
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* There may be already note put by some other pass, such 		 as builtin_expect expander.  */
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|prob
argument_list|)
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|prob
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num_branches
operator|++
expr_stmt|;
block|}
block|}
comment|/* Otherwise distribute the probabilities evenly so we get sane 	 sum.  Use simple heuristics that if there are normal edges, 	 give all abnormals frequency of 0, otherwise distribute the 	 frequency over abnormals (this is the case of noreturn 	 calls).  */
else|else
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|total
operator|++
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
name|total
expr_stmt|;
else|else
name|e
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|total
operator|++
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
name|total
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
literal|0
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|num_branches
operator|++
operator|,
name|num_never_executed
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d branches\n"
argument_list|,
name|num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d branches never executed\n"
argument_list|,
name|num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_branches
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|hist_br_prob
index|[
name|i
index|]
operator|+
name|hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
name|total_num_branches
operator|+=
name|num_branches
expr_stmt|;
name|total_num_never_executed
operator|+=
name|num_never_executed
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|+=
name|hist_br_prob
index|[
name|i
index|]
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load value histograms for N_VALUES values whose description is stored    in VALUES array from .da file.  */
end_comment

begin_function
specifier|static
name|void
name|compute_value_histograms
parameter_list|(
name|unsigned
name|n_values
parameter_list|,
name|struct
name|histogram_value
modifier|*
name|values
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|,
name|any
decl_stmt|;
name|unsigned
name|n_histogram_counters
index|[
name|GCOV_N_VALUE_COUNTERS
index|]
decl_stmt|;
name|gcov_type
modifier|*
name|histogram_counts
index|[
name|GCOV_N_VALUE_COUNTERS
index|]
decl_stmt|;
name|gcov_type
modifier|*
name|act_count
index|[
name|GCOV_N_VALUE_COUNTERS
index|]
decl_stmt|;
name|gcov_type
modifier|*
name|aact_count
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|GCOV_N_VALUE_COUNTERS
condition|;
name|t
operator|++
control|)
name|n_histogram_counters
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_values
condition|;
name|i
operator|++
control|)
name|n_histogram_counters
index|[
call|(
name|int
call|)
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|type
argument_list|)
index|]
operator|+=
name|values
index|[
name|i
index|]
operator|.
name|n_counters
expr_stmt|;
name|any
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|GCOV_N_VALUE_COUNTERS
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|n_histogram_counters
index|[
name|t
index|]
condition|)
block|{
name|histogram_counts
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|histogram_counts
index|[
name|t
index|]
operator|=
name|get_coverage_counts
argument_list|(
name|COUNTER_FOR_HIST_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|n_histogram_counters
index|[
name|t
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|histogram_counts
index|[
name|t
index|]
condition|)
name|any
operator|=
literal|1
expr_stmt|;
name|act_count
index|[
name|t
index|]
operator|=
name|histogram_counts
index|[
name|t
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_values
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|hist_list
init|=
name|NULL_RTX
decl_stmt|;
name|t
operator|=
call|(
name|int
call|)
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|aact_count
operator|=
name|act_count
index|[
name|t
index|]
expr_stmt|;
name|act_count
index|[
name|t
index|]
operator|+=
name|values
index|[
name|i
index|]
operator|.
name|n_counters
expr_stmt|;
for|for
control|(
name|j
operator|=
name|values
index|[
name|i
index|]
operator|.
name|n_counters
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|hist_list
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|GEN_INT
argument_list|(
name|aact_count
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|hist_list
argument_list|)
expr_stmt|;
name|hist_list
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|copy_rtx
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|hist_list
argument_list|)
expr_stmt|;
name|hist_list
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|GEN_INT
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|hist_list
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_VALUE_PROFILE
argument_list|,
name|hist_list
argument_list|,
name|REG_NOTES
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|GCOV_N_VALUE_COUNTERS
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|histogram_counts
index|[
name|t
index|]
condition|)
name|free
argument_list|(
name|histogram_counts
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Instrument and/or analyze program behavior based on program flow graph.    In either case, this function builds a flow graph for the function being    compiled.  The flow graph is stored in BB_GRAPH.     When FLAG_PROFILE_ARCS is nonzero, this function instruments the edges in    the flow graph that are needed to reconstruct the dynamic behavior of the    flow graph.     When FLAG_BRANCH_PROBABILITIES is nonzero, this function reads auxiliary    information from a data file containing edge count information from previous    executions of the function being compiled.  In this case, the flow graph is    annotated with actual execution counts, which are later propagated into the    rtl for optimization purposes.     Main entry point of this file.  */
end_comment

begin_function
name|void
name|branch_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|num_edges
decl_stmt|,
name|ignored_edges
decl_stmt|;
name|unsigned
name|num_instrumented
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
name|unsigned
name|n_values
init|=
literal|0
decl_stmt|;
name|struct
name|histogram_value
modifier|*
name|values
init|=
name|NULL
decl_stmt|;
name|total_num_times_called
operator|++
expr_stmt|;
name|flow_call_edges_add
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
comment|/* We can't handle cyclic regions constructed using abnormal edges.      To avoid these we replace every source of abnormal edge by a fake      edge from entry node and every destination by fake edge to exit.      This keeps graph acyclic and our calculation exact for all normal      edges except for exit and entrance ones.       We also add fake exit edges for each call and asm statement in the      basic, since it may not return.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|need_exit_edge
init|=
literal|0
decl_stmt|,
name|need_entry_edge
init|=
literal|0
decl_stmt|;
name|int
name|have_exit_edge
init|=
literal|0
decl_stmt|,
name|have_entry_edge
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Functions returning multiple times are not handled by extra edges.          Instead we simply allow negative counts on edges from exit to the          block past call and corresponding probabilities.  We can't go          with the extra edges because that would result in flowgraph that 	 needs to have fake edges outside the spanning tree.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|need_exit_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|have_exit_edge
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|need_entry_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|have_entry_edge
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_exit_edge
operator|&&
operator|!
name|have_exit_edge
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Adding fake exit edge to bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_entry_edge
operator|&&
operator|!
name|have_entry_edge
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Adding fake entry edge to bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
block|}
name|el
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The basic blocks are expected to be numbered sequentially.  */
name|compact_blocks
argument_list|()
expr_stmt|;
name|ignored_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Mark edges we've replaced by fake edges above as ignored.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|ignored_edges
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Create spanning tree from basic block graph, mark each edge that is      on the spanning tree.  We insert as many abnormal and critical edges      as possible to minimize number of edge splits necessary.  */
name|find_spanning_tree
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* Fake edges that are not on the tree will not be instrumented, so      mark them ignored.  */
for|for
control|(
name|num_instrumented
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|edge_info
modifier|*
name|inf
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|inf
operator|->
name|ignore
operator|||
name|inf
operator|->
name|on_tree
condition|)
comment|/*NOP*/
empty_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
block|{
name|inf
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|ignored_edges
operator|++
expr_stmt|;
block|}
else|else
name|num_instrumented
operator|++
expr_stmt|;
block|}
name|total_num_blocks
operator|+=
name|n_basic_blocks
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d basic blocks\n"
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|total_num_edges
operator|+=
name|num_edges
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d edges\n"
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
name|total_num_edges_ignored
operator|+=
name|ignored_edges
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d ignored edges\n"
argument_list|,
name|ignored_edges
argument_list|)
expr_stmt|;
comment|/* Write the data from which gcov can reconstruct the basic block      graph.  */
comment|/* Basic block flags */
if|if
condition|(
name|coverage_begin_output
argument_list|()
condition|)
block|{
name|gcov_position_t
name|offset
decl_stmt|;
name|offset
operator|=
name|gcov_write_tag
argument_list|(
name|GCOV_TAG_BLOCKS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|n_basic_blocks
operator|+
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
name|gcov_write_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gcov_write_length
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Keep all basic block indexes nonnegative in the gcov output.       Index 0 is used for entry block, last index is for exit block.       */
name|ENTRY_BLOCK_PTR
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|index
operator|=
name|last_basic_block
expr_stmt|;
define|#
directive|define
name|BB_TO_GCOV_INDEX
parameter_list|(
name|bb
parameter_list|)
value|((bb)->index + 1)
comment|/* Arcs */
if|if
condition|(
name|coverage_begin_output
argument_list|()
condition|)
block|{
name|gcov_position_t
name|offset
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|offset
operator|=
name|gcov_write_tag
argument_list|(
name|GCOV_TAG_ARCS
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|BB_TO_GCOV_INDEX
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|struct
name|edge_info
modifier|*
name|i
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i
operator|->
name|ignore
condition|)
block|{
name|unsigned
name|flag_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|->
name|on_tree
condition|)
name|flag_bits
operator||=
name|GCOV_ARC_ON_TREE
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
name|flag_bits
operator||=
name|GCOV_ARC_FAKE
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|flag_bits
operator||=
name|GCOV_ARC_FALLTHROUGH
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|BB_TO_GCOV_INDEX
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|flag_bits
argument_list|)
expr_stmt|;
block|}
block|}
name|gcov_write_length
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Line numbers.  */
if|if
condition|(
name|coverage_begin_output
argument_list|()
condition|)
block|{
name|char
specifier|const
modifier|*
name|prev_file_name
init|=
name|NULL
decl_stmt|;
name|gcov_position_t
name|offset
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|int
name|ignore_next_note
init|=
literal|0
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* We are looking for line number notes.  Search backward 	     before basic block to find correct ones.  */
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Must ignore the line number notes that 		     immediately follow the end of an inline function 		     to avoid counting it twice.  There is a note 		     before the call, and one after the call.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_REPEATED_LINE_NUMBER
condition|)
name|ignore_next_note
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<=
literal|0
condition|)
comment|/*NOP*/
empty_stmt|;
elseif|else
if|if
condition|(
name|ignore_next_note
condition|)
name|ignore_next_note
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|offset
condition|)
block|{
name|offset
operator|=
name|gcov_write_tag
argument_list|(
name|GCOV_TAG_LINES
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|BB_TO_GCOV_INDEX
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a new source file, then output the 			 file's name to the .bb file.  */
if|if
condition|(
operator|!
name|prev_file_name
operator|||
name|strcmp
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|prev_file_name
argument_list|)
condition|)
block|{
name|prev_file_name
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gcov_write_string
argument_list|(
name|prev_file_name
argument_list|)
expr_stmt|;
block|}
name|gcov_write_unsigned
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
condition|)
block|{
comment|/* A file of NULL indicates the end of run.  */
name|gcov_write_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gcov_write_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|gcov_write_length
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ENTRY_BLOCK_PTR
operator|->
name|index
operator|=
name|ENTRY_BLOCK
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|index
operator|=
name|EXIT_BLOCK
expr_stmt|;
undef|#
directive|undef
name|BB_TO_GCOV_INDEX
if|if
condition|(
name|flag_profile_values
condition|)
block|{
name|life_analysis
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
name|find_values_to_profile
argument_list|(
operator|&
name|n_values
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
name|compute_branch_probabilities
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_profile_values
condition|)
name|compute_value_histograms
argument_list|(
name|n_values
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
comment|/* For each edge not on the spanning tree, add counting code as rtl.  */
if|if
condition|(
name|profile_arc_flag
operator|&&
name|coverage_counter_alloc
argument_list|(
name|GCOV_COUNTER_ARCS
argument_list|,
name|num_instrumented
argument_list|)
condition|)
block|{
name|unsigned
name|n_instrumented
init|=
name|instrument_edges
argument_list|(
name|el
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_instrumented
operator|!=
name|num_instrumented
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_profile_values
condition|)
name|instrument_values
argument_list|(
name|n_values
argument_list|,
name|values
argument_list|)
expr_stmt|;
comment|/* Commit changes done by instrumentation.  */
name|commit_edge_insertions_watch_calls
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|free_aux_for_edges
argument_list|()
expr_stmt|;
comment|/* Re-merge split basic blocks and the mess introduced by      insert_insn_on_edge.  */
name|cleanup_cfg
argument_list|(
name|profile_arc_flag
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|free_edge_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Union find algorithm implementation for the basic blocks using    aux fields.  */
end_comment

begin_function
specifier|static
name|basic_block
name|find_group
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|basic_block
name|group
init|=
name|bb
decl_stmt|,
name|bb1
decl_stmt|;
while|while
condition|(
operator|(
name|basic_block
operator|)
name|group
operator|->
name|aux
operator|!=
name|group
condition|)
name|group
operator|=
operator|(
name|basic_block
operator|)
name|group
operator|->
name|aux
expr_stmt|;
comment|/* Compress path.  */
while|while
condition|(
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|aux
operator|!=
name|group
condition|)
block|{
name|bb1
operator|=
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|aux
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
name|group
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
return|return
name|group
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|union_groups
parameter_list|(
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|)
block|{
name|basic_block
name|bb1g
init|=
name|find_group
argument_list|(
name|bb1
argument_list|)
decl_stmt|;
name|basic_block
name|bb2g
init|=
name|find_group
argument_list|(
name|bb2
argument_list|)
decl_stmt|;
comment|/* ??? I don't have a place for the rank field.  OK.  Lets go w/o it,      this code is unlikely going to be performance problem anyway.  */
if|if
condition|(
name|bb1g
operator|==
name|bb2g
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb1g
operator|->
name|aux
operator|=
name|bb2g
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function searches all of the edges in the program flow graph, and puts    as many bad edges as possible onto the spanning tree.  Bad edges include    abnormals edges, which can't be instrumented at the moment.  Since it is    possible for fake edges to form a cycle, we will have to develop some    better way in the future.  Also put critical edges to the tree, since they    are more expensive to instrument.  */
end_comment

begin_function
specifier|static
name|void
name|find_spanning_tree
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* We use aux field for standard union-find algorithm.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
comment|/* Add fake edge exit to entry we can't instrument.  */
name|union_groups
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* First add all abnormal edges to the tree unless they form a cycle. Also      add all edges to EXIT_BLOCK_PTR to avoid inserting profiling code behind      setting return value from function.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_FAKE
operator|)
operator|)
operator|||
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|(
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Abnormal edge %d to %d put to tree\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now insert all critical edges to the tree unless they form a cycle.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Critical edge %d to %d put to tree\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And now the rest.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Normal edge %d to %d put to tree\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform file-level initialization for branch-prob processing.  */
end_comment

begin_function
name|void
name|init_branch_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|total_num_blocks
operator|=
literal|0
expr_stmt|;
name|total_num_edges
operator|=
literal|0
expr_stmt|;
name|total_num_edges_ignored
operator|=
literal|0
expr_stmt|;
name|total_num_edges_instrumented
operator|=
literal|0
expr_stmt|;
name|total_num_blocks_created
operator|=
literal|0
expr_stmt|;
name|total_num_passes
operator|=
literal|0
expr_stmt|;
name|total_num_times_called
operator|=
literal|0
expr_stmt|;
name|total_num_branches
operator|=
literal|0
expr_stmt|;
name|total_num_never_executed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Performs file-level cleanup after branch-prob processing    is completed.  */
end_comment

begin_function
name|void
name|end_branch_prob
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of blocks: %d\n"
argument_list|,
name|total_num_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of edges: %d\n"
argument_list|,
name|total_num_edges
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of ignored edges: %d\n"
argument_list|,
name|total_num_edges_ignored
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of instrumented edges: %d\n"
argument_list|,
name|total_num_edges_instrumented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of blocks created: %d\n"
argument_list|,
name|total_num_blocks_created
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of graph solution passes: %d\n"
argument_list|,
name|total_num_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_times_called
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Average number of graph solution passes: %d\n"
argument_list|,
operator|(
name|total_num_passes
operator|+
operator|(
name|total_num_times_called
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total_num_times_called
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of branches: %d\n"
argument_list|,
name|total_num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of branches never executed: %d\n"
argument_list|,
name|total_num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_branches
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|total_hist_br_prob
index|[
name|i
index|]
operator|+
name|total_hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|total_num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output instructions as RTL to increment the edge execution count.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_edge_profiler
parameter_list|(
name|int
name|edgeno
parameter_list|)
block|{
name|rtx
name|ref
init|=
name|coverage_counter_ref
argument_list|(
name|GCOV_COUNTER_ARCS
argument_list|,
name|edgeno
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|ref
operator|=
name|validize_mem
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|ref
argument_list|,
name|const1_rtx
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|ref
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|ref
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Output instructions as RTL to increment the interval histogram counter.    VALUE is the expression whose value is profiled.  TAG is the tag of the    section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_interval_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
name|value
parameter_list|,
name|unsigned
name|tag
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|unsigned
name|gcov_size
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|GCOV_TYPE_NODE
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|gcov_size
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem_ref
decl_stmt|,
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|,
name|mr
decl_stmt|,
name|val
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|more_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|less_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_of_code_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|per_counter
init|=
name|gcov_size
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|seq
condition|)
name|emit_insn
argument_list|(
name|value
operator|->
name|seq
argument_list|)
expr_stmt|;
name|mr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_simple_binop
argument_list|(
name|value
operator|->
name|mode
argument_list|,
name|MINUS
argument_list|,
name|copy_rtx
argument_list|(
name|value
operator|->
name|value
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|int_start
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_more
condition|)
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|val
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
argument_list|)
argument_list|,
name|GE
argument_list|,
literal|0
argument_list|,
name|value
operator|->
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|more_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_less
condition|)
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|val
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
literal|0
argument_list|,
name|value
operator|->
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|less_label
argument_list|)
expr_stmt|;
comment|/* We are in range.  */
name|tmp1
operator|=
name|expand_simple_binop
argument_list|(
name|value
operator|->
name|mode
argument_list|,
name|MULT
argument_list|,
name|copy_rtx
argument_list|(
name|val
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|per_counter
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|tmp1
argument_list|,
name|mr
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|mr
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mr
argument_list|)
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_more
operator|||
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_less
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|end_of_code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
comment|/* Above the interval.  */
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_more
condition|)
block|{
name|emit_label
argument_list|(
name|more_label
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|per_counter
operator|*
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
argument_list|)
argument_list|,
name|mr
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|mr
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mr
argument_list|)
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_less
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|end_of_code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Below the interval.  */
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_less
condition|)
block|{
name|emit_label
argument_list|(
name|less_label
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|per_counter
operator|*
operator|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
operator|+
operator|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_more
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
argument_list|)
argument_list|,
name|mr
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|mr
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mr
argument_list|)
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_more
operator|||
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|may_be_less
condition|)
name|emit_label
argument_list|(
name|end_of_code_label
argument_list|)
expr_stmt|;
name|mem_ref
operator|=
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|mr
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|mem_ref
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|mem_ref
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|mem_ref
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mem_ref
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Output instructions as RTL to increment the power of two histogram counter.    VALUE is the expression whose value is profiled.  TAG is the tag of the    section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_pow2_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
name|value
parameter_list|,
name|unsigned
name|tag
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|unsigned
name|gcov_size
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|GCOV_TYPE_NODE
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|gcov_size
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem_ref
decl_stmt|,
name|tmp
decl_stmt|,
name|mr
decl_stmt|,
name|uval
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|end_of_code_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|loop_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|per_counter
init|=
name|gcov_size
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|seq
condition|)
name|emit_insn
argument_list|(
name|value
operator|->
name|seq
argument_list|)
expr_stmt|;
name|mr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|uval
operator|=
name|gen_reg_rtx
argument_list|(
name|value
operator|->
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|uval
argument_list|,
name|copy_rtx
argument_list|(
name|value
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for non-power of 2.  */
if|if
condition|(
name|value
operator|->
name|hdata
operator|.
name|pow2
operator|.
name|may_be_other
condition|)
block|{
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|LE
argument_list|,
literal|0
argument_list|,
name|value
operator|->
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|end_of_code_label
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|value
operator|->
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|value
operator|->
name|mode
argument_list|,
name|AND
argument_list|,
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|tmp
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|value
operator|->
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|end_of_code_label
argument_list|)
expr_stmt|;
block|}
comment|/* Count log_2(value).  */
name|emit_label
argument_list|(
name|loop_label
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|mr
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|per_counter
argument_list|)
argument_list|,
name|mr
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|mr
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mr
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|value
operator|->
name|mode
argument_list|,
name|ASHIFTRT
argument_list|,
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|uval
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|uval
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|value
operator|->
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|loop_label
argument_list|)
expr_stmt|;
comment|/* Increase the counter.  */
name|emit_label
argument_list|(
name|end_of_code_label
argument_list|)
expr_stmt|;
name|mem_ref
operator|=
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|mr
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|mem_ref
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|mem_ref
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|mem_ref
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mem_ref
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Output instructions as RTL for code to find the most common value.    VALUE is the expression whose value is profiled.  TAG is the tag of the    section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_one_value_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
name|value
parameter_list|,
name|unsigned
name|tag
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|unsigned
name|gcov_size
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|GCOV_TYPE_NODE
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|gcov_size
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|stored_value_ref
decl_stmt|,
name|counter_ref
decl_stmt|,
name|all_ref
decl_stmt|,
name|stored_value
decl_stmt|,
name|counter
decl_stmt|,
name|all
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|uval
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|same_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|zero_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_of_code_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|seq
condition|)
name|emit_insn
argument_list|(
name|value
operator|->
name|seq
argument_list|)
expr_stmt|;
name|stored_value_ref
operator|=
name|coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|counter_ref
operator|=
name|coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
name|all_ref
operator|=
name|coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
operator|+
literal|2
argument_list|)
expr_stmt|;
name|stored_value
operator|=
name|validize_mem
argument_list|(
name|stored_value_ref
argument_list|)
expr_stmt|;
name|counter
operator|=
name|validize_mem
argument_list|(
name|counter_ref
argument_list|)
expr_stmt|;
name|all
operator|=
name|validize_mem
argument_list|(
name|all_ref
argument_list|)
expr_stmt|;
name|uval
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|uval
argument_list|,
name|copy_rtx
argument_list|(
name|value
operator|->
name|value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check if the stored value matches.  */
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|stored_value
argument_list|)
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|same_label
argument_list|)
expr_stmt|;
comment|/* Does not match; check whether the counter is zero.  */
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|counter
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|zero_label
argument_list|)
expr_stmt|;
comment|/* The counter is not zero yet.  */
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|counter
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|,
name|counter
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|counter
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|counter
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|end_of_code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|zero_label
argument_list|)
expr_stmt|;
comment|/* Set new value.  */
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|stored_value
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|same_label
argument_list|)
expr_stmt|;
comment|/* Increase the counter.  */
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|counter
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|counter
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|counter
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|counter
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_of_code_label
argument_list|)
expr_stmt|;
comment|/* Increase the counter of all executions; this seems redundant given      that ve have counts for edges in cfg, but it may happen that some      optimization will change the counts for the block (either because      it is unable to update them correctly, or because it will duplicate      the block or its part).  */
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|all
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|all
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|all
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|all
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Output instructions as RTL for code to find the most common value of    a difference between two evaluations of an expression.    VALUE is the expression whose value is profiled.  TAG is the tag of the    section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_const_delta_profiler
parameter_list|(
name|struct
name|histogram_value
modifier|*
name|value
parameter_list|,
name|unsigned
name|tag
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|struct
name|histogram_value
name|one_value_delta
decl_stmt|;
name|unsigned
name|gcov_size
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|GCOV_TYPE_NODE
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|gcov_size
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|stored_value_ref
decl_stmt|,
name|stored_value
decl_stmt|,
name|tmp
decl_stmt|,
name|uval
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|seq
condition|)
name|emit_insn
argument_list|(
name|value
operator|->
name|seq
argument_list|)
expr_stmt|;
name|stored_value_ref
operator|=
name|coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|stored_value
operator|=
name|validize_mem
argument_list|(
name|stored_value_ref
argument_list|)
expr_stmt|;
name|uval
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|uval
argument_list|,
name|copy_rtx
argument_list|(
name|value
operator|->
name|value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|MINUS
argument_list|,
name|copy_rtx
argument_list|(
name|uval
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|stored_value
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|one_value_delta
operator|.
name|value
operator|=
name|tmp
expr_stmt|;
name|one_value_delta
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|one_value_delta
operator|.
name|seq
operator|=
name|NULL_RTX
expr_stmt|;
name|one_value_delta
operator|.
name|insn
operator|=
name|value
operator|->
name|insn
expr_stmt|;
name|one_value_delta
operator|.
name|type
operator|=
name|HIST_TYPE_SINGLE_VALUE
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_one_value_profiler
argument_list|(
operator|&
name|one_value_delta
argument_list|,
name|tag
argument_list|,
name|base
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|stored_value
argument_list|)
argument_list|,
name|uval
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

end_unit

