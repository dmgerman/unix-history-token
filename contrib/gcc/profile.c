begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate branch probabilities, and basic block execution counts.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,    2000, 2001  Free Software Foundation, Inc.    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;    based on some ideas from Dain Samples of UC Berkeley.    Further mangling by Bob Manson, Cygnus Support.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ??? Register allocation should use basic block execution counts to    give preference to the most commonly executed blocks.  */
end_comment

begin_comment
comment|/* ??? The .da files are not safe.  Changing the program after creating .da    files or using different options when compiling with -fbranch-probabilities    can result the arc data not matching the program.  Maybe add instrumented    arc count to .bbg file?  Maybe check whether PFG matches the .bbg file?  */
end_comment

begin_comment
comment|/* ??? Should calculate branch probabilities before instrumenting code, since    then we can use arc counts to help decide which arcs to instrument.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Additional information about the edges we need.  */
end_comment

begin_struct
struct|struct
name|edge_info
block|{
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|ignore
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bb_info
block|{
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|gcov_type
name|succ_count
decl_stmt|;
name|gcov_type
name|pred_count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EDGE_INFO
parameter_list|(
name|e
parameter_list|)
value|((struct edge_info *) (e)->aux)
end_define

begin_define
define|#
directive|define
name|BB_INFO
parameter_list|(
name|b
parameter_list|)
value|((struct bb_info *) (b)->aux)
end_define

begin_comment
comment|/* Keep all basic block indexes nonnegative in the gcov output.  Index 0    is used for entry block, last block exit block.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_INDEX_TO_BB
parameter_list|(
name|i
parameter_list|)
value|((i) == 0 ? ENTRY_BLOCK_PTR		\ 			      : (((i) == n_basic_blocks + 1)		\ 			         ? EXIT_BLOCK_PTR : BASIC_BLOCK ((i)-1)))
end_define

begin_define
define|#
directive|define
name|BB_TO_GCOV_INDEX
parameter_list|(
name|bb
parameter_list|)
value|((bb) == ENTRY_BLOCK_PTR ? 0		\ 			       : ((bb) == EXIT_BLOCK_PTR		\ 				  ? n_basic_blocks + 1 : (bb)->index + 1))
end_define

begin_comment
comment|/* Name and file pointer of the output file for the basic block graph.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bbg_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the arc count data.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|da_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer of the output file for the basic block/line number map.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bb_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last source file name written to bb_file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_bb_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by final, for allocating the proper amount of storage for the    instrumented arc execution counts.  */
end_comment

begin_decl_stmt
name|int
name|count_instrumented_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Collect statistics on the performance of this pass for the entire source    file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges_ignored
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges_instrumented
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks_created
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_passes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_times_called
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_hist_br_prob
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_never_executed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_branches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|find_spanning_tree
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_edge_profiler
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_edge_profiler
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|instrument_edges
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_gcov_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_branch_probabilities
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|find_group
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_groups
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, we need to output a constructor to set up the    per-object-file data.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_func_profiler
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add edge instrumentation code to the entire insn chain.     F is the first insn of the chain.    NUM_BLOCKS is the number of basic blocks found in F.  */
end_comment

begin_function
specifier|static
name|void
name|instrument_edges
parameter_list|(
name|el
parameter_list|)
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_instr_edges
init|=
literal|0
decl_stmt|;
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
decl_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|GCOV_INDEX_TO_BB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
init|=
name|bb
operator|->
name|succ
decl_stmt|;
while|while
condition|(
name|e
condition|)
block|{
name|struct
name|edge_info
modifier|*
name|inf
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inf
operator|->
name|ignore
operator|&&
operator|!
name|inf
operator|->
name|on_tree
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Edge %d to %d instrumented%s\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|?
literal|" (and split)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|need_func_profiler
operator|=
literal|1
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|gen_edge_profiler
argument_list|(
name|total_num_edges_instrumented
operator|+
name|num_instr_edges
operator|++
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
block|}
block|}
name|total_num_edges_instrumented
operator|+=
name|num_instr_edges
expr_stmt|;
name|count_instrumented_edges
operator|=
name|total_num_edges_instrumented
expr_stmt|;
name|total_num_blocks_created
operator|+=
name|num_edges
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d edges instrumented\n"
argument_list|,
name|num_instr_edges
argument_list|)
expr_stmt|;
name|commit_edge_insertions
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output STRING to bb_file, surrounded by DELIMITER.  */
end_comment

begin_function
specifier|static
name|void
name|output_gcov_string
parameter_list|(
name|string
parameter_list|,
name|delimiter
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|long
name|delimiter
decl_stmt|;
block|{
name|long
name|temp
decl_stmt|;
comment|/* Write a delimiter to indicate that a file name follows.  */
name|__write_long
argument_list|(
name|delimiter
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Write the string.  */
name|temp
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fwrite
argument_list|(
name|string
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|bb_file
argument_list|)
expr_stmt|;
comment|/* Append a few zeros, to align the output to a 4 byte boundary.  */
name|temp
operator|=
name|temp
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
literal|1
index|]
operator|=
name|c
index|[
literal|2
index|]
operator|=
name|c
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|4
operator|-
name|temp
argument_list|,
name|bb_file
argument_list|)
expr_stmt|;
block|}
comment|/* Store another delimiter in the .bb file, just to make it easy to find      the end of the file name.  */
name|__write_long
argument_list|(
name|delimiter
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the branch probabilities for the various branches.    Annotate them accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|compute_branch_probabilities
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_edges
init|=
literal|0
decl_stmt|;
name|int
name|changes
decl_stmt|;
name|int
name|passes
decl_stmt|;
name|int
name|hist_br_prob
index|[
literal|20
index|]
decl_stmt|;
name|int
name|num_never_executed
decl_stmt|;
name|int
name|num_branches
decl_stmt|;
comment|/* Attach extra info block to each bb.  */
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|GCOV_INDEX_TO_BB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|++
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|pred_count
operator|++
expr_stmt|;
block|}
comment|/* Avoid predicting entry on exit nodes.  */
name|BB_INFO
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
operator|->
name|succ_count
operator|=
literal|2
expr_stmt|;
name|BB_INFO
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|pred_count
operator|=
literal|2
expr_stmt|;
comment|/* For each edge not on the spanning tree, set its execution count from      the .da file.  */
comment|/* The first count in the .da file is the number of times that the function      was entered.  This is the exec_count for block zero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|GCOV_INDEX_TO_BB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
condition|)
block|{
name|num_edges
operator|++
expr_stmt|;
if|if
condition|(
name|da_file
condition|)
block|{
name|gcov_type
name|value
decl_stmt|;
name|__read_gcov_type
argument_list|(
operator|&
name|value
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|value
expr_stmt|;
block|}
else|else
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|pred_count
operator|--
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nRead edge from %i to %i, count:"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n%d edge counts read\n"
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
comment|/* For every block in the file,      - if every exit/entrance edge has a known count, then set the block count      - if the block count is known, and every exit/entrance edge but one has      a known execution count, then set the count of the remaining edge       As edge counts are set, decrement the succ/pred count, but don't delete      the edge, that way we can easily tell when all edges are known, or only      one edge is unknown.  */
comment|/* The order that the basic blocks are iterated through is important.      Since the code that finds spanning trees starts with block 0, low numbered      edges are put on the spanning tree in preference to high numbered edges.      Hence, most instrumented edges are at the end.  Graph solving works much      faster if we propagate numbers from the end to the start.       This takes an average of slightly more than 3 passes.  */
name|changes
operator|=
literal|1
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|passes
operator|++
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|+
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|GCOV_INDEX_TO_BB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bi
init|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|bi
operator|->
name|succ_count
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bi
operator|->
name|pred_count
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bi
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|bi
operator|->
name|succ_count
operator|==
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Seedgeh for the invalid edge, and set its count.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
break|break;
comment|/* Calculate count for remaining edge by conservation.  */
name|total
operator|=
name|bb
operator|->
name|count
operator|-
name|total
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|abort
argument_list|()
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|succ_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|pred_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bi
operator|->
name|pred_count
operator|==
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Seedgeh for the invalid edge, and set its count.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
break|break;
comment|/* Calculate count for remaining edge by conservation.  */
name|total
operator|=
name|bb
operator|->
name|count
operator|-
name|total
operator|+
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|abort
argument_list|()
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|pred_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|succ_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|total_num_passes
operator|+=
name|passes
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Graph solving took %d passes.\n\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
comment|/* If the graph has been correctly solved, every block will have a      succ and pred count of zero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|||
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|pred_count
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* For every edge, calculate its branch probability and add a reg_note      to the branch insn to indicate this.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|num_never_executed
operator|=
literal|0
expr_stmt|;
name|num_branches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n_basic_blocks
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|GCOV_INDEX_TO_BB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|gcov_type
name|total
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|total
operator|=
name|bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|e
operator|->
name|probability
operator|=
operator|(
name|e
operator|->
name|count
operator|*
name|REG_BR_PROB_BASE
operator|+
name|total
operator|/
literal|2
operator|)
operator|/
name|total
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|probability
operator|<
literal|0
operator|||
name|e
operator|->
name|probability
operator|>
name|REG_BR_PROB_BASE
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: prob for %d-%d thought to be %d"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|e
operator|->
name|probability
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
literal|0
operator|&&
name|any_condjump_p
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|int
name|prob
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Find the branch edge.  It is possible that we do have fake 		 edges here.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_FAKE
operator||
name|EDGE_FALLTHRU
operator|)
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
continue|continue;
comment|/* Loop body has been intentionally left blank.  */
name|prob
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|index
operator|=
name|prob
operator|*
literal|20
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|20
condition|)
name|index
operator|=
literal|19
expr_stmt|;
name|hist_br_prob
index|[
name|index
index|]
operator|++
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|bb
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* There may be already note put by some other pass, such 		 as builtin_expect expander.  */
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|prob
argument_list|)
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|prob
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|bb
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|num_branches
operator|++
expr_stmt|;
block|}
block|}
comment|/* Otherwise distribute the probabilities evenly so we get sane sum. 	 Use simple heuristics that if there are normal edges, give all abnormals 	 frequency of 0, otherwise distribute the frequency over abnormals 	 (this is the case of noreturn calls).  */
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|total
operator|++
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
name|total
expr_stmt|;
else|else
name|e
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|total
operator|++
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
name|total
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
literal|0
operator|&&
name|any_condjump_p
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|num_branches
operator|++
operator|,
name|num_never_executed
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d branches\n"
argument_list|,
name|num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d branches never executed\n"
argument_list|,
name|num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_branches
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|hist_br_prob
index|[
name|i
index|]
operator|+
name|hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
name|total_num_branches
operator|+=
name|num_branches
expr_stmt|;
name|total_num_never_executed
operator|+=
name|num_never_executed
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|+=
name|hist_br_prob
index|[
name|i
index|]
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Instrument and/or analyze program behavior based on program flow graph.    In either case, this function builds a flow graph for the function being    compiled.  The flow graph is stored in BB_GRAPH.     When FLAG_PROFILE_ARCS is nonzero, this function instruments the edges in    the flow graph that are needed to reconstruct the dynamic behavior of the    flow graph.     When FLAG_BRANCH_PROBABILITIES is nonzero, this function reads auxiliary    information from a data file containing edge count information from previous    executions of the function being compiled.  In this case, the flow graph is    annotated with actual execution counts, which are later propagated into the    rtl for optimization purposes.     Main entry point of this file.  */
end_comment

begin_function
name|void
name|branch_prob
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_edges
decl_stmt|,
name|ignored_edges
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
comment|/* Start of a function.  */
if|if
condition|(
name|flag_test_coverage
condition|)
name|output_gcov_string
argument_list|(
name|current_function_name
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|total_num_times_called
operator|++
expr_stmt|;
name|flow_call_edges_add
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
comment|/* We can't handle cyclic regions constructed using abnormal edges.      To avoid these we replace every source of abnormal edge by a fake      edge from entry node and every destination by fake edge to exit.      This keeps graph acyclic and our calculation exact for all normal      edges except for exit and entrance ones.       We also add fake exit edges for each call and asm statement in the      basic, since it may not return.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|int
name|need_exit_edge
init|=
literal|0
decl_stmt|,
name|need_entry_edge
init|=
literal|0
decl_stmt|;
name|int
name|have_exit_edge
init|=
literal|0
decl_stmt|,
name|have_entry_edge
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Add fake edges from entry block to the call insns that may return 	 twice.  The CFG is not quite correct then, as call insn plays more 	 role of CODE_LABEL, but for our purposes, everything should be OK, 	 as we never insert code to the beggining of basic block.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb
operator|->
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
condition|)
block|{
name|e
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* We should not get abort here, as call to setjmp should not 		     be the very first instruction of function.  */
if|if
condition|(
operator|!
name|i
condition|)
name|abort
argument_list|()
expr_stmt|;
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|need_exit_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|have_exit_edge
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|need_entry_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|have_entry_edge
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_exit_edge
operator|&&
operator|!
name|have_exit_edge
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Adding fake exit edge to bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_entry_edge
operator|&&
operator|!
name|have_entry_edge
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Adding fake entry edge to bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
block|}
name|el
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_info
argument_list|)
argument_list|)
expr_stmt|;
name|ignored_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Mark edges we've replaced by fake edges above as ignored.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|ignored_edges
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Output line number information about each basic block for      GCOV utility.  */
if|if
condition|(
name|flag_test_coverage
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|bb
operator|->
name|head
decl_stmt|;
specifier|static
name|int
name|ignore_next_note
init|=
literal|0
decl_stmt|;
comment|/* We are looking for line number notes.  Search backward before 	     basic block to find correct ones.  */
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Output a zero to the .bb file to indicate that a new 	     block list is starting.  */
name|__write_long
argument_list|(
literal|0
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|bb
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Must ignore the line number notes that immediately 		     follow the end of an inline function to avoid counting 		     it twice.  There is a note before the call, and one 		     after the call.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_REPEATED_LINE_NUMBER
condition|)
name|ignore_next_note
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_next_note
condition|)
name|ignore_next_note
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* If this is a new source file, then output the 			     file's name to the .bb file.  */
if|if
condition|(
operator|!
name|last_bb_file_name
operator|||
name|strcmp
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|last_bb_file_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_bb_file_name
condition|)
name|free
argument_list|(
name|last_bb_file_name
argument_list|)
expr_stmt|;
name|last_bb_file_name
operator|=
name|xstrdup
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|output_gcov_string
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the line number to the .bb file.  Must be 			     done after the output_bb_profile_data() call, and 			     after the file name is written, to ensure that it 			     is correctly handled by gcov.  */
name|__write_long
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|__write_long
argument_list|(
literal|0
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Create spanning tree from basic block graph, mark each edge that is      on the spanning tree.  We insert as many abnormal and critical edges      as possible to minimize number of edge splits necessary.  */
name|find_spanning_tree
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* Fake edges that are not on the tree will not be instrumented, so      mark them ignored.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|edge_info
modifier|*
name|inf
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|&&
operator|!
name|inf
operator|->
name|ignore
operator|&&
operator|!
name|inf
operator|->
name|on_tree
condition|)
block|{
name|inf
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|ignored_edges
operator|++
expr_stmt|;
block|}
block|}
name|total_num_blocks
operator|+=
name|n_basic_blocks
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d basic blocks\n"
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|total_num_edges
operator|+=
name|num_edges
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d edges\n"
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
name|total_num_edges_ignored
operator|+=
name|ignored_edges
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d ignored edges\n"
argument_list|,
name|ignored_edges
argument_list|)
expr_stmt|;
comment|/* Create a .bbg file from which gcov can reconstruct the basic block      graph.  First output the number of basic blocks, and then for every      edge output the source and target basic block numbers.      NOTE: The format of this file must be compatible with gcov.  */
if|if
condition|(
name|flag_test_coverage
condition|)
block|{
name|int
name|flag_bits
decl_stmt|;
comment|/* The plus 2 stands for entry and exit block.  */
name|__write_long
argument_list|(
name|n_basic_blocks
operator|+
literal|2
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|__write_long
argument_list|(
name|num_edges
operator|-
name|ignored_edges
operator|+
literal|1
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|GCOV_INDEX_TO_BB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
name|count
operator|++
expr_stmt|;
name|__write_long
argument_list|(
name|count
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|struct
name|edge_info
modifier|*
name|i
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i
operator|->
name|ignore
condition|)
block|{
name|flag_bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|on_tree
condition|)
name|flag_bits
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
name|flag_bits
operator||=
literal|0x2
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|flag_bits
operator||=
literal|0x4
expr_stmt|;
name|__write_long
argument_list|(
name|BB_TO_GCOV_INDEX
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|__write_long
argument_list|(
name|flag_bits
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Emit fake loopback edge for EXIT block to maintain compatibility with          old gcov format.  */
name|__write_long
argument_list|(
literal|1
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|__write_long
argument_list|(
literal|0
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|__write_long
argument_list|(
literal|0x1
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Emit a -1 to separate the list of all edges from the list of 	 loop back edges that follows.  */
name|__write_long
argument_list|(
operator|-
literal|1
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_branch_probabilities
condition|)
name|compute_branch_probabilities
argument_list|()
expr_stmt|;
comment|/* For each edge not on the spanning tree, add counting code as rtl.  */
if|if
condition|(
name|profile_arc_flag
condition|)
block|{
name|instrument_edges
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|remove_fake_edges
argument_list|()
expr_stmt|;
comment|/* Re-merge split basic blocks and the mess introduced by      insert_insn_on_edge.  */
name|cleanup_cfg
argument_list|(
name|profile_arc_flag
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|free_aux_for_edges
argument_list|()
expr_stmt|;
name|free_edge_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Union find algorithm implementation for the basic blocks using    aux fields.  */
end_comment

begin_function
specifier|static
name|basic_block
name|find_group
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|basic_block
name|group
init|=
name|bb
decl_stmt|,
name|bb1
decl_stmt|;
while|while
condition|(
operator|(
name|basic_block
operator|)
name|group
operator|->
name|aux
operator|!=
name|group
condition|)
name|group
operator|=
operator|(
name|basic_block
operator|)
name|group
operator|->
name|aux
expr_stmt|;
comment|/* Compress path.  */
while|while
condition|(
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|aux
operator|!=
name|group
condition|)
block|{
name|bb1
operator|=
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|aux
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
name|group
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
return|return
name|group
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|union_groups
parameter_list|(
name|bb1
parameter_list|,
name|bb2
parameter_list|)
name|basic_block
name|bb1
decl_stmt|,
name|bb2
decl_stmt|;
block|{
name|basic_block
name|bb1g
init|=
name|find_group
argument_list|(
name|bb1
argument_list|)
decl_stmt|;
name|basic_block
name|bb2g
init|=
name|find_group
argument_list|(
name|bb2
argument_list|)
decl_stmt|;
comment|/* ??? I don't have a place for the rank field.  OK.  Lets go w/o it,      this code is unlikely going to be performance problem anyway.  */
if|if
condition|(
name|bb1g
operator|==
name|bb2g
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb1g
operator|->
name|aux
operator|=
name|bb2g
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function searches all of the edges in the program flow graph, and puts    as many bad edges as possible onto the spanning tree.  Bad edges include    abnormals edges, which can't be instrumented at the moment.  Since it is    possible for fake edges to form an cycle, we will have to develop some    better way in the future.  Also put critical edges to the tree, since they    are more expensive to instrument.  */
end_comment

begin_function
specifier|static
name|void
name|find_spanning_tree
parameter_list|(
name|el
parameter_list|)
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
decl_stmt|;
comment|/* We use aux field for standard union-find algorithm.  */
name|EXIT_BLOCK_PTR
operator|->
name|aux
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Add fake edge exit to entry we can't instrument.  */
name|union_groups
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* First add all abnormal edges to the tree unless they form an cycle.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_FAKE
operator|)
operator|)
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|(
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|)
condition|)
block|{
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now insert all critical edges to the tree unless they form an cycle.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
operator|)
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|(
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|)
condition|)
block|{
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And now the rest.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
block|{
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
name|EXIT_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform file-level initialization for branch-prob processing.  */
end_comment

begin_function
name|void
name|init_branch_prob
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|long
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flag_test_coverage
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data_file
decl_stmt|,
modifier|*
name|bbg_file_name
decl_stmt|;
comment|/* Open an output file for the basic block/line number map.  */
name|data_file
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|data_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|data_file
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|".bb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb_file
operator|=
name|fopen
argument_list|(
name|data_file
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|fatal_io_error
argument_list|(
literal|"can't open %s"
argument_list|,
name|data_file
argument_list|)
expr_stmt|;
comment|/* Open an output file for the program flow graph.  */
name|bbg_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|bbg_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bbg_file_name
argument_list|,
literal|".bbg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bbg_file
operator|=
name|fopen
argument_list|(
name|bbg_file_name
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|fatal_io_error
argument_list|(
literal|"can't open %s"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
comment|/* Initialize to zero, to ensure that the first file name will be 	 written to the .bb file.  */
name|last_bb_file_name
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
name|char
modifier|*
name|da_file_name
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|da_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|da_file_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|da_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|da_file_name
argument_list|,
literal|".da"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|da_file
operator|=
name|fopen
argument_list|(
name|da_file_name
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"file %s not found, execution counts assumed to be zero"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
comment|/* The first word in the .da file gives the number of instrumented 	 edges, which is not needed for our purposes.  */
if|if
condition|(
name|da_file
condition|)
name|__read_long
argument_list|(
operator|&
name|len
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|profile_arc_flag
condition|)
name|init_edge_profiler
argument_list|()
expr_stmt|;
name|total_num_blocks
operator|=
literal|0
expr_stmt|;
name|total_num_edges
operator|=
literal|0
expr_stmt|;
name|total_num_edges_ignored
operator|=
literal|0
expr_stmt|;
name|total_num_edges_instrumented
operator|=
literal|0
expr_stmt|;
name|total_num_blocks_created
operator|=
literal|0
expr_stmt|;
name|total_num_passes
operator|=
literal|0
expr_stmt|;
name|total_num_times_called
operator|=
literal|0
expr_stmt|;
name|total_num_branches
operator|=
literal|0
expr_stmt|;
name|total_num_never_executed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Performs file-level cleanup after branch-prob processing    is completed.  */
end_comment

begin_function
name|void
name|end_branch_prob
parameter_list|()
block|{
if|if
condition|(
name|flag_test_coverage
condition|)
block|{
name|fclose
argument_list|(
name|bb_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|bbg_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
if|if
condition|(
name|da_file
condition|)
block|{
name|long
name|temp
decl_stmt|;
comment|/* This seems slightly dangerous, as it presumes the EOF 	     flag will not be set until an attempt is made to read 	     past the end of the file.  */
if|if
condition|(
name|feof
argument_list|(
name|da_file
argument_list|)
condition|)
name|error
argument_list|(
literal|".da file contents exhausted too early"
argument_list|)
expr_stmt|;
comment|/* Should be at end of file now.  */
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|temp
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|".da file contents not exhausted"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|da_file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of blocks: %d\n"
argument_list|,
name|total_num_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of edges: %d\n"
argument_list|,
name|total_num_edges
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of ignored edges: %d\n"
argument_list|,
name|total_num_edges_ignored
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of instrumented edges: %d\n"
argument_list|,
name|total_num_edges_instrumented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of blocks created: %d\n"
argument_list|,
name|total_num_blocks_created
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of graph solution passes: %d\n"
argument_list|,
name|total_num_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_times_called
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Average number of graph solution passes: %d\n"
argument_list|,
operator|(
name|total_num_passes
operator|+
operator|(
name|total_num_times_called
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total_num_times_called
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of branches: %d\n"
argument_list|,
name|total_num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Total number of branches never executed: %d\n"
argument_list|,
name|total_num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_branches
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|total_hist_br_prob
index|[
name|i
index|]
operator|+
name|total_hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|total_num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The label used by the edge profiling code.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|profiler_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the profiler_label.  */
end_comment

begin_function
specifier|static
name|void
name|init_edge_profiler
parameter_list|()
block|{
comment|/* Generate and save a copy of this so it can be shared.  */
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|profiler_label
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|profiler_label
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output instructions as RTL to increment the edge execution count.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_edge_profiler
parameter_list|(
name|edgeno
parameter_list|)
name|int
name|edgeno
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|GCOV_TYPE_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem_ref
decl_stmt|,
name|tmp
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|profiler_label
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
name|GCOV_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
operator|*
name|edgeno
argument_list|)
expr_stmt|;
name|mem_ref
operator|=
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|mem_ref
argument_list|,
name|const1_rtx
argument_list|,
name|mem_ref
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|mem_ref
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mem_ref
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Output code for a constructor that will invoke __bb_init_func, if    this has not already been done.  */
end_comment

begin_function
name|void
name|output_func_start_profiler
parameter_list|()
block|{
name|tree
name|fnname
decl_stmt|,
name|fndecl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cfnname
decl_stmt|;
name|rtx
name|table_address
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|GCOV_TYPE_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|save_flag_inline_functions
init|=
name|flag_inline_functions
decl_stmt|;
name|int
name|save_flag_test_coverage
init|=
name|flag_test_coverage
decl_stmt|;
name|int
name|save_profile_arc_flag
init|=
name|profile_arc_flag
decl_stmt|;
name|int
name|save_flag_branch_probabilities
init|=
name|flag_branch_probabilities
decl_stmt|;
comment|/* It's either already been output, or we don't need it because we're      not doing profile-edges.  */
if|if
condition|(
operator|!
name|need_func_profiler
condition|)
return|return;
name|need_func_profiler
operator|=
literal|0
expr_stmt|;
comment|/* Synthesize a constructor function to invoke __bb_init_func with a      pointer to this object file's profile block.  */
comment|/* Try and make a unique name given the "file function name".       And no, I don't like this either.  */
name|fnname
operator|=
name|get_file_function_name
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
name|cfnname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|name
operator|=
name|concat
argument_list|(
name|cfnname
argument_list|,
literal|"GCOV"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fnname
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* It can be a static function as long as collect2 does not have      to scan the object file to find its ctor/dtor routine.  */
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
operator|=
operator|!
name|targetm
operator|.
name|have_ctors_dtors
expr_stmt|;
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|pushdecl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|announce_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|fndecl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Actually generate the code to call __bb_init_func.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LPBX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table_address
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__bb_init_func"
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|table_address
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Since fndecl isn't in the list of globals, it would never be emitted      when it's considered to be 'safe' for inlining, so turn off      flag_inline_functions.  */
name|flag_inline_functions
operator|=
literal|0
expr_stmt|;
comment|/* Don't instrument the function that turns on instrumentation.  Which      is also handy since we'd get silly warnings about not consuming all      of our da_file input.  */
name|flag_test_coverage
operator|=
literal|0
expr_stmt|;
name|profile_arc_flag
operator|=
literal|0
expr_stmt|;
name|flag_branch_probabilities
operator|=
literal|0
expr_stmt|;
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Reset flag_inline_functions to its original value.  */
name|flag_inline_functions
operator|=
name|save_flag_inline_functions
expr_stmt|;
name|flag_test_coverage
operator|=
name|save_flag_test_coverage
expr_stmt|;
name|profile_arc_flag
operator|=
name|save_profile_arc_flag
expr_stmt|;
name|flag_branch_probabilities
operator|=
name|save_flag_branch_probabilities
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|have_ctors_dtors
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|constructor
call|)
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

