begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate branch probabilities, and basic block execution counts.     Copyright (C) 1990, 91-94, 96-98, 1999 Free Software Foundation, Inc.    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;    based on some ideas from Dain Samples of UC Berkeley.    Further mangling by Bob Manson, Cygnus Support.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ??? Really should not put insns inside of LIBCALL sequences, when putting    insns after a call, should look for the insn setting the retval, and    insert the insns after that one.  */
end_comment

begin_comment
comment|/* ??? Register allocation should use basic block execution counts to    give preference to the most commonly executed blocks.  */
end_comment

begin_comment
comment|/* ??? The .da files are not safe.  Changing the program after creating .da    files or using different options when compiling with -fbranch-probabilities    can result the arc data not matching the program.  Maybe add instrumented    arc count to .bbg file?  Maybe check whether PFG matches the .bbg file?  */
end_comment

begin_comment
comment|/* ??? Should calculate branch probabilities before instrumenting code, since    then we can use arc counts to help decide which arcs to instrument.  */
end_comment

begin_comment
comment|/* ??? Rearrange code so that the most frequently executed arcs become from    one block to the next block (i.e. a fall through), move seldom executed    code outside of loops even at the expense of adding a few branches to    achieve this, see Dain Sample's UC Berkeley thesis.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* One of these is dynamically created whenever we identify an arc in the    function.  */
end_comment

begin_struct
struct|struct
name|adj_list
block|{
name|int
name|source
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|arc_count
decl_stmt|;
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fake
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fall_through
range|:
literal|1
decl_stmt|;
name|rtx
name|branch_insn
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|pred_next
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|succ_next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ARC_TARGET
parameter_list|(
name|ARCPTR
parameter_list|)
value|(ARCPTR->target)
end_define

begin_define
define|#
directive|define
name|ARC_SOURCE
parameter_list|(
name|ARCPTR
parameter_list|)
value|(ARCPTR->source)
end_define

begin_define
define|#
directive|define
name|ARC_COUNT
parameter_list|(
name|ARCPTR
parameter_list|)
value|(ARCPTR->arc_count)
end_define

begin_comment
comment|/* Count the number of basic blocks, and create an array of these structures,    one for each bb in the function.  */
end_comment

begin_struct
struct|struct
name|bb_info
block|{
name|struct
name|adj_list
modifier|*
name|succ
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|pred
decl_stmt|;
name|int
name|succ_count
decl_stmt|;
name|int
name|pred_count
decl_stmt|;
name|int
name|exec_count
decl_stmt|;
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Indexed by label number, gives the basic block number containing that    label.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|label_to_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of valid entries in the label_to_bb array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|label_to_bb_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by block index, holds the basic block graph.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb_info
modifier|*
name|bb_graph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the output file for the basic block graph.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bbg_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bbg_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and file pointer of the input file for the arc count data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|da_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|da_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer of the output file for the basic block/line number map. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bb_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last source file name written to bb_file. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_bb_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates whether the next line number note should be output to    bb_file or not.  Used to eliminate a redundant note after an    expanded inline function call.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_next_note
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by final, for allocating the proper amount of storage for the    instrumented arc execution counts.  */
end_comment

begin_decl_stmt
name|int
name|count_instrumented_arcs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of executions for the return label.  */
end_comment

begin_decl_stmt
name|int
name|return_label_execution_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Collect statistics on the performance of this pass for the entire source    file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_arcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_arcs_instrumented
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks_created
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_passes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_times_called
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_hist_br_prob
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_never_executed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_branches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_arc
name|PROTO
argument_list|(
operator|(
expr|struct
name|adj_list
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_spanning_tree
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_spanning_tree
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_spanning_tree
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_arc_profiler
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_arc_profiler
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-zero, we need to output a constructor to set up the    per-object-file data. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_func_profiler
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add arc instrumentation code to the entire insn chain.     F is the first insn of the chain.    NUM_BLOCKS is the number of basic blocks found in F.    DUMP_FILE, if nonzero, is an rtl dump file we can write to.  */
end_comment

begin_function
specifier|static
name|void
name|instrument_arcs
parameter_list|(
name|f
parameter_list|,
name|num_blocks
parameter_list|,
name|dump_file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|num_blocks
decl_stmt|;
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|,
modifier|*
name|backptr
decl_stmt|;
name|int
name|num_arcs
init|=
literal|0
decl_stmt|;
name|int
name|num_instr_arcs
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Instrument the program start.  */
comment|/* Handle block 0 specially, since it will always be instrumented,      but it doesn't have a valid first_insn or branch_insn.  We must      put the instructions before the NOTE_INSN_FUNCTION_BEG note, so      that they don't clobber any of the parameters of the current      function.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|need_func_profiler
operator|=
literal|1
expr_stmt|;
name|output_arc_profiler
argument_list|(
name|total_num_arcs_instrumented
operator|+
name|num_instr_arcs
operator|++
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|on_tree
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Arc %d to %d instrumented\n"
argument_list|,
name|i
argument_list|,
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if this arc is the only exit from its source block, 	     or the only entrance to its target block.  In either case, 	     we don't need to create a new block to instrument the arc.  */
if|if
condition|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
operator|==
name|arcptr
operator|&&
name|arcptr
operator|->
name|succ_next
operator|==
literal|0
condition|)
block|{
comment|/* Instrument the source block.  */
name|output_arc_profiler
argument_list|(
name|total_num_arcs_instrumented
operator|+
name|num_instr_arcs
operator|++
argument_list|,
name|PREV_INSN
argument_list|(
name|bb_graph
index|[
name|i
index|]
operator|.
name|first_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arcptr
operator|==
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|pred
operator|&&
name|arcptr
operator|->
name|pred_next
operator|==
literal|0
condition|)
block|{
comment|/* Instrument the target block.  */
name|output_arc_profiler
argument_list|(
name|total_num_arcs_instrumented
operator|+
name|num_instr_arcs
operator|++
argument_list|,
name|PREV_INSN
argument_list|(
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|first_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arcptr
operator|->
name|fall_through
condition|)
block|{
comment|/* This is a fall-through; put the instrumentation code after 		 the branch that ends this block.  */
for|for
control|(
name|backptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|backptr
condition|;
name|backptr
operator|=
name|backptr
operator|->
name|succ_next
control|)
if|if
condition|(
name|backptr
operator|!=
name|arcptr
condition|)
break|break;
name|output_arc_profiler
argument_list|(
name|total_num_arcs_instrumented
operator|+
name|num_instr_arcs
operator|++
argument_list|,
name|backptr
operator|->
name|branch_insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Must emit a new basic block to hold the arc counting code.  */
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Create the new basic block right after the branch. 		     Invert the branch so that it jumps past the end of the new 		     block.  The new block will consist of the instrumentation 		     code, and a jump to the target of this arc.  */
name|int
name|this_is_simplejump
init|=
name|simplejump_p
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
decl_stmt|;
name|rtx
name|new_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|old_label
decl_stmt|,
name|set_src
decl_stmt|;
name|rtx
name|after
init|=
name|arcptr
operator|->
name|branch_insn
decl_stmt|;
comment|/* Simplejumps can't reach here.  */
if|if
condition|(
name|this_is_simplejump
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We can't use JUMP_LABEL, because it won't be set if we 		     are compiling without optimization.  */
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|single_set
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|old_label
operator|=
name|set_src
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
name|old_label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|old_label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the JUMP_LABEL so that redirect_jump will work.  */
name|JUMP_LABEL
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
operator|=
name|old_label
expr_stmt|;
comment|/* Add a use for OLD_LABEL that will be needed when we emit 		     the JUMP_INSN below.  If we don't do this here, 		     `invert_jump' might delete it for us.  We must add two 		     when not optimizing, because the NUSES is zero now, 		     but must be at least two to prevent the label from being 		     deleted.  */
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
operator|+=
literal|2
expr_stmt|;
comment|/* Emit the insns for the new block in reverse order, 		     since that is most convenient.  */
if|if
condition|(
name|this_is_simplejump
condition|)
block|{
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|,
name|new_label
argument_list|)
condition|)
comment|/* Don't know what to do if this branch won't 			   redirect.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|invert_jump
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|,
name|new_label
argument_list|)
condition|)
comment|/* Don't know what to do if this branch won't invert.  */
name|abort
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|new_label
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
operator|++
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|old_label
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|=
name|old_label
expr_stmt|;
comment|/* Instrument the source arc.  */
name|output_arc_profiler
argument_list|(
name|total_num_arcs_instrumented
operator|+
name|num_instr_arcs
operator|++
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_simplejump
condition|)
block|{
name|emit_label_after
argument_list|(
name|new_label
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_VEC
operator|||
name|code
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
comment|/* A table jump.  Create a new basic block immediately 		     after the table, by emitting a barrier, a label, a 		     counting note, and a jump to the old label.  Put the 		     new label in the table.  */
name|rtx
name|new_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|old_lref
decl_stmt|,
name|new_lref
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Must determine the old_label reference, do this 		     by counting the arcs after this one, which will 		     give the index of our label in the table.  */
name|index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|backptr
operator|=
name|arcptr
operator|->
name|succ_next
init|;
name|backptr
condition|;
name|backptr
operator|=
name|backptr
operator|->
name|succ_next
control|)
name|index
operator|++
expr_stmt|;
name|old_lref
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
argument_list|,
operator|(
name|code
operator|==
name|ADDR_DIFF_VEC
operator|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Emit the insns for the new block in reverse order, 		     since that is most convenient.  */
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|XEXP
argument_list|(
name|old_lref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|arcptr
operator|->
name|branch_insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|NEXT_INSN
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
argument_list|)
operator|=
name|XEXP
argument_list|(
name|old_lref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Instrument the source arc.  */
name|output_arc_profiler
argument_list|(
name|total_num_arcs_instrumented
operator|+
name|num_instr_arcs
operator|++
argument_list|,
name|arcptr
operator|->
name|branch_insn
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|new_label
argument_list|,
name|arcptr
operator|->
name|branch_insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|NEXT_INSN
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
expr_stmt|;
comment|/* Fix up the table jump.  */
name|new_lref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
argument_list|,
operator|(
name|code
operator|==
name|ADDR_DIFF_VEC
operator|)
argument_list|,
name|index
argument_list|)
operator|=
name|new_lref
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|num_arcs
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Arc %d to %d needed new basic block\n"
argument_list|,
name|i
argument_list|,
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|total_num_arcs_instrumented
operator|+=
name|num_instr_arcs
expr_stmt|;
name|count_instrumented_arcs
operator|=
name|total_num_arcs_instrumented
expr_stmt|;
name|total_num_blocks_created
operator|+=
name|num_arcs
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d arcs instrumented\n"
argument_list|,
name|num_instr_arcs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d extra basic blocks created\n"
argument_list|,
name|num_arcs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output STRING to bb_file, surrounded by DELIMITER.  */
end_comment

begin_function
specifier|static
name|void
name|output_gcov_string
parameter_list|(
name|string
parameter_list|,
name|delimiter
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|long
name|delimiter
decl_stmt|;
block|{
name|long
name|temp
decl_stmt|;
comment|/* Write a delimiter to indicate that a file name follows.  */
name|__write_long
argument_list|(
name|delimiter
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Write the string.  */
name|temp
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fwrite
argument_list|(
name|string
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|bb_file
argument_list|)
expr_stmt|;
comment|/* Append a few zeros, to align the output to a 4 byte boundary.  */
name|temp
operator|=
name|temp
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
literal|1
index|]
operator|=
name|c
index|[
literal|2
index|]
operator|=
name|c
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|4
operator|-
name|temp
argument_list|,
name|bb_file
argument_list|)
expr_stmt|;
block|}
comment|/* Store another delimiter in the .bb file, just to make it easy to find the      end of the file name.  */
name|__write_long
argument_list|(
name|delimiter
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE if this insn must be a tablejump entry insn.  This works for    the MIPS port, but may give false negatives for some targets.  */
end_comment

begin_function
name|int
name|tablejump_entry_p
parameter_list|(
name|insn
parameter_list|,
name|label
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|;
block|{
name|rtx
name|next
init|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|ADDR_DIFF_VEC
operator|&&
name|code
operator|!=
name|ADDR_VEC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|==
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Instrument and/or analyze program behavior based on program flow graph.    In either case, this function builds a flow graph for the function being    compiled.  The flow graph is stored in BB_GRAPH.     When FLAG_PROFILE_ARCS is nonzero, this function instruments the arcs in    the flow graph that are needed to reconstruct the dynamic behavior of the    flow graph.     When FLAG_BRANCH_PROBABILITIES is nonzero, this function reads auxiliary    information from a data file containing arc count information from previous    executions of the function being compiled.  In this case, the flow graph is    annotated with actual execution counts, which are later propagated into the    rtl for optimization purposes.     Main entry point of this file.  */
end_comment

begin_function
name|void
name|branch_prob
parameter_list|(
name|f
parameter_list|,
name|dump_file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|num_blocks
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|int
name|num_arcs
decl_stmt|,
name|changes
decl_stmt|,
name|passes
decl_stmt|;
name|int
name|total
decl_stmt|,
name|prob
decl_stmt|;
name|int
name|hist_br_prob
index|[
literal|20
index|]
decl_stmt|,
name|num_never_executed
decl_stmt|,
name|num_branches
decl_stmt|;
comment|/* Set to non-zero if we got bad count information.  */
name|int
name|bad_counts
init|=
literal|0
decl_stmt|;
comment|/* start of a function.  */
if|if
condition|(
name|flag_test_coverage
condition|)
name|output_gcov_string
argument_list|(
name|current_function_name
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Execute this only if doing arc profiling or branch probabilities.  */
if|if
condition|(
operator|!
name|profile_arc_flag
operator|&&
operator|!
name|flag_branch_probabilities
operator|&&
operator|!
name|flag_test_coverage
condition|)
name|abort
argument_list|()
expr_stmt|;
name|total_num_times_called
operator|++
expr_stmt|;
comment|/* Create an array label_to_bb of ints of size max_label_num.  */
name|label_to_bb_size
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|label_to_bb
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|label_to_bb_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|label_to_bb
argument_list|,
name|label_to_bb_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the insns in the function, count the number of basic blocks      present.  When a code label is passed, set label_to_bb[label] = bb      number.  */
comment|/* The first block found will be block 1, so that function entry can be      block 0.  */
block|{
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|JUMP_INSN
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|block_separator_emitted
init|=
literal|0
decl_stmt|;
name|ignore_next_note
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|f
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|BARRIER
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
comment|/* This label is part of the next block, but we can't increment 	     block number yet since there might be multiple labels.  */
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* We make NOTE_INSN_SETJMP notes into a block of their own, so that 	   they can be the target of the fake arc for the setjmp call. 	   This avoids creating cycles of fake arcs, which would happen if 	   the block after the setjmp call contained a call insn.  */
elseif|else
if|if
condition|(
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
name|prev_code
operator|==
name|CALL_INSN
operator|||
name|prev_code
operator|==
name|CODE_LABEL
operator|||
name|prev_code
operator|==
name|BARRIER
operator|)
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|||
operator|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
operator|)
operator|)
condition|)
block|{
name|i
operator|+=
literal|1
expr_stmt|;
comment|/* Emit the block separator if it hasn't already been emitted.  */
if|if
condition|(
name|flag_test_coverage
operator|&&
operator|!
name|block_separator_emitted
condition|)
block|{
comment|/* Output a zero to the .bb file to indicate that a new 		   block list is starting.  */
name|__write_long
argument_list|(
literal|0
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|block_separator_emitted
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If flag_test_coverage is true, then we must add an entry to the 	   .bb file for every note.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|NOTE
operator|&&
name|flag_test_coverage
condition|)
block|{
comment|/* Must ignore the line number notes that immediately follow the 	       end of an inline function to avoid counting it twice.  There 	       is a note before the call, and one after the call.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_REPEATED_LINE_NUMBER
condition|)
name|ignore_next_note
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_next_note
condition|)
name|ignore_next_note
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Emit a block separator here to ensure that a NOTE 		       immediately following a JUMP_INSN or CALL_INSN will end 		       up in the right basic block list.  */
if|if
condition|(
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
name|prev_code
operator|==
name|CALL_INSN
operator|||
name|prev_code
operator|==
name|CODE_LABEL
operator|||
name|prev_code
operator|==
name|BARRIER
operator|)
operator|&&
operator|!
name|block_separator_emitted
condition|)
block|{
comment|/* Output a zero to the .bb file to indicate that 			   a new block list is starting.  */
name|__write_long
argument_list|(
literal|0
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|block_separator_emitted
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a new source file, then output the file's 		       name to the .bb file.  */
if|if
condition|(
operator|!
name|last_bb_file_name
operator|||
name|strcmp
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|last_bb_file_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_bb_file_name
condition|)
name|free
argument_list|(
name|last_bb_file_name
argument_list|)
expr_stmt|;
name|last_bb_file_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|last_bb_file_name
argument_list|,
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|output_gcov_string
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the line number to the .bb file.  Must be done 		       after the output_bb_profile_data() call, and after the 		       file name is written, to ensure that it is correctly 		       handled by gcov.  */
name|__write_long
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|prev_code
operator|=
name|CALL_INSN
expr_stmt|;
block|}
comment|/* Allocate last `normal' entry for bb_graph.  */
comment|/* The last insn was a jump, call, or label.  In that case we have        a block at the end of the function with no insns.  */
if|if
condition|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
name|prev_code
operator|==
name|CALL_INSN
operator|||
name|prev_code
operator|==
name|CODE_LABEL
operator|||
name|prev_code
operator|==
name|BARRIER
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* Emit the block separator if it hasn't already been emitted.  */
if|if
condition|(
name|flag_test_coverage
operator|&&
operator|!
name|block_separator_emitted
condition|)
block|{
comment|/* Output a zero to the .bb file to indicate that a new 	       block list is starting.  */
name|__write_long
argument_list|(
literal|0
argument_list|,
name|bb_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create another block to stand for EXIT, and make all return insns, and        the last basic block point here.  Add one more to account for block        zero.  */
name|num_blocks
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
name|total_num_blocks
operator|+=
name|num_blocks
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d basic blocks\n"
argument_list|,
name|num_blocks
argument_list|)
expr_stmt|;
comment|/* If we are only doing test coverage here, then return now.  */
if|if
condition|(
operator|!
name|profile_arc_flag
operator|&&
operator|!
name|flag_branch_probabilities
condition|)
return|return;
comment|/* Create and initialize the arrays that will hold bb_graph      and execution count info.  */
name|bb_graph
operator|=
operator|(
expr|struct
name|bb_info
operator|*
operator|)
name|alloca
argument_list|(
name|num_blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_graph
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
operator|*
name|num_blocks
operator|)
argument_list|)
expr_stmt|;
block|{
comment|/* Scan the insns again:        - at the entry to each basic block, increment the predecessor count        (and successor of previous block) if it is a fall through entry,        create adj_list entries for this and the previous block        - at each jump insn, increment predecessor/successor counts for        target/source basic blocks, add this insn to pred/succ lists.         This also cannot be broken out as a separate subroutine        because it uses `alloca'.  */
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|JUMP_INSN
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fall_through
init|=
literal|0
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|int
name|dest
init|=
literal|0
decl_stmt|;
comment|/* Block 0 always falls through to block 1.  */
name|num_arcs
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
literal|1
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
comment|/* Add a fake fall through arc from the last block to block 0, to make the        graph complete.  */
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|num_blocks
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
literal|1
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
comment|/* Exit must be one node of the graph, and all exits from the function        must point there.  When see a return branch, must point the arc to the        exit node.  */
comment|/* Must start scan with second insn in function as above.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|f
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|BARRIER
condition|)
name|fall_through
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
empty_stmt|;
comment|/* We make NOTE_INSN_SETJMP notes into a block of their own, so that 	   they can be the target of the fake arc for the setjmp call. 	   This avoids creating cycles of fake arcs, which would happen if 	   the block after the setjmp call ended with a call.  */
elseif|else
if|if
condition|(
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
name|prev_code
operator|==
name|CALL_INSN
operator|||
name|prev_code
operator|==
name|CODE_LABEL
operator|||
name|prev_code
operator|==
name|BARRIER
operator|)
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|||
operator|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
operator|)
operator|)
condition|)
block|{
comment|/* This is the first insn of the block.  */
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|fall_through
condition|)
block|{
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
literal|1
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
block|}
name|fall_through
operator|=
literal|1
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|first_insn
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
block|{
empty_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* In the normal case, the call returns, and this is just like 	       a branch fall through.  */
name|fall_through
operator|=
literal|1
expr_stmt|;
comment|/* Setjmp may return more times than called, so to make the graph 	       solvable, add a fake arc from the function entrance to the 	       next block.  	       All other functions may return fewer times than called (if 	       a descendent call longjmp or exit), so to make the graph 	       solvable, add a fake arc to the function exit from the 	       current block.  	       Distinguish the cases by checking for a SETJUMP note. 	       A call_insn can be the last ins of a function, so must check 	       to see if next insn actually exists.  */
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|init_arc
argument_list|(
name|arcptr
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|i
argument_list|,
name|num_blocks
operator|-
literal|1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
literal|1
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|tem
decl_stmt|,
name|pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|tablejump
init|=
literal|0
decl_stmt|;
comment|/* If running without optimization, then jump label won't be valid, 	       so we must search for the destination label in that case. 	       We have to handle tablejumps and returns specially anyways, so 	       we don't check the JUMP_LABEL at all here.  */
comment|/* ??? This code should be rewritten.  We need a more elegant way 	       to find the LABEL_REF.  We need a more elegant way to 	       differentiate tablejump entries from computed gotos. 	       We should perhaps reuse code from flow to compute the CFG 	       instead of trying to compute it here.  	       We can't use current_function_has_computed_jump, because that 	       is calculated later by flow.  We can't use computed_jump_p, 	       because that returns true for tablejump entry insns for some 	       targets, e.g. HPPA and MIPS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* This assumes that PARALLEL jumps with a USE are 		   tablejump entry jumps.  The same assumption can be found 		   in computed_jump_p.  */
comment|/* Make an arc from this jump to the label of the 		   jump table.  This will instrument the number of 		   times the switch statement is executed.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|tem
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|LABEL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dest
operator|=
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
name|tem
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest
operator|=
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|tablejump
operator|=
name|pattern
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|RETURN
condition|)
name|dest
operator|=
name|num_blocks
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tem
operator|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|dest
operator|=
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Recognize HPPA table jump entry.  This code is similar to 	       the code above in the PARALLEL case.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|tablejump_entry_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|dest
operator|=
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Recognize the MIPS table jump entry.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|tablejump_entry_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|dest
operator|=
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
else|else
block|{
name|rtx
name|label_ref
decl_stmt|;
comment|/* Must be an IF_THEN_ELSE branch.  If it isn't, assume it 		   is a computed goto, which aren't supported yet.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
name|fatal
argument_list|(
literal|"-fprofile-arcs does not support computed gotos"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
operator|!=
name|pc_rtx
condition|)
name|label_ref
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|label_ref
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dest
operator|=
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|label_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|tablejump
condition|)
block|{
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|tablejump
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|tablejump
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|tablejump
argument_list|,
name|diff_vec_p
argument_list|,
name|k
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dest
operator|=
name|label_to_bb
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|tem
argument_list|)
index|]
expr_stmt|;
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|i
argument_list|,
name|dest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|i
argument_list|,
name|dest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
block|}
comment|/* Determine whether or not this jump will fall through. 	       Unconditional jumps and returns are not always followed by 	       barriers.  */
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|RETURN
condition|)
name|fall_through
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
comment|/* These aren't actually jump insns, but they never fall 		 through, so...  */
name|fall_through
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
operator|!=
name|pc_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
name|fall_through
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
comment|/* Make a fake insn to tag our notes on.  */
name|bb_graph
index|[
name|i
index|]
operator|.
name|first_insn
operator|=
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|prev_code
operator|=
name|CALL_INSN
expr_stmt|;
block|}
block|}
comment|/* If the code at the end of the function would give a new block, then        do the following.  */
if|if
condition|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
name|prev_code
operator|==
name|CALL_INSN
operator|||
name|prev_code
operator|==
name|CODE_LABEL
operator|||
name|prev_code
operator|==
name|BARRIER
condition|)
block|{
if|if
condition|(
name|fall_through
condition|)
block|{
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
literal|1
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
block|}
comment|/* This may not be a real insn, but that should not cause a problem.  */
name|bb_graph
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|first_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* There is always a fake arc from the last block of the function        to the function exit block.  */
name|arcptr
operator|=
operator|(
expr|struct
name|adj_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adj_list
argument_list|)
argument_list|)
expr_stmt|;
name|init_arc
argument_list|(
name|arcptr
argument_list|,
name|num_blocks
operator|-
literal|2
argument_list|,
name|num_blocks
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
literal|1
expr_stmt|;
name|num_arcs
operator|++
expr_stmt|;
block|}
name|total_num_arcs
operator|+=
name|num_arcs
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d arcs\n"
argument_list|,
name|num_arcs
argument_list|)
expr_stmt|;
comment|/* Create spanning tree from basic block graph, mark each arc that is      on the spanning tree.  */
comment|/* To reduce the instrumentation cost, make two passes over the tree.      First, put as many must-split (crowded and fake) arcs on the tree as      possible, then on the second pass fill in the rest of the tree.      Note that the spanning tree is considered undirected, so that as many      must-split arcs as possible can be put on it.       Fallthrough arcs which are crowded should not be chosen on the first      pass, since they do not require creating a new basic block.  These      arcs will have fall_through set.  */
name|find_spanning_tree
argument_list|(
name|num_blocks
argument_list|)
expr_stmt|;
comment|/* Create a .bbg file from which gcov can reconstruct the basic block      graph.  First output the number of basic blocks, and then for every      arc output the source and target basic block numbers.      NOTE: The format of this file must be compatible with gcov.  */
if|if
condition|(
name|flag_test_coverage
condition|)
block|{
name|int
name|flag_bits
decl_stmt|;
name|__write_long
argument_list|(
name|num_blocks
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|__write_long
argument_list|(
name|num_arcs
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
name|count
operator|++
expr_stmt|;
name|__write_long
argument_list|(
name|count
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
block|{
name|flag_bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arcptr
operator|->
name|on_tree
condition|)
name|flag_bits
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|arcptr
operator|->
name|fake
condition|)
name|flag_bits
operator||=
literal|0x2
expr_stmt|;
if|if
condition|(
name|arcptr
operator|->
name|fall_through
condition|)
name|flag_bits
operator||=
literal|0x4
expr_stmt|;
name|__write_long
argument_list|(
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|__write_long
argument_list|(
name|flag_bits
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit a -1 to separate the list of all arcs from the list of 	 loop back edges that follows.  */
name|__write_long
argument_list|(
operator|-
literal|1
argument_list|,
name|bbg_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* For each arc not on the spanning tree, add counting code as rtl.  */
if|if
condition|(
name|profile_arc_flag
condition|)
block|{
name|instrument_arcs
argument_list|(
name|f
argument_list|,
name|num_blocks
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Execute the rest only if doing branch probabilities.  */
if|if
condition|(
operator|!
name|flag_branch_probabilities
condition|)
return|return;
comment|/* For each arc not on the spanning tree, set its execution count from      the .da file.  */
comment|/* The first count in the .da file is the number of times that the function      was entered.  This is the exec_count for block zero.  */
name|num_arcs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|on_tree
condition|)
block|{
name|num_arcs
operator|++
expr_stmt|;
if|if
condition|(
name|da_file
condition|)
block|{
name|long
name|value
decl_stmt|;
name|__read_long
argument_list|(
operator|&
name|value
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
else|else
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d arc counts read\n"
argument_list|,
name|num_arcs
argument_list|)
expr_stmt|;
comment|/* For every block in the file,      - if every exit/entrance arc has a known count, then set the block count      - if the block count is known, and every exit/entrance arc but one has        a known execution count, then set the count of the remaining arc       As arc counts are set, decrement the succ/pred count, but don't delete      the arc, that way we can easily tell when all arcs are known, or only      one arc is unknown.  */
comment|/* The order that the basic blocks are iterated through is important.      Since the code that finds spanning trees starts with block 0, low numbered      arcs are put on the spanning tree in preference to high numbered arcs.      Hence, most instrumented arcs are at the end.  Graph solving works much      faster if we propagate numbers from the end to the start.            This takes an average of slightly more than 3 passes.  */
name|changes
operator|=
literal|1
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|passes
operator|++
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|bb_info
modifier|*
name|binfo
init|=
operator|&
name|bb_graph
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|binfo
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|binfo
operator|->
name|succ_count
operator|==
literal|0
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
name|total
operator|+=
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
expr_stmt|;
name|binfo
operator|->
name|exec_count
operator|=
name|total
expr_stmt|;
name|binfo
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binfo
operator|->
name|pred_count
operator|==
literal|0
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
name|total
operator|+=
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
expr_stmt|;
name|binfo
operator|->
name|exec_count
operator|=
name|total
expr_stmt|;
name|binfo
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|binfo
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|binfo
operator|->
name|succ_count
operator|==
literal|1
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
name|total
operator|+=
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
expr_stmt|;
comment|/* Calculate count for remaining arc by conservation.  */
name|total
operator|=
name|binfo
operator|->
name|exec_count
operator|-
name|total
expr_stmt|;
comment|/* Search for the invalid arc, and set its count.  */
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|count_valid
condition|)
break|break;
if|if
condition|(
operator|!
name|arcptr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
operator|=
name|total
expr_stmt|;
name|binfo
operator|->
name|succ_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|pred_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|binfo
operator|->
name|pred_count
operator|==
literal|1
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
name|total
operator|+=
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
expr_stmt|;
comment|/* Calculate count for remaining arc by conservation.  */
name|total
operator|=
name|binfo
operator|->
name|exec_count
operator|-
name|total
expr_stmt|;
comment|/* Search for the invalid arc, and set its count.  */
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|count_valid
condition|)
break|break;
if|if
condition|(
operator|!
name|arcptr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
operator|=
name|total
expr_stmt|;
name|binfo
operator|->
name|pred_count
operator|--
expr_stmt|;
name|bb_graph
index|[
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|succ_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
name|total_num_passes
operator|+=
name|passes
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Graph solving took %d passes.\n\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
comment|/* If the graph has been correctly solved, every block will have a      succ and pred count of zero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bb_info
modifier|*
name|binfo
init|=
operator|&
name|bb_graph
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|binfo
operator|->
name|succ_count
operator|||
name|binfo
operator|->
name|pred_count
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* For every arc, calculate its branch probability and add a reg_note      to the branch insn to indicate this.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|num_never_executed
operator|=
literal|0
expr_stmt|;
name|num_branches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bb_info
modifier|*
name|binfo
init|=
operator|&
name|bb_graph
index|[
name|i
index|]
decl_stmt|;
name|total
operator|=
name|binfo
operator|->
name|exec_count
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|arcptr
operator|->
name|branch_insn
condition|)
block|{
comment|/* This calculates the branch probability as an integer between 		 0 and REG_BR_PROB_BASE, properly rounded to the nearest 		 integer.  Perform the arithmetic in double to avoid 		 overflowing the range of ints.  */
if|if
condition|(
name|total
operator|==
literal|0
condition|)
name|prob
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
decl_stmt|;
name|prob
operator|=
operator|(
operator|(
operator|(
name|double
operator|)
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
operator|*
name|REG_BR_PROB_BASE
operator|)
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
expr_stmt|;
if|if
condition|(
name|prob
operator|<
literal|0
operator|||
name|prob
operator|>
name|REG_BR_PROB_BASE
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"bad count: prob for %d-%d thought to be %d (forcibly normalized)\n"
argument_list|,
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
argument_list|,
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
argument_list|,
name|prob
argument_list|)
expr_stmt|;
name|bad_counts
operator|=
literal|1
expr_stmt|;
name|prob
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|2
expr_stmt|;
block|}
comment|/* Match up probability with JUMP pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
operator|==
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|/* A fall through arc should never have a 			     branch insn.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the arc for the taken branch.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
name|prob
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|prob
operator|==
operator|-
literal|1
condition|)
name|num_never_executed
operator|++
expr_stmt|;
else|else
block|{
name|int
name|index
init|=
name|prob
operator|*
literal|20
operator|/
name|REG_BR_PROB_BASE
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|20
condition|)
name|index
operator|=
literal|19
expr_stmt|;
name|hist_br_prob
index|[
name|index
index|]
operator|++
expr_stmt|;
block|}
name|num_branches
operator|++
expr_stmt|;
name|REG_NOTES
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|prob
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|arcptr
operator|->
name|branch_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add a REG_EXEC_COUNT note to the first instruction of this block.  */
if|if
condition|(
operator|!
name|binfo
operator|->
name|first_insn
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|binfo
operator|->
name|first_insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
block|{
comment|/* Block 0 is a fake block representing function entry, and does 	     not have a real first insn.  The second last block might not 	     begin with a real insn.  */
if|if
condition|(
name|i
operator|==
name|num_blocks
operator|-
literal|1
condition|)
name|return_label_execution_count
operator|=
name|total
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|!=
name|num_blocks
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|REG_NOTES
argument_list|(
name|binfo
operator|->
name|first_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EXEC_COUNT
argument_list|,
name|GEN_INT
argument_list|(
name|total
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|binfo
operator|->
name|first_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|num_blocks
operator|-
literal|1
condition|)
name|return_label_execution_count
operator|=
name|total
expr_stmt|;
block|}
block|}
comment|/* This should never happen.  */
if|if
condition|(
name|bad_counts
condition|)
name|warning
argument_list|(
literal|"Arc profiling: some arc counts were bad."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d branches\n"
argument_list|,
name|num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d branches never executed\n"
argument_list|,
name|num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_branches
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|hist_br_prob
index|[
name|i
index|]
operator|+
name|hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
name|total_num_branches
operator|+=
name|num_branches
expr_stmt|;
name|total_num_never_executed
operator|+=
name|num_never_executed
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|+=
name|hist_br_prob
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize a new arc.    ARCPTR is the empty adj_list this function fills in.    SOURCE is the block number of the source block.    TARGET is the block number of the target block.    INSN is the insn which transfers control from SOURCE to TARGET,    or zero if the transfer is implicit.  */
end_comment

begin_function
specifier|static
name|void
name|init_arc
parameter_list|(
name|arcptr
parameter_list|,
name|source
parameter_list|,
name|target
parameter_list|,
name|insn
parameter_list|)
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|int
name|source
decl_stmt|,
name|target
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
operator|=
name|target
expr_stmt|;
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
operator|=
name|source
expr_stmt|;
name|ARC_COUNT
argument_list|(
name|arcptr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|count_valid
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|on_tree
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|fake
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|fall_through
operator|=
literal|0
expr_stmt|;
name|arcptr
operator|->
name|branch_insn
operator|=
name|insn
expr_stmt|;
name|arcptr
operator|->
name|succ_next
operator|=
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ
expr_stmt|;
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ
operator|=
name|arcptr
expr_stmt|;
name|bb_graph
index|[
name|source
index|]
operator|.
name|succ_count
operator|++
expr_stmt|;
name|arcptr
operator|->
name|pred_next
operator|=
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred
expr_stmt|;
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred
operator|=
name|arcptr
expr_stmt|;
name|bb_graph
index|[
name|target
index|]
operator|.
name|pred_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function searches all of the arcs in the program flow graph, and puts    as many bad arcs as possible onto the spanning tree.  Bad arcs include    fake arcs (needed for setjmp(), longjmp(), exit()) which MUST be on the    spanning tree as they can't be instrumented.  Also, arcs which must be    split when instrumented should be part of the spanning tree if possible.  */
end_comment

begin_function
specifier|static
name|void
name|find_spanning_tree
parameter_list|(
name|num_blocks
parameter_list|)
name|int
name|num_blocks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|binfo
init|=
operator|&
name|bb_graph
index|[
literal|0
index|]
decl_stmt|;
comment|/* Fake arcs must be part of the spanning tree, and are always safe to put      on the spanning tree.  Fake arcs will either be a successor of node 0,      a predecessor of the last node, or from the last node to node 0.  */
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
literal|0
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
name|arcptr
operator|->
name|fake
condition|)
block|{
comment|/* Adding this arc should never cause a cycle.  This is a fatal  	   error if it would.  */
if|if
condition|(
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
operator|&&
name|binfo
operator|->
name|on_tree
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|arcptr
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
operator|=
literal|1
expr_stmt|;
name|binfo
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|binfo
operator|=
operator|&
name|bb_graph
index|[
name|num_blocks
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
if|if
condition|(
name|arcptr
operator|->
name|fake
condition|)
block|{
comment|/* Adding this arc should never cause a cycle.  This is a fatal  	   error if it would.  */
if|if
condition|(
name|bb_graph
index|[
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
operator|&&
name|binfo
operator|->
name|on_tree
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|arcptr
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|bb_graph
index|[
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
operator|=
literal|1
expr_stmt|;
name|binfo
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* The only entrace to node zero is a fake arc.  */
name|bb_graph
index|[
literal|0
index|]
operator|.
name|pred
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
comment|/* Arcs which are crowded at both the source and target should be put on      the spanning tree if possible, except for fall_throuch arcs which never      require adding a new block even if crowded, add arcs with the same source      and dest which must always be instrumented.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|binfo
operator|=
operator|&
name|bb_graph
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|binfo
operator|->
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|binfo
operator|->
name|succ
operator|==
name|arcptr
operator|&&
name|arcptr
operator|->
name|succ_next
operator|==
literal|0
operator|)
operator|||
operator|(
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|pred
operator|&&
name|arcptr
operator|->
name|pred_next
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|!
name|arcptr
operator|->
name|fall_through
operator|&&
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
operator|!=
name|i
condition|)
block|{
comment|/* This is a crowded arc at both source and target.  Try to put 	       in on the spanning tree.  Can do this if either the source or 	       target block is not yet on the tree.  */
if|if
condition|(
operator|!
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
operator|||
operator|!
name|binfo
operator|->
name|on_tree
condition|)
block|{
name|arcptr
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
operator|=
literal|1
expr_stmt|;
name|binfo
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Clear all of the basic block on_tree bits, so that we can use them to      create the spanning tree.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
name|bb_graph
index|[
name|i
index|]
operator|.
name|on_tree
operator|=
literal|0
expr_stmt|;
comment|/* Now fill in the spanning tree until every basic block is on it.      Don't put the 0 to 1 fall through arc on the tree, since it is       always cheap to instrument, so start filling the tree from node 1.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|i
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|on_tree
operator|&&
operator|!
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
condition|)
block|{
name|fill_spanning_tree
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Add arcs reached from BLOCK to the spanning tree if they are needed and    not already there.  */
end_comment

begin_function
specifier|static
name|void
name|fill_spanning_tree
parameter_list|(
name|block
parameter_list|)
name|int
name|block
decl_stmt|;
block|{
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|expand_spanning_tree
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|block
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|arcptr
operator|->
name|on_tree
operator|&&
operator|!
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
condition|)
block|{
name|arcptr
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|fill_spanning_tree
argument_list|(
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* When first visit a block, must add all blocks that are already connected    to this block via tree arcs to the spanning tree.  */
end_comment

begin_function
specifier|static
name|void
name|expand_spanning_tree
parameter_list|(
name|block
parameter_list|)
name|int
name|block
decl_stmt|;
block|{
name|struct
name|adj_list
modifier|*
name|arcptr
decl_stmt|;
name|bb_graph
index|[
name|block
index|]
operator|.
name|on_tree
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|block
index|]
operator|.
name|succ
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|succ_next
control|)
if|if
condition|(
name|arcptr
operator|->
name|on_tree
operator|&&
operator|!
name|bb_graph
index|[
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
condition|)
name|expand_spanning_tree
argument_list|(
name|ARC_TARGET
argument_list|(
name|arcptr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|arcptr
operator|=
name|bb_graph
index|[
name|block
index|]
operator|.
name|pred
init|;
name|arcptr
condition|;
name|arcptr
operator|=
name|arcptr
operator|->
name|pred_next
control|)
if|if
condition|(
name|arcptr
operator|->
name|on_tree
operator|&&
operator|!
name|bb_graph
index|[
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
index|]
operator|.
name|on_tree
condition|)
name|expand_spanning_tree
argument_list|(
name|ARC_SOURCE
argument_list|(
name|arcptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform file-level initialization for branch-prob processing.  */
end_comment

begin_function
name|void
name|init_branch_prob
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|long
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flag_test_coverage
condition|)
block|{
comment|/* Open an output file for the basic block/line number map.  */
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data_file
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|data_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|data_file
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|".bb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb_file
operator|=
name|fopen
argument_list|(
name|data_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|data_file
argument_list|)
expr_stmt|;
comment|/* Open an output file for the program flow graph.  */
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|bbg_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|bbg_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bbg_file_name
argument_list|,
literal|".bbg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bbg_file
operator|=
name|fopen
argument_list|(
name|bbg_file_name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|bbg_file_name
argument_list|)
expr_stmt|;
comment|/* Initialize to zero, to ensure that the first file name will be 	 written to the .bb file.  */
name|last_bb_file_name
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|da_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|da_file_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|da_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|da_file_name
argument_list|,
literal|".da"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|da_file
operator|=
name|fopen
argument_list|(
name|da_file_name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"file %s not found, execution counts assumed to be zero."
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
comment|/* The first word in the .da file gives the number of instrumented arcs, 	 which is not needed for our purposes.  */
if|if
condition|(
name|da_file
condition|)
name|__read_long
argument_list|(
operator|&
name|len
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|profile_arc_flag
condition|)
name|init_arc_profiler
argument_list|()
expr_stmt|;
name|total_num_blocks
operator|=
literal|0
expr_stmt|;
name|total_num_arcs
operator|=
literal|0
expr_stmt|;
name|total_num_arcs_instrumented
operator|=
literal|0
expr_stmt|;
name|total_num_blocks_created
operator|=
literal|0
expr_stmt|;
name|total_num_passes
operator|=
literal|0
expr_stmt|;
name|total_num_times_called
operator|=
literal|0
expr_stmt|;
name|total_num_branches
operator|=
literal|0
expr_stmt|;
name|total_num_never_executed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Performs file-level cleanup after branch-prob processing    is completed.  */
end_comment

begin_function
name|void
name|end_branch_prob
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
if|if
condition|(
name|flag_test_coverage
condition|)
block|{
name|fclose
argument_list|(
name|bb_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|bbg_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
if|if
condition|(
name|da_file
condition|)
block|{
name|long
name|temp
decl_stmt|;
comment|/* This seems slightly dangerous, as it presumes the EOF 	     flag will not be set until an attempt is made to read 	     past the end of the file. */
if|if
condition|(
name|feof
argument_list|(
name|da_file
argument_list|)
condition|)
name|warning
argument_list|(
literal|".da file contents exhausted too early\n"
argument_list|)
expr_stmt|;
comment|/* Should be at end of file now.  */
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|temp
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|".da file contents not exhausted\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|da_file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of blocks: %d\n"
argument_list|,
name|total_num_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of arcs: %d\n"
argument_list|,
name|total_num_arcs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of instrumented arcs: %d\n"
argument_list|,
name|total_num_arcs_instrumented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of blocks created: %d\n"
argument_list|,
name|total_num_blocks_created
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of graph solution passes: %d\n"
argument_list|,
name|total_num_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_times_called
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Average number of graph solution passes: %d\n"
argument_list|,
operator|(
name|total_num_passes
operator|+
operator|(
name|total_num_times_called
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total_num_times_called
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of branches: %d\n"
argument_list|,
name|total_num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of branches never executed: %d\n"
argument_list|,
name|total_num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_branches
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|total_hist_br_prob
index|[
name|i
index|]
operator|+
name|total_hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|total_num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The label used by the arc profiling code.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|profiler_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the profiler_label.  */
end_comment

begin_function
specifier|static
name|void
name|init_arc_profiler
parameter_list|()
block|{
comment|/* Generate and save a copy of this so it can be shared.  */
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|profiler_label
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output instructions as RTL to increment the arc execution count.  */
end_comment

begin_function
specifier|static
name|void
name|output_arc_profiler
parameter_list|(
name|arcno
parameter_list|,
name|insert_after
parameter_list|)
name|int
name|arcno
decl_stmt|;
name|rtx
name|insert_after
decl_stmt|;
block|{
name|rtx
name|profiler_target_addr
init|=
operator|(
name|arcno
condition|?
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|profiler_label
argument_list|,
name|GEN_INT
argument_list|(
name|LONG_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
operator|*
name|arcno
argument_list|)
argument_list|)
argument_list|)
else|:
name|profiler_label
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|LONG_TYPE_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|profiler_reg
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|address_reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|mem_ref
decl_stmt|,
name|add_ref
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
comment|/* In this case, reload can use explicitly mentioned hard registers for      reloads.  It is not safe to output profiling code between a call      and the instruction that copies the result to a pseudo-reg.  This      is because reload may allocate one of the profiling code pseudo-regs      to the return value reg, thus clobbering the return value.  So we      must check for calls here, and emit the profiling code after the      instruction that uses the return value, if any.       ??? The code here performs the same tests that reload does so hopefully      all the bases are covered.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|GET_CODE
argument_list|(
name|insert_after
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insert_after
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insert_after
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insert_after
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|)
operator|)
condition|)
block|{
name|rtx
name|return_reg
decl_stmt|;
name|rtx
name|next_insert_after
init|=
name|next_nonnote_insn
argument_list|(
name|insert_after
argument_list|)
decl_stmt|;
comment|/* The first insn after the call may be a stack pop, skip it.  */
if|if
condition|(
name|next_insert_after
operator|&&
name|GET_CODE
argument_list|(
name|next_insert_after
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_insert_after
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|next_insert_after
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|next_insert_after
operator|=
name|next_nonnote_insn
argument_list|(
name|next_insert_after
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_insert_after
operator|&&
name|GET_CODE
argument_list|(
name|next_insert_after
argument_list|)
operator|==
name|INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insert_after
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|return_reg
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insert_after
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|return_reg
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insert_after
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, NEXT_INSERT_AFTER may be an instruction that uses the 	     return value.  However, it could also be something else, 	     like a CODE_LABEL, so check that the code is INSN.  */
if|if
condition|(
name|next_insert_after
operator|!=
literal|0
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|next_insert_after
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_referenced_p
argument_list|(
name|return_reg
argument_list|,
name|PATTERN
argument_list|(
name|next_insert_after
argument_list|)
argument_list|)
condition|)
name|insert_after
operator|=
name|next_insert_after
expr_stmt|;
block|}
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|address_reg
argument_list|,
name|profiler_target_addr
argument_list|)
expr_stmt|;
name|mem_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|address_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|profiler_reg
argument_list|,
name|mem_ref
argument_list|)
expr_stmt|;
name|add_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|profiler_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|profiler_reg
argument_list|,
name|add_ref
argument_list|)
expr_stmt|;
comment|/* This is the same rtx as above, but it is not legal to share this rtx.  */
name|mem_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|address_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem_ref
argument_list|,
name|profiler_reg
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|sequence
argument_list|,
name|insert_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for a constructor that will invoke __bb_init_func, if    this has not already been done. */
end_comment

begin_function
name|void
name|output_func_start_profiler
parameter_list|()
block|{
name|tree
name|fnname
decl_stmt|,
name|fndecl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|cfnname
decl_stmt|;
name|rtx
name|table_address
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|LONG_TYPE_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|save_flag_inline_functions
init|=
name|flag_inline_functions
decl_stmt|;
comment|/* It's either already been output, or we don't need it because we're      not doing profile-arcs. */
if|if
condition|(
operator|!
name|need_func_profiler
condition|)
return|return;
name|need_func_profiler
operator|=
literal|0
expr_stmt|;
comment|/* Synthesize a constructor function to invoke __bb_init_func with a      pointer to this object file's profile block. */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Try and make a unique name given the "file function name".       And no, I don't like this either. */
name|fnname
operator|=
name|get_file_function_name
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
name|cfnname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cfnname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%sGCOV"
argument_list|,
name|cfnname
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fnname
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
operator|=
name|fnname
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|pushdecl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|announce_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|temporary_allocation
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Actually generate the code to call __bb_init_func. */
name|name
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table_address
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__bb_init_func"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|table_address
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Since fndecl isn't in the list of globals, it would never be emitted      when it's considered to be 'safe' for inlining, so turn off      flag_inline_functions.  */
name|flag_inline_functions
operator|=
literal|0
expr_stmt|;
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Reset flag_inline_functions to its original value.  */
name|flag_inline_functions
operator|=
name|save_flag_inline_functions
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|assemble_constructor
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

