begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate branch probabilities, and basic block execution counts.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;    based on some ideas from Dain Samples of UC Berkeley.    Further mangling by Bob Manson, Cygnus Support.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Generate basic block profile instrumentation and auxiliary files.    Profile generation is optimized, so that not all arcs in the basic    block graph need instrumenting. First, the BB graph is closed with    one entry (function start), and one exit (function exit).  Any    ABNORMAL_EDGE cannot be instrumented (because there is no control    path to place the code). We close the graph by inserting fake    EDGE_FAKE edges to the EXIT_BLOCK, from the sources of abnormal    edges that do not go to the exit_block. We ignore such abnormal    edges.  Naturally these fake edges are never directly traversed,    and so *cannot* be directly instrumented.  Some other graph    massaging is done. To optimize the instrumentation we generate the    BB minimal span tree, only edges that are not on the span tree    (plus the entry point) need instrumenting. From that information    all other edge counts can be deduced.  By construction all fake    edges must be on the spanning tree. We also attempt to place    EDGE_CRITICAL edges on the spanning tree.     The auxiliary files generated are<dumpbase>.gcno (at compile time)    and<dumpbase>.gcda (at run time).  The format is    described in full in gcov-io.h.  */
end_comment

begin_comment
comment|/* ??? Register allocation should use basic block execution counts to    give preference to the most commonly executed blocks.  */
end_comment

begin_comment
comment|/* ??? Should calculate branch probabilities before instrumenting code, since    then we can use arc counts to help decide which arcs to instrument.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cfghooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* Hooks for profiling.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|profile_hooks
modifier|*
name|profile_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Additional information about the edges we need.  */
end_comment

begin_struct
struct|struct
name|edge_info
block|{
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
comment|/* Is on the spanning tree.  */
name|unsigned
name|int
name|on_tree
range|:
literal|1
decl_stmt|;
comment|/* Pretend this edge does not exist (it is abnormal and we've      inserted a fake to compensate).  */
name|unsigned
name|int
name|ignore
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bb_info
block|{
name|unsigned
name|int
name|count_valid
range|:
literal|1
decl_stmt|;
comment|/* Number of successor and predecessor edges.  */
name|gcov_type
name|succ_count
decl_stmt|;
name|gcov_type
name|pred_count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EDGE_INFO
parameter_list|(
name|e
parameter_list|)
value|((struct edge_info *) (e)->aux)
end_define

begin_define
define|#
directive|define
name|BB_INFO
parameter_list|(
name|b
parameter_list|)
value|((struct bb_info *) (b)->aux)
end_define

begin_comment
comment|/* Counter summary from the last set of coverage counts read.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcov_ctr_summary
modifier|*
name|profile_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Collect statistics on the performance of this pass for the entire source    file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges_ignored
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_edges_instrumented
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_blocks_created
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_passes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_times_called
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_hist_br_prob
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_never_executed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_num_branches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|find_spanning_tree
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|instrument_edges
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instrument_values
parameter_list|(
name|histogram_values
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_branch_probabilities
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_value_histograms
parameter_list|(
name|histogram_values
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gcov_type
modifier|*
name|get_exec_counts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|find_group
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|union_groups
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Add edge instrumentation code to the entire insn chain.     F is the first insn of the chain.    NUM_BLOCKS is the number of basic blocks found in F.  */
end_comment

begin_function
specifier|static
name|unsigned
name|instrument_edges
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|unsigned
name|num_instr_edges
init|=
literal|0
decl_stmt|;
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|struct
name|edge_info
modifier|*
name|inf
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inf
operator|->
name|ignore
operator|&&
operator|!
name|inf
operator|->
name|on_tree
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Edge %d to %d instrumented%s\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|?
literal|" (and split)"
else|:
literal|""
argument_list|)
expr_stmt|;
call|(
name|profile_hooks
operator|->
name|gen_edge_profiler
call|)
argument_list|(
name|num_instr_edges
operator|++
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|total_num_blocks_created
operator|+=
name|num_edges
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d edges instrumented\n"
argument_list|,
name|num_instr_edges
argument_list|)
expr_stmt|;
return|return
name|num_instr_edges
return|;
block|}
end_function

begin_comment
comment|/* Add code to measure histograms for values in list VALUES.  */
end_comment

begin_function
specifier|static
name|void
name|instrument_values
parameter_list|(
name|histogram_values
name|values
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|t
decl_stmt|;
comment|/* Emit code to generate the histograms before the insns.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|histogram_value
argument_list|,
name|values
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|histogram_value
name|hist
init|=
name|VEC_index
argument_list|(
name|histogram_value
argument_list|,
name|values
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|hist
operator|->
name|type
condition|)
block|{
case|case
name|HIST_TYPE_INTERVAL
case|:
name|t
operator|=
name|GCOV_COUNTER_V_INTERVAL
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_POW2
case|:
name|t
operator|=
name|GCOV_COUNTER_V_POW2
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_SINGLE_VALUE
case|:
name|t
operator|=
name|GCOV_COUNTER_V_SINGLE
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_CONST_DELTA
case|:
name|t
operator|=
name|GCOV_COUNTER_V_DELTA
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coverage_counter_alloc
argument_list|(
name|t
argument_list|,
name|hist
operator|->
name|n_counters
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|hist
operator|->
name|type
condition|)
block|{
case|case
name|HIST_TYPE_INTERVAL
case|:
call|(
name|profile_hooks
operator|->
name|gen_interval_profiler
call|)
argument_list|(
name|hist
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_POW2
case|:
call|(
name|profile_hooks
operator|->
name|gen_pow2_profiler
call|)
argument_list|(
name|hist
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_SINGLE_VALUE
case|:
call|(
name|profile_hooks
operator|->
name|gen_one_value_profiler
call|)
argument_list|(
name|hist
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_CONST_DELTA
case|:
call|(
name|profile_hooks
operator|->
name|gen_const_delta_profiler
call|)
argument_list|(
name|hist
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Computes hybrid profile for all matching entries in da_file.  */
end_comment

begin_function
specifier|static
name|gcov_type
modifier|*
name|get_exec_counts
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|num_edges
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|gcov_type
modifier|*
name|counts
decl_stmt|;
comment|/* Count the edges to be (possibly) instrumented.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
condition|)
name|num_edges
operator|++
expr_stmt|;
block|}
name|counts
operator|=
name|get_coverage_counts
argument_list|(
name|GCOV_COUNTER_ARCS
argument_list|,
name|num_edges
argument_list|,
operator|&
name|profile_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|counts
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|dump_file
operator|&&
name|profile_info
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Merged %u profiles with maximal count %u.\n"
argument_list|,
name|profile_info
operator|->
name|runs
argument_list|,
operator|(
name|unsigned
operator|)
name|profile_info
operator|->
name|sum_max
argument_list|)
expr_stmt|;
return|return
name|counts
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the branch probabilities for the various branches.    Annotate them accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|compute_branch_probabilities
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_edges
init|=
literal|0
decl_stmt|;
name|int
name|changes
decl_stmt|;
name|int
name|passes
decl_stmt|;
name|int
name|hist_br_prob
index|[
literal|20
index|]
decl_stmt|;
name|int
name|num_never_executed
decl_stmt|;
name|int
name|num_branches
decl_stmt|;
name|gcov_type
modifier|*
name|exec_counts
init|=
name|get_exec_counts
argument_list|()
decl_stmt|;
name|int
name|exec_counts_pos
init|=
literal|0
decl_stmt|;
comment|/* Very simple sanity checks so we catch bugs in our profiling code.  */
if|if
condition|(
name|profile_info
condition|)
block|{
if|if
condition|(
name|profile_info
operator|->
name|run_max
operator|*
name|profile_info
operator|->
name|runs
operator|<
name|profile_info
operator|->
name|sum_max
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: run_max * runs< sum_max"
argument_list|)
expr_stmt|;
name|exec_counts
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|profile_info
operator|->
name|sum_all
operator|<
name|profile_info
operator|->
name|sum_max
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: sum_all is smaller than sum_max"
argument_list|)
expr_stmt|;
name|exec_counts
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Attach extra info block to each bb.  */
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|++
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|pred_count
operator|++
expr_stmt|;
block|}
comment|/* Avoid predicting entry on exit nodes.  */
name|BB_INFO
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
operator|->
name|succ_count
operator|=
literal|2
expr_stmt|;
name|BB_INFO
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|pred_count
operator|=
literal|2
expr_stmt|;
comment|/* For each edge not on the spanning tree, set its execution count from      the .da file.  */
comment|/* The first count in the .da file is the number of times that the function      was entered.  This is the exec_count for block zero.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
condition|)
block|{
name|num_edges
operator|++
expr_stmt|;
if|if
condition|(
name|exec_counts
condition|)
block|{
name|e
operator|->
name|count
operator|=
name|exec_counts
index|[
name|exec_counts_pos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
operator|>
name|profile_info
operator|->
name|sum_max
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: edge from %i to %i exceeds maximal count"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|pred_count
operator|--
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nRead edge from %i to %i, count:"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n%d edge counts read\n"
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
comment|/* For every block in the file,      - if every exit/entrance edge has a known count, then set the block count      - if the block count is known, and every exit/entrance edge but one has      a known execution count, then set the count of the remaining edge       As edge counts are set, decrement the succ/pred count, but don't delete      the edge, that way we can easily tell when all edges are known, or only      one edge is unknown.  */
comment|/* The order that the basic blocks are iterated through is important.      Since the code that finds spanning trees starts with block 0, low numbered      edges are put on the spanning tree in preference to high numbered edges.      Hence, most instrumented edges are at the end.  Graph solving works much      faster if we propagate numbers from the end to the start.       This takes an average of slightly more than 3 passes.  */
name|changes
operator|=
literal|1
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|passes
operator|++
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|prev_bb
argument_list|)
block|{
name|struct
name|bb_info
modifier|*
name|bi
init|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|bi
operator|->
name|succ_count
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bi
operator|->
name|pred_count
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|bb
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bi
operator|->
name|count_valid
condition|)
block|{
if|if
condition|(
name|bi
operator|->
name|succ_count
operator|==
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Seedgeh for the invalid edge, and set its count.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
break|break;
comment|/* Calculate count for remaining edge by conservation.  */
name|total
operator|=
name|bb
operator|->
name|count
operator|-
name|total
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|succ_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|pred_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bi
operator|->
name|pred_count
operator|==
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|gcov_type
name|total
init|=
literal|0
decl_stmt|;
comment|/* One of the counts will be invalid, but it is zero, 		     so adding it in also doesn't hurt.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|total
operator|+=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Search for the invalid edge, and set its count.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
condition|)
break|break;
comment|/* Calculate count for remaining edge by conservation.  */
name|total
operator|=
name|bb
operator|->
name|count
operator|-
name|total
operator|+
name|e
operator|->
name|count
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|count_valid
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|total
expr_stmt|;
name|bi
operator|->
name|pred_count
operator|--
expr_stmt|;
name|BB_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|succ_count
operator|--
expr_stmt|;
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|dump_flow_info
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|total_num_passes
operator|+=
name|passes
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Graph solving took %d passes.\n\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
comment|/* If the graph has been correctly solved, every block will have a      succ and pred count of zero.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|succ_count
operator|&&
operator|!
name|BB_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|pred_count
argument_list|)
expr_stmt|;
block|}
comment|/* For every edge, calculate its branch probability and add a reg_note      to the branch insn to indicate this.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|num_never_executed
operator|=
literal|0
expr_stmt|;
name|num_branches
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: number of iterations for basic block %d thought to be %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
operator|(
name|int
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|bb
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
comment|/* Function may return twice in the cased the called function is 	     setjmp or calls fork, but we can't represent this by extra 	     edge from the entry, since extra edge from the exit is 	     already present.  We get negative frequency from the entry 	     point.  */
if|if
condition|(
operator|(
name|e
operator|->
name|count
operator|<
literal|0
operator|&&
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
operator|||
operator|(
name|e
operator|->
name|count
operator|>
name|bb
operator|->
name|count
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|)
condition|)
block|{
if|if
condition|(
name|block_ends_with_call_p
argument_list|(
name|bb
argument_list|)
condition|)
name|e
operator|->
name|count
operator|=
name|e
operator|->
name|count
operator|<
literal|0
condition|?
literal|0
else|:
name|bb
operator|->
name|count
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
operator|||
name|e
operator|->
name|count
operator|>
name|bb
operator|->
name|count
condition|)
block|{
name|error
argument_list|(
literal|"corrupted profile info: number of executions for edge %d-%d thought to be %i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb
operator|->
name|count
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|e
operator|->
name|probability
operator|=
operator|(
name|e
operator|->
name|count
operator|*
name|REG_BR_PROB_BASE
operator|+
name|bb
operator|->
name|count
operator|/
literal|2
operator|)
operator|/
name|bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
operator|&&
name|block_ends_with_condjump_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>=
literal|2
condition|)
block|{
name|int
name|prob
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Find the branch edge.  It is possible that we do have fake 		 edges here.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_FAKE
operator||
name|EDGE_FALLTHRU
operator|)
operator|)
condition|)
break|break;
name|prob
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|index
operator|=
name|prob
operator|*
literal|20
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|20
condition|)
name|index
operator|=
literal|19
expr_stmt|;
name|hist_br_prob
index|[
name|index
index|]
operator|++
expr_stmt|;
name|num_branches
operator|++
expr_stmt|;
block|}
block|}
comment|/* As a last resort, distribute the probabilities evenly. 	 Use simple heuristics that if there are normal edges, 	 give all abnormals frequency of 0, otherwise distribute the 	 frequency over abnormals (this is the case of noreturn 	 calls).  */
elseif|else
if|if
condition|(
name|profile_status
operator|==
name|PROFILE_ABSENT
condition|)
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|total
operator|++
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
name|total
expr_stmt|;
else|else
name|e
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|total
operator|+=
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
name|total
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
operator|&&
name|block_ends_with_condjump_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>=
literal|2
condition|)
name|num_branches
operator|++
operator|,
name|num_never_executed
expr_stmt|;
block|}
block|}
name|counts_to_freqs
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d branches\n"
argument_list|,
name|num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d branches never executed\n"
argument_list|,
name|num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_branches
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|hist_br_prob
index|[
name|i
index|]
operator|+
name|hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
name|total_num_branches
operator|+=
name|num_branches
expr_stmt|;
name|total_num_never_executed
operator|+=
name|num_never_executed
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|+=
name|hist_br_prob
index|[
name|i
index|]
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load value histograms values whose description is stored in VALUES array    from .gcda file.  */
end_comment

begin_function
specifier|static
name|void
name|compute_value_histograms
parameter_list|(
name|histogram_values
name|values
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|,
name|any
decl_stmt|;
name|unsigned
name|n_histogram_counters
index|[
name|GCOV_N_VALUE_COUNTERS
index|]
decl_stmt|;
name|gcov_type
modifier|*
name|histogram_counts
index|[
name|GCOV_N_VALUE_COUNTERS
index|]
decl_stmt|;
name|gcov_type
modifier|*
name|act_count
index|[
name|GCOV_N_VALUE_COUNTERS
index|]
decl_stmt|;
name|gcov_type
modifier|*
name|aact_count
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|GCOV_N_VALUE_COUNTERS
condition|;
name|t
operator|++
control|)
name|n_histogram_counters
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|histogram_value
argument_list|,
name|values
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|histogram_value
name|hist
init|=
name|VEC_index
argument_list|(
name|histogram_value
argument_list|,
name|values
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|n_histogram_counters
index|[
operator|(
name|int
operator|)
name|hist
operator|->
name|type
index|]
operator|+=
name|hist
operator|->
name|n_counters
expr_stmt|;
block|}
name|any
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|GCOV_N_VALUE_COUNTERS
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|n_histogram_counters
index|[
name|t
index|]
condition|)
block|{
name|histogram_counts
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|histogram_counts
index|[
name|t
index|]
operator|=
name|get_coverage_counts
argument_list|(
name|COUNTER_FOR_HIST_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|n_histogram_counters
index|[
name|t
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|histogram_counts
index|[
name|t
index|]
condition|)
name|any
operator|=
literal|1
expr_stmt|;
name|act_count
index|[
name|t
index|]
operator|=
name|histogram_counts
index|[
name|t
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|histogram_value
argument_list|,
name|values
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|histogram_value
name|hist
init|=
name|VEC_index
argument_list|(
name|histogram_value
argument_list|,
name|values
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|stmt
init|=
name|hist
operator|->
name|hvalue
operator|.
name|stmt
decl_stmt|;
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|t
operator|=
operator|(
name|int
operator|)
name|hist
operator|->
name|type
expr_stmt|;
name|aact_count
operator|=
name|act_count
index|[
name|t
index|]
expr_stmt|;
name|act_count
index|[
name|t
index|]
operator|+=
name|hist
operator|->
name|n_counters
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|next
operator|=
name|ann
operator|->
name|histograms
expr_stmt|;
name|ann
operator|->
name|histograms
operator|=
name|hist
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|counters
operator|=
name|XNEWVEC
argument_list|(
name|gcov_type
argument_list|,
name|hist
operator|->
name|n_counters
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|hist
operator|->
name|n_counters
condition|;
name|j
operator|++
control|)
name|hist
operator|->
name|hvalue
operator|.
name|counters
index|[
name|j
index|]
operator|=
name|aact_count
index|[
name|j
index|]
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|GCOV_N_VALUE_COUNTERS
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|histogram_counts
index|[
name|t
index|]
condition|)
name|free
argument_list|(
name|histogram_counts
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The entry basic block will be moved around so that it has index=1,    there is nothing at index 0 and the exit is at n_basic_block.  */
end_comment

begin_define
define|#
directive|define
name|BB_TO_GCOV_INDEX
parameter_list|(
name|bb
parameter_list|)
value|((bb)->index - 1)
end_define

begin_comment
comment|/* When passed NULL as file_name, initialize.    When passed something else, output the necessary commands to change    line to LINE and offset to FILE_NAME.  */
end_comment

begin_function
specifier|static
name|void
name|output_location
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|int
name|line
parameter_list|,
name|gcov_position_t
modifier|*
name|offset
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
specifier|static
name|char
specifier|const
modifier|*
name|prev_file_name
decl_stmt|;
specifier|static
name|int
name|prev_line
decl_stmt|;
name|bool
name|name_differs
decl_stmt|,
name|line_differs
decl_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
name|prev_file_name
operator|=
name|NULL
expr_stmt|;
name|prev_line
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|name_differs
operator|=
operator|!
name|prev_file_name
operator|||
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|prev_file_name
argument_list|)
expr_stmt|;
name|line_differs
operator|=
name|prev_line
operator|!=
name|line
expr_stmt|;
if|if
condition|(
name|name_differs
operator|||
name|line_differs
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|offset
condition|)
block|{
operator|*
name|offset
operator|=
name|gcov_write_tag
argument_list|(
name|GCOV_TAG_LINES
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|BB_TO_GCOV_INDEX
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|name_differs
operator|=
name|line_differs
operator|=
name|true
expr_stmt|;
block|}
comment|/* If this is a new source file, then output the 	 file's name to the .bb file.  */
if|if
condition|(
name|name_differs
condition|)
block|{
name|prev_file_name
operator|=
name|file_name
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gcov_write_string
argument_list|(
name|prev_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line_differs
condition|)
block|{
name|gcov_write_unsigned
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|prev_line
operator|=
name|line
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Instrument and/or analyze program behavior based on program flow graph.    In either case, this function builds a flow graph for the function being    compiled.  The flow graph is stored in BB_GRAPH.     When FLAG_PROFILE_ARCS is nonzero, this function instruments the edges in    the flow graph that are needed to reconstruct the dynamic behavior of the    flow graph.     When FLAG_BRANCH_PROBABILITIES is nonzero, this function reads auxiliary    information from a data file containing edge count information from previous    executions of the function being compiled.  In this case, the flow graph is    annotated with actual execution counts, which are later propagated into the    rtl for optimization purposes.     Main entry point of this file.  */
end_comment

begin_function
name|void
name|branch_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|num_edges
decl_stmt|,
name|ignored_edges
decl_stmt|;
name|unsigned
name|num_instrumented
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
name|histogram_values
name|values
init|=
name|NULL
decl_stmt|;
name|total_num_times_called
operator|++
expr_stmt|;
name|flow_call_edges_add
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
comment|/* We can't handle cyclic regions constructed using abnormal edges.      To avoid these we replace every source of abnormal edge by a fake      edge from entry node and every destination by fake edge to exit.      This keeps graph acyclic and our calculation exact for all normal      edges except for exit and entrance ones.       We also add fake exit edges for each call and asm statement in the      basic, since it may not return.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|need_exit_edge
init|=
literal|0
decl_stmt|,
name|need_entry_edge
init|=
literal|0
decl_stmt|;
name|int
name|have_exit_edge
init|=
literal|0
decl_stmt|,
name|have_entry_edge
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Functions returning multiple times are not handled by extra edges.          Instead we simply allow negative counts on edges from exit to the          block past call and corresponding probabilities.  We can't go          with the extra edges because that would result in flowgraph that 	 needs to have fake edges outside the spanning tree.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|last
init|=
name|NULL
decl_stmt|;
comment|/* It may happen that there are compiler generated statements 	     without a locus at all.  Go through the basic block from the 	     last to the first statement looking for a locus.  */
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|last
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_LOCUS
argument_list|(
name|last
argument_list|)
condition|)
break|break;
block|}
comment|/* Edge with goto locus might get wrong coverage info unless 	     it is the only edge out of BB.    	     Don't do that when the locuses match, so  	     if (blah) goto something; 	     is not computed twice.  */
if|if
condition|(
name|last
operator|&&
name|EXPR_LOCUS
argument_list|(
name|last
argument_list|)
operator|&&
name|e
operator|->
name|goto_locus
operator|&&
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|&&
operator|(
name|LOCATION_FILE
argument_list|(
name|e
operator|->
name|goto_locus
argument_list|)
operator|!=
name|LOCATION_FILE
argument_list|(
name|EXPR_LOCATION
argument_list|(
name|last
argument_list|)
argument_list|)
operator|||
operator|(
name|LOCATION_LINE
argument_list|(
name|e
operator|->
name|goto_locus
argument_list|)
operator|!=
name|LOCATION_LINE
argument_list|(
name|EXPR_LOCATION
argument_list|(
name|last
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
else|#
directive|else
operator|&&
operator|(
name|e
operator|->
name|goto_locus
operator|->
name|file
operator|!=
name|EXPR_LOCUS
argument_list|(
name|last
argument_list|)
operator|->
name|file
operator|||
operator|(
name|e
operator|->
name|goto_locus
operator|->
name|line
operator|!=
name|EXPR_LOCUS
argument_list|(
name|last
argument_list|)
operator|->
name|line
operator|)
operator|)
block|)
endif|#
directive|endif
block|{
name|basic_block
name|new
init|=
name|split_edge
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|single_succ_edge
argument_list|(
name|new
argument_list|)
operator|->
name|goto_locus
operator|=
name|e
operator|->
name|goto_locus
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|need_exit_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|have_exit_edge
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|need_entry_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|have_entry_edge
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_exit_edge
operator|&&
operator|!
name|have_exit_edge
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Adding fake exit edge to bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_entry_edge
operator|&&
operator|!
name|have_entry_edge
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Adding fake entry edge to bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|el
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_info
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The basic blocks are expected to be numbered sequentially.  */
end_comment

begin_expr_stmt
name|compact_blocks
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ignored_edges
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Mark edges we've replaced by fake edges above as ignored.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|ignored_edges
operator|++
expr_stmt|;
block|}
block|}
end_for

begin_comment
comment|/* Create spanning tree from basic block graph, mark each edge that is      on the spanning tree.  We insert as many abnormal and critical edges      as possible to minimize number of edge splits necessary.  */
end_comment

begin_expr_stmt
name|find_spanning_tree
argument_list|(
name|el
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Fake edges that are not on the tree will not be instrumented, so      mark them ignored.  */
end_comment

begin_for
for|for
control|(
name|num_instrumented
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|edge_info
modifier|*
name|inf
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|inf
operator|->
name|ignore
operator|||
name|inf
operator|->
name|on_tree
condition|)
comment|/*NOP*/
empty_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
block|{
name|inf
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|ignored_edges
operator|++
expr_stmt|;
block|}
else|else
name|num_instrumented
operator|++
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|total_num_blocks
operator|+=
name|n_basic_blocks
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d basic blocks\n"
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|total_num_edges
operator|+=
name|num_edges
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d edges\n"
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|total_num_edges_ignored
operator|+=
name|ignored_edges
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d ignored edges\n"
argument_list|,
name|ignored_edges
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Write the data from which gcov can reconstruct the basic block      graph.  */
end_comment

begin_comment
comment|/* Basic block flags */
end_comment

begin_if
if|if
condition|(
name|coverage_begin_output
argument_list|()
condition|)
block|{
name|gcov_position_t
name|offset
decl_stmt|;
name|offset
operator|=
name|gcov_write_tag
argument_list|(
name|GCOV_TAG_BLOCKS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|n_basic_blocks
argument_list|)
condition|;
name|i
operator|++
control|)
name|gcov_write_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gcov_write_length
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Keep all basic block indexes nonnegative in the gcov output.       Index 0 is used for entry block, last index is for exit block.       */
end_comment

begin_expr_stmt
name|ENTRY_BLOCK_PTR
operator|->
name|index
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXIT_BLOCK_PTR
operator|->
name|index
operator|=
name|last_basic_block
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Arcs */
end_comment

begin_if
if|if
condition|(
name|coverage_begin_output
argument_list|()
condition|)
block|{
name|gcov_position_t
name|offset
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|offset
operator|=
name|gcov_write_tag
argument_list|(
name|GCOV_TAG_ARCS
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|BB_TO_GCOV_INDEX
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|struct
name|edge_info
modifier|*
name|i
init|=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i
operator|->
name|ignore
condition|)
block|{
name|unsigned
name|flag_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|->
name|on_tree
condition|)
name|flag_bits
operator||=
name|GCOV_ARC_ON_TREE
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
name|flag_bits
operator||=
name|GCOV_ARC_FAKE
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|flag_bits
operator||=
name|GCOV_ARC_FALLTHROUGH
expr_stmt|;
comment|/* On trees we don't have fallthru flags, but we can 		     recompute them from CFG shape.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
operator|&&
name|e
operator|->
name|src
operator|->
name|next_bb
operator|==
name|e
operator|->
name|dest
condition|)
name|flag_bits
operator||=
name|GCOV_ARC_FALLTHROUGH
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|BB_TO_GCOV_INDEX
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|flag_bits
argument_list|)
expr_stmt|;
block|}
block|}
name|gcov_write_length
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* Line numbers.  */
end_comment

begin_if
if|if
condition|(
name|coverage_begin_output
argument_list|()
condition|)
block|{
name|gcov_position_t
name|offset
decl_stmt|;
comment|/* Initialize the output.  */
name|output_location
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
condition|)
block|{
name|expanded_location
name|curr_location
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|output_location
argument_list|(
name|curr_location
operator|.
name|file
argument_list|,
name|curr_location
operator|.
name|line
argument_list|,
operator|&
name|offset
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|output_location
argument_list|(
name|EXPR_FILENAME
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|EXPR_LINENO
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
comment|/* Notice GOTO expressions we eliminated while constructing the 	     CFG.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|goto_locus
condition|)
block|{
comment|/* ??? source_locus type is marked deprecated in input.h.  */
name|source_locus
name|curr_location
init|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|goto_locus
decl_stmt|;
comment|/* ??? The FILE/LINE API is inconsistent for these cases.  */
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|output_location
argument_list|(
name|LOCATION_FILE
argument_list|(
name|curr_location
argument_list|)
argument_list|,
name|LOCATION_LINE
argument_list|(
name|curr_location
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|,
name|bb
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_location
argument_list|(
name|curr_location
operator|->
name|file
argument_list|,
name|curr_location
operator|->
name|line
argument_list|,
operator|&
name|offset
argument_list|,
name|bb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|offset
condition|)
block|{
comment|/* A file of NULL indicates the end of run.  */
name|gcov_write_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gcov_write_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|gcov_write_length
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_if

begin_expr_stmt
name|ENTRY_BLOCK_PTR
operator|->
name|index
operator|=
name|ENTRY_BLOCK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXIT_BLOCK_PTR
operator|->
name|index
operator|=
name|EXIT_BLOCK
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|BB_TO_GCOV_INDEX
end_undef

begin_if
if|if
condition|(
name|flag_profile_values
condition|)
name|find_values_to_profile
argument_list|(
operator|&
name|values
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
name|compute_branch_probabilities
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_profile_values
condition|)
name|compute_value_histograms
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|remove_fake_edges
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* For each edge not on the spanning tree, add counting code.  */
end_comment

begin_if
if|if
condition|(
name|profile_arc_flag
operator|&&
name|coverage_counter_alloc
argument_list|(
name|GCOV_COUNTER_ARCS
argument_list|,
name|num_instrumented
argument_list|)
condition|)
block|{
name|unsigned
name|n_instrumented
decl_stmt|;
name|profile_hooks
operator|->
name|init_edge_profiler
argument_list|()
expr_stmt|;
name|n_instrumented
operator|=
name|instrument_edges
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|n_instrumented
operator|==
name|num_instrumented
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_profile_values
condition|)
name|instrument_values
argument_list|(
name|values
argument_list|)
expr_stmt|;
comment|/* Commit changes done by instrumentation.  */
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|free_aux_for_edges
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VEC_free
argument_list|(
name|histogram_value
argument_list|,
name|heap
argument_list|,
name|values
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|free_edge_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|flag_branch_probabilities
condition|)
name|profile_status
operator|=
name|PROFILE_READ
expr_stmt|;
end_if

begin_expr_stmt
name|coverage_end_function
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* Union find algorithm implementation for the basic blocks using    aux fields.  */
end_comment

begin_function
unit|static
name|basic_block
name|find_group
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|basic_block
name|group
init|=
name|bb
decl_stmt|,
name|bb1
decl_stmt|;
while|while
condition|(
operator|(
name|basic_block
operator|)
name|group
operator|->
name|aux
operator|!=
name|group
condition|)
name|group
operator|=
operator|(
name|basic_block
operator|)
name|group
operator|->
name|aux
expr_stmt|;
comment|/* Compress path.  */
while|while
condition|(
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|aux
operator|!=
name|group
condition|)
block|{
name|bb1
operator|=
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|aux
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
name|group
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
return|return
name|group
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|union_groups
parameter_list|(
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|)
block|{
name|basic_block
name|bb1g
init|=
name|find_group
argument_list|(
name|bb1
argument_list|)
decl_stmt|;
name|basic_block
name|bb2g
init|=
name|find_group
argument_list|(
name|bb2
argument_list|)
decl_stmt|;
comment|/* ??? I don't have a place for the rank field.  OK.  Lets go w/o it,      this code is unlikely going to be performance problem anyway.  */
name|gcc_assert
argument_list|(
name|bb1g
operator|!=
name|bb2g
argument_list|)
expr_stmt|;
name|bb1g
operator|->
name|aux
operator|=
name|bb2g
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function searches all of the edges in the program flow graph, and puts    as many bad edges as possible onto the spanning tree.  Bad edges include    abnormals edges, which can't be instrumented at the moment.  Since it is    possible for fake edges to form a cycle, we will have to develop some    better way in the future.  Also put critical edges to the tree, since they    are more expensive to instrument.  */
end_comment

begin_function
specifier|static
name|void
name|find_spanning_tree
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* We use aux field for standard union-find algorithm.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
comment|/* Add fake edge exit to entry we can't instrument.  */
name|union_groups
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* First add all abnormal edges to the tree unless they form a cycle. Also      add all edges to EXIT_BLOCK_PTR to avoid inserting profiling code behind      setting return value from function.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_FAKE
operator|)
operator|)
operator|||
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
operator|(
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Abnormal edge %d to %d put to tree\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now insert all critical edges to the tree unless they form a cycle.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Critical edge %d to %d put to tree\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And now the rest.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|ignore
operator|&&
name|find_group
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|find_group
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Normal edge %d to %d put to tree\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|on_tree
operator|=
literal|1
expr_stmt|;
name|union_groups
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform file-level initialization for branch-prob processing.  */
end_comment

begin_function
name|void
name|init_branch_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|total_num_blocks
operator|=
literal|0
expr_stmt|;
name|total_num_edges
operator|=
literal|0
expr_stmt|;
name|total_num_edges_ignored
operator|=
literal|0
expr_stmt|;
name|total_num_edges_instrumented
operator|=
literal|0
expr_stmt|;
name|total_num_blocks_created
operator|=
literal|0
expr_stmt|;
name|total_num_passes
operator|=
literal|0
expr_stmt|;
name|total_num_times_called
operator|=
literal|0
expr_stmt|;
name|total_num_branches
operator|=
literal|0
expr_stmt|;
name|total_num_never_executed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|total_hist_br_prob
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Performs file-level cleanup after branch-prob processing    is completed.  */
end_comment

begin_function
name|void
name|end_branch_prob
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of blocks: %d\n"
argument_list|,
name|total_num_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of edges: %d\n"
argument_list|,
name|total_num_edges
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of ignored edges: %d\n"
argument_list|,
name|total_num_edges_ignored
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of instrumented edges: %d\n"
argument_list|,
name|total_num_edges_instrumented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of blocks created: %d\n"
argument_list|,
name|total_num_blocks_created
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of graph solution passes: %d\n"
argument_list|,
name|total_num_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_times_called
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Average number of graph solution passes: %d\n"
argument_list|,
operator|(
name|total_num_passes
operator|+
operator|(
name|total_num_times_called
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total_num_times_called
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of branches: %d\n"
argument_list|,
name|total_num_branches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Total number of branches never executed: %d\n"
argument_list|,
name|total_num_never_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_num_branches
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d%% branches in range %d-%d%%\n"
argument_list|,
operator|(
name|total_hist_br_prob
index|[
name|i
index|]
operator|+
name|total_hist_br_prob
index|[
literal|19
operator|-
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|total_num_branches
argument_list|,
literal|5
operator|*
name|i
argument_list|,
literal|5
operator|*
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set up hooks to enable tree-based profiling.  */
end_comment

begin_function
name|void
name|tree_register_profile_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|ir_type
argument_list|()
argument_list|)
expr_stmt|;
name|profile_hooks
operator|=
operator|&
name|tree_profile_hooks
expr_stmt|;
block|}
end_function

end_unit

