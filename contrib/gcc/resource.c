begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions for computing resource usage of specific insns.    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"resource.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* This structure is used to record liveness information at the targets or    fallthrough insns of branches.  We will most likely need the information    at targets again, so save them in a hash table rather than recomputing them    each time.  */
end_comment

begin_struct
struct|struct
name|target_info
block|{
name|int
name|uid
decl_stmt|;
comment|/* INSN_UID of target.  */
name|struct
name|target_info
modifier|*
name|next
decl_stmt|;
comment|/* Next info for same hash bucket.  */
name|HARD_REG_SET
name|live_regs
decl_stmt|;
comment|/* Registers live at target.  */
name|int
name|block
decl_stmt|;
comment|/* Basic block number containing target.  */
name|int
name|bb_tick
decl_stmt|;
comment|/* Generation count of basic block info.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TARGET_HASH_PRIME
value|257
end_define

begin_comment
comment|/* Indicates what resources are required at the beginning of the epilogue.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|resources
name|start_of_epilogue_needs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates what resources are required at function end.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|resources
name|end_of_function_needs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the hash table itself.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_info
modifier|*
modifier|*
name|target_hash_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each basic block, we maintain a generation number of its basic    block info, which is updated each time we move an insn from the    target of a jump.  This is the generation number indexed by block    number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bb_ticks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Marks registers possibly live at the current place being scanned by    mark_target_live_regs.  Also used by update_live_status.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|current_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Marks registers for which we have seen a REG_DEAD note but no assignment.    Also only used by the next two functions.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|pending_dead_regs
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|update_live_status
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_basic_block
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|next_insn_no_annul
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_dead_or_set_registers
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
expr|struct
name|resources
operator|,
expr|struct
name|resources
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Utility function called from mark_target_live_regs via note_stores.    It deadens any CLOBBERed registers and livens any SET registers.  */
end_comment

begin_function
specifier|static
name|void
name|update_live_status
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|first_regno
operator|=
name|subreg_regno
argument_list|(
name|dest
argument_list|)
expr_stmt|;
else|else
name|first_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|last_regno
operator|=
name|first_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|first_regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|pending_dead_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the number of the basic block with correct live register    information that starts closest to INSN.  Return -1 if we couldn't    find such a basic block or the beginning is more than    SEARCH_LIMIT instructions before INSN.  Use SEARCH_LIMIT = -1 for    an unlimited search.     The delay slot filling code destroys the control-flow graph so,    instead of finding the basic block containing INSN, we search    backwards toward a BARRIER where the live register information is    correct.  */
end_comment

begin_function
specifier|static
name|int
name|find_basic_block
parameter_list|(
name|insn
parameter_list|,
name|search_limit
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|search_limit
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Scan backwards to the previous BARRIER.  Then see if we can find a      label that starts a basic block.  Return the basic block number.  */
for|for
control|(
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
operator|&&
name|search_limit
operator|!=
literal|0
condition|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|,
operator|--
name|search_limit
control|)
empty_stmt|;
comment|/* The closest BARRIER is too far away.  */
if|if
condition|(
name|search_limit
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The start of the function is basic block zero.  */
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* See if any of the upcoming CODE_LABELs start a basic block.  If we reach      anything other than a CODE_LABEL or note, we can't find this code.  */
for|for
control|(
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|==
name|BLOCK_HEAD
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to next_insn, but ignores insns in the delay slots of    an annulled branch.  */
end_comment

begin_function
specifier|static
name|rtx
name|next_insn_no_annul
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
block|{
comment|/* If INSN is an annulled branch, skip any insns from the target 	 of the branch.  */
if|if
condition|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|insn
condition|)
while|while
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given X, some rtl, and RES, a pointer to a `struct resource', mark    which resources are referenced by the insn.  If INCLUDE_DELAYED_EFFECTS    is TRUE, resources used by the called routine will be included for    CALL_INSNs.  */
end_comment

begin_function
name|void
name|mark_referenced_resources
parameter_list|(
name|x
parameter_list|,
name|res
parameter_list|,
name|include_delayed_effects
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|int
name|include_delayed_effects
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
comment|/* Handle leaf items for which we set resource flags.  Also, special-case      CALL, SET and CLOBBER operators.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|mark_referenced_resources
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|last_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_regno
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|last_regno
condition|;
name|r
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|REG
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|last_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_regno
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|last_regno
condition|;
name|r
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MEM
case|:
comment|/* If this memory shouldn't change, it really isn't referencing 	 memory.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
name|res
operator|->
name|unch_memory
operator|=
literal|1
expr_stmt|;
else|else
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|volatil
operator||=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Mark registers used to access memory.  */
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|CC0
case|:
name|res
operator|->
name|cc
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|ASM_INPUT
case|:
comment|/* Traditional asm's are always volatile.  */
name|res
operator|->
name|volatil
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|TRAP_IF
case|:
name|res
operator|->
name|volatil
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
name|res
operator|->
name|volatil
operator||=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	 We can not just fall through here since then we would be confused 	 by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	 traditional asms unlike their normal usage.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_referenced_resources
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL
case|:
comment|/* The first operand will be a (MEM (xxx)) but doesn't really reference 	 memory.  The second operand may be referenced, though.  */
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* Usually, the first operand of SET is set, not referenced.  But 	 registers used to access memory are referenced.  SET_DEST is 	 also referenced if it is a ZERO_EXTRACT or SIGN_EXTRACT.  */
name|mark_referenced_resources
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|mark_referenced_resources
argument_list|(
name|x
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
return|return;
case|case
name|CALL_INSN
case|:
if|if
condition|(
name|include_delayed_effects
condition|)
block|{
comment|/* A CALL references memory, the frame pointer if it exists, the 	     stack pointer, any global registers and any registers given in 	     USE insns immediately in front of the CALL.  	     However, we may have moved some of the parameter loading insns 	     into the delay slot of this CALL.  If so, the USE's for them 	     don't count and should be skipped.  */
name|rtx
name|insn
init|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|sequence
init|=
literal|0
decl_stmt|;
name|int
name|seq_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we are part of a delay slot sequence, point at the SEQUENCE.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|x
condition|)
block|{
name|sequence
operator|=
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|seq_size
operator|=
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sequence
argument_list|)
operator|!=
name|SEQUENCE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Check for a REG_SETJMP.  If it exists, then we must 	     assume that this call can need any register.  	     This is done to be more conservative about how we handle setjmp. 	     We assume that they both use and set all registers.  Using all 	     registers ensures that a register will not be considered dead 	     just because it crosses a setjmp call.  A register should be 	     considered dead only if the setjmp call returns non-zero.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|x
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
name|SET_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|seq_size
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot_pat
init|=
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|slot_pat
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|seq_size
condition|)
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ... fall through to other INSN processing ...  */
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
ifdef|#
directive|ifdef
name|INSN_REFERENCES_ARE_DELAYED
if|if
condition|(
operator|!
name|include_delayed_effects
operator|&&
name|INSN_REFERENCES_ARE_DELAYED
argument_list|(
name|x
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* No special processing, just speed up.  */
name|mark_referenced_resources
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Process each sub-expression and flag what it needs.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_referenced_resources
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of mark_target_live_regs.  Search forward from TARGET    looking for registers that are set before they are used.  These are dead.     Stop after passing a few conditional jumps, and/or a small    number of unconditional branches.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_dead_or_set_registers
parameter_list|(
name|target
parameter_list|,
name|res
parameter_list|,
name|jump_target
parameter_list|,
name|jump_count
parameter_list|,
name|set
parameter_list|,
name|needed
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|rtx
modifier|*
name|jump_target
decl_stmt|;
name|int
name|jump_count
decl_stmt|;
name|struct
name|resources
name|set
decl_stmt|,
name|needed
decl_stmt|;
block|{
name|HARD_REG_SET
name|scratch
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|rtx
name|jump_insn
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|target
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|this_jump_insn
init|=
name|insn
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If this instruction can throw an exception, then we don't 	 know where we might end up next.  That means that we have to 	 assume that whatever we have already marked as live really is 	 live.  */
if|if
condition|(
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* After a label, any pending dead registers that weren't yet 	     used can be made dead.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|pending_dead_regs
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
continue|continue;
case|case
name|INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
comment|/* If INSN is a USE made by update_block, we care about the 		 underlying insn.  Any registers set by the underlying insn 		 are live since the insn is being done somewhere else.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
comment|/* All other USE insns are to be ignored.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* An unconditional jump can be used to fill the delay slot 		 of a call, so search for a JUMP_INSN in any position.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|this_jump_insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_jump_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_jump_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|jump_count
operator|++
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|this_jump_insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_jump_insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|next
operator|=
name|JUMP_LABEL
argument_list|(
name|this_jump_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_insn
operator|==
literal|0
condition|)
block|{
name|jump_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|jump_target
condition|)
operator|*
name|jump_target
operator|=
name|JUMP_LABEL
argument_list|(
name|this_jump_insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|any_condjump_p
argument_list|(
name|this_jump_insn
argument_list|)
condition|)
block|{
name|struct
name|resources
name|target_set
decl_stmt|,
name|target_res
decl_stmt|;
name|struct
name|resources
name|fallthrough_res
decl_stmt|;
comment|/* We can handle conditional branches here by following 		     both paths, and then IOR the results of the two paths 		     together, which will give us registers that are dead 		     on both paths.  Since this is expensive, we give it 		     a much higher cost than unconditional branches.  The 		     cost was chosen so that we will follow at most 1 		     conditional branch.  */
name|jump_count
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|jump_count
operator|>=
literal|10
condition|)
break|break;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For an annulled branch, mark_set_resources ignores slots 		     filled by instructions from the target.  This is correct 		     if the branch is not taken.  Since we are following both 		     paths from the branch, we must also compute correct info 		     if the branch is taken.  We do this by inverting all of 		     the INSN_FROM_TARGET_P bits, calling mark_set_resources, 		     and then inverting the INSN_FROM_TARGET_P bits again.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|this_jump_insn
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|target_set
operator|=
name|set
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|target_set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|target_set
operator|=
name|set
expr_stmt|;
block|}
name|target_res
operator|=
operator|*
name|res
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|target_set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|target_res
operator|.
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|fallthrough_res
operator|=
operator|*
name|res
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|fallthrough_res
operator|.
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|find_dead_or_set_registers
argument_list|(
name|JUMP_LABEL
argument_list|(
name|this_jump_insn
argument_list|)
argument_list|,
operator|&
name|target_res
argument_list|,
literal|0
argument_list|,
name|jump_count
argument_list|,
name|target_set
argument_list|,
name|needed
argument_list|)
expr_stmt|;
name|find_dead_or_set_registers
argument_list|(
name|next
argument_list|,
operator|&
name|fallthrough_res
argument_list|,
literal|0
argument_list|,
name|jump_count
argument_list|,
name|set
argument_list|,
name|needed
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|fallthrough_res
operator|.
name|regs
argument_list|,
name|target_res
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|fallthrough_res
operator|.
name|regs
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
break|break;
block|}
else|else
block|{
comment|/* Don't try this optimization if we expired our jump count 		 above, since that would mean there may be an infinite loop 		 in the function being compiled.  */
name|jump_insn
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
block|}
return|return
name|jump_insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given X, a part of an insn, and a pointer to a `struct resource',    RES, indicate which resources are modified by the insn. If    MARK_TYPE is MARK_SRC_DEST_CALL, also mark resources potentially    set by the called routine.  If MARK_TYPE is MARK_DEST, only mark SET_DESTs     If IN_DEST is nonzero, it means we are inside a SET.  Otherwise,    objects are being referenced instead of set.     We never mark the insn as modifying the condition code unless it explicitly    SETs CC0 even though this is not totally correct.  The reason for this is    that we require a SET of CC0 to immediately precede the reference to CC0.    So if some other insn sets CC0 as a side-effect, we know it cannot affect    our computation and thus may be placed in a delay slot.  */
end_comment

begin_function
name|void
name|mark_set_resources
parameter_list|(
name|x
parameter_list|,
name|res
parameter_list|,
name|in_dest
parameter_list|,
name|mark_type
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|int
name|in_dest
decl_stmt|;
name|enum
name|mark_resource_type
name|mark_type
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|restart
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|USE
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
comment|/* These don't set any resources.  */
return|return;
case|case
name|CC0
case|:
if|if
condition|(
name|in_dest
condition|)
name|res
operator|->
name|cc
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|CALL_INSN
case|:
comment|/* Called routine modifies the condition code, memory, any registers 	 that aren't saved across calls, global registers and anything 	 explicitly CLOBBERed immediately after the CALL_INSN.  */
if|if
condition|(
name|mark_type
operator|==
name|MARK_SRC_DEST_CALL
condition|)
block|{
name|rtx
name|link
decl_stmt|;
name|res
operator|->
name|cc
operator|=
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|r
index|]
operator|||
name|global_regs
index|[
name|r
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_set_resources
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|res
argument_list|,
literal|1
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
comment|/* Check for a REG_SETJMP.  If it exists, then we must 	     assume that this call can clobber any register.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|x
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
name|SET_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
block|}
comment|/* ... and also what its RTL says it modifies, if anything.  */
case|case
name|JUMP_INSN
case|:
case|case
name|INSN
case|:
comment|/* An insn consisting of just a CLOBBER (or USE) is just for flow 	   and doesn't actually do anything, so we ignore it.  */
ifdef|#
directive|ifdef
name|INSN_SETS_ARE_DELAYED
if|if
condition|(
name|mark_type
operator|!=
name|MARK_SRC_DEST_CALL
operator|&&
name|INSN_SETS_ARE_DELAYED
argument_list|(
name|x
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CLOBBER
condition|)
goto|goto
name|restart
goto|;
return|return;
case|case
name|SET
case|:
comment|/* If the source of a SET is a CALL, this is actually done by 	 the called routine.  So only include it if we are to include the 	 effects of the calling routine.  */
name|mark_set_resources
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
operator|(
name|mark_type
operator|==
name|MARK_SRC_DEST_CALL
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CALL
operator|)
argument_list|,
name|mark_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_type
operator|!=
name|MARK_DEST
condition|)
name|mark_set_resources
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|1
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
return|return;
case|case
name|SEQUENCE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
name|mark_set_resources
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|mark_type
argument_list|)
expr_stmt|;
return|return;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|1
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
return|return;
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|1
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
return|return;
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
operator|!
operator|(
name|mark_type
operator|==
name|MARK_DEST
operator|&&
name|in_dest
operator|)
condition|)
block|{
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MEM
case|:
if|if
condition|(
name|in_dest
condition|)
block|{
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|unch_memory
operator||=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|res
operator|->
name|volatil
operator||=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|in_dest
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|mark_set_resources
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|mark_type
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|last_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_regno
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|last_regno
condition|;
name|r
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|REG
case|:
if|if
condition|(
name|in_dest
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|last_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_regno
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|last_regno
condition|;
name|r
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|STRICT_LOW_PART
case|:
if|if
condition|(
operator|!
operator|(
name|mark_type
operator|==
name|MARK_DEST
operator|&&
name|in_dest
operator|)
condition|)
block|{
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|ASM_INPUT
case|:
comment|/* Traditional asm's are always volatile.  */
name|res
operator|->
name|volatil
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|TRAP_IF
case|:
name|res
operator|->
name|volatil
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
name|res
operator|->
name|volatil
operator||=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	 We can not just fall through here since then we would be confused 	 by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	 traditional asms unlike their normal usage.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_set_resources
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Process each sub-expression and flag what it needs.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|mark_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_set_resources
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|mark_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the resources that are live at TARGET.     If TARGET is zero, we refer to the end of the current function and can    return our precomputed value.     Otherwise, we try to find out what is live by consulting the basic block    information.  This is tricky, because we must consider the actions of    reload and jump optimization, which occur after the basic block information    has been computed.     Accordingly, we proceed as follows::     We find the previous BARRIER and look at all immediately following labels    (with no intervening active insns) to see if any of them start a basic    block.  If we hit the start of the function first, we use block 0.     Once we have found a basic block and a corresponding first insns, we can    accurately compute the live status from basic_block_live_regs and    reg_renumber.  (By starting at a label following a BARRIER, we are immune    to actions taken by reload and jump.)  Then we scan all insns between    that point and our target.  For each CLOBBER (or for call-clobbered regs    when we pass a CALL_INSN), mark the appropriate registers are dead.  For    a SET, mark them as live.     We have to be careful when using REG_DEAD notes because they are not    updated by such things as find_equiv_reg.  So keep track of registers    marked as dead that haven't been assigned to, and mark them dead at the    next CODE_LABEL since reload and jump won't propagate values across labels.     If we cannot find the start of a basic block (should be a very rare    case, if it can happen at all), mark everything as potentially live.     Next, scan forward from TARGET looking for things set or clobbered    before they are used.  These are not live.     Because we can be called many times on the same target, save our results    in a hash table indexed by INSN_UID.  This is only done if the function    init_resource_info () was invoked before we are called.  */
end_comment

begin_function
name|void
name|mark_target_live_regs
parameter_list|(
name|insns
parameter_list|,
name|target
parameter_list|,
name|res
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|b
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|target_info
modifier|*
name|tinfo
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|jump_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|jump_target
decl_stmt|;
name|HARD_REG_SET
name|scratch
decl_stmt|;
name|struct
name|resources
name|set
decl_stmt|,
name|needed
decl_stmt|;
comment|/* Handle end of function.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|end_of_function_needs
expr_stmt|;
return|return;
block|}
comment|/* We have to assume memory is needed, but the CC isn't.  */
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|volatil
operator|=
name|res
operator|->
name|unch_memory
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
comment|/* See if we have computed this value already.  */
if|if
condition|(
name|target_hash_table
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|tinfo
operator|=
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
init|;
name|tinfo
condition|;
name|tinfo
operator|=
name|tinfo
operator|->
name|next
control|)
if|if
condition|(
name|tinfo
operator|->
name|uid
operator|==
name|INSN_UID
argument_list|(
name|target
argument_list|)
condition|)
break|break;
comment|/* Start by getting the basic block number.  If we have saved 	 information, we can get it from there unless the insn at the 	 start of the basic block has been deleted.  */
if|if
condition|(
name|tinfo
operator|&&
name|tinfo
operator|->
name|block
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|tinfo
operator|->
name|block
argument_list|)
argument_list|)
condition|)
name|b
operator|=
name|tinfo
operator|->
name|block
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
name|b
operator|=
name|find_basic_block
argument_list|(
name|target
argument_list|,
name|MAX_DELAY_SLOT_LIVE_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_hash_table
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tinfo
condition|)
block|{
comment|/* If the information is up-to-date, use it.  Otherwise, we will 	     update it below.  */
if|if
condition|(
name|b
operator|==
name|tinfo
operator|->
name|block
operator|&&
name|b
operator|!=
operator|-
literal|1
operator|&&
name|tinfo
operator|->
name|bb_tick
operator|==
name|bb_ticks
index|[
name|b
index|]
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|tinfo
operator|->
name|live_regs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Allocate a place to put our results and chain it into the  	     hash table.  */
name|tinfo
operator|=
operator|(
expr|struct
name|target_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|target_info
argument_list|)
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|uid
operator|=
name|INSN_UID
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|block
operator|=
name|b
expr_stmt|;
name|tinfo
operator|->
name|next
operator|=
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
expr_stmt|;
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
operator|=
name|tinfo
expr_stmt|;
block|}
block|}
name|CLEAR_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|)
expr_stmt|;
comment|/* If we found a basic block, get the live registers from it and update      them with anything set or killed between its start and the insn before      TARGET.  Otherwise, we must assume everything is live.  */
if|if
condition|(
name|b
operator|!=
operator|-
literal|1
condition|)
block|{
name|regset
name|regs_live
init|=
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|start_insn
decl_stmt|,
name|stop_insn
decl_stmt|;
comment|/* Compute hard regs live at start of block -- this is the real hard regs 	 marked live, plus live pseudo regs that have been renumbered to 	 hard regs.  */
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|current_live_regs
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|regs_live
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 	   if (reg_renumber[i]>=
literal|0
argument|) 	     { 	       regno = reg_renumber[i]; 	       for (j = regno; 		    j< regno + HARD_REGNO_NREGS (regno, 						  PSEUDO_REGNO_MODE (i)); 		    j++) 		 SET_HARD_REG_BIT (current_live_regs, j); 	     } 	 }
argument_list|)
empty_stmt|;
comment|/* Get starting and ending insn, handling the case where each might 	 be a SEQUENCE.  */
name|start_insn
operator|=
operator|(
name|b
operator|==
literal|0
condition|?
name|insns
else|:
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
operator|)
expr_stmt|;
name|stop_insn
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|start_insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|start_insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|start_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|stop_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|stop_insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|stop_insn
operator|=
name|next_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|stop_insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|start_insn
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|next_insn_no_annul
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|;
name|rtx
name|real_insn
init|=
name|insn
decl_stmt|;
comment|/* If this insn is from the target of a branch, it isn't going to 	     be used in the sequel.  If it is used in both cases, this 	     test will not be true.  */
if|if
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* If this insn is a USE made by update_block, we care about the 	     underlying insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|INSN_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|real_insn
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* CALL clobbers all call-used regs that aren't fixed except 		 sp, ap, and fp.  Do this before setting the result of the 		 call live.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|current_live_regs
argument_list|,
name|regs_invalidated_by_call
argument_list|)
expr_stmt|;
comment|/* A CALL_INSN sets any global register live, since it may 		 have been modified by the call.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Mark anything killed in an insn to be deadened at the next 	     label.  Ignore USE insns; the only REG_DEAD notes will be for 	     parameters.  But they might be early.  A CALL_INSN will usually 	     clobber registers used for parameters.  It isn't worth bothering 	     with the unlikely case when it won't.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|real_insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|real_insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|real_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|first_regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|last_regno
init|=
operator|(
name|first_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|first_regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|pending_dead_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|real_insn
argument_list|)
argument_list|,
name|update_live_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If any registers were unused after this insn, kill them. 		 These notes will always be accurate.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|real_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|first_regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|last_regno
init|=
operator|(
name|first_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|first_regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* A label clobbers the pending dead registers since neither 		 reload nor jump will propagate a value across a label.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|current_live_regs
argument_list|,
name|pending_dead_regs
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|)
expr_stmt|;
block|}
comment|/* The beginning of the epilogue corresponds to the end of the 	     RTL chain when there are no epilogue insns.  Certain resources 	     are implicitly required at that point.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|real_insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|current_live_regs
argument_list|,
name|start_of_epilogue_needs
operator|.
name|regs
argument_list|)
expr_stmt|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|current_live_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
name|tinfo
operator|->
name|block
operator|=
name|b
expr_stmt|;
name|tinfo
operator|->
name|bb_tick
operator|=
name|bb_ticks
index|[
name|b
index|]
expr_stmt|;
block|}
block|}
else|else
comment|/* We didn't find the start of a basic block.  Assume everything        in use.  This should happen only extremely rarely.  */
name|SET_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|find_dead_or_set_registers
argument_list|(
name|target
argument_list|,
name|res
argument_list|,
operator|&
name|jump_target
argument_list|,
literal|0
argument_list|,
name|set
argument_list|,
name|needed
argument_list|)
expr_stmt|;
comment|/* If we hit an unconditional branch, we have another way of finding out      what is live: we can see what is live at the branch target and include      anything used but not set before the branch.  We add the live      resources found using the test below to those found until now.  */
if|if
condition|(
name|jump_insn
condition|)
block|{
name|struct
name|resources
name|new_resources
decl_stmt|;
name|rtx
name|stop_insn
init|=
name|next_active_insn
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
name|mark_target_live_regs
argument_list|(
name|insns
argument_list|,
name|next_active_insn
argument_list|(
name|jump_target
argument_list|)
argument_list|,
operator|&
name|new_resources
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
comment|/* Include JUMP_INSN in the needed registers.  */
for|for
control|(
name|insn
operator|=
name|target
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|new_resources
operator|.
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
block|}
name|IOR_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|new_resources
operator|.
name|regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|tinfo
operator|->
name|live_regs
argument_list|,
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the resources required by mark_target_live_regs ().    This should be invoked before the first call to mark_target_live_regs.  */
end_comment

begin_function
name|void
name|init_resource_info
parameter_list|(
name|epilogue_insn
parameter_list|)
name|rtx
name|epilogue_insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Indicate what resources are required to be valid at the end of the current      function.  The condition code never is and memory always is.  If the      frame pointer is needed, it is and so is the stack pointer unless      EXIT_IGNORE_STACK is non-zero.  If the frame pointer is not needed, the      stack pointer is.  Registers used to return the function value are      needed.  Registers holding global variables are needed.  */
name|end_of_function_needs
operator|.
name|cc
operator|=
literal|0
expr_stmt|;
name|end_of_function_needs
operator|.
name|memory
operator|=
literal|1
expr_stmt|;
name|end_of_function_needs
operator|.
name|unch_memory
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
name|current_function_sp_is_unchanging
condition|)
endif|#
directive|endif
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mark_referenced_resources
argument_list|(
name|current_function_return_rtx
argument_list|,
operator|&
name|end_of_function_needs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
ifdef|#
directive|ifdef
name|EPILOGUE_USES
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
endif|#
directive|endif
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The registers required to be live at the end of the function are      represented in the flow information as being dead just prior to      reaching the end of the function.  For example, the return of a value      might be represented by a USE of the return register immediately      followed by an unconditional jump to the return label where the      return label is the end of the RTL chain.  The end of the RTL chain      is then taken to mean that the return register is live.       This sequence is no longer maintained when epilogue instructions are      added to the RTL chain.  To reconstruct the original meaning, the      start of the epilogue (NOTE_INSN_EPILOGUE_BEG) is regarded as the      point where these registers become live (start_of_epilogue_needs).      If epilogue instructions are present, the registers set by those      instructions won't have been processed by flow.  Thus, those      registers are additionally required at the end of the RTL chain      (end_of_function_needs).  */
name|start_of_epilogue_needs
operator|=
name|end_of_function_needs
expr_stmt|;
while|while
condition|(
operator|(
name|epilogue_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|epilogue_insn
argument_list|)
operator|)
condition|)
name|mark_set_resources
argument_list|(
name|epilogue_insn
argument_list|,
operator|&
name|end_of_function_needs
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize the tables used by mark_target_live_regs.  */
name|target_hash_table
operator|=
operator|(
expr|struct
name|target_info
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|TARGET_HASH_PRIME
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bb_ticks
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free up the resources allcated to mark_target_live_regs ().  This    should be invoked after the last call to mark_target_live_regs ().  */
end_comment

begin_function
name|void
name|free_resource_info
parameter_list|()
block|{
if|if
condition|(
name|target_hash_table
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TARGET_HASH_PRIME
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|target_info
modifier|*
name|ti
init|=
name|target_hash_table
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|ti
condition|)
block|{
name|struct
name|target_info
modifier|*
name|next
init|=
name|ti
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|ti
operator|=
name|next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|target_hash_table
argument_list|)
expr_stmt|;
name|target_hash_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bb_ticks
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|bb_ticks
argument_list|)
expr_stmt|;
name|bb_ticks
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear any hashed information that we have stored for INSN.  */
end_comment

begin_function
name|void
name|clear_hashed_info_for_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|target_info
modifier|*
name|tinfo
decl_stmt|;
if|if
condition|(
name|target_hash_table
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|tinfo
operator|=
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
init|;
name|tinfo
condition|;
name|tinfo
operator|=
name|tinfo
operator|->
name|next
control|)
if|if
condition|(
name|tinfo
operator|->
name|uid
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tinfo
condition|)
name|tinfo
operator|->
name|block
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Increment the tick count for the basic block that contains INSN.  */
end_comment

begin_function
name|void
name|incr_ticks_for_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|b
init|=
name|find_basic_block
argument_list|(
name|insn
argument_list|,
name|MAX_DELAY_SLOT_LIVE_SEARCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
operator|-
literal|1
condition|)
name|bb_ticks
index|[
name|b
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add TRIAL to the set of resources used at the end of the current    function.  */
end_comment

begin_function
name|void
name|mark_end_of_function_resources
parameter_list|(
name|trial
parameter_list|,
name|include_delayed_effects
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|include_delayed_effects
decl_stmt|;
block|{
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|end_of_function_needs
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

